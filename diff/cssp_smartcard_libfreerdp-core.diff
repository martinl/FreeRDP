--- libfreerdp/core/CMakeLists.txt	2019-07-24 06:11:52.470197578 +0300
+++ ../../informatimago/FreeRDP/libfreerdp/core/CMakeLists.txt	2019-07-19 20:00:34.121156386 +0300
@@ -15,6 +15,7 @@
 # See the License for the specific language governing permissions and
 # limitations under the License.
 
+
 set(MODULE_NAME "freerdp-core")
 set(MODULE_PREFIX "FREERDP_CORE")
 
@@ -128,10 +129,12 @@
 	window.h
 	listener.c
 	listener.h
+    smartcardlogon.c
+    smartcardlogon.h
+    tscredentials.c
+    tscredentials.h
 	peer.c
-	peer.h
-	display.c
-	display.h)
+	peer.h)
 
 set(${MODULE_PREFIX}_SRCS ${${MODULE_PREFIX}_SRCS} ${${MODULE_PREFIX}_GATEWAY_SRCS})
 
--- libfreerdp/core/freerdp.c	2019-07-25 19:51:02.917907617 +0300
+++ ../../informatimago/FreeRDP/libfreerdp/core/freerdp.c	2019-07-25 20:11:26.851977148 +0300
@@ -267,16 +267,12 @@
 			Stream_SetLength(s, record.length);
 			Stream_SetPosition(s, 0);
 
-			if (!update_begin_paint(update))
+			if (!update->BeginPaint(update->context))
+				status = FALSE;
+			else if (update_recv_surfcmds(update, s) < 0)
+				status = FALSE;
+			else if (!update->EndPaint(update->context))
 				status = FALSE;
-			else
-			{
-				if (update_recv_surfcmds(update, s) < 0)
-					status = FALSE;
-
-				if (!update_end_paint(update))
-					status = FALSE;
-			}
 
 			Stream_Release(s);
 		}
@@ -774,14 +770,6 @@
 	rdp_set_error_info(rdp, error);
 }
 
-BOOL freerdp_send_error_info(rdpRdp* rdp)
-{
-	if (!rdp)
-		return FALSE;
-
-	return rdp_send_error_info(rdp);
-}
-
 UINT32 freerdp_get_last_error(rdpContext* context)
 {
 	return context->LastError;
@@ -985,6 +973,11 @@
  */
 void freerdp_free(freerdp* instance)
 {
+	if (instance->saved_identity != NULL)
+	{
+		instance->saved_identity->free(instance->saved_identity);
+	}
+
 	free(instance);
 }
 
@@ -998,40 +991,6 @@
 	return written;
 }
 
-BOOL freerdp_nla_impersonate(rdpContext* context)
-{
-	rdpNla* nla;
-
-	if (!context)
-		return FALSE;
-
-	if (!context->rdp)
-		return FALSE;
-
-	if (!context->rdp->transport)
-		return FALSE;
-
-	nla = context->rdp->transport->nla;
-	return nla_impersonate(nla);
-}
-
-BOOL freerdp_nla_revert_to_self(rdpContext* context)
-{
-	rdpNla* nla;
-
-	if (!context)
-		return FALSE;
-
-	if (!context->rdp)
-		return FALSE;
-
-	if (!context->rdp->transport)
-		return FALSE;
-
-	nla = context->rdp->transport->nla;
-	return nla_revert_to_self(nla);
-}
-
 HANDLE getChannelErrorEventHandle(rdpContext* context)
 {
 	return context->channelErrorEvent;
@@ -1078,10 +1037,12 @@
 	SetEvent(context->channelErrorEvent);
 }
 
-const char* freerdp_nego_get_routing_token(rdpContext* context, DWORD* length)
+freerdp_blob* freerdp_saved_identity(freerdp* instance)
 {
-	if (!context || !context->rdp)
-		return NULL;
+	return instance->saved_identity;
+}
 
-	return (const char*)nego_get_routing_token(context->rdp->nego, length);
+void freerdp_save_identity(freerdp* instance, freerdp_blob* identity)
+{
+	instance->saved_identity = identity;
 }
--- libfreerdp/core/gateway/rpc_client.c	2019-07-25 19:51:03.017908112 +0300
+++ ../../informatimago/FreeRDP/libfreerdp/core/gateway/rpc_client.c	2019-07-25 20:11:26.951977644 +0300
@@ -424,6 +424,9 @@
 		}
 		else
 		{
+			if (rpc->VirtualConnection->State < VIRTUAL_CONNECTION_STATE_OPENED)
+				WLog_ERR(TAG, "warning: unhandled RTS PDU");
+
 			if (rts_recv_out_of_sequence_pdu(rpc, buffer, header->common.frag_length) < 0)
 				return -1;
 		}
@@ -891,7 +894,7 @@
 	UINT32 offset;
 	BYTE* buffer = NULL;
 	UINT32 stub_data_pad;
-	SecBuffer Buffers[2] = { 0 };
+	SecBuffer Buffers[2] = { { 0 } };
 	SecBufferDesc Message;
 	RpcClientCall* clientCall = NULL;
 	rdpNtlm* ntlm;
--- libfreerdp/core/nla.c	2019-07-25 19:51:03.889912436 +0300
+++ ../../informatimago/FreeRDP/libfreerdp/core/nla.c	2019-07-25 20:11:27.827981988 +0300
@@ -42,61 +42,38 @@
 #include <winpr/print.h>
 #include <winpr/tchar.h>
 #include <winpr/dsparse.h>
+#include <winpr/strlst.h>
 #include <winpr/library.h>
 #include <winpr/registry.h>
 
+#include "../mit-krb5-pkinit/kinit.h"
 #include "nla.h"
+#include "smartcardlogon.h"
+#include "tscredentials.h"
 
 #define TAG FREERDP_TAG("core.nla")
 
 #define SERVER_KEY "Software\\" FREERDP_VENDOR_STRING "\\" FREERDP_PRODUCT_STRING "\\Server"
 
-/**
- * TSRequest ::= SEQUENCE {
- * 	version    [0] INTEGER,
- * 	negoTokens [1] NegoData OPTIONAL,
- * 	authInfo   [2] OCTET STRING OPTIONAL,
- * 	pubKeyAuth [3] OCTET STRING OPTIONAL,
- * 	errorCode  [4] INTEGER OPTIONAL
- * }
- *
- * NegoData ::= SEQUENCE OF NegoDataItem
- *
- * NegoDataItem ::= SEQUENCE {
- * 	negoToken [0] OCTET STRING
- * }
- *
- * TSCredentials ::= SEQUENCE {
- * 	credType    [0] INTEGER,
- * 	credentials [1] OCTET STRING
- * }
- *
- * TSPasswordCreds ::= SEQUENCE {
- * 	domainName  [0] OCTET STRING,
- * 	userName    [1] OCTET STRING,
- * 	password    [2] OCTET STRING
- * }
- *
- * TSSmartCardCreds ::= SEQUENCE {
- * 	pin        [0] OCTET STRING,
- * 	cspData    [1] TSCspDataDetail,
- * 	userHint   [2] OCTET STRING OPTIONAL,
- * 	domainHint [3] OCTET STRING OPTIONAL
- * }
- *
- * TSCspDataDetail ::= SEQUENCE {
- * 	keySpec       [0] INTEGER,
- * 	cardName      [1] OCTET STRING OPTIONAL,
- * 	readerName    [2] OCTET STRING OPTIONAL,
- * 	containerName [3] OCTET STRING OPTIONAL,
- * 	cspName       [4] OCTET STRING OPTIONAL
- * }
- *
- */
+#define TERMSRV_SPN_PREFIX "TERMSRV/"
+#define PREFIX_CONTAINER_NAME "0x"
+#define PREFIX_PIN_GLOBAL "CredProv&PIN Global&"
 
 #define NLA_PKG_NAME NEGO_SSP_NAME
 
-#define TERMSRV_SPN_PREFIX "TERMSRV/"
+#ifdef WITH_GSSAPI /* KERBEROS SSP */
+#	define PACKAGE_NAME KERBEROS_SSP_NAME
+#else /* NTLM SSP */
+#	define PACKAGE_NAME NLA_PKG_NAME
+#endif
+
+#ifdef UNICODE
+#	define INIT_SECURITY_INTERFACE_NAME "InitSecurityInterfaceW"
+#else
+#	define INIT_SECURITY_INTERFACE_NAME "InitSecurityInterfaceA"
+#endif
+
+#define NLA_PKG_NAME NEGO_SSP_NAME
 
 struct rdp_nla
 {
@@ -139,9 +116,9 @@
 	SecBuffer PublicKey;
 	SecBuffer tsCredentials;
 	LPTSTR ServicePrincipalName;
-	SEC_WINNT_AUTH_IDENTITY* identity;
 	PSecurityFunctionTable table;
 	SecPkgContext_Sizes ContextSizes;
+	auth_identity* identity;
 };
 
 static BOOL nla_send(rdpNla* nla);
@@ -154,14 +131,6 @@
 static SECURITY_STATUS nla_decrypt_public_key_hash(rdpNla* nla);
 static SECURITY_STATUS nla_encrypt_ts_credentials(rdpNla* nla);
 static SECURITY_STATUS nla_decrypt_ts_credentials(rdpNla* nla);
-static BOOL nla_read_ts_password_creds(rdpNla* nla, wStream* s);
-static void nla_identity_free(SEC_WINNT_AUTH_IDENTITY* identity);
-
-#define ber_sizeof_sequence_octet_string(length) \
-	ber_sizeof_contextual_tag(ber_sizeof_octet_string(length)) + ber_sizeof_octet_string(length)
-#define ber_write_sequence_octet_string(stream, context, value, length)                \
-	ber_write_contextual_tag(stream, context, ber_sizeof_octet_string(length), TRUE) + \
-	    ber_write_octet_string(stream, value, length)
 
 /* CredSSP Client-To-Server Binding Hash\0 */
 static const BYTE ClientServerHashMagic[] = { 0x43, 0x72, 0x65, 0x64, 0x53, 0x53, 0x50, 0x20,
@@ -179,212 +148,513 @@
 
 static const UINT32 NonceLength = 32;
 
-void nla_identity_free(SEC_WINNT_AUTH_IDENTITY* identity)
+/* ============================================================ */
+
+#define CHECK_MEMORY(pointer, result, description, ...)                                 \
+	do                                                                                  \
+	{                                                                                   \
+		if (!(pointer))                                                                 \
+		{                                                                               \
+			WLog_ERR(TAG, "%s:%d: %s() " description, __FILE__, __LINE__, __FUNCTION__, \
+			         ##__VA_ARGS__);                                                    \
+			return result;                                                              \
+		}                                                                               \
+	} while (0)
+
+/* ============================================================ */
+
+/*
+Duplicate the cstring, or convert it to WCHAR,  depending on UNICODE.
+*/
+LPTSTR stringX_from_cstring(const char* cstring)
 {
-	if (identity)
+	LPTSTR result = NULL;
+
+	if (cstring != NULL)
 	{
-		/* Password authentication */
-		if (identity->User)
-		{
-			memset(identity->User, 0, identity->UserLength * 2);
-			free(identity->User);
-		}
+#ifdef UNICODE
+		ConvertToUnicode(CP_UTF8, 0, cstring, -1, &result, 0);
+		CHECK_MEMORY(result, NULL, "Could not allocate %d bytes.", 2 * (1 + strlen(cstring)));
+#else
+		result = strdup(cstring);
+		CHECK_MEMORY(result, NULL, "Could not allocate %d bytes.", 1 + strlen(cstring));
+#endif
+	}
 
-		if (identity->Password)
-		{
-			size_t len = identity->PasswordLength;
+	return result;
+}
 
-			if (len > LB_PASSWORD_MAX_LENGTH) /* [pth] Password hash */
-				len -= LB_PASSWORD_MAX_LENGTH;
+/**
+ * Returns whether the username is found in the SAM database.
+ * @param username: C string.
+ */
 
-			memset(identity->Password, 0, len * 2);
-			free(identity->Password);
-		}
+static BOOL user_is_in_sam_database(const char* username)
+{
+	char mutable_username[128]; /*  greater than the max of 104 on MS-Windows 2000,  and 20 on
+	                               MS-Windows 2003 */
+	WINPR_SAM* sam = SamOpen(NULL, TRUE);
+	BOOL is_in = FALSE;
+
+	if (sizeof(mutable_username) - 1 < strlen(username))
+	{
+		return FALSE;
+	}
+
+	strcpy(mutable_username, username);
 
-		if (identity->Domain)
+	if (sam)
+	{
+		WINPR_SAM_ENTRY* entry =
+		    SamLookupUserA(sam, mutable_username, strlen(mutable_username), NULL, 0);
+
+		if (entry)
 		{
-			memset(identity->Domain, 0, identity->DomainLength * 2);
-			free(identity->Domain);
+			is_in = TRUE;
+			SamFreeEntry(sam, entry);
 		}
+
+		SamClose(sam);
+	}
+
+	return is_in;
+}
+
+/* ============================================================ */
+
+static void free_identity_blob(freerdp_blob* blob)
+{
+	if (blob != NULL)
+	{
+		auth_identity_free(blob->data);
+		free(blob);
 	}
+}
 
-	free(identity);
+static void save_identity(rdpNla* nla)
+{
+	auth_identity* saved_identity = auth_identity_deepcopy(nla->identity);
+	freerdp_blob* blob = malloc(sizeof(*blob));
+
+	if (blob != NULL)
+	{
+		blob->data = saved_identity;
+		blob->free = free_identity_blob;
+		freerdp_save_identity(nla->instance, blob);
+	}
 }
 
 /**
- * Initialize NTLM/Kerberos SSP authentication module (client).
- * @param credssp
+ * Returns whether the username is found in the SAM database.
+ * @param username: C string.
  */
 
-static int nla_client_init(rdpNla* nla)
+static int nla_client_init_smartcard_logon(rdpNla* nla)
 {
-	char* spn;
-	size_t length;
-	rdpTls* tls = NULL;
-	BOOL PromptPassword = FALSE;
-	freerdp* instance = nla->instance;
+	csp_data_detail* csp_data = NULL;
+	smartcard_creds* smartcard_creds = NULL;
 	rdpSettings* settings = nla->settings;
-	WINPR_SAM* sam;
-	WINPR_SAM_ENTRY* entry;
-	nla->state = NLA_STATE_INITIAL;
+	/*
+	In case of redirection we don't need to re-establish the identity
+	(notably with kerberos), we used the one we saved previously.
+	*/
+	freerdp_blob* blob = freerdp_saved_identity(nla->instance);
+	auth_identity* saved_identity = (blob == NULL) ? NULL : blob->data;
+
+	if (saved_identity != NULL)
+	{
+		if (nla->identity != NULL)
+		{
+			auth_identity_free(nla->identity);
+		}
+
+		nla->identity = auth_identity_deepcopy(saved_identity);
+		return 0;
+	}
 
-	if (settings->RestrictedAdminModeRequired)
-		settings->DisableCredentialsDelegation = TRUE;
+#if defined(WITH_PKCS11H) && defined(WITH_GSSAPI)
 
-	if ((!settings->Username) || (!strlen(settings->Username)) ||
-	    ((!settings->Password) && (!settings->RedirectionPassword)))
+	/* gets the UPN settings->UserPrincipalName */
+	if (get_info_smartcard(settings) != 0)
 	{
-		PromptPassword = TRUE;
+		WLog_ERR(TAG, "Failed to retrieve UPN !");
+		return -1;
 	}
 
-	if (PromptPassword && settings->Username && strlen(settings->Username))
+#	if defined(WITH_KERBEROS)
+	WLog_INFO(TAG, "WITH_KERBEROS");
+
+	if (0 == kerberos_get_tgt(settings))
 	{
-		sam = SamOpen(NULL, TRUE);
+		WLog_INFO(TAG, "Got Ticket Granting Ticket for %s", settings->CanonicalizedUserHint);
+	}
+	else
+	{
+		WLog_ERR(TAG, "Failed to get Ticket Granting Ticket from KDC!");
+		return -1;
+	}
 
-		if (sam)
-		{
-			entry = SamLookupUserA(sam, settings->Username, strlen(settings->Username), NULL, 0);
+#	else
+	/* TODO: try to get the CanonicalizedUserHint from klist? */
+	WLog_INFO(TAG, "NOT WITH_KERBEROS");
+#	endif
+#else
+	WLog_ERR(
+	    TAG,
+	    "Recompile with the PKCS11H and GSSAPI features enabled to authenticate via smartcard.");
+	return -1;
+#endif
 
-			if (entry)
-			{
-				/**
-				 * The user could be found in SAM database.
-				 * Use entry in SAM database later instead of prompt
-				 */
-				PromptPassword = FALSE;
-				SamFreeEntry(sam, entry);
-			}
+	if (settings->PinPadIsPresent)
+	{
+		/* The middleware talking to the card performs PIN caching and will provide
+		 * to its CSP (Cryptographic Service Provider) the PIN code
+		 * when asked. If PIN caching fails, or is not handled by the middleware,
+		 * the PIN code will be asked one more time before opening the session.
+		 * Thus, entering PIN code on pinpad does not give the PIN code explicitly to the CSP.
+		 * That's why we set it here to "0000".
+		 * The PIN code is not communicated to any software module, nor central processing unit.
+		 * Contrary to /pin option in command line or with getpass() which are less secure,
+		 * because the PIN code is communicated (at the present) in clear and transit via the code.
+		 */
+		settings->Password = string_concatenate(PREFIX_PIN_GLOBAL, "0000", NULL);
+	}
+	else if (settings->Pin)
+	{
+		settings->Password = string_concatenate(PREFIX_PIN_GLOBAL, settings->Pin, NULL);
+	}
+	else
+	{
+		settings->Password = strdup("");
+	}
 
-			SamClose(sam);
-		}
+	CHECK_MEMORY(settings->Password, -1, "Could not allocate memory for password.");
+	settings->Username = NULL;
+
+	if (settings->UserPrincipalName != NULL)
+	{
+		settings->Username = strdup(settings->UserPrincipalName);
+		CHECK_MEMORY(settings->Username, -1, "Could not strdup the UserPrincipalName (length = %d)",
+		             strlen(settings->UserPrincipalName));
 	}
 
-#ifndef _WIN32
+	if (settings->Domain == NULL)
+	{
+		WLog_ERR(TAG, "Missing domain.");
+		return -1;
+	}
+
+	CHECK_MEMORY(settings->DomainHint = strdup(settings->Domain), /* They're freed separately! */
+	             -1, "Could not strdup the Domain (length = %d)", strlen(settings->Domain));
 
-	if (PromptPassword)
+	if (settings->CanonicalizedUserHint == NULL)
 	{
-		if (settings->RestrictedAdminModeRequired)
-		{
-			if ((settings->PasswordHash) && (strlen(settings->PasswordHash) > 0))
-				PromptPassword = FALSE;
-		}
+		WLog_ERR(TAG, "Missing Canonicalized User Hint (Domain Hint = %s,  UPN = %s).",
+		         settings->DomainHint, settings->UserPrincipalName);
+		return -1;
 	}
 
-#endif
+	CHECK_MEMORY((settings->UserHint = strdup(settings->CanonicalizedUserHint)), -1,
+	             "Could not strdup the CanonicalizedUserHint (length = %d)",
+	             strlen(settings->CanonicalizedUserHint));
+	WLog_INFO(TAG, "Canonicalized User Hint = %s,  Domain Hint = %s,  UPN = %s",
+	          settings->CanonicalizedUserHint, settings->DomainHint, settings->UserPrincipalName);
+	CHECK_MEMORY((settings->ContainerName =
+	                  string_concatenate(PREFIX_CONTAINER_NAME, settings->IdCertificate, NULL)),
+	             -1, "Could not allocate memory for container name.");
 
-	if (PromptPassword)
+	if ((settings->CspName == NULL) ||
+	    (settings->CspName != NULL && strlen(settings->CspName) == 0))
 	{
-		if (!instance->settings->PromptForCredentials || !instance->Authenticate)
-		{
-			freerdp_set_last_error(instance->context,
-			                       FREERDP_ERROR_CONNECT_NO_OR_MISSING_CREDENTIALS);
-			return 0;
-		}
-		else
-		{
-			BOOL proceed = instance->Authenticate(instance, &settings->Username,
-			                                      &settings->Password, &settings->Domain);
+		WLog_ERR(TAG, "/csp argument is mandatory for smartcard-logon ");
+		return -1;
+	}
 
-			if (!proceed)
-			{
-				freerdp_set_last_error(instance->context,
-				                       FREERDP_ERROR_CONNECT_NO_OR_MISSING_CREDENTIALS);
-				return 0;
-			}
-		}
+	if (!settings->RedirectSmartCards && !settings->DeviceRedirection)
+	{
+		WLog_ERR(TAG, "/smartcard argument is mandatory for smartcard-logon ");
+		return -1;
 	}
 
-	if (!settings->Username)
+	WLog_DBG(TAG, "smartcard ReaderName=%s", settings->ReaderName);
+	csp_data =
+	    csp_data_detail_new(AT_KEYEXCHANGE /*AT_AUTHENTICATE*/, settings->CardName,
+	                        settings->ReaderName, settings->ContainerName, settings->CspName);
+
+	if (csp_data == NULL)
 	{
-		nla_identity_free(nla->identity);
-		nla->identity = NULL;
+		goto failure;
 	}
-	else
+
+	smartcard_creds = smartcard_creds_new(/* Pin: */ settings->Password, settings->UserHint,
+	                                      settings->DomainHint, csp_data);
+	csp_data_detail_free(csp_data);
+
+	if (smartcard_creds == NULL)
 	{
-		if (settings->RedirectionPassword && settings->RedirectionPasswordLength > 0)
-		{
-			if (sspi_SetAuthIdentityWithUnicodePassword(
-			        nla->identity, settings->Username, settings->Domain,
-			        (UINT16*)settings->RedirectionPassword,
-			        settings->RedirectionPasswordLength / sizeof(WCHAR) - 1) < 0)
-				return -1;
-		}
-		else
-		{
-			BOOL usePassword = TRUE;
+		goto failure;
+	}
 
-			if (settings->RestrictedAdminModeRequired)
-			{
-				if (settings->PasswordHash)
-				{
-					if (strlen(settings->PasswordHash) == 32)
-					{
-						if (sspi_SetAuthIdentity(nla->identity, settings->Username,
-						                         settings->Domain, settings->PasswordHash) < 0)
-							return -1;
-
-						/**
-						 * Increase password hash length by LB_PASSWORD_MAX_LENGTH to obtain a
-						 * length exceeding the maximum (LB_PASSWORD_MAX_LENGTH) and use it this for
-						 * hash identification in WinPR.
-						 */
-						nla->identity->PasswordLength += LB_PASSWORD_MAX_LENGTH;
-						usePassword = FALSE;
-					}
-				}
-			}
+	if (nla->identity != NULL)
+	{
+		auth_identity_free(nla->identity);
+	}
 
-			if (usePassword)
-			{
-				if (sspi_SetAuthIdentity(nla->identity, settings->Username, settings->Domain,
-				                         settings->Password) < 0)
-					return -1;
-			}
-		}
+	nla->identity = auth_identity_new_smartcard(smartcard_creds);
+
+	if (nla->identity == NULL)
+	{
+		goto failure;
 	}
 
-	tls = nla->transport->tls;
+	save_identity(nla);
+	return 0;
+failure:
+	WLog_ERR(TAG, "%s:%d: %s() Failed to set smartcard authentication parameters !", __FILE__,
+	         __LINE__, __FUNCTION__);
+	smartcard_creds_free(smartcard_creds);
+	return -1;
+}
 
-	if (!tls)
+static BOOL sspi_SecBufferFill(PSecBuffer buffer, BYTE* data, DWORD size)
+{
+	if (buffer == NULL)
 	{
-		WLog_ERR(TAG, "Unknown NLA transport layer");
-		return -1;
+		return FALSE;
 	}
 
-	if (!sspi_SecBufferAlloc(&nla->PublicKey, tls->PublicKeyLength))
+	CHECK_MEMORY(sspi_SecBufferAlloc(buffer, size), FALSE,
+	             "Failed to allocate sspi SecBuffer %d bytes", size);
+	CopyMemory(buffer->pvBuffer, data, size);
+	return TRUE;
+}
+
+#define EMPTY_SL(field) (((field) == NULL) || ((field##Length) == 0))
+#define EMPTY_S(cstring) (((cstring) == NULL) || (strlen(cstring) == 0))
+#define HAS_SL(field) ((field) != NULL)
+#define HAS_S(cstring) ((cstring) != NULL)
+
+static BOOL should_prompt_password(rdpSettings* settings)
+{
+	BOOL PromptPassword = (!settings->SmartcardLogon &&
+	                       (EMPTY_S(settings->Username) ||
+	                        (!HAS_S(settings->Password) && !HAS_S(settings->RedirectionPassword))));
+#ifndef _WIN32
+
+	if (PromptPassword && settings->RestrictedAdminModeRequired && !EMPTY_S(settings->PasswordHash))
+	{
+		PromptPassword = FALSE;
+	}
+
+#endif
+
+	if (PromptPassword && !EMPTY_S(settings->Username))
+	{
+		/* Use entry in SAM database later instead of prompt when user is in the SAM database */
+		PromptPassword = !user_is_in_sam_database(settings->Username);
+	}
+
+	return PromptPassword;
+}
+
+static LPTSTR service_principal_name(const char* server_hostname)
+{
+	char* spnA = string_concatenate(TERMSRV_SPN_PREFIX, server_hostname, NULL);
+	LPTSTR spnX = stringX_from_cstring(spnA);
+	free(spnA);
+	return spnX;
+}
+
+/*
+nla_client_init
+
+Initialize NTLM/Kerberos SSP authentication module (client).
+
+We prepare the CSSP negotiation, which involves sending three packets:
+
+- TLSencrypted(TSRequest([SPNEGO token]))
+(nla_client_begin)
+using the parameters: nla->credentials, nla->ServicePrincipalName, nla->fContextReq,
+nla->pPackageInfo
+
+- TLSencrypted(TSRequest([SPNego encrypted(client / server hash of public key)]))
+(nla_client_recv->nal_encrypt_public_key_{echo,hash})
+using the parameters: nla->credentials, nla->ServicePrincipalName, nla->fContextReq,
+nla->ClientNonce,  nla->PublicKey
+
+- TLSencrypted(TSRequest([SPNego encrypted(user credentials)]))
+(nla_client_recv->nla_encrypt_ts_credentials)
+using the parameters: nla->credentials, nla->ServicePrincipalName, nla->fContextReq,
+nla->settings->DisableCredentialsDelegation,  nla->identity
+
+
+
+
+INPUT:
+
+nla->instance
+
+nla->settings->RestrictedAdminModeRequired
+nla->settings->SmartcardLogon
+
+nla->settings->ServerHostname
+
+nla->settings->Username
+nla->settings->Password
+nla->settings->Domain
+
+nla->settings->RedirectionPassword
+nla->settings->PasswordHash
+
+{nla->tls->PublicKey,  nla->tls->PublicKeyLength}
+
+OUTPUT:
+
+nla->state = NLA_STATE_INITIAL;
+nla->cred_type = credential_type_default;
+
+nla->identity
+nla->identity->password_creds
+nla->identity->smartcard_creds
+nla->identity->csp_data
+
+
+settings->DisableCredentialsDelegation
+nla->ServicePrincipalName
+
+nla->table
+nla->status
+nla->pPackageInfo
+nla->cbMaxToken
+nla->packageName
+nla->haveContext
+nla->haveInputBuffer
+nla->HavePubKeyAuth
+nla->inputBuffer
+nla->outputBuffer
+nla->ContextSizes
+nla->fContextReq
+nla->credentials
+nla->expiration
+
+RULES:
+
+settings->RestrictedAdminModeRequired => settings->DisableCredentialsDelegation
+
+settings->SmartcardLogon => PromptPin
+(!settings->Username || !settings->Password) && !settings->SmartcardLogon => PromptPassword
+PromptPassword && settings->Username && user_is_in_sam_database(settings->Username) =>
+PromptPassword = FALSE
+!_WIN32 &&  PromptPassword && settings->RestrictedAdminModeRequired && settings->PasswordHash =>
+PromptPassword = FALSE
+
+(PromptPassword || PromptPin) &&  instance->Authenticate => instance->Authenticate(instance,
+&settings->Username, &settings->Password, &settings->Domain)
+
+!settings->UserName => nla->identity->password_creds == NULL
+settings->UserName && settings->RedirectionPassword
+
+nla->ServicePrincipalName =  TERMSRV_SPN_PREFIX + settings->ServerHostname
+
+CALLS:
+
+nla->table->QuerySecurityPackageInfo()
+nla->table->AcquireCredentialsHandle()
+
+*/
+static int nla_client_init(rdpNla* nla)
+{
+	freerdp* instance = nla->instance;
+	rdpSettings* settings = nla->settings;
+	BOOL PromptPassword = should_prompt_password(settings);
+	rdpTls* tls = NULL;
+	nla->state = NLA_STATE_INITIAL;
+	nla->identity = auth_identity_new_password(SEC_WINNT_AUTH_IDENTITY_new(NULL, NULL, NULL));
+
+	if ((nla->identity == NULL) || (nla->identity->creds.password_creds == NULL))
+	{
+		auth_identity_free(nla->identity);
+		return 0;
+	}
+
+	settings->DisableCredentialsDelegation |= settings->RestrictedAdminModeRequired;
+
+	if ((PromptPassword || settings->SmartcardLogon) && (instance->Authenticate != NULL) &&
+	    (!instance->Authenticate(instance, &settings->Username, &settings->Password,
+	                             &settings->Domain)))
+	{
+		freerdp_set_last_error(instance->context, FREERDP_ERROR_CONNECT_NO_OR_MISSING_CREDENTIALS);
+		return 0;
+	}
+
+	if (settings->SmartcardLogon)
+	{
+		if (nla_client_init_smartcard_logon(nla) < 0)
+		{
+			WLog_ERR(TAG, "Could not initialize Smartcard Logon.");
+			return -1;
+		}
+	}
+	else if (!HAS_S(settings->Username))
+	{
+		SEC_WINNT_AUTH_IDENTITY_free(nla->identity->creds.password_creds);
+		nla->identity->creds.password_creds = NULL;
+	}
+	else if (!HAS_S(settings->Domain))
 	{
-		WLog_ERR(TAG, "Failed to allocate sspi secBuffer");
+		/* Perhaps it's too early: it's needed only by NTLM, not by kerberos. */
+		WLog_ERR(TAG, "Missing domain.");
 		return -1;
 	}
+	else if (!EMPTY_SL(settings->RedirectionPassword))
+	{
+		/*  When a broker redirects the connection, it may give a substitute password */
+		if (sspi_SetAuthIdentityWithUnicodePassword(
+		        nla->identity->creds.password_creds, settings->Username, settings->Domain,
+		        (UINT16*)settings->RedirectionPassword,
+		        settings->RedirectionPasswordLength / sizeof(WCHAR) - 1) < 0)
+			return -1;
+	}
+	else if (settings->RestrictedAdminModeRequired && !EMPTY_S(settings->PasswordHash) &&
+	         (strlen(settings->PasswordHash) == 32))
+	{
+		/*  Pass-the-hash hack */
+		if (sspi_SetAuthIdentity(nla->identity->creds.password_creds, settings->Username,
+		                         settings->Domain, settings->PasswordHash) < 0)
+			return -1;
 
-	CopyMemory(nla->PublicKey.pvBuffer, tls->PublicKey, tls->PublicKeyLength);
-	length = sizeof(TERMSRV_SPN_PREFIX) + strlen(settings->ServerHostname);
-	spn = (SEC_CHAR*)malloc(length + 1);
+		/**
+		 * Increase password hash length by LB_PASSWORD_MAX_LENGTH to obtain a length exceeding
+		 * the maximum (LB_PASSWORD_MAX_LENGTH) and use it this for hash identification in WinPR.
+		 */
+		nla->identity->creds.password_creds->PasswordLength += LB_PASSWORD_MAX_LENGTH;
+	}
+	else
+	{
+		/* Normal password */
+		if (sspi_SetAuthIdentity(nla->identity->creds.password_creds, settings->Username,
+		                         settings->Domain, settings->Password) < 0)
+			return -1;
+	}
 
-	if (!spn)
+	if ((tls = nla->transport->tls) == NULL)
+	{
+		WLog_ERR(TAG, "Unknown NLA transport layer");
 		return -1;
+	}
 
-	sprintf_s(spn, length + 1, "%s%s", TERMSRV_SPN_PREFIX, settings->ServerHostname);
-#ifdef UNICODE
-	nla->ServicePrincipalName = NULL;
-	ConvertToUnicode(CP_UTF8, 0, spn, -1, &nla->ServicePrincipalName, 0);
-	free(spn);
-#else
-	nla->ServicePrincipalName = spn;
-#endif
-	nla->table = InitSecurityInterfaceEx(0);
-#ifdef WITH_GSSAPI /* KERBEROS SSP */
-	nla->status = nla->table->QuerySecurityPackageInfo(KERBEROS_SSP_NAME, &nla->pPackageInfo);
+	if (!sspi_SecBufferFill(&nla->PublicKey, tls->PublicKey, tls->PublicKeyLength))
+	{
+		return -1;
+	}
 
-	if (nla->status != SEC_E_OK)
+	if ((nla->ServicePrincipalName = service_principal_name(settings->ServerHostname)) == NULL)
 	{
-		WLog_ERR(TAG, "QuerySecurityPackageInfo status %s [0x%08" PRIX32 "]",
-		         GetSecurityStatusString(nla->status), nla->status);
 		return -1;
 	}
 
-#else /* NTLM SSP */
-	nla->status = nla->table->QuerySecurityPackageInfo(NLA_PKG_NAME, &nla->pPackageInfo);
+	nla->table = InitSecurityInterfaceEx(0);
+	nla->status = nla->table->QuerySecurityPackageInfo(PACKAGE_NAME, &nla->pPackageInfo);
 
 	if (nla->status != SEC_E_OK)
 	{
@@ -393,14 +663,16 @@
 		return -1;
 	}
 
-#endif
 	nla->cbMaxToken = nla->pPackageInfo->cbMaxToken;
 	nla->packageName = nla->pPackageInfo->Name;
-	WLog_DBG(TAG, "%s %" PRIu32 " : packageName=%ls ; cbMaxToken=%d", __FUNCTION__, __LINE__,
+	WLog_DBG(TAG, "%s:%d: %s() packageName=%ls ; cbMaxToken=%d", __FILE__, __LINE__, __FUNCTION__,
 	         nla->packageName, nla->cbMaxToken);
-	nla->status = nla->table->AcquireCredentialsHandle(NULL, NLA_PKG_NAME, SECPKG_CRED_OUTBOUND,
-	                                                   NULL, nla->identity, NULL, NULL,
-	                                                   &nla->credentials, &nla->expiration);
+	nla->status = nla->table->AcquireCredentialsHandle(
+	    NULL, NLA_PKG_NAME, SECPKG_CRED_OUTBOUND, NULL,
+	    ((nla->identity->cred_type == credential_type_password)
+	         ? nla->identity->creds.password_creds
+	         : NULL /* use the default credentials for that package */),
+	    NULL, NULL, &nla->credentials, &nla->expiration);
 
 	if (nla->status != SEC_E_OK)
 	{
@@ -464,6 +736,7 @@
 
 		if (nla->status)
 		{
+			/* Kerberos failed, Switch to NTLM */
 			SECURITY_STATUS status =
 			    nla->table->QuerySecurityPackageInfo(NTLM_SSP_NAME, &nla->pPackageInfo);
 
@@ -494,10 +767,19 @@
 			}
 		}
 
-		if (nla->status == SEC_I_COMPLETE_NEEDED)
+		switch (nla->status)
+		{
+		case SEC_I_COMPLETE_NEEDED:
 			nla->status = SEC_E_OK;
-		else if (nla->status == SEC_I_COMPLETE_AND_CONTINUE)
+			break;
+
+		case SEC_I_COMPLETE_AND_CONTINUE:
 			nla->status = SEC_I_CONTINUE_NEEDED;
+			break;
+
+		default:
+			break;
+		}
 	}
 
 	if (nla->status != SEC_I_CONTINUE_NEEDED)
@@ -508,7 +790,7 @@
 
 	nla->negoToken.pvBuffer = nla->outputBuffer.pvBuffer;
 	nla->negoToken.cbBuffer = nla->outputBuffer.cbBuffer;
-	WLog_DBG(TAG, "Sending Authentication Token");
+	WLog_DBG(TAG, "Sending Authentication Token (1)");
 #if defined(WITH_DEBUG_NLA)
 	winpr_HexDump(TAG, WLOG_DEBUG, nla->negoToken.pvBuffer, nla->negoToken.cbBuffer);
 #endif
@@ -541,7 +823,7 @@
 		nla->outputBufferDesc.pBuffers = &nla->outputBuffer;
 		nla->outputBuffer.BufferType = SECBUFFER_TOKEN;
 		nla->outputBuffer.cbBuffer = nla->cbMaxToken;
-		nla->outputBuffer.pvBuffer = malloc(nla->outputBuffer.cbBuffer);
+		nla->outputBuffer.pvBuffer = calloc(nla->outputBuffer.cbBuffer, 1);
 
 		if (!nla->outputBuffer.pvBuffer)
 			return -1;
@@ -590,6 +872,11 @@
 				return -1;
 			}
 
+#if defined(WITH_DEBUG_NLA)
+			WLog_DBG(TAG, "Encrypting Authentication Token (2)");
+			winpr_HexDump(TAG, WLOG_DEBUG, nla->outputBuffer.pvBuffer, nla->outputBuffer.cbBuffer);
+#endif
+
 			if (nla->peerVersion < 5)
 				nla->status = nla_encrypt_public_key_echo(nla);
 			else
@@ -601,7 +888,7 @@
 
 		nla->negoToken.pvBuffer = nla->outputBuffer.pvBuffer;
 		nla->negoToken.cbBuffer = nla->outputBuffer.cbBuffer;
-		WLog_DBG(TAG, "Sending Authentication Token");
+		WLog_DBG(TAG, "Sending Authentication Token (2)");
 #if defined(WITH_DEBUG_NLA)
 		winpr_HexDump(TAG, WLOG_DEBUG, nla->negoToken.pvBuffer, nla->negoToken.cbBuffer);
 #endif
@@ -855,7 +1142,7 @@
 		nla->outputBufferDesc.pBuffers = &nla->outputBuffer;
 		nla->outputBuffer.BufferType = SECBUFFER_TOKEN;
 		nla->outputBuffer.cbBuffer = nla->cbMaxToken;
-		nla->outputBuffer.pvBuffer = malloc(nla->outputBuffer.cbBuffer);
+		nla->outputBuffer.pvBuffer = calloc(nla->outputBuffer.cbBuffer, 1);
 
 		if (!nla->outputBuffer.pvBuffer)
 			return -1;
@@ -977,8 +1264,8 @@
 		if ((nla->status != SEC_E_OK) && (nla->status != SEC_I_CONTINUE_NEEDED))
 		{
 			/* Special handling of these specific error codes as NTSTATUS_FROM_WIN32
-			   unfortunately does not map directly to the corresponding NTSTATUS values
-			 */
+			unfortunately does not map directly to the corresponding NTSTATUS values
+			*/
 			switch (GetLastError())
 			{
 			case ERROR_PASSWORD_MUST_CHANGE:
@@ -1005,7 +1292,7 @@
 		}
 
 		/* send authentication token */
-		WLog_DBG(TAG, "Sending Authentication Token");
+		WLog_DBG(TAG, "Sending Authentication Token (3)");
 		nla_buffer_print(nla);
 
 		if (!nla_send(nla))
@@ -1296,7 +1583,7 @@
 	ntlm = (_tcsncmp(nla->packageName, NTLM_SSP_NAME, ARRAYSIZE(NTLM_SSP_NAME)) == 0);
 	signature_length = nla->pubKeyAuth.cbBuffer - nla->PublicKey.cbBuffer;
 
-	if ((signature_length < 0) || ((UINT32)signature_length > nla->ContextSizes.cbSecurityTrailer))
+	if ((signature_length < 0) || (signature_length > nla->ContextSizes.cbSecurityTrailer))
 	{
 		WLog_ERR(TAG, "unexpected pubKeyAuth buffer size: %" PRIu32 "", nla->pubKeyAuth.cbBuffer);
 		goto fail;
@@ -1479,250 +1766,86 @@
 	return status;
 }
 
-static size_t nla_sizeof_ts_password_creds(rdpNla* nla)
+/**
+ * Encode TSCredentials structure.
+ * @param credssp
+ */
+
+static BOOL nla_encode_ts_credentials(rdpNla* nla)
 {
+	BOOL result = TRUE;
+	wStream* s = NULL;
 	size_t length = 0;
+	auth_identity* identity = NULL;
 
-	if (nla->identity)
+	if (nla->settings->DisableCredentialsDelegation && nla->identity->creds.password_creds)
 	{
-		length += ber_sizeof_sequence_octet_string(nla->identity->DomainLength * 2);
-		length += ber_sizeof_sequence_octet_string(nla->identity->UserLength * 2);
-		length += ber_sizeof_sequence_octet_string(nla->identity->PasswordLength * 2);
+		char* user = strdup("");
+		char* password = strdup("");
+		char* domain = strdup("");
+		SEC_WINNT_AUTH_IDENTITY* password_creds =
+		    SEC_WINNT_AUTH_IDENTITY_new(user, password, domain);
+		identity = auth_identity_new_password(password_creds);
 	}
-
-	return length;
-}
-
-static size_t nla_sizeof_ts_credentials(rdpNla* nla)
-{
-	size_t size = 0;
-	size += ber_sizeof_integer(1);
-	size += ber_sizeof_contextual_tag(ber_sizeof_integer(1));
-	size +=
-	    ber_sizeof_sequence_octet_string(ber_sizeof_sequence(nla_sizeof_ts_password_creds(nla)));
-	return size;
-}
-
-BOOL nla_read_ts_password_creds(rdpNla* nla, wStream* s)
-{
-	size_t length;
-
-	if (!nla->identity)
+	else
 	{
-		WLog_ERR(TAG, "nla->identity is NULL!");
-		return FALSE;
+		identity = nla->identity;
 	}
 
-	/* TSPasswordCreds (SEQUENCE)
-	 * Initialise to default values. */
-	nla->identity->Flags = SEC_WINNT_AUTH_IDENTITY_UNICODE;
-	nla->identity->UserLength = (UINT32)0;
-	nla->identity->User = NULL;
-	nla->identity->DomainLength = (UINT32)0;
-	nla->identity->Domain = NULL;
-	nla->identity->Password = NULL;
-	nla->identity->PasswordLength = (UINT32)0;
-
-	if (!ber_read_sequence_tag(s, &length))
-		return FALSE;
-
-	/* The sequence is empty, return early,
-	 * TSPasswordCreds (SEQUENCE) is optional. */
-	if (length == 0)
-		return TRUE;
+	length = nla_sizeof_ts_credentials(identity);
 
-	/* [0] domainName (OCTET STRING) */
-	if (!ber_read_contextual_tag(s, 0, &length, TRUE) || !ber_read_octet_string_tag(s, &length))
+	if (!sspi_SecBufferAlloc(&nla->tsCredentials, length))
 	{
-		return FALSE;
+		WLog_ERR(TAG, "sspi_SecBufferAlloc failed!");
+		result = FALSE;
+		goto cleanup;
 	}
 
-	nla->identity->DomainLength = (UINT32)length;
-
-	if (nla->identity->DomainLength > 0)
-	{
-		nla->identity->Domain = (UINT16*)malloc(length);
-
-		if (!nla->identity->Domain)
-			return FALSE;
-
-		CopyMemory(nla->identity->Domain, Stream_Pointer(s), nla->identity->DomainLength);
-		Stream_Seek(s, nla->identity->DomainLength);
-		nla->identity->DomainLength /= 2;
-	}
+	s = Stream_New((BYTE*)nla->tsCredentials.pvBuffer, length);
 
-	/* [1] userName (OCTET STRING) */
-	if (!ber_read_contextual_tag(s, 1, &length, TRUE) || !ber_read_octet_string_tag(s, &length))
+	if (!s)
 	{
-		return FALSE;
+		sspi_SecBufferFree(&nla->tsCredentials);
+		WLog_ERR(TAG, "Stream_New failed!");
+		result = FALSE;
+		goto cleanup;
 	}
 
-	nla->identity->UserLength = (UINT32)length;
-
-	if (nla->identity->UserLength > 0)
-	{
-		nla->identity->User = (UINT16*)malloc(length);
-
-		if (!nla->identity->User)
-			return FALSE;
-
-		CopyMemory(nla->identity->User, Stream_Pointer(s), nla->identity->UserLength);
-		Stream_Seek(s, nla->identity->UserLength);
-		nla->identity->UserLength /= 2;
-	}
+	WLog_INFO(TAG, "TSCredentials: %s", auth_identity_credential_type_label(nla->identity));
+	nla_write_ts_credentials(nla->identity, s);
+	result = TRUE;
+cleanup:
 
-	/* [2] password (OCTET STRING) */
-	if (!ber_read_contextual_tag(s, 2, &length, TRUE) || !ber_read_octet_string_tag(s, &length))
+	if (s)
 	{
-		return FALSE;
+		Stream_Free(s, FALSE);
 	}
 
-	nla->identity->PasswordLength = (UINT32)length;
-
-	if (nla->identity->PasswordLength > 0)
+	if (identity != nla->identity)
 	{
-		nla->identity->Password = (UINT16*)malloc(length);
-
-		if (!nla->identity->Password)
-			return FALSE;
-
-		CopyMemory(nla->identity->Password, Stream_Pointer(s), nla->identity->PasswordLength);
-		Stream_Seek(s, nla->identity->PasswordLength);
-		nla->identity->PasswordLength /= 2;
+		auth_identity_free(identity);
 	}
 
-	return TRUE;
+	return result;
 }
 
-static size_t nla_write_ts_password_creds(rdpNla* nla, wStream* s)
+void dump_ssp(BOOL krb, BOOL nego, BOOL ntlm)
 {
-	size_t size = 0;
-	size_t innerSize = nla_sizeof_ts_password_creds(nla);
-	/* TSPasswordCreds (SEQUENCE) */
-	size += ber_write_sequence_tag(s, innerSize);
-
-	if (nla->identity)
-	{
-		/* [0] domainName (OCTET STRING) */
-		size += ber_write_sequence_octet_string(s, 0, (BYTE*)nla->identity->Domain,
-		                                        nla->identity->DomainLength * 2);
-		/* [1] userName (OCTET STRING) */
-		size += ber_write_sequence_octet_string(s, 1, (BYTE*)nla->identity->User,
-		                                        nla->identity->UserLength * 2);
-		/* [2] password (OCTET STRING) */
-		size += ber_write_sequence_octet_string(s, 2, (BYTE*)nla->identity->Password,
-		                                        nla->identity->PasswordLength * 2);
-	}
-
-	return size;
+	WLog_DBG(TAG, "krb = %d, nego = %d, ntlm = %d\n", krb, nego, ntlm);
 }
 
-static BOOL nla_read_ts_credentials(rdpNla* nla, PSecBuffer ts_credentials)
+void dump_message(SecBufferDesc* message)
 {
-	wStream* s;
-	size_t length;
-	size_t ts_password_creds_length = 0;
-	BOOL ret;
-
-	if (!ts_credentials || !ts_credentials->pvBuffer)
-		return FALSE;
+	WLog_DBG(TAG, "message: buffer count = %d\n", message->cBuffers);
 
-	s = Stream_New(ts_credentials->pvBuffer, ts_credentials->cbBuffer);
-
-	if (!s)
+	for (int i = 0; i < message->cBuffers; i++)
 	{
-		WLog_ERR(TAG, "Stream_New failed!");
-		return FALSE;
+		WLog_DBG(TAG, "message->buffer[%d].BufferType = %d\n", i, message->pBuffers[i].BufferType);
+		WLog_DBG(TAG, "message->buffer[%d].cbBuffer = %d\n", i, message->pBuffers[i].cbBuffer);
+		WLog_DBG(TAG, "message->buffer[%d].pvBuffer = ", i);
+		winpr_HexDump(TAG, WLOG_DEBUG, message->pBuffers[i].pvBuffer,
+		              message->pBuffers[i].cbBuffer);
 	}
-
-	/* TSCredentials (SEQUENCE) */
-	ret = ber_read_sequence_tag(s, &length) &&
-	      /* [0] credType (INTEGER) */
-	      ber_read_contextual_tag(s, 0, &length, TRUE) && ber_read_integer(s, NULL) &&
-	      /* [1] credentials (OCTET STRING) */
-	      ber_read_contextual_tag(s, 1, &length, TRUE) &&
-	      ber_read_octet_string_tag(s, &ts_password_creds_length) &&
-	      nla_read_ts_password_creds(nla, s);
-	Stream_Free(s, FALSE);
-	return ret;
-}
-
-static size_t nla_write_ts_credentials(rdpNla* nla, wStream* s)
-{
-	size_t size = 0;
-	size_t passwordSize;
-	size_t innerSize = nla_sizeof_ts_credentials(nla);
-	/* TSCredentials (SEQUENCE) */
-	size += ber_write_sequence_tag(s, innerSize);
-	/* [0] credType (INTEGER) */
-	size += ber_write_contextual_tag(s, 0, ber_sizeof_integer(1), TRUE);
-	size += ber_write_integer(s, 1);
-	/* [1] credentials (OCTET STRING) */
-	passwordSize = ber_sizeof_sequence(nla_sizeof_ts_password_creds(nla));
-	size += ber_write_contextual_tag(s, 1, ber_sizeof_octet_string(passwordSize), TRUE);
-	size += ber_write_octet_string_tag(s, passwordSize);
-	size += nla_write_ts_password_creds(nla, s);
-	return size;
-}
-
-/**
- * Encode TSCredentials structure.
- * @param credssp
- */
-
-static BOOL nla_encode_ts_credentials(rdpNla* nla)
-{
-	wStream* s;
-	size_t length;
-	int DomainLength = 0;
-	int UserLength = 0;
-	int PasswordLength = 0;
-
-	if (nla->identity)
-	{
-		/* TSPasswordCreds */
-		DomainLength = nla->identity->DomainLength;
-		UserLength = nla->identity->UserLength;
-		PasswordLength = nla->identity->PasswordLength;
-	}
-
-	if (nla->settings->DisableCredentialsDelegation && nla->identity)
-	{
-		/* TSPasswordCreds */
-		nla->identity->DomainLength = 0;
-		nla->identity->UserLength = 0;
-		nla->identity->PasswordLength = 0;
-	}
-
-	length = ber_sizeof_sequence(nla_sizeof_ts_credentials(nla));
-
-	if (!sspi_SecBufferAlloc(&nla->tsCredentials, length))
-	{
-		WLog_ERR(TAG, "sspi_SecBufferAlloc failed!");
-		return FALSE;
-	}
-
-	s = Stream_New((BYTE*)nla->tsCredentials.pvBuffer, length);
-
-	if (!s)
-	{
-		sspi_SecBufferFree(&nla->tsCredentials);
-		WLog_ERR(TAG, "Stream_New failed!");
-		return FALSE;
-	}
-
-	nla_write_ts_credentials(nla, s);
-
-	if (nla->settings->DisableCredentialsDelegation && nla->identity)
-	{
-		/* TSPasswordCreds */
-		nla->identity->DomainLength = DomainLength;
-		nla->identity->UserLength = UserLength;
-		nla->identity->PasswordLength = PasswordLength;
-	}
-
-	Stream_Free(s, FALSE);
-	return TRUE;
 }
 
 static SECURITY_STATUS nla_encrypt_ts_credentials(rdpNla* nla)
@@ -1738,6 +1861,11 @@
 	if (!nla_encode_ts_credentials(nla))
 		return SEC_E_INSUFFICIENT_MEMORY;
 
+#if defined(WITH_DEBUG_NLA)
+	WLog_DBG(TAG, "Encrypting TSCredentials");
+	winpr_HexDump(TAG, WLOG_DEBUG, nla->tsCredentials.pvBuffer, nla->tsCredentials.cbBuffer);
+#endif
+
 	if (!sspi_SecBufferAlloc(&nla->authInfo,
 	                         nla->tsCredentials.cbBuffer + nla->ContextSizes.cbSecurityTrailer))
 		return SEC_E_INSUFFICIENT_MEMORY;
@@ -1835,24 +1963,45 @@
 	Message.pBuffers = (PSecBuffer)&Buffers;
 	status = nla->table->DecryptMessage(&nla->context, &Message, nla->recvSeqNum++, &pfQOP);
 
-	if (status != SEC_E_OK)
+	if (status == SEC_E_OK)
 	{
-		WLog_ERR(TAG, "DecryptMessage failure %s [0x%08" PRIX32 "]",
-		         GetSecurityStatusString(status), status);
-		free(buffer);
-		return status;
-	}
+		auth_identity* identity = nla_read_ts_credentials(&Buffers[1]);
 
-	if (!nla_read_ts_credentials(nla, &Buffers[1]))
-	{
+		if (identity == NULL)
+		{
+			free(buffer);
+			return SEC_E_INSUFFICIENT_MEMORY;
+		}
+
+		auth_identity_free(nla->identity);
+		nla->identity = identity;
 		free(buffer);
-		return SEC_E_INSUFFICIENT_MEMORY;
+		return SEC_E_OK;
 	}
 
+	WLog_ERR(TAG, "DecryptMessage failure %s [0x%08" PRIX32 "]", GetSecurityStatusString(status),
+	         status);
 	free(buffer);
-	return SEC_E_OK;
+	return status;
 }
 
+/**
+ * TSRequest ::= SEQUENCE {
+ * 	version    [0] INTEGER,
+ * 	negoTokens [1] NegoData OPTIONAL,
+ * 	authInfo   [2] OCTET STRING OPTIONAL,
+ * 	pubKeyAuth [3] OCTET STRING OPTIONAL,
+ * 	errorCode  [4] INTEGER OPTIONAL
+ * }
+ *
+ * NegoData ::= SEQUENCE OF NegoDataItem
+ *
+ * NegoDataItem ::= SEQUENCE {
+ * 	negoToken [0] OCTET STRING
+ * }
+ *
+ */
+
 static size_t nla_sizeof_nego_token(size_t length)
 {
 	length = ber_sizeof_octet_string(length);
@@ -2257,16 +2406,9 @@
 {
 	DWORD status;
 	DWORD SpnLength;
-	LPTSTR hostnameX = NULL;
-	LPTSTR ServiceClassX = NULL;
+	LPTSTR hostnameX = stringX_from_cstring(hostname);
+	LPTSTR ServiceClassX = stringX_from_cstring(ServiceClass);
 	LPTSTR ServicePrincipalName = NULL;
-#ifdef UNICODE
-	ConvertToUnicode(CP_UTF8, 0, hostname, -1, &hostnameX, 0);
-	ConvertToUnicode(CP_UTF8, 0, ServiceClass, -1, &ServiceClassX, 0);
-#else
-	hostnameX = _strdup(hostname);
-	ServiceClassX = _strdup(ServiceClass);
-#endif
 
 	if (!hostnameX || !ServiceClassX)
 	{
@@ -2325,19 +2467,8 @@
 
 rdpNla* nla_new(freerdp* instance, rdpTransport* transport, rdpSettings* settings)
 {
-	rdpNla* nla = (rdpNla*)calloc(1, sizeof(rdpNla));
-
-	if (!nla)
-		return NULL;
-
-	nla->identity = calloc(1, sizeof(SEC_WINNT_AUTH_IDENTITY));
-
-	if (!nla->identity)
-	{
-		free(nla);
-		return NULL;
-	}
-
+	rdpNla* nla;
+	CHECK_MEMORY(nla = calloc(1, sizeof(*nla)), NULL, "rdpNla structure");
 	nla->instance = instance;
 	nla->settings = settings;
 	nla->server = settings->ServerMode;
@@ -2417,8 +2548,10 @@
 
 void nla_free(rdpNla* nla)
 {
-	if (!nla)
+	if (nla == NULL)
+	{
 		return;
+	}
 
 	if (nla->table)
 	{
@@ -2446,22 +2579,30 @@
 		}
 	}
 
-	free(nla->SamFile);
-	nla->SamFile = NULL;
 	sspi_SecBufferFree(&nla->ClientNonce);
 	sspi_SecBufferFree(&nla->PublicKey);
 	sspi_SecBufferFree(&nla->tsCredentials);
+	auth_identity_free(nla->identity);
+	free(nla->SamFile);
 	free(nla->ServicePrincipalName);
-	nla_identity_free(nla->identity);
 	free(nla);
 }
 
 SEC_WINNT_AUTH_IDENTITY* nla_get_identity(rdpNla* nla)
 {
-	if (!nla)
+	if ((nla == NULL) || (nla->identity == NULL))
+	{
 		return NULL;
+	}
 
-	return nla->identity;
+	if (nla->identity->cred_type == credential_type_password)
+	{
+		return nla->identity->creds.password_creds;
+	}
+	else
+	{
+		return NULL;
+	}
 }
 
 NLA_STATE nla_get_state(rdpNla* nla)
@@ -2489,25 +2630,3 @@
 	nla->ServicePrincipalName = principal;
 	return TRUE;
 }
-
-BOOL nla_impersonate(rdpNla* nla)
-{
-	if (!nla)
-		return FALSE;
-
-	if (!nla->table || !nla->table->ImpersonateSecurityContext)
-		return FALSE;
-
-	return (nla->table->ImpersonateSecurityContext(&nla->context) == SEC_E_OK);
-}
-
-BOOL nla_revert_to_self(rdpNla* nla)
-{
-	if (!nla)
-		return FALSE;
-
-	if (!nla->table || !nla->table->RevertSecurityContext)
-		return FALSE;
-
-	return (nla->table->RevertSecurityContext(&nla->context) == SEC_E_OK);
-}
--- libfreerdp/core/nla.h	2019-07-25 19:51:03.893912455 +0300
+++ ../../informatimago/FreeRDP/libfreerdp/core/nla.h	2019-07-25 20:11:27.831982008 +0300
@@ -60,9 +60,6 @@
 
 FREERDP_LOCAL BOOL nla_set_service_principal(rdpNla* nla, LPSTR principal);
 
-FREERDP_LOCAL BOOL nla_impersonate(rdpNla* nla);
-FREERDP_LOCAL BOOL nla_revert_to_self(rdpNla* nla);
-
 FREERDP_LOCAL rdpNla* nla_new(freerdp* instance, rdpTransport* transport, rdpSettings* settings);
 FREERDP_LOCAL void nla_free(rdpNla* nla);
 
--- libfreerdp/core/peer.c	2019-07-25 19:51:03.977912872 +0300
+++ ../../informatimago/FreeRDP/libfreerdp/core/peer.c	2019-07-25 20:11:27.915982424 +0300
@@ -31,6 +31,7 @@
 #include <freerdp/log.h>
 
 #include "rdp.h"
+#include "nla.h"
 #include "peer.h"
 
 #define TAG FREERDP_TAG("core.peer")
@@ -574,45 +575,16 @@
 		break;
 
 	case CONNECTION_STATE_LICENSING:
-	{
-		LicenseCallbackResult res;
-
-		if (!client->LicenseCallback)
-		{
-			WLog_ERR(TAG, "peer_recv_callback: LicenseCallback has been removed, assuming "
-			              "licensing is ok (please fix your app)");
-			res = LICENSE_CB_COMPLETED;
-		}
-		else
-			res = client->LicenseCallback(client, s);
-
-		switch (res)
+		if (!license_send_valid_client_error_packet(rdp->license))
 		{
-		case LICENSE_CB_INTERNAL_ERROR:
-			WLog_ERR(TAG, "peer_recv_callback: CONNECTION_STATE_LICENSING - callback internal "
-			              "error, aborting");
+			WLog_ERR(TAG, "peer_recv_callback: CONNECTION_STATE_LICENSING - "
+			              "license_send_valid_client_error_packet() fail");
 			return -1;
-
-		case LICENSE_CB_ABORT:
-			return -1;
-
-		case LICENSE_CB_IN_PROGRESS:
-			break;
-
-		case LICENSE_CB_COMPLETED:
-			rdp_server_transition_to_state(rdp, CONNECTION_STATE_CAPABILITIES_EXCHANGE);
-			return peer_recv_callback(transport, NULL, extra);
-
-		default:
-			WLog_ERR(TAG,
-			         "peer_recv_callback: CONNECTION_STATE_LICENSING - unknown license callback "
-			         "result %d",
-			         (int)res);
-			break;
 		}
 
+		rdp_server_transition_to_state(rdp, CONNECTION_STATE_CAPABILITIES_EXCHANGE);
+		return peer_recv_callback(transport, NULL, extra);
 		break;
-	}
 
 	case CONNECTION_STATE_CAPABILITIES_EXCHANGE:
 		if (!rdp->AwaitCapabilities)
@@ -701,7 +673,7 @@
 	if (!rdp_send_deactivate_all(client->context->rdp))
 		return FALSE;
 
-	if (freerdp_settings_get_bool(client->settings, FreeRDP_SupportErrorInfoPdu))
+	if (freerdp_get_param_bool(client->settings, FreeRDP_SupportErrorInfoPdu))
 	{
 		rdp_send_error_info(client->context->rdp);
 	}
@@ -738,19 +710,6 @@
 	return peer->context->rdp->transport->haveMoreBytesToRead;
 }
 
-static LicenseCallbackResult freerdp_peer_nolicense(freerdp_peer* peer, wStream* s)
-{
-	rdpRdp* rdp = peer->context->rdp;
-
-	if (!license_send_valid_client_error_packet(rdp))
-	{
-		WLog_ERR(TAG, "freerdp_peer_nolicense: license_send_valid_client_error_packet() failed");
-		return LICENSE_CB_ABORT;
-	}
-
-	return LICENSE_CB_COMPLETED;
-}
-
 BOOL freerdp_peer_context_new(freerdp_peer* client)
 {
 	rdpRdp* rdp;
@@ -804,7 +763,6 @@
 	client->IsWriteBlocked = freerdp_peer_is_write_blocked;
 	client->DrainOutputBuffer = freerdp_peer_drain_output_buffer;
 	client->HasMoreToRead = freerdp_peer_has_more_to_read;
-	client->LicenseCallback = freerdp_peer_nolicense;
 	IFCALLRET(client->ContextNew, ret, client, client->context);
 
 	if (ret)
--- libfreerdp/core/settings.c	2019-07-25 19:51:04.109913526 +0300
+++ ../../informatimago/FreeRDP/libfreerdp/core/settings.c	2019-07-25 20:11:28.043983059 +0300
@@ -315,13 +315,6 @@
 	if (!settings)
 		return NULL;
 
-	settings->HiDefRemoteApp = FALSE;
-	settings->RemoteApplicationSupportMask =
-	    RAIL_LEVEL_SUPPORTED | RAIL_LEVEL_DOCKED_LANGBAR_SUPPORTED |
-	    RAIL_LEVEL_SHELL_INTEGRATION_SUPPORTED | RAIL_LEVEL_LANGUAGE_IME_SYNC_SUPPORTED |
-	    RAIL_LEVEL_SERVER_TO_CLIENT_IME_SYNC_SUPPORTED | RAIL_LEVEL_HIDE_MINIMIZED_APPS_SUPPORTED |
-	    RAIL_LEVEL_WINDOW_CLOAKING_SUPPORTED | RAIL_LEVEL_HANDSHAKE_EX_SUPPORTED;
-	settings->SupportHeartbeatPdu = TRUE;
 	settings->ServerMode = (flags & FREERDP_SETTINGS_SERVER_MODE) ? TRUE : FALSE;
 	settings->WaitForOutputBufferFlush = TRUE;
 	settings->MaxTimeInCheckLoop = 100;
@@ -331,7 +324,7 @@
 	settings->Fullscreen = FALSE;
 	settings->GrabKeyboard = TRUE;
 	settings->Decorations = TRUE;
-	settings->RdpVersion = RDP_VERSION_10_6;
+	settings->RdpVersion = RDP_VERSION_5_PLUS;
 	settings->ColorDepth = 16;
 	settings->ExtSecurity = FALSE;
 	settings->NlaSecurity = TRUE;
@@ -430,6 +423,9 @@
 	settings->DrawAllowDynamicColorFidelity = FALSE;
 	settings->FrameMarkerCommandEnabled = TRUE;
 	settings->SurfaceFrameMarkerEnabled = TRUE;
+	settings->BitmapCacheV3Enabled = FALSE;
+	settings->BitmapCacheEnabled = TRUE;
+	settings->BitmapCachePersistEnabled = FALSE;
 	settings->AllowCacheWaitingList = TRUE;
 	settings->BitmapCacheV2NumCells = 5;
 	settings->BitmapCacheV2CellInfo =
@@ -484,7 +480,7 @@
 	settings->GlyphCache[9].cacheMaximumCellSize = 256;
 	settings->FragCache->cacheEntries = 256;
 	settings->FragCache->cacheMaximumCellSize = 256;
-	settings->OffscreenSupportLevel = FALSE;
+	settings->OffscreenSupportLevel = TRUE;
 	settings->OffscreenCacheSize = 7680;
 	settings->OffscreenCacheEntries = 2000;
 	settings->DrawNineGridCacheSize = 2560;
@@ -494,7 +490,7 @@
 	if (!settings->ClientDir)
 		goto out_fail;
 
-	settings->RemoteWndSupportLevel = WINDOW_LEVEL_SUPPORTED | WINDOW_LEVEL_SUPPORTED_EX;
+	settings->RemoteWndSupportLevel = WINDOW_LEVEL_SUPPORTED_EX;
 	settings->RemoteAppNumIconCaches = 3;
 	settings->RemoteAppNumIconCacheEntries = 12;
 	settings->VirtualChannelChunkSize = CHANNEL_CHUNK_LENGTH;
@@ -584,7 +580,7 @@
 		}
 		else
 		{
-			size_t i;
+			int i;
 			char product[sizeof(FREERDP_PRODUCT_STRING)];
 			memset(product, 0, sizeof(product));
 
@@ -606,7 +602,6 @@
 
 	settings->ActionScript = _strdup("~/.config/freerdp/action.sh");
 	settings->SmartcardLogon = FALSE;
-	settings->PromptForCredentials = TRUE;
 	settings->TlsSecLevel = 1;
 	settings->OrderSupport = calloc(1, 32);
 
@@ -642,474 +637,378 @@
 	return NULL;
 }
 
-static void freerdp_settings_free_internal(rdpSettings* settings)
-{
-	free(settings->ServerHostname);
-	free(settings->Username);
-	free(settings->Password);
-	free(settings->Domain);
-	free(settings->PasswordHash);
-	free(settings->AcceptedCert);
-	free(settings->AlternateShell);
-	free(settings->ShellWorkingDirectory);
-	free(settings->ComputerName);
-	free(settings->ChannelDefArray);
-	free(settings->MonitorDefArray);
-	free(settings->MonitorIds);
-	free(settings->ClientAddress);
-	free(settings->ClientDir);
-	free(settings->AllowedTlsCiphers);
-	free(settings->NtlmSamFile);
-	free(settings->CertificateFile);
-	free(settings->PrivateKeyFile);
-	free(settings->ConnectionFile);
-	free(settings->AssistanceFile);
-	free(settings->ReceivedCapabilities);
-	free(settings->OrderSupport);
-	free(settings->ClientHostname);
-	free(settings->ClientProductId);
-	free(settings->ServerRandom);
-	free(settings->ClientRandom);
-	free(settings->ServerCertificate);
-	free(settings->RdpKeyFile);
-	certificate_free(settings->RdpServerCertificate);
-	free(settings->CertificateContent);
-	free(settings->PrivateKeyContent);
-	free(settings->RdpKeyContent);
-	free(settings->ClientAutoReconnectCookie);
-	free(settings->ServerAutoReconnectCookie);
-	free(settings->ClientTimeZone);
-	free(settings->BitmapCacheV2CellInfo);
-	free(settings->GlyphCache);
-	free(settings->FragCache);
-	key_free(settings->RdpServerRsaKey);
-	free(settings->ConfigPath);
-	free(settings->CurrentPath);
-	free(settings->HomePath);
-	free(settings->LoadBalanceInfo);
-	free(settings->TargetNetAddress);
-	free(settings->RedirectionTargetFQDN);
-	free(settings->RedirectionTargetNetBiosName);
-	free(settings->RedirectionUsername);
-	free(settings->RedirectionDomain);
-	free(settings->RedirectionPassword);
-	free(settings->RedirectionTsvUrl);
-	free(settings->RedirectionAcceptedCert);
-	free(settings->RemoteAssistanceSessionId);
-	free(settings->RemoteAssistancePassword);
-	free(settings->RemoteAssistancePassStub);
-	free(settings->RemoteAssistanceRCTicket);
-	free(settings->AuthenticationServiceClass);
-	free(settings->GatewayHostname);
-	free(settings->GatewayUsername);
-	free(settings->GatewayPassword);
-	free(settings->GatewayDomain);
-	free(settings->GatewayAccessToken);
-	free(settings->GatewayAcceptedCert);
-	free(settings->CertificateName);
-	free(settings->DynamicDSTTimeZoneKeyName);
-	free(settings->PreconnectionBlob);
-	free(settings->KerberosKdc);
-	free(settings->KerberosRealm);
-	free(settings->DumpRemoteFxFile);
-	free(settings->PlayRemoteFxFile);
-	free(settings->RemoteApplicationName);
-	free(settings->RemoteApplicationIcon);
-	free(settings->RemoteApplicationProgram);
-	free(settings->RemoteApplicationFile);
-	free(settings->RemoteApplicationGuid);
-	free(settings->RemoteApplicationCmdLine);
-	free(settings->ImeFileName);
-	free(settings->DrivesToRedirect);
-	free(settings->WindowTitle);
-	free(settings->WmClass);
-	free(settings->ActionScript);
-	freerdp_target_net_addresses_free(settings);
-	freerdp_device_collection_free(settings);
-	freerdp_static_channel_collection_free(settings);
-	freerdp_dynamic_channel_collection_free(settings);
-	free(settings->SettingsModified);
-	memset(settings, 0, sizeof(rdpSettings));
-}
-
-void freerdp_settings_free(rdpSettings* settings)
-{
-	if (!settings)
-		return;
-
-	freerdp_settings_free_internal(settings);
-	free(settings);
-}
-
-BOOL freerdp_settings_copy(rdpSettings* _settings, const rdpSettings* settings)
+rdpSettings* freerdp_settings_clone(rdpSettings* settings)
 {
 	UINT32 index;
+	rdpSettings* _settings;
+	_settings = (rdpSettings*)calloc(1, sizeof(rdpSettings));
 
-	if (!settings || !_settings)
-		return FALSE;
-
-	freerdp_settings_free_internal(_settings);
-	*_settings = *settings;
-	/* char* values */
+	if (_settings)
+	{
+		CopyMemory(_settings, settings, sizeof(rdpSettings));
+		/* char* values */
 #define CHECKED_STRDUP(name)                                            \
 	if (settings->name && !(_settings->name = _strdup(settings->name))) \
 	goto out_fail
-	CHECKED_STRDUP(ServerHostname);             /* 20 */
-	CHECKED_STRDUP(Username);                   /* 21 */
-	CHECKED_STRDUP(Password);                   /* 22 */
-	CHECKED_STRDUP(Domain);                     /* 23 */
-	CHECKED_STRDUP(PasswordHash);               /* 24 */
-	CHECKED_STRDUP(AcceptedCert);               /* 27 */
-	CHECKED_STRDUP(AlternateShell);             /* 640 */
-	CHECKED_STRDUP(ShellWorkingDirectory);      /* 641 */
-	CHECKED_STRDUP(ClientAddress);              /* 769 */
-	CHECKED_STRDUP(ClientDir);                  /* 770 */
-	CHECKED_STRDUP(DynamicDSTTimeZoneKeyName);  /* 897 */
-	CHECKED_STRDUP(RemoteAssistanceSessionId);  /* 1025 */
-	CHECKED_STRDUP(RemoteAssistancePassStub);   /* 1026 */
-	CHECKED_STRDUP(RemoteAssistancePassword);   /* 1027 */
-	CHECKED_STRDUP(RemoteAssistanceRCTicket);   /* 1028 */
-	CHECKED_STRDUP(AuthenticationServiceClass); /* 1098 */
-	CHECKED_STRDUP(AllowedTlsCiphers);          /* 1101 */
-	CHECKED_STRDUP(NtlmSamFile);                /* 1103 */
-	CHECKED_STRDUP(PreconnectionBlob);          /* 1155 */
-	CHECKED_STRDUP(RedirectionAcceptedCert);    /* 1231 */
-	CHECKED_STRDUP(KerberosKdc);                /* 1344 */
-	CHECKED_STRDUP(KerberosRealm);              /* 1345 */
-	CHECKED_STRDUP(CertificateName);            /* 1409 */
-	CHECKED_STRDUP(CertificateFile);            /* 1410 */
-	CHECKED_STRDUP(PrivateKeyFile);             /* 1411 */
-	CHECKED_STRDUP(RdpKeyFile);                 /* 1412 */
-	CHECKED_STRDUP(CertificateContent);         /* 1416 */
-	CHECKED_STRDUP(PrivateKeyContent);          /* 1417 */
-	CHECKED_STRDUP(RdpKeyContent);              /* 1418 */
-	CHECKED_STRDUP(WindowTitle);                /* 1542 */
-	CHECKED_STRDUP(WmClass);                    /* 1549 */
-	CHECKED_STRDUP(ComputerName);               /* 1664 */
-	CHECKED_STRDUP(ConnectionFile);             /* 1728 */
-	CHECKED_STRDUP(AssistanceFile);             /* 1729 */
-	CHECKED_STRDUP(HomePath);                   /* 1792 */
-	CHECKED_STRDUP(ConfigPath);                 /* 1793 */
-	CHECKED_STRDUP(CurrentPath);                /* 1794 */
-	CHECKED_STRDUP(DumpRemoteFxFile);           /* 1858 */
-	CHECKED_STRDUP(PlayRemoteFxFile);           /* 1859 */
-	CHECKED_STRDUP(GatewayHostname);            /* 1986 */
-	CHECKED_STRDUP(GatewayUsername);            /* 1987 */
-	CHECKED_STRDUP(GatewayPassword);            /* 1988 */
-	CHECKED_STRDUP(GatewayDomain);              /* 1989 */
-	CHECKED_STRDUP(GatewayAccessToken);         /* 1997 */
-	CHECKED_STRDUP(GatewayAcceptedCert);        /* 1998 */
-	CHECKED_STRDUP(ProxyHostname);              /* 2016 */
-	CHECKED_STRDUP(RemoteApplicationName);      /* 2113 */
-	CHECKED_STRDUP(RemoteApplicationIcon);      /* 2114 */
-	CHECKED_STRDUP(RemoteApplicationProgram);   /* 2115 */
-	CHECKED_STRDUP(RemoteApplicationFile);      /* 2116 */
-	CHECKED_STRDUP(RemoteApplicationGuid);      /* 2117 */
-	CHECKED_STRDUP(RemoteApplicationCmdLine);   /* 2118 */
-	CHECKED_STRDUP(ImeFileName);                /* 2628 */
-	CHECKED_STRDUP(DrivesToRedirect);           /* 4290 */
-	CHECKED_STRDUP(ActionScript);
+		CHECKED_STRDUP(ServerHostname);             /* 20 */
+		CHECKED_STRDUP(Username);                   /* 21 */
+		CHECKED_STRDUP(Password);                   /* 22 */
+		CHECKED_STRDUP(Domain);                     /* 23 */
+		CHECKED_STRDUP(PasswordHash);               /* 24 */
+		CHECKED_STRDUP(AcceptedCert);               /* 27 */
+		_settings->ClientHostname = NULL;           /* 134 */
+		_settings->ClientProductId = NULL;          /* 135 */
+		CHECKED_STRDUP(AlternateShell);             /* 640 */
+		CHECKED_STRDUP(ShellWorkingDirectory);      /* 641 */
+		CHECKED_STRDUP(ClientAddress);              /* 769 */
+		CHECKED_STRDUP(ClientDir);                  /* 770 */
+		CHECKED_STRDUP(DynamicDSTTimeZoneKeyName);  /* 897 */
+		CHECKED_STRDUP(RemoteAssistanceSessionId);  /* 1025 */
+		CHECKED_STRDUP(RemoteAssistancePassStub);   /* 1026 */
+		CHECKED_STRDUP(RemoteAssistancePassword);   /* 1027 */
+		CHECKED_STRDUP(RemoteAssistanceRCTicket);   /* 1028 */
+		CHECKED_STRDUP(AuthenticationServiceClass); /* 1098 */
+		CHECKED_STRDUP(AllowedTlsCiphers);          /* 1101 */
+		CHECKED_STRDUP(NtlmSamFile);                /* 1103 */
+		CHECKED_STRDUP(PreconnectionBlob);          /* 1155 */
+		CHECKED_STRDUP(RedirectionAcceptedCert);    /* 1231 */
+		CHECKED_STRDUP(KerberosKdc);                /* 1344 */
+		CHECKED_STRDUP(KerberosRealm);              /* 1345 */
+		CHECKED_STRDUP(CertificateName);            /* 1409 */
+		CHECKED_STRDUP(CertificateFile);            /* 1410 */
+		CHECKED_STRDUP(PrivateKeyFile);             /* 1411 */
+		CHECKED_STRDUP(RdpKeyFile);                 /* 1412 */
+		CHECKED_STRDUP(CertificateContent);         /* 1416 */
+		CHECKED_STRDUP(PrivateKeyContent);          /* 1417 */
+		CHECKED_STRDUP(RdpKeyContent);              /* 1418 */
+		CHECKED_STRDUP(WindowTitle);                /* 1542 */
+		CHECKED_STRDUP(WmClass);                    /* 1549 */
+		CHECKED_STRDUP(ComputerName);               /* 1664 */
+		CHECKED_STRDUP(ConnectionFile);             /* 1728 */
+		CHECKED_STRDUP(AssistanceFile);             /* 1729 */
+		CHECKED_STRDUP(HomePath);                   /* 1792 */
+		CHECKED_STRDUP(ConfigPath);                 /* 1793 */
+		CHECKED_STRDUP(CurrentPath);                /* 1794 */
+		CHECKED_STRDUP(DumpRemoteFxFile);           /* 1858 */
+		CHECKED_STRDUP(PlayRemoteFxFile);           /* 1859 */
+		CHECKED_STRDUP(GatewayHostname);            /* 1986 */
+		CHECKED_STRDUP(GatewayUsername);            /* 1987 */
+		CHECKED_STRDUP(GatewayPassword);            /* 1988 */
+		CHECKED_STRDUP(GatewayDomain);              /* 1989 */
+		CHECKED_STRDUP(GatewayAccessToken);         /* 1997 */
+		CHECKED_STRDUP(GatewayAcceptedCert);        /* 1998 */
+		CHECKED_STRDUP(ProxyHostname);              /* 2016 */
+		CHECKED_STRDUP(RemoteApplicationName);      /* 2113 */
+		CHECKED_STRDUP(RemoteApplicationIcon);      /* 2114 */
+		CHECKED_STRDUP(RemoteApplicationProgram);   /* 2115 */
+		CHECKED_STRDUP(RemoteApplicationFile);      /* 2116 */
+		CHECKED_STRDUP(RemoteApplicationGuid);      /* 2117 */
+		CHECKED_STRDUP(RemoteApplicationCmdLine);   /* 2118 */
+		CHECKED_STRDUP(ImeFileName);                /* 2628 */
+		CHECKED_STRDUP(DrivesToRedirect);           /* 4290 */
+		CHECKED_STRDUP(ActionScript);
+		/**
+		 * Manual Code
+		 */
+		_settings->LoadBalanceInfo = NULL;
+		_settings->LoadBalanceInfoLength = 0;
+		_settings->TargetNetAddress = NULL;
+		_settings->RedirectionTargetFQDN = NULL;
+		_settings->RedirectionTargetNetBiosName = NULL;
+		_settings->RedirectionUsername = NULL;
+		_settings->RedirectionDomain = NULL;
+		_settings->RedirectionPassword = NULL;
+		_settings->RedirectionPasswordLength = 0;
+		_settings->RedirectionTsvUrl = NULL;
+		_settings->RedirectionTsvUrlLength = 0;
+		_settings->TargetNetAddressCount = 0;
+		_settings->TargetNetAddresses = NULL;
+		_settings->TargetNetPorts = NULL;
 
-	if (settings->LoadBalanceInfo && settings->LoadBalanceInfoLength)
-	{
-		_settings->LoadBalanceInfo = (BYTE*)calloc(1, settings->LoadBalanceInfoLength + 2);
+		if (settings->LoadBalanceInfo && settings->LoadBalanceInfoLength)
+		{
+			_settings->LoadBalanceInfo = (BYTE*)calloc(1, settings->LoadBalanceInfoLength + 2);
 
-		if (!_settings->LoadBalanceInfo)
-			goto out_fail;
+			if (!_settings->LoadBalanceInfo)
+				goto out_fail;
 
-		CopyMemory(_settings->LoadBalanceInfo, settings->LoadBalanceInfo,
-		           settings->LoadBalanceInfoLength);
-		_settings->LoadBalanceInfoLength = settings->LoadBalanceInfoLength;
-	}
+			CopyMemory(_settings->LoadBalanceInfo, settings->LoadBalanceInfo,
+			           settings->LoadBalanceInfoLength);
+			_settings->LoadBalanceInfoLength = settings->LoadBalanceInfoLength;
+		}
 
-	if (_settings->ServerRandomLength)
-	{
-		_settings->ServerRandom = (BYTE*)malloc(_settings->ServerRandomLength);
+		if (_settings->ServerRandomLength)
+		{
+			_settings->ServerRandom = (BYTE*)malloc(_settings->ServerRandomLength);
 
-		if (!_settings->ServerRandom)
-			goto out_fail;
+			if (!_settings->ServerRandom)
+				goto out_fail;
 
-		CopyMemory(_settings->ServerRandom, settings->ServerRandom, _settings->ServerRandomLength);
-		_settings->ServerRandomLength = settings->ServerRandomLength;
-	}
+			CopyMemory(_settings->ServerRandom, settings->ServerRandom,
+			           _settings->ServerRandomLength);
+			_settings->ServerRandomLength = settings->ServerRandomLength;
+		}
 
-	if (_settings->ClientRandomLength)
-	{
-		_settings->ClientRandom = (BYTE*)malloc(_settings->ClientRandomLength);
+		if (_settings->ClientRandomLength)
+		{
+			_settings->ClientRandom = (BYTE*)malloc(_settings->ClientRandomLength);
 
-		if (!_settings->ClientRandom)
-			goto out_fail;
+			if (!_settings->ClientRandom)
+				goto out_fail;
 
-		CopyMemory(_settings->ClientRandom, settings->ClientRandom, _settings->ClientRandomLength);
-		_settings->ClientRandomLength = settings->ClientRandomLength;
-	}
+			CopyMemory(_settings->ClientRandom, settings->ClientRandom,
+			           _settings->ClientRandomLength);
+			_settings->ClientRandomLength = settings->ClientRandomLength;
+		}
 
-	if (settings->RdpServerCertificate)
-	{
-		_settings->RdpServerCertificate = certificate_clone(settings->RdpServerCertificate);
+		if (settings->RdpServerCertificate)
+		{
+			_settings->RdpServerCertificate = certificate_clone(settings->RdpServerCertificate);
 
-		if (!_settings->RdpServerCertificate)
-			goto out_fail;
-	}
+			if (!_settings->RdpServerCertificate)
+				goto out_fail;
+		}
 
-	if (settings->RdpServerRsaKey)
-	{
-		_settings->RdpServerRsaKey = key_clone(settings->RdpServerRsaKey);
+		_settings->ChannelCount = settings->ChannelCount;
+		_settings->ChannelDefArraySize = settings->ChannelDefArraySize;
 
-		if (!_settings->RdpServerRsaKey)
-			goto out_fail;
-	}
+		if (_settings->ChannelDefArraySize > 0)
+		{
+			_settings->ChannelDefArray =
+			    (CHANNEL_DEF*)calloc(settings->ChannelDefArraySize, sizeof(CHANNEL_DEF));
 
-	_settings->ChannelCount = settings->ChannelCount;
-	_settings->ChannelDefArraySize = settings->ChannelDefArraySize;
+			if (!_settings->ChannelDefArray)
+				goto out_fail;
 
-	if (_settings->ChannelDefArraySize > 0)
-	{
-		_settings->ChannelDefArray =
-		    (CHANNEL_DEF*)calloc(settings->ChannelDefArraySize, sizeof(CHANNEL_DEF));
+			CopyMemory(_settings->ChannelDefArray, settings->ChannelDefArray,
+			           sizeof(CHANNEL_DEF) * settings->ChannelDefArraySize);
+		}
+		else
+			_settings->ChannelDefArray = NULL;
+
+		_settings->MonitorCount = settings->MonitorCount;
+		_settings->MonitorDefArraySize = settings->MonitorDefArraySize;
 
-		if (!_settings->ChannelDefArray)
+		if (_settings->MonitorDefArraySize > 0)
+		{
+			_settings->MonitorDefArray =
+			    (rdpMonitor*)calloc(settings->MonitorDefArraySize, sizeof(rdpMonitor));
+
+			if (!_settings->MonitorDefArray)
+				goto out_fail;
+
+			CopyMemory(_settings->MonitorDefArray, settings->MonitorDefArray,
+			           sizeof(rdpMonitor) * settings->MonitorDefArraySize);
+		}
+		else
+			_settings->MonitorDefArray = NULL;
+
+		_settings->MonitorIds = (UINT32*)calloc(16, sizeof(UINT32));
+
+		if (!_settings->MonitorIds)
 			goto out_fail;
 
-		CopyMemory(_settings->ChannelDefArray, settings->ChannelDefArray,
-		           sizeof(CHANNEL_DEF) * settings->ChannelDefArraySize);
-	}
-	else
-		_settings->ChannelDefArray = NULL;
+		CopyMemory(_settings->MonitorIds, settings->MonitorIds, 16 * sizeof(UINT32));
+		_settings->ReceivedCapabilities = malloc(32);
 
-	_settings->MonitorCount = settings->MonitorCount;
-	_settings->MonitorDefArraySize = settings->MonitorDefArraySize;
+		if (!_settings->ReceivedCapabilities)
+			goto out_fail;
 
-	if (_settings->MonitorDefArraySize > 0)
-	{
-		_settings->MonitorDefArray =
-		    (rdpMonitor*)calloc(settings->MonitorDefArraySize, sizeof(rdpMonitor));
+		_settings->OrderSupport = malloc(32);
 
-		if (!_settings->MonitorDefArray)
+		if (!_settings->OrderSupport)
 			goto out_fail;
 
-		CopyMemory(_settings->MonitorDefArray, settings->MonitorDefArray,
-		           sizeof(rdpMonitor) * settings->MonitorDefArraySize);
-	}
-	else
-		_settings->MonitorDefArray = NULL;
+		if (!_settings->ReceivedCapabilities || !_settings->OrderSupport)
+			goto out_fail;
 
-	_settings->MonitorIds = (UINT32*)calloc(16, sizeof(UINT32));
+		CopyMemory(_settings->ReceivedCapabilities, settings->ReceivedCapabilities, 32);
+		CopyMemory(_settings->OrderSupport, settings->OrderSupport, 32);
+		_settings->ClientHostname = _strdup(settings->ClientHostname);
 
-	if (!_settings->MonitorIds)
-		goto out_fail;
+		if (!_settings->ClientHostname)
+			goto out_fail;
 
-	CopyMemory(_settings->MonitorIds, settings->MonitorIds, 16 * sizeof(UINT32));
-	_settings->ReceivedCapabilities = malloc(32);
+		_settings->ClientProductId = _strdup(settings->ClientProductId);
 
-	if (!_settings->ReceivedCapabilities)
-		goto out_fail;
+		if (!_settings->ClientProductId)
+			goto out_fail;
 
-	_settings->OrderSupport = malloc(32);
+		_settings->BitmapCacheV2CellInfo =
+		    (BITMAP_CACHE_V2_CELL_INFO*)malloc(sizeof(BITMAP_CACHE_V2_CELL_INFO) * 6);
 
-	if (!_settings->OrderSupport)
-		goto out_fail;
+		if (!_settings->BitmapCacheV2CellInfo)
+			goto out_fail;
 
-	if (!_settings->ReceivedCapabilities || !_settings->OrderSupport)
-		goto out_fail;
+		CopyMemory(_settings->BitmapCacheV2CellInfo, settings->BitmapCacheV2CellInfo,
+		           sizeof(BITMAP_CACHE_V2_CELL_INFO) * 6);
+		_settings->GlyphCache = malloc(sizeof(GLYPH_CACHE_DEFINITION) * 10);
 
-	CopyMemory(_settings->ReceivedCapabilities, settings->ReceivedCapabilities, 32);
-	CopyMemory(_settings->OrderSupport, settings->OrderSupport, 32);
-	_settings->ClientHostname = _strdup(settings->ClientHostname);
+		if (!_settings->GlyphCache)
+			goto out_fail;
 
-	if (!_settings->ClientHostname)
-		goto out_fail;
+		_settings->FragCache = malloc(sizeof(GLYPH_CACHE_DEFINITION));
 
-	_settings->ClientProductId = _strdup(settings->ClientProductId);
+		if (!_settings->FragCache)
+			goto out_fail;
 
-	if (!_settings->ClientProductId)
-		goto out_fail;
+		CopyMemory(_settings->GlyphCache, settings->GlyphCache,
+		           sizeof(GLYPH_CACHE_DEFINITION) * 10);
+		CopyMemory(_settings->FragCache, settings->FragCache, sizeof(GLYPH_CACHE_DEFINITION));
+		_settings->ClientAutoReconnectCookie =
+		    (ARC_CS_PRIVATE_PACKET*)malloc(sizeof(ARC_CS_PRIVATE_PACKET));
 
-	_settings->BitmapCacheV2CellInfo =
-	    (BITMAP_CACHE_V2_CELL_INFO*)malloc(sizeof(BITMAP_CACHE_V2_CELL_INFO) * 6);
+		if (!_settings->ClientAutoReconnectCookie)
+			goto out_fail;
 
-	if (!_settings->BitmapCacheV2CellInfo)
-		goto out_fail;
+		_settings->ServerAutoReconnectCookie =
+		    (ARC_SC_PRIVATE_PACKET*)malloc(sizeof(ARC_SC_PRIVATE_PACKET));
 
-	CopyMemory(_settings->BitmapCacheV2CellInfo, settings->BitmapCacheV2CellInfo,
-	           sizeof(BITMAP_CACHE_V2_CELL_INFO) * 6);
-	_settings->GlyphCache = malloc(sizeof(GLYPH_CACHE_DEFINITION) * 10);
+		if (!_settings->ServerAutoReconnectCookie)
+			goto out_fail;
 
-	if (!_settings->GlyphCache)
-		goto out_fail;
+		CopyMemory(_settings->ClientAutoReconnectCookie, settings->ClientAutoReconnectCookie,
+		           sizeof(ARC_CS_PRIVATE_PACKET));
+		CopyMemory(_settings->ServerAutoReconnectCookie, settings->ServerAutoReconnectCookie,
+		           sizeof(ARC_SC_PRIVATE_PACKET));
+		_settings->ClientTimeZone = (LPTIME_ZONE_INFORMATION)malloc(sizeof(TIME_ZONE_INFORMATION));
 
-	_settings->FragCache = malloc(sizeof(GLYPH_CACHE_DEFINITION));
+		if (!_settings->ClientTimeZone)
+			goto out_fail;
 
-	if (!_settings->FragCache)
-		goto out_fail;
+		CopyMemory(_settings->ClientTimeZone, settings->ClientTimeZone,
+		           sizeof(TIME_ZONE_INFORMATION));
+		_settings->TargetNetAddressCount = settings->TargetNetAddressCount;
 
-	CopyMemory(_settings->GlyphCache, settings->GlyphCache, sizeof(GLYPH_CACHE_DEFINITION) * 10);
-	CopyMemory(_settings->FragCache, settings->FragCache, sizeof(GLYPH_CACHE_DEFINITION));
-	_settings->ClientAutoReconnectCookie =
-	    (ARC_CS_PRIVATE_PACKET*)malloc(sizeof(ARC_CS_PRIVATE_PACKET));
+		if (settings->TargetNetAddressCount > 0)
+		{
+			_settings->TargetNetAddresses =
+			    (char**)calloc(settings->TargetNetAddressCount, sizeof(char*));
 
-	if (!_settings->ClientAutoReconnectCookie)
-		goto out_fail;
+			if (!_settings->TargetNetAddresses)
+			{
+				_settings->TargetNetAddressCount = 0;
+				goto out_fail;
+			}
 
-	_settings->ServerAutoReconnectCookie =
-	    (ARC_SC_PRIVATE_PACKET*)malloc(sizeof(ARC_SC_PRIVATE_PACKET));
+			for (index = 0; index < settings->TargetNetAddressCount; index++)
+			{
+				_settings->TargetNetAddresses[index] = _strdup(settings->TargetNetAddresses[index]);
 
-	if (!_settings->ServerAutoReconnectCookie)
-		goto out_fail;
+				if (!_settings->TargetNetAddresses[index])
+				{
+					while (index)
+						free(_settings->TargetNetAddresses[--index]);
+
+					free(_settings->TargetNetAddresses);
+					_settings->TargetNetAddresses = NULL;
+					_settings->TargetNetAddressCount = 0;
+					goto out_fail;
+				}
+			}
 
-	CopyMemory(_settings->ClientAutoReconnectCookie, settings->ClientAutoReconnectCookie,
-	           sizeof(ARC_CS_PRIVATE_PACKET));
-	CopyMemory(_settings->ServerAutoReconnectCookie, settings->ServerAutoReconnectCookie,
-	           sizeof(ARC_SC_PRIVATE_PACKET));
-	_settings->ClientTimeZone = (LPTIME_ZONE_INFORMATION)malloc(sizeof(TIME_ZONE_INFORMATION));
+			if (settings->TargetNetPorts)
+			{
+				_settings->TargetNetPorts =
+				    (UINT32*)calloc(settings->TargetNetAddressCount, sizeof(UINT32));
 
-	if (!_settings->ClientTimeZone)
-		goto out_fail;
+				if (!_settings->TargetNetPorts)
+					goto out_fail;
 
-	CopyMemory(_settings->ClientTimeZone, settings->ClientTimeZone, sizeof(TIME_ZONE_INFORMATION));
-	_settings->TargetNetAddressCount = settings->TargetNetAddressCount;
+				for (index = 0; index < settings->TargetNetAddressCount; index++)
+					_settings->TargetNetPorts[index] = settings->TargetNetPorts[index];
+			}
+		}
 
-	if (settings->TargetNetAddressCount > 0)
-	{
-		_settings->TargetNetAddresses =
-		    (char**)calloc(settings->TargetNetAddressCount, sizeof(char*));
+		_settings->DeviceCount = settings->DeviceCount;
+		_settings->DeviceArraySize = settings->DeviceArraySize;
+		_settings->DeviceArray =
+		    (RDPDR_DEVICE**)calloc(_settings->DeviceArraySize, sizeof(RDPDR_DEVICE*));
 
-		if (!_settings->TargetNetAddresses)
+		if (!_settings->DeviceArray && _settings->DeviceArraySize)
 		{
-			_settings->TargetNetAddressCount = 0;
+			_settings->DeviceCount = 0;
+			_settings->DeviceArraySize = 0;
 			goto out_fail;
 		}
 
-		for (index = 0; index < settings->TargetNetAddressCount; index++)
+		if (_settings->DeviceArraySize < _settings->DeviceCount)
 		{
-			_settings->TargetNetAddresses[index] = _strdup(settings->TargetNetAddresses[index]);
-
-			if (!_settings->TargetNetAddresses[index])
-			{
-				while (index)
-					free(_settings->TargetNetAddresses[--index]);
-
-				free(_settings->TargetNetAddresses);
-				_settings->TargetNetAddresses = NULL;
-				_settings->TargetNetAddressCount = 0;
-				goto out_fail;
-			}
+			_settings->DeviceCount = 0;
+			_settings->DeviceArraySize = 0;
+			goto out_fail;
 		}
 
-		if (settings->TargetNetPorts)
+		for (index = 0; index < _settings->DeviceCount; index++)
 		{
-			_settings->TargetNetPorts =
-			    (UINT32*)calloc(settings->TargetNetAddressCount, sizeof(UINT32));
+			_settings->DeviceArray[index] = freerdp_device_clone(settings->DeviceArray[index]);
 
-			if (!_settings->TargetNetPorts)
+			if (!_settings->DeviceArray[index])
 				goto out_fail;
-
-			for (index = 0; index < settings->TargetNetAddressCount; index++)
-				_settings->TargetNetPorts[index] = settings->TargetNetPorts[index];
 		}
-	}
-
-	_settings->DeviceCount = settings->DeviceCount;
-	_settings->DeviceArraySize = settings->DeviceArraySize;
-	_settings->DeviceArray =
-	    (RDPDR_DEVICE**)calloc(_settings->DeviceArraySize, sizeof(RDPDR_DEVICE*));
 
-	if (!_settings->DeviceArray && _settings->DeviceArraySize)
-	{
-		_settings->DeviceCount = 0;
-		_settings->DeviceArraySize = 0;
-		goto out_fail;
-	}
+		_settings->StaticChannelCount = settings->StaticChannelCount;
+		_settings->StaticChannelArraySize = settings->StaticChannelArraySize;
+		_settings->StaticChannelArray =
+		    (ADDIN_ARGV**)calloc(_settings->StaticChannelArraySize, sizeof(ADDIN_ARGV*));
 
-	if (_settings->DeviceArraySize < _settings->DeviceCount)
-	{
-		_settings->DeviceCount = 0;
-		_settings->DeviceArraySize = 0;
-		goto out_fail;
-	}
-
-	for (index = 0; index < _settings->DeviceCount; index++)
-	{
-		_settings->DeviceArray[index] = freerdp_device_clone(settings->DeviceArray[index]);
-
-		if (!_settings->DeviceArray[index])
+		if (!_settings->StaticChannelArray && _settings->StaticChannelArraySize)
+		{
+			_settings->StaticChannelArraySize = 0;
+			_settings->ChannelCount = 0;
 			goto out_fail;
-	}
+		}
 
-	_settings->StaticChannelCount = settings->StaticChannelCount;
-	_settings->StaticChannelArraySize = settings->StaticChannelArraySize;
-	_settings->StaticChannelArray =
-	    (ADDIN_ARGV**)calloc(_settings->StaticChannelArraySize, sizeof(ADDIN_ARGV*));
+		if (_settings->StaticChannelArraySize < _settings->StaticChannelCount)
+		{
+			_settings->StaticChannelArraySize = 0;
+			_settings->ChannelCount = 0;
+			goto out_fail;
+		}
 
-	if (!_settings->StaticChannelArray && _settings->StaticChannelArraySize)
-	{
-		_settings->StaticChannelArraySize = 0;
-		_settings->ChannelCount = 0;
-		goto out_fail;
-	}
+		for (index = 0; index < _settings->StaticChannelCount; index++)
+		{
+			_settings->StaticChannelArray[index] =
+			    freerdp_static_channel_clone(settings->StaticChannelArray[index]);
 
-	if (_settings->StaticChannelArraySize < _settings->StaticChannelCount)
-	{
-		_settings->StaticChannelArraySize = 0;
-		_settings->ChannelCount = 0;
-		goto out_fail;
-	}
+			if (!_settings->StaticChannelArray[index])
+				goto out_fail;
+		}
 
-	for (index = 0; index < _settings->StaticChannelCount; index++)
-	{
-		_settings->StaticChannelArray[index] =
-		    freerdp_static_channel_clone(settings->StaticChannelArray[index]);
+		_settings->DynamicChannelCount = settings->DynamicChannelCount;
+		_settings->DynamicChannelArraySize = settings->DynamicChannelArraySize;
+		_settings->DynamicChannelArray =
+		    (ADDIN_ARGV**)calloc(_settings->DynamicChannelArraySize, sizeof(ADDIN_ARGV*));
 
-		if (!_settings->StaticChannelArray[index])
+		if (!_settings->DynamicChannelArray && _settings->DynamicChannelArraySize)
+		{
+			_settings->DynamicChannelCount = 0;
+			_settings->DynamicChannelArraySize = 0;
 			goto out_fail;
-	}
+		}
 
-	_settings->DynamicChannelCount = settings->DynamicChannelCount;
-	_settings->DynamicChannelArraySize = settings->DynamicChannelArraySize;
-	_settings->DynamicChannelArray =
-	    (ADDIN_ARGV**)calloc(_settings->DynamicChannelArraySize, sizeof(ADDIN_ARGV*));
+		if (_settings->DynamicChannelArraySize < _settings->DynamicChannelCount)
+		{
+			_settings->DynamicChannelCount = 0;
+			_settings->DynamicChannelArraySize = 0;
+			goto out_fail;
+		}
 
-	if (!_settings->DynamicChannelArray && _settings->DynamicChannelArraySize)
-	{
-		_settings->DynamicChannelCount = 0;
-		_settings->DynamicChannelArraySize = 0;
-		goto out_fail;
-	}
+		for (index = 0; index < _settings->DynamicChannelCount; index++)
+		{
+			_settings->DynamicChannelArray[index] =
+			    freerdp_dynamic_channel_clone(settings->DynamicChannelArray[index]);
 
-	if (_settings->DynamicChannelArraySize < _settings->DynamicChannelCount)
-	{
-		_settings->DynamicChannelCount = 0;
-		_settings->DynamicChannelArraySize = 0;
-		goto out_fail;
-	}
+			if (!_settings->DynamicChannelArray[index])
+				goto out_fail;
+		}
 
-	for (index = 0; index < _settings->DynamicChannelCount; index++)
-	{
-		_settings->DynamicChannelArray[index] =
-		    freerdp_dynamic_channel_clone(settings->DynamicChannelArray[index]);
+		_settings->SettingsModified = (BYTE*)calloc(1, sizeof(rdpSettings) / 8);
 
-		if (!_settings->DynamicChannelArray[index])
+		if (!_settings->SettingsModified)
 			goto out_fail;
 	}
 
-	_settings->SettingsModified = (BYTE*)calloc(1, sizeof(rdpSettings) / 8);
-
-	if (!_settings->SettingsModified)
-		goto out_fail;
-
-	return TRUE;
-out_fail:
-	freerdp_settings_free_internal(_settings);
-	return FALSE;
-}
-
-rdpSettings* freerdp_settings_clone(const rdpSettings* settings)
-{
-	rdpSettings* _settings = (rdpSettings*)calloc(1, sizeof(rdpSettings));
-
-	if (!freerdp_settings_copy(_settings, settings))
-		goto out_fail;
-
 	return _settings;
 out_fail:
 	/* In case any memory allocation failed during clone, some bytes might leak.
@@ -1121,6 +1020,118 @@
 	free(_settings);
 	return NULL;
 }
+
+void freerdp_settings_free(rdpSettings* settings)
+{
+	if (!settings)
+		return;
+
+	free(settings->ServerHostname);
+	free(settings->Username);
+	free(settings->Password);
+	free(settings->Domain);
+	free(settings->PasswordHash);
+	free(settings->AcceptedCert);
+	free(settings->AlternateShell);
+	free(settings->ShellWorkingDirectory);
+	free(settings->ComputerName);
+	free(settings->ChannelDefArray);
+	free(settings->MonitorDefArray);
+	free(settings->MonitorIds);
+	free(settings->ClientAddress);
+	free(settings->ClientDir);
+	free(settings->AllowedTlsCiphers);
+	free(settings->NtlmSamFile);
+	free(settings->CertificateFile);
+	free(settings->PrivateKeyFile);
+	free(settings->ConnectionFile);
+	free(settings->AssistanceFile);
+	free(settings->ReceivedCapabilities);
+	free(settings->OrderSupport);
+	free(settings->ClientHostname);
+	free(settings->ClientProductId);
+	free(settings->ServerRandom);
+	free(settings->ClientRandom);
+	free(settings->ServerCertificate);
+	free(settings->RdpKeyFile);
+	certificate_free(settings->RdpServerCertificate);
+	free(settings->CertificateContent);
+	free(settings->PrivateKeyContent);
+	free(settings->RdpKeyContent);
+	free(settings->ClientAutoReconnectCookie);
+	free(settings->ServerAutoReconnectCookie);
+	free(settings->ClientTimeZone);
+	free(settings->BitmapCacheV2CellInfo);
+	free(settings->GlyphCache);
+	free(settings->FragCache);
+	key_free(settings->RdpServerRsaKey);
+	free(settings->ConfigPath);
+	free(settings->CurrentPath);
+	free(settings->HomePath);
+	free(settings->LoadBalanceInfo);
+	free(settings->TargetNetAddress);
+	free(settings->RedirectionTargetFQDN);
+	free(settings->RedirectionTargetNetBiosName);
+	free(settings->RedirectionUsername);
+	free(settings->RedirectionDomain);
+	free(settings->RedirectionPassword);
+	free(settings->RedirectionTsvUrl);
+	free(settings->RedirectionAcceptedCert);
+	free(settings->Pkcs11Module);
+	free(settings->Pin);
+	free(settings->CardName);
+	free(settings->ReaderName);
+	free(settings->ContainerName);
+	free(settings->CspName);
+	free(settings->UserHint);
+	free(settings->DomainHint);
+	free(settings->UserPrincipalName);
+	free(settings->CanonicalizedUserHint);
+	free(settings->IdCertificate);
+	free(settings->PkinitIdentity);
+	free(settings->PkinitAnchors);
+	free(settings->KerberosStartTime);
+	free(settings->KerberosLifeTime);
+	free(settings->KerberosRenewableLifeTime);
+	free(settings->TokenLabel);
+	free(settings->PkinitCertificate);
+	free(settings->RemoteAssistanceSessionId);
+	free(settings->RemoteAssistancePassword);
+	free(settings->RemoteAssistancePassStub);
+	free(settings->RemoteAssistanceRCTicket);
+	free(settings->AuthenticationServiceClass);
+	free(settings->GatewayHostname);
+	free(settings->GatewayUsername);
+	free(settings->GatewayPassword);
+	free(settings->GatewayDomain);
+	free(settings->GatewayAccessToken);
+	free(settings->GatewayAcceptedCert);
+	free(settings->CertificateName);
+	free(settings->DynamicDSTTimeZoneKeyName);
+	free(settings->PreconnectionBlob);
+	free(settings->KerberosKdc);
+	free(settings->KerberosRealm);
+	free(settings->DumpRemoteFxFile);
+	free(settings->PlayRemoteFxFile);
+	free(settings->RemoteApplicationName);
+	free(settings->RemoteApplicationIcon);
+	free(settings->RemoteApplicationProgram);
+	free(settings->RemoteApplicationFile);
+	free(settings->RemoteApplicationGuid);
+	free(settings->RemoteApplicationCmdLine);
+	free(settings->ImeFileName);
+	free(settings->DrivesToRedirect);
+	free(settings->WindowTitle);
+	free(settings->WmClass);
+	free(settings->ActionScript);
+	freerdp_target_net_addresses_free(settings);
+	freerdp_device_collection_free(settings);
+	freerdp_static_channel_collection_free(settings);
+	freerdp_dynamic_channel_collection_free(settings);
+	free(settings->SettingsModified);
+	free(settings);
+}
+
 #ifdef _WIN32
 #	pragma warning(pop)
 #endif
--- libfreerdp/core/smartcardlogon.c	1970-01-01 03:00:00.000000000 +0300
+++ ../../informatimago/FreeRDP/libfreerdp/core/smartcardlogon.c	2019-07-25 20:11:28.047983079 +0300
@@ -0,0 +1,59 @@
+#ifdef WITH_PKCS11H
+
+#	include <freerdp/log.h>
+#	include <freerdp/settings.h>
+
+#	include "../scquery/scquery.h"
+#	include "../scquery/scquery_error.h"
+
+#	define TAG CLIENT_TAG("smartcardlogon")
+#	define ORNIL(x) ((x) ? (x) : "(nil)")
+
+static void copy_string(char** old_string, char* new_string)
+{
+	free(*old_string);
+	(*old_string) = NULL;
+
+	if (new_string != NULL)
+	{
+		(*old_string) = check_memory(strdup(new_string), strlen(new_string));
+	}
+}
+
+int get_info_smartcard(rdpSettings* settings)
+{
+	scquery_result identity = NULL;
+
+	if (settings->Pkcs11Module == NULL)
+	{
+		WLog_ERR(TAG, "Missing /pkcs11module");
+		return -1;
+	}
+
+	identity = scquery_X509_user_identities(settings->Pkcs11Module, settings->ReaderName,
+	                                        settings->CardName, settings->Krb5Trace);
+
+	if (identity == NULL)
+	{
+		WLog_ERR(TAG, "Could not get an identity from the smartcard %s (reader %s)",
+		         ORNIL(settings->CardName), ORNIL(settings->ReaderName));
+		return -1;
+	}
+
+	copy_string(&settings->CardName, identity->certificate->token_label);
+	copy_string(&settings->ReaderName, identity->certificate->slot_description);
+	copy_string(&settings->UserPrincipalName, identity->upn);
+	copy_string(&settings->PkinitIdentity, identity->X509_user_identity);
+	copy_string(&settings->TokenLabel, identity->certificate->token_label);
+	copy_string(&settings->IdCertificate, identity->certificate->id);
+	settings->SlotID = identity->certificate->slot_id;
+	settings->IdCertificateLength = strlen(identity->certificate->id);
+	settings->PinPadIsPresent = identity->certificate->protected_authentication_path;
+	WLog_INFO(TAG, "Got identity from the smartcard %s (reader %s): %s (UPN = %s)",
+	          ORNIL(settings->CardName), ORNIL(settings->ReaderName), identity->X509_user_identity,
+	          identity->upn);
+	scquery_result_free(identity);
+	return 0;
+}
+
+#endif
--- libfreerdp/core/smartcardlogon.h	1970-01-01 03:00:00.000000000 +0300
+++ ../../informatimago/FreeRDP/libfreerdp/core/smartcardlogon.h	2019-07-19 20:00:34.129156365 +0300
@@ -0,0 +1,7 @@
+#ifndef LIBFREERDP_CORE_SMARTCARDLOGON_H
+#define LIBFREERDP_CORE_SMARTCARDLOGON_H
+#include <freerdp/settings.h>
+
+int get_info_smartcard(rdpSettings* settings);
+
+#endif
--- libfreerdp/core/test/CMakeLists.txt	2019-07-24 06:11:52.482197637 +0300
+++ ../../informatimago/FreeRDP/libfreerdp/core/test/CMakeLists.txt	2019-07-19 20:00:34.129156365 +0300
@@ -6,7 +6,8 @@
 
 set(${MODULE_PREFIX}_TESTS
 	TestVersion.c
-	TestSettings.c)
+	TestSettings.c
+    TestTSCredentials.c)
 
 if(WITH_SAMPLE AND WITH_SERVER)
 	set(${MODULE_PREFIX}_TESTS
--- libfreerdp/core/test/TestTSCredentials.c	1970-01-01 03:00:00.000000000 +0300
+++ ../../informatimago/FreeRDP/libfreerdp/core/test/TestTSCredentials.c	2019-07-25 20:11:28.107983376 +0300
@@ -0,0 +1,314 @@
+#include <stdio.h>
+#include <string.h>
+
+#include <winpr/sspi.h>
+#include <winpr/wlog.h>
+#include <winpr/stream.h>
+
+#include <freerdp/log.h>
+#include <freerdp/crypto/ber.h>
+
+#include "../tscredentials.h"
+
+#define TAG FREERDP_TAG("test.TestTSCredentials")
+
+#define printref() printf("%s:%d: in function %-40s:", __FILE__, __LINE__, __FUNCTION__)
+
+#define ERROR(format, ...)                      \
+	do                                          \
+	{                                           \
+		fprintf(stderr, format, ##__VA_ARGS__); \
+		printref();                             \
+		printf(format "\n", ##__VA_ARGS__);     \
+		fflush(stdout);                         \
+		error_count++;                          \
+	} while (0)
+
+#define FAILURE(format, ...)                \
+	do                                      \
+	{                                       \
+		printref();                         \
+		printf(" FAILURE ");                \
+		printf(format "\n", ##__VA_ARGS__); \
+		fflush(stdout);                     \
+		failure_count++;                    \
+	} while (0)
+
+#define TEST(condition, format, ...)                           \
+	if (!(condition))                                          \
+	{                                                          \
+		FAILURE("test %s " format, #condition, ##__VA_ARGS__); \
+	}
+
+size_t min(size_t a, size_t b)
+{
+	return (a < b) ? a : b;
+}
+
+auth_identity* make_test_smartcard_creds()
+{
+	csp_data_detail* csp =
+	    csp_data_detail_new(1, "IAS-ECC", "XIRING Leo v2 (8288830623) 00 00",
+	                        "Cl d'authentification1", "Middleware IAS ECC Cryptographic Provider");
+	auth_identity* identity = auth_identity_new_smartcard(
+	    smartcard_creds_new("0000", "EXAMPLEUSER", "EXAMPLE.DOMAIN", csp));
+	csp_data_detail_free(csp);
+	return identity;
+}
+
+auth_identity* make_test_remote_guard_creds()
+{
+	/*
+	 * ASN.1 value:
+	 *
+	 * value TSRemoteGuardCreds ::= {
+	 *     logonCred {
+	 *         packageName  '4D007900530065006300750072006900740079005000610063006B00610067006500'H
+	 * , credBuffer   '4D7920427265617468204973204D792050617373776F7264'H
+	 *     },
+	 *     supplementalCreds {
+	 *         {
+	 *             packageName
+	 * '41006C007400650072006E0061007400690076006500530065006300750072006900740079005000610063006B00610067006500'H
+	 * , credBuffer  '4D7920427265617468204973204D79204F746865722050617373776F7264'H
+	 *         },
+	 *         {
+	 *             packageName '500041004D00'H ,
+	 *             credBuffer  '666F6F62617262617A2170617373'H
+	 *         }
+	 *     }
+	 * }
+	 *
+	 */
+	char* package_name;
+	char* credentials;
+	remote_guard_creds* remote_guard_creds;
+	package_name = strdup("MySecurityPackage");
+	credentials = strdup("My Breath Is My Password");
+	remote_guard_creds =
+	    remote_guard_creds_new_nocopy(package_name, strlen(credentials), (BYTE*)credentials);
+	package_name = strdup("AlternativeSecurityPackage");
+	credentials = strdup("My Breath Is My Other Password");
+	remote_guard_creds_add_supplemental_cred(
+	    remote_guard_creds, remote_guard_package_cred_new_nocopy(package_name, strlen(credentials),
+	                                                             (BYTE*)credentials));
+	package_name = strdup("PAM");
+	credentials = strdup("foobarbaz!pass");
+	remote_guard_creds_add_supplemental_cred(
+	    remote_guard_creds, remote_guard_package_cred_new_nocopy(package_name, strlen(credentials),
+	                                                             (BYTE*)credentials));
+	return auth_identity_new_remote_guard(remote_guard_creds);
+}
+
+static unsigned failure_count = 0;
+static unsigned error_count = 0;
+
+void reset_counters()
+{
+	failure_count = 0;
+	error_count = 0;
+}
+
+typedef size_t (*writer_pr)(void* data, wStream* s);
+
+size_t stream_size(size_t allocated_size, writer_pr writer, void* data)
+{
+	size_t written_size;
+	size_t result_size;
+	wStream* s;
+	s = Stream_New(NULL, /* some margin: */ 1024 + 2 * allocated_size);
+	written_size = writer(data, s);
+	Stream_SealLength(s);
+	result_size = Stream_Length(s);
+	Stream_Free(s, TRUE);
+	return result_size;
+}
+
+size_t write_csp(void* csp, wStream* s)
+{
+	return nla_write_ts_csp_data_detail(csp, 3, s);
+}
+
+int string_length(char* string); /* in tscredentials.c */
+
+BOOL test_sizeof_smartcard_creds()
+{
+	csp_data_detail* csp;
+	size_t csp_expected_inner;
+	size_t csp_expected;
+	auth_identity* identity = make_test_smartcard_creds();
+	reset_counters();
+	WLog_INFO(TAG, "Testing %s", __FUNCTION__);
+	csp = identity->creds.smartcard_creds->csp_data;
+	csp_expected_inner = (ber_sizeof_contextual_tag(ber_sizeof_integer(csp->KeySpec)) +
+	                      ber_sizeof_integer(csp->KeySpec) +
+	                      ber_sizeof_sequence_octet_string(2 * string_length(csp->CardName)) +
+	                      ber_sizeof_sequence_octet_string(2 * string_length(csp->ReaderName)) +
+	                      ber_sizeof_sequence_octet_string(2 * string_length(csp->ContainerName)) +
+	                      ber_sizeof_sequence_octet_string(2 * string_length(csp->CspName)));
+	csp_expected = ber_sizeof_contextual_tag(ber_sizeof_sequence(csp_expected_inner)) +
+	               ber_sizeof_sequence(csp_expected_inner);
+	{
+		size_t result_inner = nla_sizeof_ts_cspdatadetail_inner(csp);
+		size_t result = nla_sizeof_ts_cspdatadetail(csp);
+		size_t written_size = stream_size(csp_expected, write_csp, csp);
+		TEST(csp_expected_inner == result_inner,
+		     "cspdatadetail_inner expected = %d != %d = result_inner", csp_expected_inner,
+		     result_inner);
+		TEST(csp_expected == result, "cspdatadetail expected = %d != %d = result", csp_expected,
+		     result);
+		TEST(csp_expected == written_size, "cspdatadetail expected = %d != %d = written",
+		     csp_expected, written_size);
+	}
+	{
+		smartcard_creds* creds = identity->creds.smartcard_creds;
+		size_t expected_inner =
+		    (0 + ber_sizeof_sequence_octet_string(2 * string_length(creds->Pin)) + csp_expected +
+		     ber_sizeof_sequence_octet_string(2 * string_length(creds->UserHint)) +
+		     ber_sizeof_sequence_octet_string(2 * string_length(creds->DomainHint)));
+		size_t expected = ber_sizeof_sequence(expected_inner);
+		size_t result_inner = nla_sizeof_ts_smartcard_creds_inner(creds);
+		size_t result = nla_sizeof_ts_smartcard_creds(creds);
+		size_t written_size = stream_size(expected, (writer_pr)nla_write_ts_smartcard_creds, creds);
+		TEST(expected_inner == result_inner, "smartcard_creds_inner expected = %d != %d = result",
+		     expected_inner, result_inner);
+		TEST(expected == result, "smartcard_creds expected = %d != %d = result", expected, result);
+		TEST(expected == written_size, "smartcard_creds expected = %d != %d = written", expected,
+		     written_size);
+	}
+	auth_identity_free(identity);
+	return (failure_count == 0) && (error_count == 0);
+}
+
+BOOL test_sizeof_ts_credentials()
+{
+	auth_identity* identity = make_test_smartcard_creds();
+	reset_counters();
+	WLog_INFO(TAG, "Testing %s", __FUNCTION__);
+	{
+		size_t expected_inner = nla_sizeof_ts_credentials_inner(identity);
+		size_t expected = ber_sizeof_sequence(expected_inner);
+		size_t result_inner = nla_sizeof_ts_credentials_inner(identity);
+		size_t written_size = stream_size(expected, (writer_pr)nla_write_ts_credentials, identity);
+		size_t result = expected;
+		TEST(expected_inner == result_inner, "credentials_inner expected = %d != %d = result",
+		     expected_inner, result_inner);
+		TEST(expected == result, "credentials expected = %d != %d = result", expected, result);
+		TEST(expected == written_size, "credentials expected = %d != %d = written", expected,
+		     written_size);
+	}
+	auth_identity_free(identity);
+	return (failure_count == 0) && (error_count == 0);
+}
+
+void compare_buffers(BYTE* expected_ber, size_t expected_length, BYTE* result_ber,
+                     size_t result_length)
+{
+	TEST(result_length == expected_length, "result length = %d != %d = expected length",
+	     result_length, expected_length);
+	TEST(0 == memcmp(result_ber, expected_ber, min(result_length, expected_length)),
+	     "BER bytes differ");
+
+	if (failure_count > 0)
+	{
+		FAILURE();
+		WLog_ERR(TAG, "==== Expected:");
+		winpr_HexDump(TAG, WLOG_ERROR, expected_ber, expected_length);
+		WLog_ERR(TAG, "==== Result:");
+		winpr_HexDump(TAG, WLOG_ERROR, result_ber, result_length);
+	}
+}
+
+void test_creds(auth_identity* identity, BYTE* expected_ber, size_t expected_length)
+{
+	size_t creds_size;
+	size_t written_size;
+	size_t result_length;
+	BYTE* result_ber;
+	wStream* s;
+	creds_size = nla_sizeof_ts_creds(identity);
+	WLog_INFO(TAG, "ts_creds  size   = %4d", creds_size);
+	s = Stream_New(NULL, creds_size);
+	written_size = nla_write_ts_creds(identity, s);
+	TEST(written_size == creds_size, "written_size = %d ; creds_size = %d", written_size,
+	     creds_size);
+	WLog_INFO(TAG, "written   size   = %4d", written_size);
+	Stream_SealLength(s);
+	result_length = Stream_Length(s);
+	TEST(written_size == result_length, "written_size = %d ; result_length = %d", written_size,
+	     result_length);
+	WLog_INFO(TAG, "expected length  = %4d", expected_length);
+	WLog_INFO(TAG, "result   length  = %4d", result_length);
+	result_ber = Stream_Buffer(s);
+	compare_buffers(expected_ber, expected_length, result_ber, result_length);
+	Stream_Free(s, TRUE);
+}
+
+BOOL test_write_smartcard_creds()
+{
+	static BYTE expected_ber[] = {
+		0x30, 0x82, 0x01, 0x2f, 0xa0, 0x0a, 0x04, 0x08, 0x30, 0x00, 0x30, 0x00, 0x30, 0x00, 0x30,
+		0x00, 0xa1, 0x81, 0xe6, 0x30, 0x81, 0xe3, 0xa0, 0x03, 0x02, 0x01, 0x01, 0xa1, 0x10, 0x04,
+		0x0e, 0x49, 0x00, 0x41, 0x00, 0x53, 0x00, 0x2d, 0x00, 0x45, 0x00, 0x43, 0x00, 0x43, 0x00,
+		0xa2, 0x42, 0x04, 0x40, 0x58, 0x00, 0x49, 0x00, 0x52, 0x00, 0x49, 0x00, 0x4e, 0x00, 0x47,
+		0x00, 0x20, 0x00, 0x4c, 0x00, 0x65, 0x00, 0x6f, 0x00, 0x20, 0x00, 0x76, 0x00, 0x32, 0x00,
+		0x20, 0x00, 0x28, 0x00, 0x38, 0x00, 0x32, 0x00, 0x38, 0x00, 0x38, 0x00, 0x38, 0x00, 0x33,
+		0x00, 0x30, 0x00, 0x36, 0x00, 0x32, 0x00, 0x33, 0x00, 0x29, 0x00, 0x20, 0x00, 0x30, 0x00,
+		0x30, 0x00, 0x20, 0x00, 0x30, 0x00, 0x30, 0x00, 0xa3, 0x30, 0x04, 0x2e, 0x43, 0x00, 0x6c,
+		0x00, 0xe9, 0x00, 0x20, 0x00, 0x64, 0x00, 0x27, 0x00, 0x61, 0x00, 0x75, 0x00, 0x74, 0x00,
+		0x68, 0x00, 0x65, 0x00, 0x6e, 0x00, 0x74, 0x00, 0x69, 0x00, 0x66, 0x00, 0x69, 0x00, 0x63,
+		0x00, 0x61, 0x00, 0x74, 0x00, 0x69, 0x00, 0x6f, 0x00, 0x6e, 0x00, 0x31, 0x00, 0xa4, 0x54,
+		0x04, 0x52, 0x4d, 0x00, 0x69, 0x00, 0x64, 0x00, 0x64, 0x00, 0x6c, 0x00, 0x65, 0x00, 0x77,
+		0x00, 0x61, 0x00, 0x72, 0x00, 0x65, 0x00, 0x20, 0x00, 0x49, 0x00, 0x41, 0x00, 0x53, 0x00,
+		0x20, 0x00, 0x45, 0x00, 0x43, 0x00, 0x43, 0x00, 0x20, 0x00, 0x43, 0x00, 0x72, 0x00, 0x79,
+		0x00, 0x70, 0x00, 0x74, 0x00, 0x6f, 0x00, 0x67, 0x00, 0x72, 0x00, 0x61, 0x00, 0x70, 0x00,
+		0x68, 0x00, 0x69, 0x00, 0x63, 0x00, 0x20, 0x00, 0x50, 0x00, 0x72, 0x00, 0x6f, 0x00, 0x76,
+		0x00, 0x69, 0x00, 0x64, 0x00, 0x65, 0x00, 0x72, 0x00, 0xa2, 0x18, 0x04, 0x16, 0x45, 0x00,
+		0x58, 0x00, 0x41, 0x00, 0x4d, 0x00, 0x50, 0x00, 0x4c, 0x00, 0x45, 0x00, 0x55, 0x00, 0x53,
+		0x00, 0x45, 0x00, 0x52, 0x00, 0xa3, 0x1e, 0x04, 0x1c, 0x45, 0x00, 0x58, 0x00, 0x41, 0x00,
+		0x4d, 0x00, 0x50, 0x00, 0x4c, 0x00, 0x45, 0x00, 0x2e, 0x00, 0x44, 0x00, 0x4f, 0x00, 0x4d,
+		0x00, 0x41, 0x00, 0x49, 0x00, 0x4e, 0x00,
+	};
+	static size_t expected_length = sizeof(expected_ber);
+	auth_identity* identity = make_test_smartcard_creds();
+	reset_counters();
+	WLog_INFO(TAG, "Testing %s", __FUNCTION__);
+	test_creds(identity, expected_ber, expected_length);
+	auth_identity_free(identity);
+	return (failure_count == 0) && (error_count == 0);
+}
+
+BOOL test_write_remote_guard_creds()
+{
+	static BYTE expected_ber[] = {
+		0x30, 0x81, 0xc4, 0xa0, 0x44, 0x30, 0x42, 0xa0, 0x24, 0x04, 0x22, 0x4d, 0x00, 0x79, 0x00,
+		0x53, 0x00, 0x65, 0x00, 0x63, 0x00, 0x75, 0x00, 0x72, 0x00, 0x69, 0x00, 0x74, 0x00, 0x79,
+		0x00, 0x50, 0x00, 0x61, 0x00, 0x63, 0x00, 0x6b, 0x00, 0x61, 0x00, 0x67, 0x00, 0x65, 0x00,
+		0xa1, 0x1a, 0x04, 0x18, 0x4d, 0x79, 0x20, 0x42, 0x72, 0x65, 0x61, 0x74, 0x68, 0x20, 0x49,
+		0x73, 0x20, 0x4d, 0x79, 0x20, 0x50, 0x61, 0x73, 0x73, 0x77, 0x6f, 0x72, 0x64, 0xa1, 0x7c,
+		0x30, 0x7a, 0x30, 0x5a, 0xa0, 0x36, 0x04, 0x34, 0x41, 0x00, 0x6c, 0x00, 0x74, 0x00, 0x65,
+		0x00, 0x72, 0x00, 0x6e, 0x00, 0x61, 0x00, 0x74, 0x00, 0x69, 0x00, 0x76, 0x00, 0x65, 0x00,
+		0x53, 0x00, 0x65, 0x00, 0x63, 0x00, 0x75, 0x00, 0x72, 0x00, 0x69, 0x00, 0x74, 0x00, 0x79,
+		0x00, 0x50, 0x00, 0x61, 0x00, 0x63, 0x00, 0x6b, 0x00, 0x61, 0x00, 0x67, 0x00, 0x65, 0x00,
+		0xa1, 0x20, 0x04, 0x1e, 0x4d, 0x79, 0x20, 0x42, 0x72, 0x65, 0x61, 0x74, 0x68, 0x20, 0x49,
+		0x73, 0x20, 0x4d, 0x79, 0x20, 0x4f, 0x74, 0x68, 0x65, 0x72, 0x20, 0x50, 0x61, 0x73, 0x73,
+		0x77, 0x6f, 0x72, 0x64, 0x30, 0x1c, 0xa0, 0x08, 0x04, 0x06, 0x50, 0x00, 0x41, 0x00, 0x4d,
+		0x00, 0xa1, 0x10, 0x04, 0x0e, 0x66, 0x6f, 0x6f, 0x62, 0x61, 0x72, 0x62, 0x61, 0x7a, 0x21,
+		0x70, 0x61, 0x73, 0x73
+	};
+	static size_t expected_length = sizeof(expected_ber);
+	auth_identity* identity = make_test_remote_guard_creds();
+	reset_counters();
+	WLog_INFO(TAG, "Testing %s", __FUNCTION__);
+	test_creds(identity, expected_ber, expected_length);
+	auth_identity_free(identity);
+	return (failure_count == 0) && (error_count == 0);
+}
+
+int TestTSCredentials(int argc, char* argv[])
+{
+	return ((test_sizeof_smartcard_creds() && test_sizeof_ts_credentials() &&
+	         test_write_smartcard_creds() && test_write_remote_guard_creds())
+	            ? 0
+	            : 1);
+}
--- libfreerdp/core/transport.c	2019-07-25 19:51:04.193913944 +0300
+++ ../../informatimago/FreeRDP/libfreerdp/core/transport.c	2019-07-25 20:11:28.135983515 +0300
@@ -178,7 +178,8 @@
 				UINT32 kret = 0;
 #ifdef WITH_GSSAPI
 
-				if ((strlen(transport->settings->Domain) != 0) &&
+				if ((transport->settings->Domain != NULL) &&
+				    (strlen(transport->settings->Domain) != 0) &&
 				    (strncmp(transport->settings->Domain, ".", 1) != 0))
 				{
 					kret = transport_krb5_check_account(transport, transport->settings->Username,
@@ -302,7 +303,7 @@
 	}
 
 	transport->frontBio = tls->bio;
-	BIO_callback_ctrl(tls->bio, BIO_CTRL_SET_CALLBACK, (bio_info_cb*)(void*)transport_ssl_cb);
+	BIO_callback_ctrl(tls->bio, BIO_CTRL_SET_CALLBACK, (bio_info_cb*)transport_ssl_cb);
 	SSL_set_app_data(tls->ssl, transport);
 
 	if (!transport->frontBio)
@@ -349,6 +350,8 @@
 			freerdp_set_last_error(context, FREERDP_ERROR_AUTHENTICATION_FAILED);
 
 		transport_set_nla_mode(transport, FALSE);
+		nla_free(rdp->nla);
+		rdp->nla = NULL;
 		return FALSE;
 	}
 
@@ -548,21 +551,20 @@
 	}
 }
 
-SSIZE_T transport_read_layer(rdpTransport* transport, BYTE* data, size_t bytes)
+int transport_read_layer(rdpTransport* transport, BYTE* data, int bytes)
 {
-	SSIZE_T read = 0;
+	int read = 0;
+	int status = -1;
 
-	if (!transport->frontBio || (bytes > SSIZE_MAX))
+	if (!transport->frontBio)
 	{
 		transport->layer = TRANSPORT_LAYER_CLOSED;
 		return -1;
 	}
 
-	while (read < (SSIZE_T)bytes)
+	while (read < bytes)
 	{
-		const SSIZE_T tr = (SSIZE_T)bytes - read;
-		int r = (int)((tr > INT_MAX) ? INT_MAX : tr);
-		int status = status = BIO_read(transport->frontBio, data + read, r);
+		status = BIO_read(transport->frontBio, data + read, bytes - read);
 
 		if (status <= 0)
 		{
@@ -618,20 +620,16 @@
  * @param[in] toRead number of bytes to read
  * @return < 0 on error; 0 if not enough data is available (non blocking mode); 1 toRead bytes read
  */
-static SSIZE_T transport_read_layer_bytes(rdpTransport* transport, wStream* s, size_t toRead)
+static int transport_read_layer_bytes(rdpTransport* transport, wStream* s, unsigned int toRead)
 {
-	SSIZE_T status;
-
-	if (toRead > SSIZE_MAX)
-		return 0;
-
+	int status;
 	status = transport_read_layer(transport, Stream_Pointer(s), toRead);
 
 	if (status <= 0)
 		return status;
 
-	Stream_Seek(s, (size_t)status);
-	return status == (SSIZE_T)toRead ? 1 : 0;
+	Stream_Seek(s, status);
+	return status == toRead ? 1 : 0;
 }
 
 /**
@@ -650,7 +648,7 @@
 {
 	int status;
 	size_t position;
-	size_t pduLength;
+	int pduLength;
 	BYTE* header;
 	pduLength = 0;
 
@@ -738,8 +736,7 @@
 			/* min and max values according to ITU-T Rec. T.123 (01/2007) section 8 */
 			if (pduLength < 7 || pduLength > 0xFFFF)
 			{
-				WLog_Print(transport->log, WLOG_ERROR, "tpkt - invalid pduLength: %" PRIdz,
-				           pduLength);
+				WLog_Print(transport->log, WLOG_ERROR, "tpkt - invalid pduLength: %d", pduLength);
 				return -1;
 			}
 		}
@@ -765,7 +762,7 @@
 			 */
 			if (pduLength < 3 || pduLength > 0x8000)
 			{
-				WLog_Print(transport->log, WLOG_ERROR, "fast path - invalid pduLength: %" PRIdz,
+				WLog_Print(transport->log, WLOG_ERROR, "fast path - invalid pduLength: %d",
 				           pduLength);
 				return -1;
 			}
--- libfreerdp/core/tscredentials.c	1970-01-01 03:00:00.000000000 +0300
+++ ../../informatimago/FreeRDP/libfreerdp/core/tscredentials.c	2019-07-25 20:11:28.155983614 +0300
@@ -0,0 +1,1244 @@
+/**
+ * FreeRDP: A Remote Desktop Protocol Implementation
+ * TSCredentials reading and writing.
+ *
+ * Copyright 2010-2012 Marc-Andre Moreau <marcandre.moreau@gmail.com>
+ * Copyright 2015 Thincast Technologies GmbH
+ * Copyright 2015 DI (FH) Martin Haimberger <martin.haimberger@thincast.com>
+ * Copyright 2016 Martin Fleisz <martin.fleisz@thincast.com>
+ * Copyright 2017 Dorian Ducournau <dorian.ducournau@gmail.com>
+ * Copyright 2017 Pascal J. Bourguignon <pjb@informatimago.com>
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *		 http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#ifdef HAVE_CONFIG_H
+#	include "config.h"
+#endif
+
+#include <time.h>
+
+#ifndef _WIN32
+#	include <unistd.h>
+#endif
+
+#include <freerdp/log.h>
+#include <freerdp/crypto/tls.h>
+#include <freerdp/build-config.h>
+#include <freerdp/peer.h>
+
+#include <winpr/crt.h>
+#include <winpr/sam.h>
+#include <winpr/sspi.h>
+#include <winpr/print.h>
+#include <winpr/tchar.h>
+#include <winpr/dsparse.h>
+#include <winpr/strlst.h>
+#include <winpr/library.h>
+#include <winpr/registry.h>
+
+#include "tscredentials.h"
+
+#define TAG FREERDP_TAG("core.tscredentials")
+
+static void memory_clear_and_free(void* memory, size_t size)
+{
+	if (memory)
+	{
+		memset(memory, 0, size);
+		free(memory);
+	}
+}
+
+static void string_clear_and_free(char* string)
+{
+	memory_clear_and_free(string, strlen(string));
+}
+
+static void* memdup(void* source, size_t size)
+{
+	void* destination = malloc(size);
+
+	if (destination != NULL)
+	{
+		memcpy(destination, source, size);
+	}
+
+	return destination;
+}
+
+/**
+ * TSCredentials ::= SEQUENCE {
+ * 	cred_type    [0] INTEGER,
+ * 	credentials [1] OCTET STRING
+ * }
+ *
+ * TSPasswordCreds ::= SEQUENCE {
+ * 	domainName  [0] OCTET STRING,
+ * 	userName    [1] OCTET STRING,
+ * 	password    [2] OCTET STRING
+ * }
+ *
+ * TSSmartCardCreds ::= SEQUENCE {
+ * 	pin        [0] OCTET STRING,
+ * 	cspData    [1] TSCspDataDetail,
+ * 	userHint   [2] OCTET STRING OPTIONAL,
+ * 	domainHint [3] OCTET STRING OPTIONAL
+ * }
+ *
+ * TSCspDataDetail ::= SEQUENCE {
+ * 	keySpec       [0] INTEGER,
+ * 	cardName      [1] OCTET STRING OPTIONAL,
+ * 	readerName    [2] OCTET STRING OPTIONAL,
+ * 	containerName [3] OCTET STRING OPTIONAL,
+ * 	cspName       [4] OCTET STRING OPTIONAL
+ * }
+ *
+ *
+ * TSRemoteGuardCreds ::= SEQUENCE {
+ *     logonCred         [0] TSRemoteGuardPackageCred,
+ *     supplementalCreds [1] SEQUENCE OF TSRemoteGuardPackageCred OPTIONAL,
+ * }
+ *
+ * TSRemoteGuardPackageCred ::=  SEQUENCE {
+ *     packageName [0] OCTET STRING,
+ *     credBuffer  [1] OCTET STRING,
+ * }
+ *
+ */
+
+#define CHECK_MEMORY(pointer, error_action)                                \
+	do                                                                     \
+	{                                                                      \
+		if (!(pointer))                                                    \
+		{                                                                  \
+			WLog_ERR(TAG, "%s:%d: out of memory", __FUNCTION__, __LINE__); \
+			error_action;                                                  \
+		}                                                                  \
+	} while (0)
+
+/* ============================================================ */
+
+/* SEC_WINNT_AUTH_IDENTITY contains only UTF-16 strings,  with length fields. */
+#define WSTRING_LENGTH_CLEAR_AND_FREE(structure, field) \
+	memory_clear_and_free(structure->field, structure->field##Length * 2)
+#define WSTRING_LENGTH_SET_CSTRING(structure, field, cstring)                         \
+	(structure->field##Length =                                                       \
+	     (cstring ? ConvertToUnicode(CP_UTF8, 0, cstring, -1, &(structure->field), 0) \
+	              : (structure->field = NULL, 0)))
+#define WSTRING_LENGTH_COPY(source, destination, field)    \
+	((destination->field##Length = source->field##Length), \
+	 (destination->field =                                 \
+	      ((source->field == NULL) ? NULL : memdup(source->field, source->field##Length))))
+
+SEC_WINNT_AUTH_IDENTITY* SEC_WINNT_AUTH_IDENTITY_new(char* user, char* password, char* domain)
+{
+	SEC_WINNT_AUTH_IDENTITY* password_creds;
+	CHECK_MEMORY(password_creds = malloc(sizeof(*password_creds)), return NULL);
+	password_creds->Flags = SEC_WINNT_AUTH_IDENTITY_UNICODE;
+	WSTRING_LENGTH_SET_CSTRING(password_creds, User, user);
+	WSTRING_LENGTH_SET_CSTRING(password_creds, Domain, domain);
+	WSTRING_LENGTH_SET_CSTRING(password_creds, Password, password);
+	return password_creds;
+}
+
+SEC_WINNT_AUTH_IDENTITY* SEC_WINNT_AUTH_IDENTITY_deepcopy(SEC_WINNT_AUTH_IDENTITY* original)
+{
+	SEC_WINNT_AUTH_IDENTITY* copy;
+	CHECK_MEMORY(copy = calloc(1, sizeof(*copy)), return NULL);
+	copy->Flags = SEC_WINNT_AUTH_IDENTITY_UNICODE;
+	WSTRING_LENGTH_COPY(original, copy, User);
+	WSTRING_LENGTH_COPY(original, copy, Domain);
+	WSTRING_LENGTH_COPY(original, copy, Password);
+
+	if (((original->User != NULL) && (copy->User == NULL)) ||
+	    ((original->Password != NULL) && (copy->Password == NULL)) ||
+	    ((original->Domain != NULL) && (copy->Domain == NULL)))
+	{
+		SEC_WINNT_AUTH_IDENTITY_free(copy);
+		WLog_ERR(TAG,
+		         "%s:%d: %s() Could not allocate the fields of a SEC_WINNT_AUTH_IDENTITY structure",
+		         __FILE__, __LINE__, __FUNCTION__);
+		return NULL;
+	}
+
+	return copy;
+}
+
+void SEC_WINNT_AUTH_IDENTITY_free(SEC_WINNT_AUTH_IDENTITY* password_creds)
+{
+	if (password_creds)
+	{
+		WSTRING_LENGTH_CLEAR_AND_FREE(password_creds, User);
+		WSTRING_LENGTH_CLEAR_AND_FREE(password_creds, Domain);
+		WSTRING_LENGTH_CLEAR_AND_FREE(password_creds, Password);
+	}
+
+	free(password_creds);
+}
+
+/* ============================================================ */
+
+csp_data_detail* csp_data_detail_new_nocopy(UINT32 KeySpec, char* CardName, char* ReaderName,
+                                            char* ContainerName, char* CspName)
+{
+	csp_data_detail* csp;
+	CHECK_MEMORY(csp = malloc(sizeof(*csp)), return NULL);
+	csp->KeySpec = KeySpec;
+	csp->CardName = CardName;
+	csp->ReaderName = ReaderName;
+	csp->ContainerName = ContainerName;
+	csp->CspName = CspName;
+	return csp;
+}
+
+csp_data_detail* csp_data_detail_new(UINT32 KeySpec, char* cardname, char* readername,
+                                     char* containername, char* cspname)
+{
+	char* CardName = strdup(cardname);
+	char* ReaderName = strdup(readername);
+	char* ContainerName = strdup(containername);
+	char* CspName = strdup(cspname);
+
+	if (!CardName || !ReaderName || !ContainerName || !CspName)
+	{
+		free(CardName);
+		free(ReaderName);
+		free(ContainerName);
+		free(CspName);
+		WLog_ERR(TAG,
+		         "%s:%d: %s() Could not allocate CardName, ReaderName, ContainerName or CspName",
+		         __FILE__, __LINE__, __FUNCTION__);
+		return NULL;
+	}
+
+	return csp_data_detail_new_nocopy(KeySpec, CardName, ReaderName, ContainerName, CspName);
+}
+
+csp_data_detail* csp_data_detail_deepcopy(csp_data_detail* original)
+{
+	return csp_data_detail_new(original->KeySpec, original->CardName, original->ReaderName,
+	                           original->ContainerName, original->CspName);
+}
+
+void csp_data_detail_free(csp_data_detail* csp)
+{
+	if (csp == NULL)
+	{
+		return;
+	}
+
+	string_clear_and_free(csp->CardName);
+	string_clear_and_free(csp->ReaderName);
+	string_clear_and_free(csp->ContainerName);
+	string_clear_and_free(csp->CspName);
+	memory_clear_and_free(csp, sizeof(*csp));
+}
+
+/* ============================================================ */
+
+smartcard_creds* smartcard_creds_new_nocopy(char* Pin, char* UserHint, char* DomainHint,
+                                            csp_data_detail* csp_data)
+{
+	smartcard_creds* that;
+	CHECK_MEMORY(that = malloc(sizeof(*that)), return NULL);
+	that->Pin = Pin;
+	that->UserHint = UserHint;
+	that->DomainHint = DomainHint;
+	that->csp_data = csp_data;
+	return that;
+}
+
+smartcard_creds* smartcard_creds_new(char* pin, char* userhint, char* domainhint,
+                                     csp_data_detail* cspdata)
+{
+	char* Pin = strdup(pin);
+	char* UserHint = strdup(userhint);
+	char* DomainHint = strdup(domainhint);
+	csp_data_detail* cspData = csp_data_detail_deepcopy(cspdata);
+
+	if ((Pin == NULL) || (UserHint == NULL) || (DomainHint == NULL) || (cspData == NULL))
+	{
+		free(Pin);
+		free(UserHint);
+		free(DomainHint);
+		csp_data_detail_free(cspData);
+		WLog_ERR(
+		    TAG,
+		    "%s:%d: %s() Could not allocate Pin, UserHint or DomainHint,  or copy CSP Data Details",
+		    __FILE__, __LINE__, __FUNCTION__);
+		return NULL;
+	}
+
+	return smartcard_creds_new_nocopy(Pin, UserHint, DomainHint, cspData);
+}
+
+smartcard_creds* smartcard_creds_deepcopy(smartcard_creds* original)
+{
+	return smartcard_creds_new(original->Pin, original->UserHint, original->DomainHint,
+	                           original->csp_data);
+}
+
+void smartcard_creds_free(smartcard_creds* that)
+{
+	if (that == NULL)
+	{
+		return;
+	}
+
+	string_clear_and_free(that->Pin);
+	string_clear_and_free(that->UserHint);
+	string_clear_and_free(that->DomainHint);
+	csp_data_detail_free(that->csp_data);
+	memory_clear_and_free(that, sizeof(*that));
+}
+
+/* ============================================================ */
+
+remote_guard_package_cred*
+remote_guard_package_cred_new_nocopy(char* package_name, unsigned credential_size, BYTE* credential)
+{
+	remote_guard_package_cred* that;
+	CHECK_MEMORY(that = malloc(sizeof(*that)), return NULL);
+	that->package_name = package_name;
+	that->credential_size = credential_size;
+	that->credential = credential;
+	return that;
+}
+
+void remote_guard_package_cred_free(remote_guard_package_cred* that)
+{
+	if (that == NULL)
+	{
+		return;
+	}
+
+	free(that->package_name);
+	free(that->credential);
+	memset(that, 0, sizeof(*that));
+	free(that);
+}
+
+remote_guard_package_cred* remote_guard_package_cred_deepcopy(remote_guard_package_cred* that)
+{
+	remote_guard_package_cred* copy;
+	CHECK_MEMORY(copy = malloc(sizeof(*copy)), return NULL);
+	copy->package_name = strdup(that->package_name);
+	copy->credential_size = that->credential_size;
+	copy->credential = memdup(that->credential, that->credential_size);
+
+	if ((copy->package_name == NULL) || (copy->credential == NULL))
+	{
+		remote_guard_package_cred_free(copy);
+		CHECK_MEMORY(NULL, return NULL);
+	}
+
+	return copy;
+}
+
+/* ============================================================ */
+
+remote_guard_creds* remote_guard_creds_new_logon_cred(remote_guard_package_cred* logon_cred)
+{
+	remote_guard_creds* that;
+	CHECK_MEMORY(that = malloc(sizeof(*that)), return NULL);
+	that->login_cred = logon_cred;
+	that->supplemental_creds_count = 0;
+	that->supplemental_creds = NULL;
+	return that;
+}
+
+remote_guard_creds* remote_guard_creds_new_nocopy(char* package_name, unsigned credenial_size,
+                                                  BYTE* credential)
+{
+	remote_guard_package_cred* logon_cred =
+	    remote_guard_package_cred_new_nocopy(package_name, credenial_size, credential);
+	CHECK_MEMORY(logon_cred, return NULL);
+	return remote_guard_creds_new_logon_cred(logon_cred);
+}
+
+void remote_guard_creds_add_supplemental_cred(remote_guard_creds* that,
+                                              remote_guard_package_cred* supplemental_cred)
+{
+	remote_guard_package_cred** new_creds =
+	    realloc(that->supplemental_creds,
+	            (that->supplemental_creds_count + 1) * sizeof(that->supplemental_creds[0]));
+	CHECK_MEMORY(new_creds, return );
+	new_creds[that->supplemental_creds_count] = supplemental_cred;
+	that->supplemental_creds = new_creds;
+	that->supplemental_creds_count++;
+}
+
+remote_guard_creds* remote_guard_creds_deepcopy(remote_guard_creds* that)
+{
+	unsigned i;
+	remote_guard_creds* copy;
+	CHECK_MEMORY(copy = malloc(sizeof(*copy)), return NULL);
+	copy->login_cred = remote_guard_package_cred_deepcopy(that->login_cred);
+	copy->supplemental_creds_count = that->supplemental_creds_count;
+	copy->supplemental_creds =
+	    malloc(copy->supplemental_creds_count * sizeof(copy->supplemental_creds[0]));
+
+	for (i = 0; i < copy->supplemental_creds_count; i++)
+	{
+		copy->supplemental_creds[i] =
+		    remote_guard_package_cred_deepcopy(that->supplemental_creds[i]);
+
+		if (copy->supplemental_creds[i] == NULL)
+		{
+			break;
+		}
+	}
+
+	if ((copy->login_cred == NULL) || (copy->supplemental_creds == NULL) ||
+	    (i < copy->supplemental_creds_count))
+	{
+		remote_guard_creds_free(copy);
+		CHECK_MEMORY(NULL, return NULL);
+	}
+
+	return copy;
+}
+
+void remote_guard_creds_free(remote_guard_creds* that)
+{
+	remote_guard_package_cred_free(that->login_cred);
+
+	if (that->supplemental_creds != NULL)
+	{
+		unsigned i;
+
+		for (i = 0; i < that->supplemental_creds_count; i++)
+		{
+			remote_guard_package_cred_free(that->supplemental_creds[i]);
+		}
+
+		memory_clear_and_free(that->supplemental_creds,
+		                      that->supplemental_creds_count * sizeof(that->supplemental_creds[0]));
+	}
+
+	memory_clear_and_free(that, sizeof(*that));
+}
+
+/* ============================================================ */
+
+auth_identity* auth_identity_new_password(SEC_WINNT_AUTH_IDENTITY* password_creds)
+{
+	auth_identity* that;
+	CHECK_MEMORY(that = malloc(sizeof(*that)), return NULL);
+	that->cred_type = credential_type_password;
+	that->creds.password_creds = password_creds;
+	return that;
+}
+
+auth_identity* auth_identity_new_smartcard(smartcard_creds* smartcard_creds)
+{
+	auth_identity* that;
+	CHECK_MEMORY(that = malloc(sizeof(*that)), return NULL);
+	that->cred_type = credential_type_smartcard;
+	that->creds.smartcard_creds = smartcard_creds;
+	return that;
+}
+
+auth_identity* auth_identity_new_remote_guard(remote_guard_creds* remote_guard_creds)
+{
+	auth_identity* that;
+	CHECK_MEMORY(that = malloc(sizeof(*that)), return NULL);
+	that->cred_type = credential_type_remote_guard;
+	that->creds.remote_guard_creds = remote_guard_creds;
+	return that;
+}
+
+void auth_identity_free(auth_identity* that)
+{
+	if (that != NULL)
+	{
+		switch (that->cred_type)
+		{
+		case credential_type_password:
+			SEC_WINNT_AUTH_IDENTITY_free(that->creds.password_creds);
+			break;
+
+		case credential_type_smartcard:
+			smartcard_creds_free(that->creds.smartcard_creds);
+			break;
+
+		case credential_type_remote_guard:
+			remote_guard_creds_free(that->creds.remote_guard_creds);
+			break;
+		}
+
+		memory_clear_and_free(that, sizeof(*that));
+	}
+}
+
+const char* auth_identity_credential_type_label(auth_identity* that)
+{
+	if (that == NULL)
+	{
+		return "NULL";
+	}
+
+	switch (that->cred_type)
+	{
+	case credential_type_password:
+		return "password";
+
+	case credential_type_smartcard:
+		return "smartcard";
+
+	case credential_type_remote_guard:
+		return "remote-guard";
+
+	default:
+		return "unknown";
+	}
+}
+
+auth_identity* auth_identity_deepcopy(auth_identity* that)
+{
+#define CHECK_COPY(field, copier)                        \
+	if (that->creds.field != NULL)                       \
+	{                                                    \
+		if ((field = copier(that->creds.field)) == NULL) \
+		{                                                \
+			goto failure;                                \
+		}                                                \
+	}
+	SEC_WINNT_AUTH_IDENTITY* password_creds = NULL;
+	smartcard_creds* smartcard_creds = NULL;
+	remote_guard_creds* remote_guard_creds = NULL;
+
+	switch (that->cred_type)
+	{
+	case credential_type_password:
+		CHECK_COPY(password_creds, SEC_WINNT_AUTH_IDENTITY_deepcopy);
+		return auth_identity_new_password(password_creds);
+
+	case credential_type_smartcard:
+		CHECK_COPY(smartcard_creds, smartcard_creds_deepcopy);
+		return auth_identity_new_smartcard(smartcard_creds);
+
+	case credential_type_remote_guard:
+		CHECK_COPY(remote_guard_creds, remote_guard_creds_deepcopy);
+		return auth_identity_new_remote_guard(remote_guard_creds);
+	}
+
+failure:
+	SEC_WINNT_AUTH_IDENTITY_free(password_creds);
+	smartcard_creds_free(smartcard_creds);
+	remote_guard_creds_free(remote_guard_creds);
+	return NULL;
+#undef CHECK_COPY
+}
+
+/* ============================================================ */
+
+static BOOL nla_read_octet_string(wStream* s, const char* field_name, int contextual_tag,
+                                  BYTE** field, UINT32* field_length)
+{
+	size_t length = 0;
+
+	if (!ber_read_contextual_tag(s, contextual_tag, &length, TRUE) ||
+	    !ber_read_octet_string_tag(s, &length))
+	{
+		return FALSE;
+	}
+
+	if (length == 0)
+	{
+		CHECK_MEMORY((*field) = calloc(1, 2), return FALSE);
+	}
+	else
+	{
+		CHECK_MEMORY((*field) = malloc(length), return FALSE);
+		CopyMemory((*field), Stream_Pointer(s), length);
+		Stream_Seek(s, length);
+	}
+
+	(*field_length) = (UINT32)length;
+	return TRUE;
+}
+
+static BOOL nla_read_octet_string_field(wStream* s, const char* field_name, int contextual_tag,
+                                        UINT16** field, UINT32* field_length)
+{
+	if (nla_read_octet_string(s, field_name, contextual_tag, (BYTE**)field, field_length))
+	{
+		(*field_length) /= 2;
+		return TRUE;
+	}
+	else
+	{
+		return FALSE;
+	}
+}
+
+static BOOL nla_read_octet_string_string(wStream* s, const char* field_name, int contextual_tag,
+                                         char** string)
+{
+	int result;
+	UINT16* field = NULL;
+	UINT32 field_length = 0;
+	(*string) = NULL;
+
+	if (!nla_read_octet_string_field(s, field_name, contextual_tag, &field, &field_length))
+	{
+		return 0;
+	}
+
+	result = ConvertFromUnicode(CP_UTF8, 0, field, 2 * field_length, string, 0, 0, FALSE);
+	free(field);
+	return 0 <= result;
+}
+
+static size_t nla_write_sequence_octet_string_string(wStream* s, const char* field_name,
+                                                     int contextual_tag, char* string)
+{
+	LPWSTR buffer = NULL;
+	size_t length;
+	int increment;
+
+	if ((length = ConvertToUnicode(CP_UTF8, 0, string, -1, &buffer, 0)) <= 0)
+	{
+		WLog_ERR(TAG, "Cannot ConvertToUnicode '%s'", string);
+		return 0;
+	}
+
+	/* ConvertToUnicode returns the number of codepoints, including the terminating nul! */
+	increment = ber_write_sequence_octet_string(s, contextual_tag, (BYTE*)buffer, (length - 1) * 2);
+	free(buffer);
+	return increment;
+}
+
+/*
+string_length returns the number of characters in the utf-8 string.
+That is, the number of WCHAR in the string converted to "unicode".
+*/
+int string_length(char* string)
+{
+	if (string == NULL)
+	{
+		return 0;
+	}
+	else
+	{
+		LPWSTR wstring = NULL;
+		int length = ConvertToUnicode(CP_UTF8, 0, string, -1, &wstring, 0);
+		free(wstring);
+		/* ConvertToUnicode returns the number of codepoints, including the terminating nul! */
+		return (length <= 0) ? 0 : length - 1;
+	}
+}
+
+/* ============================================================ */
+
+size_t nla_sizeof_ts_password_creds_inner(SEC_WINNT_AUTH_IDENTITY* password_creds)
+{
+	if (password_creds == NULL)
+	{
+		return 0;
+	}
+
+	return (ber_sizeof_sequence_octet_string(password_creds->DomainLength * 2) +
+	        ber_sizeof_sequence_octet_string(password_creds->UserLength * 2) +
+	        ber_sizeof_sequence_octet_string(password_creds->PasswordLength * 2));
+}
+
+size_t nla_sizeof_ts_password_creds(SEC_WINNT_AUTH_IDENTITY* password_creds)
+{
+	size_t inner_size = nla_sizeof_ts_password_creds_inner(password_creds);
+	return ber_sizeof_sequence(inner_size);
+}
+
+size_t nla_sizeof_ts_cspdatadetail_inner(csp_data_detail* csp_data)
+{
+	if (csp_data == NULL)
+	{
+		return 0;
+	}
+
+	return (ber_sizeof_contextual_tag(ber_sizeof_integer(csp_data->KeySpec)) +
+	        ber_sizeof_integer(csp_data->KeySpec) +
+	        ber_sizeof_sequence_octet_string(string_length(csp_data->CardName) * 2) +
+	        ber_sizeof_sequence_octet_string(string_length(csp_data->ReaderName) * 2) +
+	        ber_sizeof_sequence_octet_string(string_length(csp_data->ContainerName) * 2) +
+	        ber_sizeof_sequence_octet_string(string_length(csp_data->CspName) * 2));
+}
+
+size_t nla_sizeof_ts_cspdatadetail(csp_data_detail* csp_data)
+{
+	size_t inner_size = nla_sizeof_ts_cspdatadetail_inner(csp_data);
+	size_t seq_size = ber_sizeof_sequence(inner_size);
+	return (ber_sizeof_contextual_tag(seq_size) + seq_size);
+}
+
+size_t nla_sizeof_ts_smartcard_creds_inner(smartcard_creds* smartcard_creds)
+{
+	if (smartcard_creds == NULL)
+	{
+		return 0;
+	}
+
+	return (ber_sizeof_sequence_octet_string(string_length(smartcard_creds->Pin) * 2) +
+	        nla_sizeof_ts_cspdatadetail(smartcard_creds->csp_data) +
+	        ber_sizeof_sequence_octet_string(string_length(smartcard_creds->UserHint) * 2) +
+	        ber_sizeof_sequence_octet_string(string_length(smartcard_creds->DomainHint) * 2));
+}
+
+size_t nla_sizeof_ts_smartcard_creds(smartcard_creds* smartcard_creds)
+{
+	return ber_sizeof_sequence(nla_sizeof_ts_smartcard_creds_inner(smartcard_creds));
+}
+
+size_t nla_sizeof_ts_remote_guard_package_cred_inner(remote_guard_package_cred* package_cred)
+{
+	return (ber_sizeof_sequence_octet_string(string_length(package_cred->package_name) * 2) +
+	        ber_sizeof_sequence_octet_string(package_cred->credential_size));
+}
+
+size_t nla_sizeof_ts_remote_guard_package_cred(remote_guard_package_cred* package_cred)
+{
+	return ber_sizeof_sequence(nla_sizeof_ts_remote_guard_package_cred_inner(package_cred));
+}
+
+size_t nla_sizeof_ts_remote_guard_creds_inner(remote_guard_creds* remote_guard_creds)
+{
+	size_t size = 0;
+	unsigned i;
+
+	if (remote_guard_creds == NULL)
+	{
+		return 0;
+	}
+
+	/* logonCred         [0] TSRemoteGuardPackageCred, */
+	{
+		size_t login_size = nla_sizeof_ts_remote_guard_package_cred(remote_guard_creds->login_cred);
+		size += ber_sizeof_contextual_tag(login_size);
+		size += login_size;
+	}
+
+	/* supplementalCreds [1] SEQUENCE OF TSRemoteGuardPackageCred OPTIONAL, */
+	if (0 < remote_guard_creds->supplemental_creds_count)
+	{
+		size_t seq_size = 0;
+		size_t supplemental_size = 0;
+
+		for (i = 0; i < remote_guard_creds->supplemental_creds_count; i++)
+		{
+			supplemental_size +=
+			    nla_sizeof_ts_remote_guard_package_cred(remote_guard_creds->supplemental_creds[i]);
+		}
+
+		seq_size = ber_sizeof_sequence(supplemental_size);
+		size += ber_sizeof_contextual_tag(seq_size);
+		size += seq_size;
+	}
+
+	return size;
+}
+
+size_t nla_sizeof_ts_remote_guard_creds(remote_guard_creds* remote_guard_creds)
+{
+	return ber_sizeof_sequence(nla_sizeof_ts_remote_guard_creds_inner(remote_guard_creds));
+}
+
+size_t nla_sizeof_ts_creds(auth_identity* identity)
+{
+	switch (identity->cred_type)
+	{
+	case credential_type_password:
+		return nla_sizeof_ts_password_creds(identity->creds.password_creds);
+
+	case credential_type_smartcard:
+		return nla_sizeof_ts_smartcard_creds(identity->creds.smartcard_creds);
+
+	case credential_type_remote_guard:
+		return nla_sizeof_ts_remote_guard_creds(identity->creds.remote_guard_creds);
+
+	default:
+		return 0;
+	}
+}
+
+size_t nla_sizeof_ts_credentials_inner(auth_identity* identity)
+{
+	return (ber_sizeof_contextual_tag(ber_sizeof_integer(identity->cred_type)) +
+	        ber_sizeof_integer(identity->cred_type) +
+	        ber_sizeof_sequence_octet_string(nla_sizeof_ts_creds(identity)));
+}
+
+size_t nla_sizeof_ts_credentials(auth_identity* identity)
+{
+	return ber_sizeof_sequence(nla_sizeof_ts_credentials_inner(identity));
+}
+
+static SEC_WINNT_AUTH_IDENTITY* nla_read_ts_password_creds(wStream* s, size_t* length)
+{
+	SEC_WINNT_AUTH_IDENTITY* password_creds = NULL;
+
+	/* TSPasswordCreds (SEQUENCE) */
+	if (!ber_read_sequence_tag(s, length))
+	{
+		return NULL;
+	}
+
+	/* The sequence is empty, return early,
+	 * TSPasswordCreds (SEQUENCE) is optional. */
+	if ((*length) == 0)
+	{
+		return NULL;
+	}
+
+	password_creds = SEC_WINNT_AUTH_IDENTITY_new(NULL, NULL, NULL);
+
+	if (nla_read_octet_string_field(s, "[0] domainName (OCTET STRING)", 0, &password_creds->Domain,
+	                                &password_creds->DomainLength) &&
+	    nla_read_octet_string_field(s, "[1] userName (OCTET STRING)", 1, &password_creds->User,
+	                                &password_creds->UserLength) &&
+	    nla_read_octet_string_field(s, "[2] password (OCTET STRING)", 2, &password_creds->Password,
+	                                &password_creds->PasswordLength))
+	{
+		return password_creds;
+	}
+
+	SEC_WINNT_AUTH_IDENTITY_free(password_creds);
+	return NULL;
+}
+
+static csp_data_detail* nla_read_ts_cspdatadetail(wStream* s, size_t* length)
+{
+	csp_data_detail* csp_data = NULL;
+	UINT32 key_spec = 0;
+
+	/* TSCspDataDetail (SEQUENCE)
+	 * Initialise to default values. */
+	if (!ber_read_sequence_tag(s, length))
+	{
+		return NULL;
+	}
+
+	/* The sequence is empty, return early,
+	 * TSCspDataDetail (SEQUENCE) is optional. */
+	if (*length == 0)
+	{
+		return NULL;
+	}
+
+	/* [0] keySpec (INTEGER) */
+	if (!ber_read_contextual_tag(s, 0, length, TRUE) || !ber_read_integer(s, &key_spec))
+	{
+		return NULL;
+	}
+
+	CHECK_MEMORY((csp_data = csp_data_detail_new_nocopy(key_spec, NULL, NULL, NULL, NULL)) == NULL,
+	             return NULL);
+
+	if (nla_read_octet_string_string(s, "[1] cardName (OCTET STRING)", 1, &csp_data->CardName) &&
+	    nla_read_octet_string_string(s, "[2] readerName (OCTET STRING)", 2,
+	                                 &csp_data->ReaderName) &&
+	    nla_read_octet_string_string(s, "[3] containerName (OCTET STRING)", 3,
+	                                 &csp_data->ContainerName) &&
+	    nla_read_octet_string_string(s, "[4] cspName (OCTET STRING)", 4, &csp_data->CspName))
+	{
+		return csp_data;
+	}
+
+	csp_data_detail_free(csp_data);
+	return NULL;
+}
+
+static smartcard_creds* nla_read_ts_smartcard_creds(wStream* s, size_t* length)
+{
+	smartcard_creds* smartcard_creds = NULL;
+
+	/* TSSmartCardCreds (SEQUENCE)
+	 * Initialize to default values. */
+	if (!ber_read_sequence_tag(s, length))
+	{
+		return NULL;
+	}
+
+	/* The sequence is empty, return early,
+	 * TSSmartCardCreds (SEQUENCE) is optional. */
+	if ((*length) == 0)
+	{
+		return NULL;
+	}
+
+	CHECK_MEMORY((smartcard_creds = smartcard_creds_new_nocopy(NULL, NULL, NULL, NULL)),
+	             return NULL);
+
+	if (nla_read_octet_string_string(s, "[0] Pin (OCTET STRING)", 0, &smartcard_creds->Pin))
+	{
+		smartcard_creds->csp_data = nla_read_ts_cspdatadetail(s, length);
+
+		if (nla_read_octet_string_string(s, "[2] UserHint (OCTET STRING)", 2,
+		                                 &smartcard_creds->UserHint) &&
+		    nla_read_octet_string_string(s, "[3] DomainHint (OCTET STRING", 3,
+		                                 &smartcard_creds->DomainHint))
+		{
+			return smartcard_creds;
+		}
+	}
+
+	smartcard_creds_free(smartcard_creds);
+	return NULL;
+}
+
+static remote_guard_package_cred* nla_read_ts_remote_guard_package_cred(wStream* s, size_t* length)
+{
+	remote_guard_package_cred* package_cred = NULL;
+
+	/*
+	 * TSRemoteGuardPackageCred ::=  SEQUENCE {
+	 *     packageName [0] OCTET STRING,
+	 *     credBuffer  [1] OCTET STRING,
+	 * }
+	 */
+
+	if (!ber_read_sequence_tag(s, length))
+	{
+		return NULL;
+	}
+
+	/* The sequence is empty, return early,
+	 * TSRemoteGuardPackageCreds (SEQUENCE) is optional. */
+	if ((*length) == 0)
+	{
+		return NULL;
+	}
+
+	char* package_name;
+	BYTE* cred_buffer;
+	UINT32 cred_buffer_size;
+
+	if (nla_read_octet_string_string(s, "[0] OCTET STRING,", 0, &package_name) &&
+	    nla_read_octet_string(s, "[1] OCTET STRING", 1, &cred_buffer, &cred_buffer_size))
+	{
+		package_cred =
+		    remote_guard_package_cred_new_nocopy(package_name, cred_buffer_size, cred_buffer);
+	}
+
+	if (package_cred == NULL)
+	{
+		free(package_name);
+		free(cred_buffer);
+		CHECK_MEMORY(NULL, return NULL);
+	}
+
+	return package_cred;
+}
+
+static remote_guard_creds* nla_read_ts_remote_guard_creds(wStream* s, size_t* length)
+{
+	/*
+	 * TSRemoteGuardCreds ::= SEQUENCE {
+	 *     logonCred         [0] TSRemoteGuardPackageCred,
+	 *     supplementalCreds [1] SEQUENCE OF TSRemoteGuardPackageCred OPTIONAL,
+	 * }
+	 */
+	remote_guard_creds* remote_guard_creds = NULL;
+	remote_guard_package_cred* logon_cred = NULL;
+	size_t supplemental_length = 0;
+
+	/* TSRemoteGuardCreds (SEQUENCE)
+	 * Initialize to default values. */
+	if (!ber_read_sequence_tag(s, length))
+	{
+		return NULL;
+	}
+
+	/* The sequence is empty, return early,
+	 * TSRemoteGuardCreds (SEQUENCE) is optional. */
+	if ((*length) == 0)
+	{
+		return NULL;
+	}
+
+	logon_cred = nla_read_ts_remote_guard_package_cred(s, length);
+	remote_guard_creds = remote_guard_creds_new_logon_cred(logon_cred);
+
+	if (remote_guard_creds == NULL)
+	{
+		free(logon_cred);
+		return NULL;
+	}
+
+	if (ber_read_sequence_tag(s, &supplemental_length) && (supplemental_length > 0))
+	{
+		remote_guard_package_cred* supplemental_cred =
+		    nla_read_ts_remote_guard_package_cred(s, length);
+
+		while (supplemental_cred != NULL)
+		{
+			remote_guard_creds_add_supplemental_cred(remote_guard_creds, supplemental_cred);
+			supplemental_cred = nla_read_ts_remote_guard_package_cred(s, length);
+		}
+	}
+
+	return remote_guard_creds;
+}
+
+static auth_identity* nla_read_ts_creds(wStream* s, credential_type cred_type, size_t* length)
+{
+	auth_identity* identity = NULL;
+	SEC_WINNT_AUTH_IDENTITY* password_creds = NULL;
+	smartcard_creds* smartcard_creds = NULL;
+	remote_guard_creds* remote_guard_creds = NULL;
+
+	switch (cred_type)
+	{
+	case credential_type_password:
+		if ((password_creds = nla_read_ts_password_creds(s, length)) != NULL)
+		{
+			identity = auth_identity_new_password(password_creds);
+		}
+
+		break;
+
+	case credential_type_smartcard:
+		if ((smartcard_creds = nla_read_ts_smartcard_creds(s, length)) != NULL)
+		{
+			identity = auth_identity_new_smartcard(smartcard_creds);
+		}
+
+		break;
+
+	case credential_type_remote_guard:
+		if ((remote_guard_creds = nla_read_ts_remote_guard_creds(s, length)) != NULL)
+		{
+			identity = auth_identity_new_remote_guard(remote_guard_creds);
+		}
+
+		break;
+
+	default:
+		WLog_ERR(TAG, "cred_type unknown: %d\n", cred_type);
+		return NULL;
+	}
+
+	if (identity != NULL)
+	{
+		return identity;
+	}
+
+	SEC_WINNT_AUTH_IDENTITY_free(password_creds);
+	smartcard_creds_free(smartcard_creds);
+	remote_guard_creds_free(remote_guard_creds);
+	return NULL;
+}
+
+auth_identity* nla_read_ts_credentials(PSecBuffer ts_credentials)
+{
+	auth_identity* identity = NULL;
+	wStream* s;
+	size_t length = 0;
+	size_t ts_creds_length = 0;
+	UINT32* value = NULL;
+
+	if (!ts_credentials || !ts_credentials->pvBuffer)
+		return FALSE;
+
+	s = Stream_New(ts_credentials->pvBuffer, ts_credentials->cbBuffer);
+
+	if (!s)
+	{
+		WLog_ERR(TAG, "Stream_New failed!");
+		return FALSE;
+	}
+
+	/* TSCredentials (SEQUENCE) */
+	if (ber_read_sequence_tag(s, &length) &&
+	    /* [0] credType (INTEGER) */
+	    ber_read_contextual_tag(s, 0, &length, TRUE) && ber_read_integer(s, value) &&
+	    /* [1] credentials (OCTET STRING) */
+	    ber_read_contextual_tag(s, 1, &length, TRUE) &&
+	    ber_read_octet_string_tag(s, &ts_creds_length))
+	{
+		identity = nla_read_ts_creds(s, *value, &length);
+	}
+
+	Stream_Free(s, FALSE);
+	return identity;
+}
+
+size_t nla_write_ts_password_creds(SEC_WINNT_AUTH_IDENTITY* password_creds, wStream* s)
+{
+	size_t size = 0;
+	size_t inner_size = nla_sizeof_ts_password_creds_inner(password_creds);
+	/* TSPasswordCreds (SEQUENCE) */
+	size += ber_write_sequence_tag(s, inner_size);
+
+	if (password_creds != NULL)
+	{
+		/* [0] domainName (OCTET STRING) */
+		size += ber_write_sequence_octet_string(s, 0, (BYTE*)password_creds->Domain,
+		                                        password_creds->DomainLength * 2);
+		/* [1] userName (OCTET STRING) */
+		size += ber_write_sequence_octet_string(s, 1, (BYTE*)password_creds->User,
+		                                        password_creds->UserLength * 2);
+		/* [2] password (OCTET STRING) */
+		size += ber_write_sequence_octet_string(s, 2, (BYTE*)password_creds->Password,
+		                                        password_creds->PasswordLength * 2);
+	}
+
+	return size;
+}
+
+size_t nla_write_ts_csp_data_detail(csp_data_detail* csp_data, int contextual_tag, wStream* s)
+{
+	size_t size = 0;
+
+	if (csp_data != NULL)
+	{
+		size_t inner_size = nla_sizeof_ts_cspdatadetail_inner(csp_data);
+		size += ber_write_contextual_tag(s, contextual_tag, ber_sizeof_sequence(inner_size), TRUE);
+		size += ber_write_sequence_tag(s, inner_size);
+		/* [0] KeySpec (INTEGER) */
+		size += ber_write_contextual_tag(s, 0, ber_sizeof_integer(csp_data->KeySpec), TRUE);
+		size += ber_write_integer(s, csp_data->KeySpec);
+		size += nla_write_sequence_octet_string_string(s, "[1] CardName (OCTET STRING)", 1,
+		                                               csp_data->CardName);
+		size += nla_write_sequence_octet_string_string(s, "[2] ReaderName (OCTET STRING)", 2,
+		                                               csp_data->ReaderName);
+		size += nla_write_sequence_octet_string_string(s, "[3] ContainerName (OCTET STRING)", 3,
+		                                               csp_data->ContainerName);
+		size += nla_write_sequence_octet_string_string(s, "[4] CspName (OCTET STRING)", 4,
+		                                               csp_data->CspName);
+	}
+
+	return size;
+}
+
+size_t nla_write_ts_smartcard_creds(smartcard_creds* smartcard_creds, wStream* s)
+{
+	size_t size = 0;
+	size_t inner_size = nla_sizeof_ts_smartcard_creds_inner(smartcard_creds);
+	/* TSSmartCardCreds (SEQUENCE) */
+	size += ber_write_sequence_tag(s, inner_size);
+
+	if (smartcard_creds != NULL)
+	{
+		size += nla_write_sequence_octet_string_string(s, "[0] Pin (OCTET STRING)", 0,
+		                                               smartcard_creds->Pin);
+		/* [1] CspDataDetail (TSCspDataDetail) (SEQUENCE) */
+		size += nla_write_ts_csp_data_detail(smartcard_creds->csp_data, 1, s);
+		size += nla_write_sequence_octet_string_string(s, "[2] userHint (OCTET STRING)", 2,
+		                                               smartcard_creds->UserHint);
+		size += nla_write_sequence_octet_string_string(s, "[3] domainHint (OCTET STRING)", 3,
+		                                               smartcard_creds->DomainHint);
+	}
+
+	return size;
+}
+
+size_t nla_write_ts_remote_guard_package_cred(remote_guard_package_cred* package_cred, wStream* s)
+{
+	/*
+	 * TSRemoteGuardPackageCred ::=  SEQUENCE {
+	 *     packageName [0] OCTET STRING,
+	 *     credBuffer  [1] OCTET STRING,
+	 * }
+	 */
+	size_t size = 0;
+	size_t inner_size = nla_sizeof_ts_remote_guard_package_cred_inner(package_cred);
+	size += ber_write_sequence_tag(s, inner_size);
+
+	if (package_cred != NULL)
+	{
+		size += nla_write_sequence_octet_string_string(s, "packageName [0] OCTET STRING", 0,
+		                                               package_cred->package_name);
+		/* credBuffer  [1] OCTET STRING, */
+		size += ber_write_sequence_octet_string(s, 1, package_cred->credential,
+		                                        package_cred->credential_size);
+	}
+
+	return size;
+}
+
+size_t nla_write_ts_remote_guard_creds(remote_guard_creds* remote_guard_creds, wStream* s)
+{
+	unsigned i;
+	size_t size = 0;
+	size_t inner_size = nla_sizeof_ts_remote_guard_creds_inner(remote_guard_creds);
+	/* TSRemoteGuardCreds ::= SEQUENCE { */
+	size += ber_write_sequence_tag(s, inner_size);
+	/*     logonCred         [0] TSRemoteGuardPackageCred, */
+	size += ber_write_contextual_tag(
+	    s, 0, nla_sizeof_ts_remote_guard_package_cred(remote_guard_creds->login_cred), TRUE);
+	size += nla_write_ts_remote_guard_package_cred(remote_guard_creds->login_cred, s);
+
+	/*     supplementalCreds [1] SEQUENCE OF TSRemoteGuardPackageCred OPTIONAL, */
+	if (0 < remote_guard_creds->supplemental_creds_count)
+	{
+		unsigned supplemental_size = 0;
+
+		for (i = 0; i < remote_guard_creds->supplemental_creds_count; i++)
+		{
+			supplemental_size +=
+			    nla_sizeof_ts_remote_guard_package_cred(remote_guard_creds->supplemental_creds[i]);
+		}
+
+		size += ber_write_contextual_tag(s, 1, ber_sizeof_sequence(supplemental_size), TRUE);
+		size += ber_write_sequence_tag(s, supplemental_size);
+
+		for (i = 0; i < remote_guard_creds->supplemental_creds_count; i++)
+		{
+			size += nla_write_ts_remote_guard_package_cred(
+			    remote_guard_creds->supplemental_creds[i], s);
+		}
+	}
+
+	return size;
+}
+
+size_t nla_write_ts_creds(auth_identity* identity, wStream* s)
+{
+	switch (identity->cred_type)
+	{
+	case credential_type_password:
+		return nla_write_ts_password_creds(identity->creds.password_creds, s);
+
+	case credential_type_smartcard:
+		return nla_write_ts_smartcard_creds(identity->creds.smartcard_creds, s);
+
+	case credential_type_remote_guard:
+		return nla_write_ts_remote_guard_creds(identity->creds.remote_guard_creds, s);
+
+	default:
+		WLog_ERR(TAG, "cred_type unknown: %d\n", identity->cred_type);
+		return 0;
+	}
+}
+
+size_t nla_write_ts_credentials(auth_identity* identity, wStream* s)
+{
+	size_t size = 0;
+	size_t cred_size = 0;
+	size_t inner_size = nla_sizeof_ts_credentials_inner(identity);
+	/* TSCredentials (SEQUENCE) */
+	size += ber_write_sequence_tag(s, inner_size);
+	/* [0] credType (INTEGER) */
+	size += ber_write_contextual_tag(s, 0, ber_sizeof_integer(identity->cred_type), TRUE);
+	size += ber_write_integer(s, identity->cred_type);
+	/* [1] credentials (OCTET STRING) */
+	cred_size = nla_sizeof_ts_creds(identity);
+	size += ber_write_contextual_tag(s, 1, ber_sizeof_octet_string(cred_size), TRUE);
+	size += ber_write_octet_string_tag(s, cred_size);
+	size += nla_write_ts_creds(identity, s);
+	return size;
+}
+
+/**** THE END ****/
--- libfreerdp/core/tscredentials.h	1970-01-01 03:00:00.000000000 +0300
+++ ../../informatimago/FreeRDP/libfreerdp/core/tscredentials.h	2019-07-25 20:11:28.159983634 +0300
@@ -0,0 +1,134 @@
+#ifndef FREERDP_LIB_CORE_TSREQUEST_H
+#define FREERDP_LIB_CORE_TSREQUEST_H
+
+#ifdef HAVE_CONFIG_H
+#	include "config.h"
+#endif
+
+#include <winpr/crt.h>
+#include <winpr/sspi.h>
+#include <winpr/print.h>
+#include <winpr/tchar.h>
+#include <winpr/strlst.h>
+
+typedef struct
+{
+	UINT32 KeySpec;
+	char* CardName;
+	char* ReaderName;
+	char* ContainerName;
+	char* CspName;
+} csp_data_detail;
+
+typedef struct
+{
+	char* Pin;
+	char* UserHint;   /* OPTIONAL */
+	char* DomainHint; /* OPTIONAL */
+	csp_data_detail* csp_data;
+} smartcard_creds;
+
+typedef struct
+{
+	char* package_name;
+	unsigned credential_size;
+	BYTE* credential;
+} remote_guard_package_cred;
+
+typedef struct
+{
+	remote_guard_package_cred* login_cred;
+	unsigned supplemental_creds_count;
+	remote_guard_package_cred** supplemental_creds;
+} remote_guard_creds;
+
+typedef enum
+{
+	credential_type_password = 1,
+	credential_type_smartcard = 2,
+	credential_type_remote_guard = 6,
+	credential_type_default = credential_type_password,
+} credential_type;
+
+typedef struct
+{
+	credential_type cred_type;
+	union {
+		SEC_WINNT_AUTH_IDENTITY* password_creds;
+		smartcard_creds* smartcard_creds;
+		remote_guard_creds* remote_guard_creds;
+	} creds;
+} auth_identity;
+
+SEC_WINNT_AUTH_IDENTITY* SEC_WINNT_AUTH_IDENTITY_new(char* user, char* password, char* domain);
+SEC_WINNT_AUTH_IDENTITY* SEC_WINNT_AUTH_IDENTITY_deepcopy(SEC_WINNT_AUTH_IDENTITY* original);
+void SEC_WINNT_AUTH_IDENTITY_free(SEC_WINNT_AUTH_IDENTITY* password_creds);
+
+csp_data_detail* csp_data_detail_new_nocopy(UINT32 KeySpec, char* CardName, char* ReaderName,
+                                            char* ContainerName, char* CspName);
+csp_data_detail* csp_data_detail_new(UINT32 KeySpec, char* cardname, char* readername,
+                                     char* containername, char* cspname);
+csp_data_detail* csp_data_detail_deepcopy(csp_data_detail* original);
+void csp_data_detail_free(csp_data_detail* csp);
+
+smartcard_creds* smartcard_creds_new_nocopy(char* Pin, char* UserHint, char* DomainHint,
+                                            csp_data_detail* csp_data);
+smartcard_creds* smartcard_creds_new(char* pin, char* userhint, char* domainhint,
+                                     csp_data_detail* cspdata);
+smartcard_creds* smartcard_creds_deepcopy(smartcard_creds* original);
+void smartcard_creds_free(smartcard_creds* that);
+
+remote_guard_package_cred* remote_guard_package_cred_new_nocopy(char* package_name,
+                                                                unsigned credential_size,
+                                                                BYTE* credential);
+remote_guard_package_cred* remote_guard_package_cred_deepcopy(remote_guard_package_cred* that);
+void remote_guard_package_cred_deepfree(remote_guard_package_cred* that);
+
+remote_guard_creds* remote_guard_creds_new_logon_cred(remote_guard_package_cred* logon_cred);
+remote_guard_creds* remote_guard_creds_new_nocopy(char* package_name, unsigned credenial_size,
+                                                  BYTE* credential);
+remote_guard_creds* remote_guard_creds_deepcopy(remote_guard_creds* that);
+void remote_guard_creds_add_supplemental_cred(remote_guard_creds* that,
+                                              remote_guard_package_cred* supplemental_cred);
+void remote_guard_creds_free(remote_guard_creds* that);
+
+auth_identity* auth_identity_new_password(SEC_WINNT_AUTH_IDENTITY* password_creds);
+auth_identity* auth_identity_new_smartcard(smartcard_creds* smartcard_creds);
+auth_identity* auth_identity_new_remote_guard(remote_guard_creds* remote_guard_creds);
+auth_identity* auth_identity_deepcopy(auth_identity* that);
+void auth_identity_free(auth_identity* that);
+const char* auth_identity_credential_type_label(auth_identity* that);
+
+size_t nla_sizeof_ts_creds(auth_identity* identity);
+size_t nla_write_ts_creds(auth_identity* identity, wStream* s);
+size_t nla_sizeof_ts_credentials_inner(auth_identity* identity);
+size_t nla_sizeof_ts_credentials(auth_identity* identity);
+size_t nla_write_ts_credentials(auth_identity* identity, wStream* s);
+auth_identity* nla_read_ts_credentials(PSecBuffer ts_credentials);
+
+#define ber_sizeof_sequence_octet_string(length) \
+	(ber_sizeof_contextual_tag(ber_sizeof_octet_string(length)) + ber_sizeof_octet_string(length))
+
+#define ber_write_sequence_octet_string(stream, context, value, length)                 \
+	(ber_write_contextual_tag(stream, context, ber_sizeof_octet_string(length), TRUE) + \
+	 ber_write_octet_string(stream, value, length))
+
+/* exported for tests */
+size_t nla_sizeof_ts_password_creds_inner(SEC_WINNT_AUTH_IDENTITY* password_creds);
+size_t nla_sizeof_ts_password_creds(SEC_WINNT_AUTH_IDENTITY* password_creds);
+size_t nla_sizeof_ts_cspdatadetail_inner(csp_data_detail* csp_data);
+size_t nla_sizeof_ts_cspdatadetail(csp_data_detail* csp_data);
+size_t nla_sizeof_ts_smartcard_creds_inner(smartcard_creds* smartcard_creds);
+size_t nla_sizeof_ts_smartcard_creds(smartcard_creds* smartcard_creds);
+size_t nla_sizeof_ts_remote_guard_package_cred_inner(remote_guard_package_cred* package_cred);
+size_t nla_sizeof_ts_remote_guard_package_cred(remote_guard_package_cred* package_cred);
+size_t nla_sizeof_ts_remote_guard_creds_inner(remote_guard_creds* remote_guard_creds);
+size_t nla_sizeof_ts_remote_guard_creds(remote_guard_creds* remote_guard_creds);
+
+size_t nla_write_ts_password_creds(SEC_WINNT_AUTH_IDENTITY* password_creds, wStream* s);
+size_t nla_write_ts_csp_data_detail(csp_data_detail* csp_data, int contextual_tag, wStream* s);
+size_t nla_write_ts_smartcard_creds(smartcard_creds* smartcard_creds, wStream* s);
+size_t nla_write_ts_remote_guard_package_cred(remote_guard_package_cred* package_cred, wStream* s);
+size_t nla_write_ts_remote_guard_creds(remote_guard_creds* remote_guard_creds, wStream* s);
+
+#endif

diff -urN libfreerdp/cache/glyph.c ../../informatimago/FreeRDP/libfreerdp/cache/glyph.c
--- libfreerdp/cache/glyph.c	2019-07-25 19:51:01.261899405 +0300
+++ ../../informatimago/FreeRDP/libfreerdp/cache/glyph.c	2019-07-25 20:11:25.239969155 +0300
@@ -188,7 +188,7 @@
 	if (bkHeight < 0)
 		bkHeight = 0;
 
-	if (opX + opWidth > (INT64)context->settings->DesktopWidth)
+	if (opX + opWidth > context->settings->DesktopWidth)
 	{
 		/**
 		 * Some Microsoft servers send erroneous high values close to the
@@ -202,7 +202,7 @@
 		opWidth = context->settings->DesktopWidth - opX;
 	}
 
-	if (bkX + bkWidth > (INT64)context->settings->DesktopWidth)
+	if (bkX + bkWidth > context->settings->DesktopWidth)
 	{
 		/**
 		 * Some Microsoft servers send erroneous high values close to the
@@ -348,8 +348,8 @@
 	/* Server can send a massive number (32766) which appears to be
 	 * undocumented special behavior for "Erase all the way right".
 	 * X11 has nondeterministic results asking for a draw that wide. */
-	if (opRight > (INT64)context->instance->settings->DesktopWidth)
-		opRight = (int)context->instance->settings->DesktopWidth;
+	if (opRight > context->instance->settings->DesktopWidth)
+		opRight = context->instance->settings->DesktopWidth;
 
 	if (x == -32768)
 		x = fastIndex->bkLeft;
@@ -420,8 +420,8 @@
 		opRight = fastGlyph->bkRight;
 
 	/* See update_gdi_fast_index opRight comment. */
-	if (opRight > (INT64)context->instance->settings->DesktopWidth)
-		opRight = (int)context->instance->settings->DesktopWidth;
+	if (opRight > context->instance->settings->DesktopWidth)
+		opRight = context->instance->settings->DesktopWidth;
 
 	if (x == -32768)
 		x = fastGlyph->bkLeft;
diff -urN libfreerdp/CMakeLists.txt ../../informatimago/FreeRDP/libfreerdp/CMakeLists.txt
--- libfreerdp/CMakeLists.txt	2019-07-24 06:11:52.454197500 +0300
+++ ../../informatimago/FreeRDP/libfreerdp/CMakeLists.txt	2019-07-20 18:27:13.142600324 +0300
@@ -69,7 +69,7 @@
 		foreach (_lib ${ARGN})
 						list (APPEND LIBFREERDP_LIBS "${_lib}")
 		endforeach()
-		 set (LIBFREERDP_LIBS ${LIBFREERDP_LIBS} PARENT_SCOPE)
+        set (LIBFREERDP_LIBS ${LIBFREERDP_LIBS} PARENT_SCOPE)
 endmacro()
 
 macro (freerdp_definition_add)
@@ -79,28 +79,6 @@
 		 set (LIBFREERDP_DEFINITIONS ${LIBFREERDP_DEFINITIONS} PARENT_SCOPE)
 endmacro()
 
-if (WITH_SWSCALE)
-    find_package(SWScale REQUIRED)
-endif(WITH_SWSCALE)
-if (WITH_CAIRO)
-    find_package(Cairo REQUIRED)
-endif(WITH_CAIRO)
-
-if (SWScale_FOUND)
-    add_definitions(-DSWSCALE_FOUND=1)
-    include_directories(${SWScale_INCLUDE_DIR})
-    freerdp_library_add(${SWScale_LIBRARY})
-else(SWScale_FOUND)
-
-    if (CAIRO_FOUND)
-        add_definitions(-DCAIRO_FOUND=1)
-        include_directories(${CAIRO_INCLUDE_DIR})
-        freerdp_library_add(${CAIRO_LIBRARY})
-    else(CAIRO_FOUND)
-        message(WARNING "neigter swscale nor libcairo detected, compiling without image scaling support!")
-    endif(CAIRO_FOUND)
-endif(SWScale_FOUND)
-
 set(${MODULE_PREFIX}_SUBMODULES
 	utils
 	common
@@ -114,6 +92,7 @@
 	add_subdirectory(${${MODULE_PREFIX}_SUBMODULE})
 endforeach()
 
+
 ## cmake source properties are only seen by targets in the same CMakeLists.txt
 ## therefore primitives and codecs need to be defined here
 
@@ -228,9 +207,7 @@
 if(WITH_OPENH264)
 	set(CODEC_SRCS ${CODEC_SRCS} codec/h264_openh264.c)
 	freerdp_include_directory_add(${OPENH264_INCLUDE_DIR})
-	if (NOT WITH_OPENH264_LOADING)
-		freerdp_library_add(${OPENH264_LIBRARIES})
-	endif (NOT WITH_OPENH264_LOADING)
+	freerdp_library_add(${OPENH264_LIBRARIES})
 endif()
 
 if(WITH_FFMPEG)
@@ -239,6 +216,28 @@
 	freerdp_library_add(${FFMPEG_LIBRARIES})
 endif()
 
+if(WITH_PKCS11H)
+    freerdp_definition_add(-DWITH_PKCS11H)
+    freerdp_include_directory_add(${PKCS11H_INCLUDE_DIR})
+    freerdp_library_add(${PKCS11H_LIBRARIES})
+    freerdp_include_directory_add(${FREERDP_SCQUERY_INCLUDE_DIR})
+    freerdp_library_add(${FREERDP_SCQUERY_LIBRARIES})
+    add_subdirectory(scquery)
+    if(GSS_FOUND)
+        if (${GSS_FLAVOUR} STREQUAL "MIT")
+            freerdp_definition_add(-DWITH_MIT_KRB5_PKINIT)
+            freerdp_include_directory_add(${FREERDP_MIT_KRB5_PKINIT_INCLUDE_DIR})
+            freerdp_library_add(${GSS_LIBRARIES})
+            freerdp_library_add(${FREERDP_MIT_KRB5_PKINIT_LIBRARIES})
+            add_subdirectory(mit-krb5-pkinit)
+        endif()
+    endif()
+endif()
+
+if(WITH_KERBEROS)
+    freerdp_definition_add(-DWITH_KERBEROS)
+endif()
+
 if(WIN32 AND WITH_MEDIA_FOUNDATION)
 	set(CODEC_SRCS ${CODEC_SRCS} codec/h264_mf.c)
 endif()
@@ -378,7 +377,6 @@
     set_target_properties(${MODULE_NAME} PROPERTIES VERSION ${FREERDP_VERSION} SOVERSION ${FREERDP_API_VERSION})
 endif()
 
-
 target_link_libraries(${MODULE_NAME} ${PRIVATE_KEYWORD} ${LIBFREERDP_LIBS} winpr)
 
 install(TARGETS ${MODULE_NAME} DESTINATION ${CMAKE_INSTALL_LIBDIR} COMPONENT libraries EXPORT FreeRDPTargets)
diff -urN libfreerdp/codec/bitmap.c ../../informatimago/FreeRDP/libfreerdp/codec/bitmap.c
--- libfreerdp/codec/bitmap.c	2019-07-25 19:51:01.301899604 +0300
+++ ../../informatimago/FreeRDP/libfreerdp/codec/bitmap.c	2019-07-25 20:11:25.279969354 +0300
@@ -26,15 +26,12 @@
 
 static INLINE UINT16 GETPIXEL16(const void* d, UINT32 x, UINT32 y, UINT32 w)
 {
-	const BYTE* src = (const BYTE*)d + ((y * w + x) * sizeof(UINT16));
-	return (UINT16)(((UINT16)src[1] << 8) | (UINT16)src[0]);
+	return (*(((const unsigned short*)d) + ((y) * (w) + (x))));
 }
 
 static INLINE UINT32 GETPIXEL32(const void* d, UINT32 x, UINT32 y, UINT32 w)
 {
-	const BYTE* src = (const BYTE*)d + ((y * w + x) * sizeof(UINT32));
-	return (((UINT32)src[3]) << 24) | (((UINT32)src[2]) << 16) | (((UINT32)src[1]) << 8) |
-	       (src[0] & 0xFF);
+	return (*(((const unsigned int*)d) + ((y) * (w) + (x))));
 }
 
 /*****************************************************************************/
diff -urN libfreerdp/codec/clear.c ../../informatimago/FreeRDP/libfreerdp/codec/clear.c
--- libfreerdp/codec/clear.c	2019-07-25 19:51:01.321899703 +0300
+++ ../../informatimago/FreeRDP/libfreerdp/codec/clear.c	2019-07-25 20:11:25.299969453 +0300
@@ -149,7 +149,7 @@
 	Stream_Read_UINT8(s, paletteCount);
 	bitmapDataOffset = 1 + (paletteCount * 3);
 
-	if ((paletteCount > 127) || (paletteCount < 1))
+	if (paletteCount > 127)
 	{
 		WLog_ERR(TAG, "paletteCount %" PRIu8 "", paletteCount);
 		return FALSE;
diff -urN libfreerdp/codec/color.c ../../informatimago/FreeRDP/libfreerdp/codec/color.c
--- libfreerdp/codec/color.c	2019-07-25 19:51:01.345899821 +0300
+++ ../../informatimago/FreeRDP/libfreerdp/codec/color.c	2019-07-25 20:11:25.311969512 +0300
@@ -33,14 +33,6 @@
 #include <freerdp/freerdp.h>
 #include <freerdp/primitives.h>
 
-#if defined(CAIRO_FOUND)
-#	include <cairo.h>
-#endif
-
-#if defined(SWSCALE_FOUND)
-#	include <libswscale/swscale.h>
-#endif
-
 #define TAG FREERDP_TAG("color")
 
 BYTE* freerdp_glyph_convert(UINT32 width, UINT32 height, const BYTE* data)
@@ -153,146 +145,6 @@
 	return FreeRDPGetColor(format, fill, fill, fill, 0xFF);
 }
 
-/*
- * DIB color palettes are arrays of RGBQUAD structs with colors in BGRX format.
- * They are used only by 1, 2, 4, and 8-bit bitmaps.
- */
-static void fill_gdi_palette_for_icon(const BYTE* colorTable, UINT16 cbColorTable,
-                                      gdiPalette* palette)
-{
-	UINT16 i;
-	palette->format = PIXEL_FORMAT_BGRX32;
-	ZeroMemory(palette->palette, sizeof(palette->palette));
-
-	if (!cbColorTable)
-		return;
-
-	if ((cbColorTable % 4 != 0) || (cbColorTable / 4 > 256))
-	{
-		WLog_WARN(TAG, "weird palette size: %u", cbColorTable);
-		return;
-	}
-
-	for (i = 0; i < cbColorTable / 4; i++)
-	{
-		palette->palette[i] = ReadColor(&colorTable[4 * i], palette->format);
-	}
-}
-
-static INLINE UINT32 div_ceil(UINT32 a, UINT32 b)
-{
-	return (a + (b - 1)) / b;
-}
-
-static INLINE UINT32 round_up(UINT32 a, UINT32 b)
-{
-	return b * div_ceil(a, b);
-}
-
-BOOL freerdp_image_copy_from_icon_data(BYTE* pDstData, UINT32 DstFormat, UINT32 nDstStep,
-                                       UINT32 nXDst, UINT32 nYDst, UINT16 nWidth, UINT16 nHeight,
-                                       const BYTE* bitsColor, UINT16 cbBitsColor,
-                                       const BYTE* bitsMask, UINT16 cbBitsMask,
-                                       const BYTE* colorTable, UINT16 cbColorTable, UINT32 bpp)
-{
-	DWORD format;
-	gdiPalette palette;
-
-	if (!pDstData || !bitsColor)
-		return FALSE;
-
-	/*
-	 * Color formats used by icons are DIB bitmap formats (2-bit format
-	 * is not used by MS-RDPERP). Note that 16-bit is RGB555, not RGB565,
-	 * and that 32-bit format uses BGRA order.
-	 */
-	switch (bpp)
-	{
-	case 1:
-	case 4:
-		/*
-		 * These formats are not supported by freerdp_image_copy().
-		 * PIXEL_FORMAT_MONO and PIXEL_FORMAT_A4 are *not* correct
-		 * color formats for this. Please fix freerdp_image_copy()
-		 * if you came here to fix a broken icon of some weird app
-		 * that still uses 1 or 4bpp format in the 21st century.
-		 */
-		WLog_WARN(TAG, "1bpp and 4bpp icons are not supported");
-		return FALSE;
-
-	case 8:
-		format = PIXEL_FORMAT_RGB8;
-		break;
-
-	case 16:
-		format = PIXEL_FORMAT_RGB15;
-		break;
-
-	case 24:
-		format = PIXEL_FORMAT_RGB24;
-		break;
-
-	case 32:
-		format = PIXEL_FORMAT_BGRA32;
-		break;
-
-	default:
-		WLog_WARN(TAG, "invalid icon bpp: %d", bpp);
-		return FALSE;
-	}
-
-	fill_gdi_palette_for_icon(colorTable, cbColorTable, &palette);
-
-	if (!freerdp_image_copy(pDstData, DstFormat, nDstStep, nXDst, nYDst, nWidth, nHeight, bitsColor,
-	                        format, 0, 0, 0, &palette, FREERDP_FLIP_VERTICAL))
-		return FALSE;
-
-	/* apply alpha mask */
-	if (ColorHasAlpha(DstFormat) && cbBitsMask)
-	{
-		BYTE nextBit;
-		const BYTE* maskByte;
-		UINT32 x, y;
-		UINT32 stride;
-		BYTE r, g, b;
-		BYTE* dstBuf = pDstData;
-		UINT32 dstBpp = GetBytesPerPixel(DstFormat);
-		/*
-		 * Each byte encodes 8 adjacent pixels (with LSB padding as needed).
-		 * And due to hysterical raisins, stride of DIB bitmaps must be
-		 * a multiple of 4 bytes.
-		 */
-		stride = round_up(div_ceil(nWidth, 8), 4);
-
-		for (y = 0; y < nHeight; y++)
-		{
-			maskByte = &bitsMask[stride * (nHeight - 1 - y)];
-			nextBit = 0x80;
-
-			for (x = 0; x < nWidth; x++)
-			{
-				UINT32 color;
-				BYTE alpha = (*maskByte & nextBit) ? 0x00 : 0xFF;
-				/* read color back, add alpha and write it back */
-				color = ReadColor(dstBuf, DstFormat);
-				SplitColor(color, DstFormat, &r, &g, &b, NULL, &palette);
-				color = FreeRDPGetColor(DstFormat, r, g, b, alpha);
-				WriteColor(dstBuf, DstFormat, color);
-				nextBit >>= 1;
-				dstBuf += dstBpp;
-
-				if (!nextBit)
-				{
-					nextBit = 0x80;
-					maskByte++;
-				}
-			}
-		}
-	}
-
-	return TRUE;
-}
-
 /**
  * Drawing Monochrome Pointers:
  * http://msdn.microsoft.com/en-us/library/windows/hardware/ff556143/
@@ -552,9 +404,6 @@
 	UINT32 dstVOffset = 0;
 	INT32 dstVMultiplier = 1;
 
-	if ((nHeight > INT32_MAX) || (nWidth > INT32_MAX))
-		return FALSE;
-
 	if (!pDstData || !pSrcData)
 		return FALSE;
 
@@ -580,7 +429,7 @@
 			/* Copy down */
 			if (nYDst < nYSrc)
 			{
-				for (y = 0; y < (INT32)nHeight; y++)
+				for (y = 0; y < nHeight; y++)
 				{
 					const BYTE* srcLine =
 					    &pSrcData[(y + nYSrc) * nSrcStep * srcVMultiplier + srcVOffset];
@@ -602,7 +451,7 @@
 			/* Copy left */
 			else if (nXSrc > nXDst)
 			{
-				for (y = 0; y < (INT32)nHeight; y++)
+				for (y = 0; y < nHeight; y++)
 				{
 					const BYTE* srcLine =
 					    &pSrcData[(y + nYSrc) * nSrcStep * srcVMultiplier + srcVOffset];
@@ -613,7 +462,7 @@
 			/* Copy right */
 			else if (nXSrc < nXDst)
 			{
-				for (y = (INT32)nHeight - 1; y >= 0; y--)
+				for (y = nHeight - 1; y >= 0; y--)
 				{
 					const BYTE* srcLine =
 					    &pSrcData[(y + nYSrc) * nSrcStep * srcVMultiplier + srcVOffset];
@@ -628,7 +477,7 @@
 		}
 		else
 		{
-			for (y = 0; y < (INT32)nHeight; y++)
+			for (y = 0; y < nHeight; y++)
 			{
 				const BYTE* srcLine =
 				    &pSrcData[(y + nYSrc) * nSrcStep * srcVMultiplier + srcVOffset];
@@ -681,112 +530,3 @@
 
 	return TRUE;
 }
-
-#if defined(SWSCALE_FOUND)
-static int av_format_for_buffer(UINT32 format)
-{
-	switch (format)
-	{
-	case PIXEL_FORMAT_ARGB32:
-		return AV_PIX_FMT_BGRA;
-
-	case PIXEL_FORMAT_XRGB32:
-		return AV_PIX_FMT_BGR0;
-
-	case PIXEL_FORMAT_BGRA32:
-		return AV_PIX_FMT_RGBA;
-
-	case PIXEL_FORMAT_BGRX32:
-		return AV_PIX_FMT_RGB0;
-
-	default:
-		return AV_PIX_FMT_NONE;
-	}
-}
-#endif
-
-BOOL freerdp_image_scale(BYTE* pDstData, DWORD DstFormat, UINT32 nDstStep, UINT32 nXDst,
-                         UINT32 nYDst, UINT32 nDstWidth, UINT32 nDstHeight, const BYTE* pSrcData,
-                         DWORD SrcFormat, UINT32 nSrcStep, UINT32 nXSrc, UINT32 nYSrc,
-                         UINT32 nSrcWidth, UINT32 nSrcHeight)
-{
-	BOOL rc = FALSE;
-	const BYTE* src = &pSrcData[nXSrc * GetBytesPerPixel(SrcFormat) + nYSrc * nSrcStep];
-	BYTE* dst = &pDstData[nXDst * GetBytesPerPixel(DstFormat) + nYDst * nDstStep];
-
-	/* direct copy is much faster than scaling, so check if we can simply copy... */
-	if ((nDstWidth == nSrcWidth) && (nDstHeight == nSrcHeight))
-	{
-		return freerdp_image_copy(pDstData, DstFormat, nDstStep, nXDst, nYDst, nDstWidth,
-		                          nDstHeight, pSrcData, SrcFormat, nSrcStep, nXSrc, nYSrc, NULL,
-		                          FREERDP_FLIP_NONE);
-	}
-	else
-#if defined(SWSCALE_FOUND)
-	{
-		int res;
-		struct SwsContext* resize;
-		int srcFormat = av_format_for_buffer(SrcFormat);
-		int dstFormat = av_format_for_buffer(DstFormat);
-		const int srcStep[1] = { (int)nSrcStep };
-		const int dstStep[1] = { (int)nDstStep };
-
-		if ((srcFormat == AV_PIX_FMT_NONE) || (dstFormat == AV_PIX_FMT_NONE))
-			return FALSE;
-
-		resize = sws_getContext((int)nSrcWidth, (int)nSrcHeight, srcFormat, (int)nDstWidth,
-		                        (int)nDstHeight, dstFormat, SWS_BILINEAR, NULL, NULL, NULL);
-
-		if (!resize)
-			goto fail;
-
-		res = sws_scale(resize, &src, srcStep, 0, (int)nSrcHeight, &dst, dstStep);
-		rc = (res == ((int)nDstHeight));
-	fail:
-		sws_freeContext(resize);
-	}
-
-#elif defined(CAIRO_FOUND)
-	{
-		const double sx = (double)nDstWidth / (double)nSrcWidth;
-		const double sy = (double)nDstHeight / (double)nSrcHeight;
-		cairo_t* cairo_context;
-		cairo_surface_t *csrc, *cdst;
-
-		if ((nSrcWidth > INT_MAX) || (nSrcHeight > INT_MAX) || (nSrcStep > INT_MAX))
-			return FALSE;
-
-		if ((nDstWidth > INT_MAX) || (nDstHeight > INT_MAX) || (nDstStep > INT_MAX))
-			return FALSE;
-
-		csrc = cairo_image_surface_create_for_data((void*)src, CAIRO_FORMAT_ARGB32, (int)nSrcWidth,
-		                                           (int)nSrcHeight, (int)nSrcStep);
-		cdst = cairo_image_surface_create_for_data(dst, CAIRO_FORMAT_ARGB32, (int)nDstWidth,
-		                                           (int)nDstHeight, (int)nDstStep);
-
-		if (!csrc || !cdst)
-			goto fail;
-
-		cairo_context = cairo_create(cdst);
-
-		if (!cairo_context)
-			goto fail2;
-
-		cairo_scale(cairo_context, sx, sy);
-		cairo_set_operator(cairo_context, CAIRO_OPERATOR_SOURCE);
-		cairo_set_source_surface(cairo_context, csrc, 0, 0);
-		cairo_paint(cairo_context);
-		rc = TRUE;
-	fail2:
-		cairo_destroy(cairo_context);
-	fail:
-		cairo_surface_destroy(csrc);
-		cairo_surface_destroy(cdst);
-	}
-#else
-	{
-		WLog_WARN(TAG, "SmartScaling requested but compiled without libcairo support!");
-	}
-#endif
-	return rc;
-}
diff -urN libfreerdp/codec/dsp.c ../../informatimago/FreeRDP/libfreerdp/codec/dsp.c
--- libfreerdp/codec/dsp.c	2019-07-25 19:51:01.393900059 +0300
+++ ../../informatimago/FreeRDP/libfreerdp/codec/dsp.c	2019-07-25 20:11:25.363969770 +0300
@@ -110,17 +110,6 @@
 #	endif
 };
 
-static INT16 read_int16(const BYTE* src)
-{
-	return (INT16)(src[0] | (src[1] << 8));
-}
-
-static void write_int16(BYTE* dst, INT32 val)
-{
-	dst[1] = (val >> 8) & 0xFF;
-	dst[0] = val & 0xFF;
-}
-
 static BOOL freerdp_dsp_channel_mix(FREERDP_DSP_CONTEXT* context, const BYTE* src, size_t size,
                                     const AUDIO_FORMAT* srcFormat, const BYTE** data,
                                     size_t* length)
@@ -215,11 +204,11 @@
 #	if defined(WITH_SOXR)
 	soxr_error_t error;
 	size_t idone, odone;
+#	endif
 	size_t sframes, rframes;
 	size_t rsize;
 	size_t j;
 	size_t sbytes, rbytes;
-#	endif
 	size_t srcBytesPerFrame, dstBytesPerFrame;
 	size_t srcChannels, dstChannels;
 	AUDIO_FORMAT format;
@@ -262,10 +251,6 @@
 	*length = Stream_Length(context->resample);
 	return (error == 0) ? TRUE : FALSE;
 #	else
-	WINPR_UNUSED(src);
-	WINPR_UNUSED(size);
-	WINPR_UNUSED(data);
-	WINPR_UNUSED(length);
 	WLog_ERR(TAG, "Missing resample support, recompile -DWITH_SOXR=ON or -DWITH_DSP_FFMPEG=ON");
 	return FALSE;
 #	endif
@@ -335,11 +320,11 @@
 	BYTE* dst;
 	BYTE sample;
 	UINT16 decoded;
-	size_t out_size = size * 4;
+	UINT32 out_size = size * 4;
 	UINT32 channel;
 	const UINT32 block_size = context->format.nBlockAlign;
 	const UINT32 channels = context->format.nChannels;
-	size_t i;
+	int i;
 
 	if (!Stream_EnsureCapacity(out, out_size))
 		return FALSE;
@@ -416,8 +401,7 @@
 	{
 		int rc;
 		gsm_signal gsmBlockBuffer[160] = { 0 };
-		rc = gsm_decode(context->gsm, (gsm_byte*)/* API does not modify */ &src[offset],
-		                gsmBlockBuffer);
+		rc = gsm_decode(context->gsm, (gsm_byte*)&src[offset], gsmBlockBuffer);
 
 		if (rc < 0)
 			return FALSE;
@@ -443,13 +427,12 @@
 
 	while (offset < size)
 	{
-		const gsm_signal* signal = (const gsm_signal*)&src[offset];
+		gsm_signal* signal = (gsm_signal*)&src[offset];
 
 		if (!Stream_EnsureRemainingCapacity(out, sizeof(gsm_frame)))
 			return FALSE;
 
-		gsm_encode(context->gsm, (gsm_signal*)/* API does not modify */ signal,
-		           Stream_Pointer(out));
+		gsm_encode(context->gsm, signal, Stream_Pointer(out));
 
 		if ((offset % 65) == 0)
 			Stream_Seek(out, 33);
@@ -488,13 +471,13 @@
 	if (rc <= 0)
 		return FALSE;
 
-	if (!Stream_EnsureRemainingCapacity(out, (size_t)rc * context->format.nChannels * 2))
+	if (!Stream_EnsureRemainingCapacity(out, rc * context->format.nChannels * 2))
 		return FALSE;
 
 	for (x = 0; x < rc; x++)
 	{
-		Stream_Write_UINT16(out, (UINT16)pcm_l[x]);
-		Stream_Write_UINT16(out, (UINT16)pcm_r[x]);
+		Stream_Write_UINT16(out, pcm_l[x]);
+		Stream_Write_UINT16(out, pcm_r[x]);
 	}
 
 	return TRUE;
@@ -512,7 +495,7 @@
 	samples_per_channel = size / context->format.nChannels / context->format.wBitsPerSample / 8;
 
 	/* Ensure worst case buffer size for mp3 stream taken from LAME header */
-	if (!Stream_EnsureRemainingCapacity(out, 5 / 4 * samples_per_channel + 7200))
+	if (!Stream_EnsureRemainingCapacity(out, 1.25 * samples_per_channel + 7200))
 		return FALSE;
 
 	samples_per_channel = size / 2 /* size of a sample */ / context->format.nChannels;
@@ -522,7 +505,7 @@
 	if (rc < 0)
 		return FALSE;
 
-	Stream_Seek(out, (size_t)rc);
+	Stream_Seek(out, rc);
 	return TRUE;
 }
 #	endif
@@ -531,10 +514,10 @@
 static BOOL freerdp_dsp_encode_faac(FREERDP_DSP_CONTEXT* context, const BYTE* src, size_t size,
                                     wStream* out)
 {
-	const int16_t* inSamples = (const int16_t*)src;
+	int16_t* inSamples = (int16_t*)src;
 	int32_t* outSamples;
 	unsigned int bpp;
-	size_t nrSamples, x;
+	unsigned int nrSamples, x;
 	int rc;
 
 	if (!context || !src || !out)
@@ -561,7 +544,7 @@
 	if (rc < 0)
 		return FALSE;
 	else if (rc > 0)
-		Stream_Seek(out, (size_t)rc);
+		Stream_Seek(out, rc);
 
 	return TRUE;
 }
@@ -582,7 +565,7 @@
 	{
 		unsigned long samplerate;
 		unsigned char channels;
-		long err =
+		char err =
 		    NeAACDecInit(context->faad, /* API is not modifying content */ (unsigned char*)src,
 		                 size, &samplerate, &channels);
 
@@ -714,7 +697,7 @@
 	BYTE* start;
 	INT16 sample;
 	BYTE encoded;
-	size_t out_size;
+	UINT32 out_size;
 	size_t align;
 	out_size = size / 2;
 
@@ -792,7 +775,7 @@
 {
 	INT8 nibble;
 	INT32 presample;
-	nibble = (sample & 0x08 ? (INT8)sample - 16 : (INT8)sample);
+	nibble = (sample & 0x08 ? (INT8)sample - 16 : sample);
 	presample = ((adpcm->ms.sample1[channel] * ms_adpcm_coeffs1[adpcm->ms.predictor[channel]]) +
 	             (adpcm->ms.sample2[channel] * ms_adpcm_coeffs2[adpcm->ms.predictor[channel]])) /
 	            256;
@@ -818,7 +801,7 @@
 {
 	BYTE* dst;
 	BYTE sample;
-	const size_t out_size = size * 4;
+	const UINT32 out_size = size * 4;
 	const UINT32 channels = context->format.nChannels;
 	const UINT32 block_size = context->format.nBlockAlign;
 
@@ -835,41 +818,41 @@
 			{
 				context->adpcm.ms.predictor[0] = *src++;
 				context->adpcm.ms.predictor[1] = *src++;
-				context->adpcm.ms.delta[0] = read_int16(src);
+				context->adpcm.ms.delta[0] = *((INT16*)src);
 				src += 2;
-				context->adpcm.ms.delta[1] = read_int16(src);
+				context->adpcm.ms.delta[1] = *((INT16*)src);
 				src += 2;
-				context->adpcm.ms.sample1[0] = read_int16(src);
+				context->adpcm.ms.sample1[0] = *((INT16*)src);
 				src += 2;
-				context->adpcm.ms.sample1[1] = read_int16(src);
+				context->adpcm.ms.sample1[1] = *((INT16*)src);
 				src += 2;
-				context->adpcm.ms.sample2[0] = read_int16(src);
+				context->adpcm.ms.sample2[0] = *((INT16*)src);
 				src += 2;
-				context->adpcm.ms.sample2[1] = read_int16(src);
+				context->adpcm.ms.sample2[1] = *((INT16*)src);
 				src += 2;
 				size -= 14;
-				write_int16(dst, context->adpcm.ms.sample2[0]);
+				*((INT16*)dst) = context->adpcm.ms.sample2[0];
 				dst += 2;
-				write_int16(dst, context->adpcm.ms.sample2[1]);
+				*((INT16*)dst) = context->adpcm.ms.sample2[1];
 				dst += 2;
-				write_int16(dst, context->adpcm.ms.sample1[0]);
+				*((INT16*)dst) = context->adpcm.ms.sample1[0];
 				dst += 2;
-				write_int16(dst, context->adpcm.ms.sample1[1]);
+				*((INT16*)dst) = context->adpcm.ms.sample1[1];
 				dst += 2;
 			}
 			else
 			{
 				context->adpcm.ms.predictor[0] = *src++;
-				context->adpcm.ms.delta[0] = read_int16(src);
+				context->adpcm.ms.delta[0] = *((INT16*)src);
 				src += 2;
-				context->adpcm.ms.sample1[0] = read_int16(src);
+				context->adpcm.ms.sample1[0] = *((INT16*)src);
 				src += 2;
-				context->adpcm.ms.sample2[0] = read_int16(src);
+				context->adpcm.ms.sample2[0] = *((INT16*)src);
 				src += 2;
 				size -= 7;
-				write_int16(dst, context->adpcm.ms.sample2[0]);
+				*((INT16*)dst) = context->adpcm.ms.sample2[0];
 				dst += 2;
-				write_int16(dst, context->adpcm.ms.sample1[0]);
+				*((INT16*)dst) = context->adpcm.ms.sample1[0];
 				dst += 2;
 			}
 		}
@@ -878,24 +861,24 @@
 		{
 			sample = *src++;
 			size--;
-			write_int16(dst, freerdp_dsp_decode_ms_adpcm_sample(&context->adpcm, sample >> 4, 0));
+			*((INT16*)dst) = freerdp_dsp_decode_ms_adpcm_sample(&context->adpcm, sample >> 4, 0);
 			dst += 2;
-			write_int16(dst, freerdp_dsp_decode_ms_adpcm_sample(&context->adpcm, sample & 0x0F, 1));
+			*((INT16*)dst) = freerdp_dsp_decode_ms_adpcm_sample(&context->adpcm, sample & 0x0F, 1);
 			dst += 2;
 			sample = *src++;
 			size--;
-			write_int16(dst, freerdp_dsp_decode_ms_adpcm_sample(&context->adpcm, sample >> 4, 0));
+			*((INT16*)dst) = freerdp_dsp_decode_ms_adpcm_sample(&context->adpcm, sample >> 4, 0);
 			dst += 2;
-			write_int16(dst, freerdp_dsp_decode_ms_adpcm_sample(&context->adpcm, sample & 0x0F, 1));
+			*((INT16*)dst) = freerdp_dsp_decode_ms_adpcm_sample(&context->adpcm, sample & 0x0F, 1);
 			dst += 2;
 		}
 		else
 		{
 			sample = *src++;
 			size--;
-			write_int16(dst, freerdp_dsp_decode_ms_adpcm_sample(&context->adpcm, sample >> 4, 0));
+			*((INT16*)dst) = freerdp_dsp_decode_ms_adpcm_sample(&context->adpcm, sample >> 4, 0);
 			dst += 2;
-			write_int16(dst, freerdp_dsp_decode_ms_adpcm_sample(&context->adpcm, sample & 0x0F, 0));
+			*((INT16*)dst) = freerdp_dsp_decode_ms_adpcm_sample(&context->adpcm, sample & 0x0F, 0);
 			dst += 2;
 		}
 	}
@@ -945,7 +928,7 @@
 	BYTE* dst;
 	BYTE* start;
 	INT32 sample;
-	size_t out_size;
+	UINT32 out_size;
 	const size_t step = 8 + ((context->format.nChannels > 1) ? 4 : 0);
 	out_size = size / 2;
 
@@ -972,14 +955,14 @@
 				*dst++ = (BYTE)((context->adpcm.ms.delta[0] >> 8) & 0xFF);
 				*dst++ = (BYTE)(context->adpcm.ms.delta[1] & 0xFF);
 				*dst++ = (BYTE)((context->adpcm.ms.delta[1] >> 8) & 0xFF);
-				context->adpcm.ms.sample1[0] = read_int16(src + 4);
-				context->adpcm.ms.sample1[1] = read_int16(src + 6);
-				context->adpcm.ms.sample2[0] = read_int16(src + 0);
-				context->adpcm.ms.sample2[1] = read_int16(src + 2);
-				write_int16(dst + 0, context->adpcm.ms.sample1[0]);
-				write_int16(dst + 2, context->adpcm.ms.sample1[1]);
-				write_int16(dst + 4, context->adpcm.ms.sample2[0]);
-				write_int16(dst + 6, context->adpcm.ms.sample2[1]);
+				context->adpcm.ms.sample1[0] = *((INT16*)(src + 4));
+				context->adpcm.ms.sample1[1] = *((INT16*)(src + 6));
+				context->adpcm.ms.sample2[0] = *((INT16*)(src + 0));
+				context->adpcm.ms.sample2[1] = *((INT16*)(src + 2));
+				*((INT16*)(dst + 0)) = (INT16)context->adpcm.ms.sample1[0];
+				*((INT16*)(dst + 2)) = (INT16)context->adpcm.ms.sample1[1];
+				*((INT16*)(dst + 4)) = (INT16)context->adpcm.ms.sample2[0];
+				*((INT16*)(dst + 6)) = (INT16)context->adpcm.ms.sample2[1];
 				dst += 8;
 				src += 8;
 				size -= 8;
@@ -989,20 +972,20 @@
 				*dst++ = context->adpcm.ms.predictor[0];
 				*dst++ = (BYTE)(context->adpcm.ms.delta[0] & 0xFF);
 				*dst++ = (BYTE)((context->adpcm.ms.delta[0] >> 8) & 0xFF);
-				context->adpcm.ms.sample1[0] = read_int16(src + 2);
-				context->adpcm.ms.sample2[0] = read_int16(src + 0);
-				write_int16(dst + 0, context->adpcm.ms.sample1[0]);
-				write_int16(dst + 2, context->adpcm.ms.sample2[0]);
+				context->adpcm.ms.sample1[0] = *((INT16*)(src + 2));
+				context->adpcm.ms.sample2[0] = *((INT16*)(src + 0));
+				*((INT16*)(dst + 0)) = (INT16)context->adpcm.ms.sample1[0];
+				*((INT16*)(dst + 2)) = (INT16)context->adpcm.ms.sample2[0];
 				dst += 4;
 				src += 4;
 				size -= 4;
 			}
 		}
 
-		sample = read_int16(src);
+		sample = *((INT16*)src);
 		src += 2;
-		*dst = (freerdp_dsp_encode_ms_adpcm_sample(&context->adpcm, sample, 0) << 4) & 0xFF;
-		sample = read_int16(src);
+		*dst = freerdp_dsp_encode_ms_adpcm_sample(&context->adpcm, sample, 0) << 4;
+		sample = *((INT16*)src);
 		src += 2;
 		*dst += freerdp_dsp_encode_ms_adpcm_sample(&context->adpcm, sample,
 		                                           context->format.nChannels > 1 ? 1 : 0);
@@ -1244,9 +1227,6 @@
 #if defined(WITH_DSP_FFMPEG)
 	return freerdp_dsp_ffmpeg_supports_format(format, encode);
 #else
-#	if !defined(WITH_DSP_EXPERIMENTAL)
-	WINPR_UNUSED(encode);
-#	endif
 
 	switch (format->wFormatTag)
 	{
diff -urN libfreerdp/codec/dsp_ffmpeg.c ../../informatimago/FreeRDP/libfreerdp/codec/dsp_ffmpeg.c
--- libfreerdp/codec/dsp_ffmpeg.c	2019-07-25 19:51:01.409900138 +0300
+++ ../../informatimago/FreeRDP/libfreerdp/codec/dsp_ffmpeg.c	2019-07-25 20:11:25.379969849 +0300
@@ -628,21 +628,18 @@
 		{
 			int inSamples = rest;
 
-			if ((inSamples < 0) || (context->bufferedSamples > (UINT32)(INT_MAX - inSamples)))
-				return FALSE;
-
-			if (inSamples + (int)context->bufferedSamples > context->context->frame_size)
-				inSamples = context->context->frame_size - (int)context->bufferedSamples;
+			if (inSamples + context->bufferedSamples > context->context->frame_size)
+				inSamples = context->context->frame_size - context->bufferedSamples;
 
 			rc =
 			    av_samples_copy(context->buffered->extended_data, context->resampled->extended_data,
-			                    (int)context->bufferedSamples, copied, inSamples,
+			                    context->bufferedSamples, copied, inSamples,
 			                    context->context->channels, context->context->sample_fmt);
 			rest -= inSamples;
 			copied += inSamples;
-			context->bufferedSamples += (UINT32)inSamples;
+			context->bufferedSamples += inSamples;
 
-			if (context->context->frame_size <= (int)context->bufferedSamples)
+			if (context->context->frame_size <= context->bufferedSamples)
 			{
 				/* Encode in desired format. */
 				if (!ffmpeg_encode_frame(context->context, context->buffered, context->packet, out))
diff -urN libfreerdp/codec/h264.c ../../informatimago/FreeRDP/libfreerdp/codec/h264.c
--- libfreerdp/codec/h264.c	2019-07-25 19:51:01.421900198 +0300
+++ ../../informatimago/FreeRDP/libfreerdp/codec/h264.c	2019-07-25 20:11:25.391969909 +0300
@@ -291,11 +291,7 @@
 	UINT32* piDstSize = h264->iYUV444Size;
 	UINT32* piDstStride = h264->iYUV444Stride;
 	BYTE** ppYUVDstData = h264->pYUV444Data;
-	const UINT32 pad = nDstHeight % 16;
-	UINT32 padDstHeight = nDstHeight; /* Need alignment to 16x16 blocks */
-
-	if (pad != 0)
-		padDstHeight += 16 - pad;
+	UINT32 padDstHeight = nDstHeight + 16; /* Need alignment to 16x16 blocks */
 
 	if ((piMainStride[0] != piDstStride[0]) || (piDstSize[0] != piMainStride[0] * padDstHeight))
 	{
diff -urN libfreerdp/codec/h264_ffmpeg.c ../../informatimago/FreeRDP/libfreerdp/codec/h264_ffmpeg.c
--- libfreerdp/codec/h264_ffmpeg.c	2019-07-25 19:51:01.445900318 +0300
+++ ../../informatimago/FreeRDP/libfreerdp/codec/h264_ffmpeg.c	2019-07-25 20:11:25.411970008 +0300
@@ -120,16 +120,13 @@
 	if (!h264 || !h264->subsystem)
 		return FALSE;
 
-	if ((h264->width > INT_MAX) || (h264->height > INT_MAX))
-		return FALSE;
-
 	sys = (H264_CONTEXT_LIBAVCODEC*)h264->pSystemData;
 	recreate = !sys->codecEncoder || !sys->codecEncoderContext;
 
 	if (sys->codecEncoderContext)
 	{
-		if ((sys->codecEncoderContext->width != (int)h264->width) ||
-		    (sys->codecEncoderContext->height != (int)h264->height))
+		if ((sys->codecEncoderContext->width != h264->width) ||
+		    (sys->codecEncoderContext->height != h264->height))
 			recreate = TRUE;
 	}
 
diff -urN libfreerdp/codec/h264_openh264.c ../../informatimago/FreeRDP/libfreerdp/codec/h264_openh264.c
--- libfreerdp/codec/h264_openh264.c	2019-07-25 19:51:01.481900496 +0300
+++ ../../informatimago/FreeRDP/libfreerdp/codec/h264_openh264.c	2019-07-25 20:11:25.435970127 +0300
@@ -18,55 +18,27 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-#ifdef HAVE_CONFIG_H
-#	include "config.h"
-#endif
-
 #include <freerdp/log.h>
 #include <freerdp/codec/h264.h>
-#include <winpr/library.h>
 
 #include "wels/codec_def.h"
 #include "wels/codec_api.h"
 #include "wels/codec_ver.h"
 
-typedef void (*pWelsGetCodecVersionEx)(OpenH264Version* pVersion);
-
-typedef long (*pWelsCreateDecoder)(ISVCDecoder** ppDecoder);
-typedef void (*pWelsDestroyDecoder)(ISVCDecoder* pDecoder);
-
-typedef int (*pWelsCreateSVCEncoder)(ISVCEncoder** ppEncoder);
-typedef void (*pWelsDestroySVCEncoder)(ISVCEncoder* pEncoder);
+#if (OPENH264_MAJOR == 1) && (OPENH264_MINOR < 3) || (OPENH264_MAJOR < 1)
+#	error "Unsupported OpenH264 version "OPENH264_MAJOR"."OPENH264_MINOR"."OPENH264_REVISION" detected!"
+#elif (OPENH264_MAJOR > 1) || (OPENH264_MINOR > 7)
+#	warning "Untested OpenH264 version "OPENH264_MAJOR"."OPENH264_MINOR"."OPENH264_REVISION" detected!"
+#endif
 
 struct _H264_CONTEXT_OPENH264
 {
-#if defined(WITH_OPENH264_LOADING)
-	HMODULE lib;
-	OpenH264Version version;
-#endif
-	pWelsGetCodecVersionEx WelsGetCodecVersionEx;
-	pWelsCreateDecoder WelsCreateDecoder;
-	pWelsDestroyDecoder WelsDestroyDecoder;
-	pWelsCreateSVCEncoder WelsCreateSVCEncoder;
-	pWelsDestroySVCEncoder WelsDestroySVCEncoder;
 	ISVCDecoder* pDecoder;
 	ISVCEncoder* pEncoder;
 	SEncParamExt EncParamExt;
 };
 typedef struct _H264_CONTEXT_OPENH264 H264_CONTEXT_OPENH264;
 
-#if defined(WITH_OPENH264_LOADING)
-static const char* openh264_library_names[] = {
-#	if defined(_WIN32)
-	"openh264.dll"
-#	elif defined(__APPLE__)
-	"libopenh264.dylib"
-#	else
-	"libopenh264.so"
-#	endif
-};
-#endif
-
 static void openh264_trace_callback(H264_CONTEXT* h264, int level, const char* message)
 {
 	if (h264)
@@ -167,15 +139,8 @@
 	if (!pYUVData[0] || !pYUVData[1] || !pYUVData[2])
 		return -1;
 
-	if ((h264->width > INT_MAX) || (h264->height > INT_MAX))
-		return -1;
-
-	if ((h264->FrameRate > INT_MAX) || (h264->NumberOfThreads > INT_MAX) ||
-	    (h264->BitRate > INT_MAX) || (h264->QP > INT_MAX))
-		return -1;
-
-	if ((sys->EncParamExt.iPicWidth != (int)h264->width) ||
-	    (sys->EncParamExt.iPicHeight != (int)h264->height))
+	if ((sys->EncParamExt.iPicWidth != h264->width) ||
+	    (sys->EncParamExt.iPicHeight != h264->height))
 	{
 		status = (*sys->pEncoder)->GetDefaultParams(sys->pEncoder, &sys->EncParamExt);
 
@@ -187,15 +152,15 @@
 		}
 
 		sys->EncParamExt.iUsageType = SCREEN_CONTENT_REAL_TIME;
-		sys->EncParamExt.iPicWidth = (int)h264->width;
-		sys->EncParamExt.iPicHeight = (int)h264->height;
-		sys->EncParamExt.fMaxFrameRate = (int)h264->FrameRate;
+		sys->EncParamExt.iPicWidth = h264->width;
+		sys->EncParamExt.iPicHeight = h264->height;
+		sys->EncParamExt.fMaxFrameRate = h264->FrameRate;
 		sys->EncParamExt.iMaxBitrate = UNSPECIFIED_BIT_RATE;
 		sys->EncParamExt.bEnableDenoise = 0;
 		sys->EncParamExt.bEnableLongTermReference = 0;
 		sys->EncParamExt.bEnableFrameSkip = 0;
 		sys->EncParamExt.iSpatialLayerNum = 1;
-		sys->EncParamExt.iMultipleThreadIdc = (int)h264->NumberOfThreads;
+		sys->EncParamExt.iMultipleThreadIdc = h264->NumberOfThreads;
 		sys->EncParamExt.sSpatialLayers[0].fFrameRate = h264->FrameRate;
 		sys->EncParamExt.sSpatialLayers[0].iVideoWidth = sys->EncParamExt.iPicWidth;
 		sys->EncParamExt.sSpatialLayers[0].iVideoHeight = sys->EncParamExt.iPicHeight;
@@ -205,13 +170,13 @@
 		{
 		case H264_RATECONTROL_VBR:
 			sys->EncParamExt.iRCMode = RC_BITRATE_MODE;
-			sys->EncParamExt.iTargetBitrate = (int)h264->BitRate;
+			sys->EncParamExt.iTargetBitrate = h264->BitRate;
 			sys->EncParamExt.sSpatialLayers[0].iSpatialBitrate = sys->EncParamExt.iTargetBitrate;
 			break;
 
 		case H264_RATECONTROL_CQP:
 			sys->EncParamExt.iRCMode = RC_OFF_MODE;
-			sys->EncParamExt.sSpatialLayers[0].iDLayerQp = (int)h264->QP;
+			sys->EncParamExt.sSpatialLayers[0].iDLayerQp = h264->QP;
 			break;
 		}
 
@@ -249,11 +214,11 @@
 		switch (h264->RateControlMode)
 		{
 		case H264_RATECONTROL_VBR:
-			if (sys->EncParamExt.iTargetBitrate != (int)h264->BitRate)
+			if (sys->EncParamExt.iTargetBitrate != h264->BitRate)
 			{
-				sys->EncParamExt.iTargetBitrate = (int)h264->BitRate;
+				sys->EncParamExt.iTargetBitrate = h264->BitRate;
 				bitrate.iLayer = SPATIAL_LAYER_ALL;
-				bitrate.iBitrate = (int)h264->BitRate;
+				bitrate.iBitrate = h264->BitRate;
 				status =
 				    (*sys->pEncoder)->SetOption(sys->pEncoder, ENCODER_OPTION_BITRATE, &bitrate);
 
@@ -265,9 +230,9 @@
 				}
 			}
 
-			if (sys->EncParamExt.fMaxFrameRate != (int)h264->FrameRate)
+			if (sys->EncParamExt.fMaxFrameRate != h264->FrameRate)
 			{
-				sys->EncParamExt.fMaxFrameRate = (int)h264->FrameRate;
+				sys->EncParamExt.fMaxFrameRate = h264->FrameRate;
 				status = (*sys->pEncoder)
 				             ->SetOption(sys->pEncoder, ENCODER_OPTION_FRAME_RATE,
 				                         &sys->EncParamExt.fMaxFrameRate);
@@ -283,9 +248,9 @@
 			break;
 
 		case H264_RATECONTROL_CQP:
-			if (sys->EncParamExt.sSpatialLayers[0].iDLayerQp != (int)h264->QP)
+			if (sys->EncParamExt.sSpatialLayers[0].iDLayerQp != h264->QP)
 			{
-				sys->EncParamExt.sSpatialLayers[0].iDLayerQp = (int)h264->QP;
+				sys->EncParamExt.sSpatialLayers[0].iDLayerQp = h264->QP;
 				status = (*sys->pEncoder)
 				             ->SetOption(sys->pEncoder, ENCODER_OPTION_SVC_ENCODE_PARAM_EXT,
 				                         &sys->EncParamExt);
@@ -349,90 +314,25 @@
 			if (sys->pDecoder)
 			{
 				(*sys->pDecoder)->Uninitialize(sys->pDecoder);
-				sysContexts->WelsDestroyDecoder(sys->pDecoder);
+				WelsDestroyDecoder(sys->pDecoder);
 				sys->pDecoder = NULL;
 			}
 
 			if (sys->pEncoder)
 			{
 				(*sys->pEncoder)->Uninitialize(sys->pEncoder);
-				sysContexts->WelsDestroySVCEncoder(sys->pEncoder);
+				WelsDestroySVCEncoder(sys->pEncoder);
 				sys->pEncoder = NULL;
 			}
 		}
 
-#if defined(WITH_OPENH264_LOADING)
-		FreeLibrary(sysContexts->lib);
-#endif
 		free(h264->pSystemData);
 		h264->pSystemData = NULL;
 	}
 }
 
-#if defined(WITH_OPENH264_LOADING)
-static BOOL openh264_load_functionpointers(H264_CONTEXT* h264, const char* name)
-{
-	H264_CONTEXT_OPENH264* sysContexts;
-
-	if (!h264)
-		return FALSE;
-
-	sysContexts = h264->pSystemData;
-
-	if (!sysContexts)
-		return FALSE;
-
-	sysContexts->lib = LoadLibraryA(name);
-
-	if (!sysContexts->lib)
-		return FALSE;
-
-	sysContexts->WelsGetCodecVersionEx =
-	    (pWelsGetCodecVersionEx)GetProcAddress(sysContexts->lib, "WelsGetCodecVersionEx");
-	sysContexts->WelsCreateDecoder =
-	    (pWelsCreateDecoder)GetProcAddress(sysContexts->lib, "WelsCreateDecoder");
-	sysContexts->WelsDestroyDecoder =
-	    (pWelsDestroyDecoder)GetProcAddress(sysContexts->lib, "WelsDestroyDecoder");
-	sysContexts->WelsCreateSVCEncoder =
-	    (pWelsCreateSVCEncoder)GetProcAddress(sysContexts->lib, "WelsCreateSVCEncoder");
-	sysContexts->WelsDestroySVCEncoder =
-	    (pWelsDestroySVCEncoder)GetProcAddress(sysContexts->lib, "WelsDestroySVCEncoder");
-
-	if (!sysContexts->WelsCreateDecoder || !sysContexts->WelsDestroyDecoder ||
-	    !sysContexts->WelsCreateSVCEncoder || !sysContexts->WelsDestroySVCEncoder ||
-	    !sysContexts->WelsGetCodecVersionEx)
-	{
-		FreeLibrary(sysContexts->lib);
-		sysContexts->lib = NULL;
-		return FALSE;
-	}
-
-	sysContexts->WelsGetCodecVersionEx(&sysContexts->version);
-	WLog_Print(h264->log, WLOG_INFO, "loaded %s %d.%d.%d", name, sysContexts->version.uMajor,
-	           sysContexts->version.uMinor, sysContexts->version.uRevision);
-
-	if ((sysContexts->version.uMajor < 1) || (sysContexts->version.uMinor < 6))
-	{
-		WLog_Print(
-		    h264->log, WLOG_ERROR,
-		    "OpenH264 %s %d.%d.%d is too old, need at least version 1.6.0 for dynamic loading",
-		    name, sysContexts->version.uMajor, sysContexts->version.uMinor,
-		    sysContexts->version.uRevision);
-		FreeLibrary(sysContexts->lib);
-		sysContexts->lib = NULL;
-		return FALSE;
-	}
-
-	return TRUE;
-}
-#endif
-
 static BOOL openh264_init(H264_CONTEXT* h264)
 {
-#if defined(WITH_OPENH264_LOADING)
-	BOOL success = FALSE;
-	size_t i;
-#endif
 	UINT32 x;
 	long status;
 	SDecodingParam sDecParam;
@@ -450,27 +350,6 @@
 		goto EXCEPTION;
 
 	h264->pSystemData = (void*)sysContexts;
-#if defined(WITH_OPENH264_LOADING)
-
-	for (i = 0; i < ARRAYSIZE(openh264_library_names); i++)
-	{
-		const char* current = openh264_library_names[i];
-		success = openh264_load_functionpointers(h264, current);
-
-		if (success)
-			break;
-	}
-
-	if (!success)
-		goto EXCEPTION;
-
-#else
-	sysContexts->WelsGetCodecVersionEx = WelsGetCodecVersionEx;
-	sysContexts->WelsCreateDecoder = WelsCreateDecoder;
-	sysContexts->WelsDestroyDecoder = WelsDestroyDecoder;
-	sysContexts->WelsCreateSVCEncoder = WelsCreateSVCEncoder;
-	sysContexts->WelsDestroySVCEncoder = WelsDestroySVCEncoder;
-#endif
 
 	for (x = 0; x < h264->numSystemData; x++)
 	{
@@ -478,7 +357,7 @@
 
 		if (h264->Compressor)
 		{
-			sysContexts->WelsCreateSVCEncoder(&sys->pEncoder);
+			WelsCreateSVCEncoder(&sys->pEncoder);
 
 			if (!sys->pEncoder)
 			{
@@ -488,7 +367,7 @@
 		}
 		else
 		{
-			sysContexts->WelsCreateDecoder(&sys->pDecoder);
+			WelsCreateDecoder(&sys->pDecoder);
 
 			if (!sys->pDecoder)
 			{
diff -urN libfreerdp/codec/include/bitmap.c ../../informatimago/FreeRDP/libfreerdp/codec/include/bitmap.c
--- libfreerdp/codec/include/bitmap.c	2019-07-25 19:51:01.489900536 +0300
+++ ../../informatimago/FreeRDP/libfreerdp/codec/include/bitmap.c	2019-07-25 20:11:25.443970167 +0300
@@ -89,8 +89,8 @@
                                  UINT32 rowDelta, UINT32 width, UINT32 height)
 {
 	const BYTE* pbSrc = pbSrcBuffer;
-	const BYTE* pbEnd;
-	const BYTE* pbDestEnd;
+	const BYTE* pbEnd = pbSrcBuffer + cbSrcBuffer;
+	const BYTE* pbDestEnd = pbDestBuffer + rowDelta * height;
 	BYTE* pbDest = pbDestBuffer;
 	PIXEL temp;
 	PIXEL fgPel = WHITE_PIXEL;
@@ -109,9 +109,6 @@
 	if (!pbSrcBuffer || !pbDestBuffer)
 		return FALSE;
 
-	pbEnd = pbSrcBuffer + cbSrcBuffer;
-	pbDestEnd = pbDestBuffer + rowDelta * height;
-
 	while (pbSrc < pbEnd)
 	{
 		/* Watch out for the end of the first scanline. */
diff -urN libfreerdp/codec/ncrush.c ../../informatimago/FreeRDP/libfreerdp/codec/ncrush.c
--- libfreerdp/codec/ncrush.c	2019-07-25 19:51:01.621901190 +0300
+++ ../../informatimago/FreeRDP/libfreerdp/codec/ncrush.c	2019-07-25 20:11:25.575970821 +0300
@@ -2448,7 +2448,7 @@
 	UINT32 DstSize;
 	BOOL PacketAtFront;
 	BOOL PacketFlushed;
-	UINT32 MatchLength;
+	int MatchLength;
 	UINT32 IndexLEC;
 	UINT32 IndexLOM;
 	UINT32 IndexCO;
@@ -2534,14 +2534,11 @@
 
 		if (ncrush->MatchTable[HistoryOffset])
 		{
-			int rc;
 			MatchOffset = 0;
-			rc = ncrush_find_best_match(ncrush, HistoryOffset, &MatchOffset);
+			MatchLength = ncrush_find_best_match(ncrush, HistoryOffset, &MatchOffset);
 
-			if (rc < 0)
+			if (MatchLength == -1)
 				return -1005;
-
-			MatchLength = (UINT32)rc;
 		}
 
 		if (MatchLength)
@@ -2550,7 +2547,7 @@
 		if ((MatchLength == 2) && (CopyOffset >= 64))
 			MatchLength = 0;
 
-		if (MatchLength == 0)
+		if (!MatchLength)
 		{
 			/* Literal */
 			Literal = *SrcPtr++;
@@ -2781,16 +2778,15 @@
 
 static int ncrush_generate_tables(NCRUSH_CONTEXT* context)
 {
-	UINT32 k, i;
-	int j, l;
+	int i, j, k, l;
 	k = 0;
 
 	for (i = 0; i < 28; i++)
 	{
 		for (j = 0; j < 1 << LOMBitsLUT[i]; j++)
 		{
-			l = (k++) + 2;
-			context->HuffTableLOM[l] = (int)i;
+			l = k++ + 2;
+			context->HuffTableLOM[l] = i;
 		}
 	}
 
diff -urN libfreerdp/codec/nsc_encode.c ../../informatimago/FreeRDP/libfreerdp/codec/nsc_encode.c
--- libfreerdp/codec/nsc_encode.c	2019-07-25 19:51:01.641901289 +0300
+++ ../../informatimago/FreeRDP/libfreerdp/codec/nsc_encode.c	2019-07-25 20:11:25.595970920 +0300
@@ -104,6 +104,10 @@
 	INT16 b_val;
 	BYTE a_val;
 	UINT32 tempWidth;
+
+	if (!context || data || (scanline == 0))
+		return FALSE;
+
 	tempWidth = ROUND_UP_TO(context->width, 8);
 	rw = (context->ChromaSubsamplingLevel ? tempWidth : context->width);
 	ccl = context->ColorLossLevel;
@@ -441,13 +445,6 @@
 	UINT32 MaxMessageSize;
 	NSC_MESSAGE* messages;
 	UINT32 PaddedMaxPlaneSize;
-
-	if (!context || !data || !numMessages)
-		return NULL;
-
-	if (maxDataSize < 1024)
-		return NULL;
-
 	k = 0;
 	MaxRegionWidth = 64 * 4;
 	MaxRegionHeight = 64 * 2;
@@ -458,10 +455,6 @@
 	MaxPlaneSize = nsc_compute_byte_count(context, (UINT32*)ByteCount, width, height);
 	MaxMessageSize = ByteCount[0] + ByteCount[1] + ByteCount[2] + ByteCount[3] + 20;
 	maxDataSize -= 1024; /* reserve enough space for headers */
-
-	if (maxDataSize < (*numMessages) * sizeof(NSC_MESSAGE))
-		return NULL;
-
 	messages = (NSC_MESSAGE*)calloc(*numMessages, sizeof(NSC_MESSAGE));
 
 	if (!messages)
diff -urN libfreerdp/codec/nsc_sse2.c ../../informatimago/FreeRDP/libfreerdp/codec/nsc_sse2.c
--- libfreerdp/codec/nsc_sse2.c	2019-07-25 19:51:01.677901468 +0300
+++ ../../informatimago/FreeRDP/libfreerdp/codec/nsc_sse2.c	2019-07-25 20:11:25.631971099 +0300
@@ -35,7 +35,7 @@
 #include "nsc_types.h"
 #include "nsc_sse2.h"
 
-static BOOL nsc_encode_argb_to_aycocg_sse2(NSC_CONTEXT* context, const BYTE* data, UINT32 scanline)
+static void nsc_encode_argb_to_aycocg_sse2(NSC_CONTEXT* context, const BYTE* data, UINT32 scanline)
 {
 	UINT16 x;
 	UINT16 y;
@@ -54,20 +54,10 @@
 	__m128i co_val;
 	__m128i cg_val;
 	UINT32 tempWidth;
-
-	if (!context || !data || (scanline == 0))
-		return FALSE;
-
 	tempWidth = ROUND_UP_TO(context->width, 8);
 	rw = (context->ChromaSubsamplingLevel > 0 ? tempWidth : context->width);
 	ccl = context->ColorLossLevel;
 
-	if (context->priv->PlaneBuffersLength < rw * scanline)
-		return FALSE;
-
-	if (rw < scanline * 2)
-		return FALSE;
-
 	for (y = 0; y < context->height; y++)
 	{
 		src = data + (context->height - 1 - y) * scanline;
@@ -312,8 +302,6 @@
 		CopyMemory(coplane, coplane - rw, rw);
 		CopyMemory(cgplane, cgplane - rw, rw);
 	}
-
-	return TRUE;
 }
 
 static void nsc_encode_subsampling_sse2(NSC_CONTEXT* context)
@@ -369,11 +357,12 @@
 
 static BOOL nsc_encode_sse2(NSC_CONTEXT* context, const BYTE* data, UINT32 scanline)
 {
-	if (!nsc_encode_argb_to_aycocg_sse2(context, data, scanline))
-		return FALSE;
+	nsc_encode_argb_to_aycocg_sse2(context, data, scanline);
 
 	if (context->ChromaSubsamplingLevel > 0)
+	{
 		nsc_encode_subsampling_sse2(context);
+	}
 
 	return TRUE;
 }
diff -urN libfreerdp/codec/planar.c ../../informatimago/FreeRDP/libfreerdp/codec/planar.c
--- libfreerdp/codec/planar.c	2019-07-25 19:51:01.701901586 +0300
+++ ../../informatimago/FreeRDP/libfreerdp/codec/planar.c	2019-07-25 20:11:25.655971218 +0300
@@ -92,7 +92,7 @@
                                                 UINT32 nYDst, UINT32 nWidth, UINT32 nHeight,
                                                 UINT32 nChannel, BOOL vFlip)
 {
-	INT32 x, y;
+	UINT32 x, y;
 	UINT32 pixel;
 	UINT32 cRawBytes;
 	UINT32 nRunLength;
@@ -102,32 +102,28 @@
 	BYTE* currentScanline;
 	BYTE* previousScanline;
 	const BYTE* srcp = pSrcData;
-
-	if ((nHeight > INT32_MAX) || (nWidth > INT32_MAX) || (nDstStep > INT32_MAX))
-		return -1;
-
 	previousScanline = NULL;
 
 	if (vFlip)
 	{
-		beg = (INT32)nHeight - 1;
+		beg = nHeight - 1;
 		end = -1;
 		inc = -1;
 	}
 	else
 	{
 		beg = 0;
-		end = (INT32)nHeight;
+		end = nHeight;
 		inc = 1;
 	}
 
 	for (y = beg; y != end; y += inc)
 	{
-		BYTE* dstp = &pDstData[((nYDst + y) * (INT32)nDstStep) + (nXDst * 4) + nChannel];
+		BYTE* dstp = &pDstData[((nYDst + y) * nDstStep) + (nXDst * 4) + nChannel];
 		pixel = 0;
 		currentScanline = dstp;
 
-		for (x = 0; x < (INT32)nWidth;)
+		for (x = 0; x < nWidth;)
 		{
 			controlByte = *srcp;
 			srcp++;
@@ -223,43 +219,6 @@
 	return (INT32)(srcp - pSrcData);
 }
 
-static INLINE INT32 planar_set_plane(BYTE bValue, BYTE* pDstData, INT32 nDstStep, UINT32 nXDst,
-                                     UINT32 nYDst, UINT32 nWidth, UINT32 nHeight, UINT32 nChannel,
-                                     BOOL vFlip)
-{
-	INT32 x, y;
-	INT32 beg, end, inc;
-
-	if ((nHeight > INT32_MAX) || (nWidth > INT32_MAX) || (nDstStep > INT32_MAX))
-		return -1;
-
-	if (vFlip)
-	{
-		beg = (INT32)nHeight - 1;
-		end = -1;
-		inc = -1;
-	}
-	else
-	{
-		beg = 0;
-		end = (INT32)nHeight;
-		inc = 1;
-	}
-
-	for (y = beg; y != end; y += inc)
-	{
-		BYTE* dstp = &pDstData[((nYDst + y) * (INT32)nDstStep) + (nXDst * 4) + nChannel];
-
-		for (x = 0; x < (INT32)nWidth; ++x)
-		{
-			*dstp = bValue;
-			dstp += 4;
-		}
-	}
-
-	return 0;
-}
-
 static INLINE BOOL writeLine(BYTE** ppRgba, UINT32 DstFormat, UINT32 width, const BYTE** ppR,
                              const BYTE** ppG, const BYTE** ppB, const BYTE** ppA)
 {
@@ -569,13 +528,10 @@
 				status = planar_decompress_plane_rle(planes[3], rleSizes[3], pTempData, nTempStep,
 				                                     nXDst, nYDst, nSrcWidth, nSrcHeight, 3,
 				                                     vFlip); /* AlphaPlane */
-			}
-			else
-				status = planar_set_plane(0xFF, pTempData, nTempStep, nXDst, nYDst, nSrcWidth,
-				                          nSrcHeight, 3, vFlip);
 
-			if (status < 0)
-				return FALSE;
+				if (status < 0)
+					return FALSE;
+			}
 
 			if (alpha)
 				srcp += rleSizes[3];
@@ -673,20 +629,16 @@
                                               UINT32 height, UINT32 scanline, BYTE* planes[4])
 {
 	INT32 i, j, k;
-
-	if ((width > INT32_MAX) || (height > INT32_MAX) || (scanline > INT32_MAX))
-		return FALSE;
-
 	k = 0;
 
 	if (scanline == 0)
 		scanline = width * GetBytesPerPixel(format);
 
-	for (i = (INT32)height - 1; i >= 0; i--)
+	for (i = height - 1; i >= 0; i--)
 	{
-		const BYTE* pixel = &data[(INT32)scanline * i];
+		const BYTE* pixel = &data[scanline * i];
 
-		for (j = 0; j < (INT32)width; j++)
+		for (j = 0; j < width; j++)
 		{
 			const UINT32 color = ReadColor(pixel, format);
 			pixel += GetBytesPerPixel(format);
@@ -1082,9 +1034,8 @@
 			offset += dstSizes[2];
 			context->rlePlanes[3] = &context->rlePlanesBuffer[offset];
 			// WLog_DBG(TAG, "R: [%"PRIu32"/%"PRIu32"] G: [%"PRIu32"/%"PRIu32"] B:
-			// [%"PRIu32"/%"PRIu32"]", 		dstSizes[1], planeSize, dstSizes[2], planeSize,
-			// dstSizes[3],
-			// planeSize);
+			// [%"PRIu32"/%"PRIu32"]", 		dstSizes[1], planeSize, dstSizes[2], planeSize, dstSizes[3],
+			//planeSize);
 		}
 	}
 
diff -urN libfreerdp/codec/progressive.c ../../informatimago/FreeRDP/libfreerdp/codec/progressive.c
--- libfreerdp/codec/progressive.c	2019-07-25 19:51:01.745901805 +0300
+++ ../../informatimago/FreeRDP/libfreerdp/codec/progressive.c	2019-07-25 20:11:25.695971416 +0300
@@ -1006,7 +1006,7 @@
                                                 INT16* sign, UINT32 length, UINT32 shift,
                                                 UINT32 bitPos, UINT32 numBits)
 {
-	UINT32 index;
+	int index;
 	INT16 input;
 	wBitStream* raw;
 
diff -urN libfreerdp/codec/region.c ../../informatimago/FreeRDP/libfreerdp/codec/region.c
--- libfreerdp/codec/region.c	2019-07-25 19:51:01.757901865 +0300
+++ ../../informatimago/FreeRDP/libfreerdp/codec/region.c	2019-07-25 20:11:25.711971495 +0300
@@ -181,7 +181,7 @@
 	assert(region);
 	assert(region->data);
 
-	if ((region->data->size > 0) && (region->data != &empty_region))
+	if (region->data->size)
 		free(region->data);
 
 	region->data = &empty_region;
@@ -213,11 +213,13 @@
 
 	dst->extents = src->extents;
 
-	if ((dst->data->size > 0) && (dst->data != &empty_region))
+	if (dst->data->size)
 		free(dst->data);
 
-	if (src->data->size == 0)
+	if (!src->data->size)
+	{
 		dst->data = &empty_region;
+	}
 	else
 	{
 		dst->data = allocateRegion(src->data->nbRects);
@@ -653,7 +655,7 @@
 		dstRect++;
 	}
 
-	if ((src == dst) && (src->data->size > 0) && (src->data != &empty_region))
+	if ((src == dst) && (src->data->size))
 		free(src->data);
 
 	dstExtents->top = MIN(rect->top, srcExtents->top);
@@ -774,7 +776,7 @@
 	newItems->nbRects = usedRects;
 	newItems->size = sizeof(REGION16_DATA) + (usedRects * sizeof(RECTANGLE_16));
 
-	if ((dst->data->size > 0) && (dst->data != &empty_region))
+	if (dst->data->size)
 		free(dst->data);
 
 	dst->data = realloc(newItems, newItems->size);
@@ -795,7 +797,7 @@
 
 	if (region->data)
 	{
-		if ((region->data->size > 0) && (region->data != &empty_region))
+		if (region->data->size)
 			free(region->data);
 
 		region->data = NULL;
diff -urN libfreerdp/codec/rfx.c ../../informatimago/FreeRDP/libfreerdp/codec/rfx.c
--- libfreerdp/codec/rfx.c	2019-07-25 19:51:01.801902083 +0300
+++ ../../informatimago/FreeRDP/libfreerdp/codec/rfx.c	2019-07-25 20:11:25.755971713 +0300
@@ -1418,11 +1418,8 @@
 }
 
 RFX_MESSAGE* rfx_encode_message(RFX_CONTEXT* context, const RFX_RECT* rects, int numRects,
-                                BYTE* data, int w, int h, int s)
+                                BYTE* data, int width, int height, int scanline)
 {
-	const UINT32 width = (UINT32)w;
-	const UINT32 height = (UINT32)h;
-	const UINT32 scanline = (UINT32)s;
 	UINT32 i, maxNbTiles, maxTilesX, maxTilesY;
 	UINT32 xIdx, yIdx, regionNbRects;
 	UINT32 gridRelX, gridRelY, ax, ay, bytesPerPixel;
@@ -1439,9 +1436,9 @@
 	assert(data);
 	assert(rects);
 	assert(numRects > 0);
-	assert(w > 0);
-	assert(h > 0);
-	assert(s > 0);
+	assert(width > 0);
+	assert(height > 0);
+	assert(scanline > 0);
 
 	if (!(message = (RFX_MESSAGE*)calloc(1, sizeof(RFX_MESSAGE))))
 		return NULL;
@@ -1502,10 +1499,10 @@
 
 	for (i = 0, rfxRect = message->rects; i < regionNbRects; i++, regionRect++, rfxRect++)
 	{
-		UINT32 startTileX = regionRect->left / 64;
-		UINT32 endTileX = (regionRect->right - 1) / 64;
-		UINT32 startTileY = regionRect->top / 64;
-		UINT32 endTileY = (regionRect->bottom - 1) / 64;
+		int startTileX = regionRect->left / 64;
+		int endTileX = (regionRect->right - 1) / 64;
+		int startTileY = regionRect->top / 64;
+		int endTileY = (regionRect->bottom - 1) / 64;
 		rfxRect->x = regionRect->left;
 		rfxRect->y = regionRect->top;
 		rfxRect->width = (regionRect->right - regionRect->left);
@@ -1514,7 +1511,7 @@
 		for (yIdx = startTileY, gridRelY = startTileY * 64; yIdx <= endTileY;
 		     yIdx++, gridRelY += 64)
 		{
-			UINT32 tileHeight = 64;
+			int tileHeight = 64;
 
 			if ((yIdx == endTileY) && (gridRelY + 64 > height))
 				tileHeight = height - gridRelY;
diff -urN libfreerdp/codec/rfx_neon.c ../../informatimago/FreeRDP/libfreerdp/codec/rfx_neon.c
--- libfreerdp/codec/rfx_neon.c	2019-07-25 19:51:01.829902222 +0300
+++ ../../informatimago/FreeRDP/libfreerdp/codec/rfx_neon.c	2019-07-25 20:11:25.779971833 +0300
@@ -145,6 +145,7 @@
 			int16x8_t l_n = vld1q_s16(l_ptr);
 			int16x8_t h_n = vld1q_s16(h_ptr);
 			int16x8_t tmp_n = vaddq_s16(h_n, vdupq_n_s16(1));
+			;
 
 			if (n == 0)
 				tmp_n = vaddq_s16(tmp_n, h_n);
diff -urN libfreerdp/codec/rfx_rlgr.c ../../informatimago/FreeRDP/libfreerdp/codec/rfx_rlgr.c
--- libfreerdp/codec/rfx_rlgr.c	2019-07-25 19:51:01.841902280 +0300
+++ ../../informatimago/FreeRDP/libfreerdp/codec/rfx_rlgr.c	2019-07-25 20:11:25.791971892 +0300
@@ -144,12 +144,10 @@
 	int cnt;
 	int size;
 	int nbits;
-	size_t offset;
+	int offset;
 	INT16 mag;
-	UINT32 k;
-	INT32 kp;
-	UINT32 kr;
-	INT32 krp;
+	int k, kp;
+	int kr, krp;
 	UINT16 code;
 	UINT32 sign;
 	UINT32 nIdx;
@@ -316,7 +314,7 @@
 				mag = (INT16)(code + 1);
 
 			/* write to output stream */
-			offset = (pOutput - pDstData);
+			offset = (int)(pOutput - pDstData);
 			size = run;
 
 			if ((offset + size) > DstSize)
@@ -501,7 +499,7 @@
 		}
 	}
 
-	offset = (pOutput - pDstData);
+	offset = (int)(pOutput - pDstData);
 
 	if (offset < DstSize)
 	{
@@ -510,7 +508,7 @@
 		pOutput += size;
 	}
 
-	offset = (pOutput - pDstData);
+	offset = (int)(pOutput - pDstData);
 
 	if (offset != DstSize)
 		return -1;
diff -urN libfreerdp/codec/test/TestFreeRDPCodec.c ../../informatimago/FreeRDP/libfreerdp/codec/test/TestFreeRDPCodec.c
--- libfreerdp/codec/test/TestFreeRDPCodec.c	2019-07-25 20:17:16.453710809 +0300
+++ ../../informatimago/FreeRDP/libfreerdp/codec/test/TestFreeRDPCodec.c	2019-07-25 20:11:25.815972011 +0300
@@ -4,11 +4,9 @@
 #include <string.h> /* NOLINT */
 
 #if defined(_MSC_VER)
-#pragma warning(disable : 4996) /* deprecation */
+#	pragma warning(disable : 4996) /* deprecation */
 #endif
 
-
-
 /* Forward declare test functions. */
 int TestFreeRDPRegion(int, char*[]);
 int TestFreeRDPCodecMppc(int, char*[]);
@@ -21,167 +19,150 @@
 int TestFreeRDPCodecProgressive(int, char*[]);
 int TestFreeRDPCodecRemoteFX(int, char*[]);
 
-
 #ifdef __cplusplus
-#define CM_CAST(TYPE, EXPR) static_cast<TYPE>(EXPR)
+#	define CM_CAST(TYPE, EXPR) static_cast<TYPE>(EXPR)
 #else
-#define CM_CAST(TYPE, EXPR) (TYPE)(EXPR)
+#	define CM_CAST(TYPE, EXPR) (TYPE)(EXPR)
 #endif
 
 /* Create map.  */
 
-typedef int (*MainFuncPointer)(int, char* []); /* NOLINT */
-typedef struct /* NOLINT */
+typedef int (*MainFuncPointer)(int, char*[]); /* NOLINT */
+typedef struct                                /* NOLINT */
 {
-  const char* name;
-  MainFuncPointer func;
+	const char* name;
+	MainFuncPointer func;
 } functionMapEntry;
 
 static functionMapEntry cmakeGeneratedFunctionMapEntries[] = {
-    {
-    "TestFreeRDPRegion",
-    TestFreeRDPRegion
-  },
-  {
-    "TestFreeRDPCodecMppc",
-    TestFreeRDPCodecMppc
-  },
-  {
-    "TestFreeRDPCodecNCrush",
-    TestFreeRDPCodecNCrush
-  },
-  {
-    "TestFreeRDPCodecXCrush",
-    TestFreeRDPCodecXCrush
-  },
-  {
-    "TestFreeRDPCodecZGfx",
-    TestFreeRDPCodecZGfx
-  },
-  {
-    "TestFreeRDPCodecPlanar",
-    TestFreeRDPCodecPlanar
-  },
-  {
-    "TestFreeRDPCodecClear",
-    TestFreeRDPCodecClear
-  },
-  {
-    "TestFreeRDPCodecInterleaved",
-    TestFreeRDPCodecInterleaved
-  },
-  {
-    "TestFreeRDPCodecProgressive",
-    TestFreeRDPCodecProgressive
-  },
-  {
-    "TestFreeRDPCodecRemoteFX",
-    TestFreeRDPCodecRemoteFX
-  },
+	{ "TestFreeRDPRegion", TestFreeRDPRegion },
+	{ "TestFreeRDPCodecMppc", TestFreeRDPCodecMppc },
+	{ "TestFreeRDPCodecNCrush", TestFreeRDPCodecNCrush },
+	{ "TestFreeRDPCodecXCrush", TestFreeRDPCodecXCrush },
+	{ "TestFreeRDPCodecZGfx", TestFreeRDPCodecZGfx },
+	{ "TestFreeRDPCodecPlanar", TestFreeRDPCodecPlanar },
+	{ "TestFreeRDPCodecClear", TestFreeRDPCodecClear },
+	{ "TestFreeRDPCodecInterleaved", TestFreeRDPCodecInterleaved },
+	{ "TestFreeRDPCodecProgressive", TestFreeRDPCodecProgressive },
+	{ "TestFreeRDPCodecRemoteFX", TestFreeRDPCodecRemoteFX },
 
-  { NULL, NULL } /* NOLINT */
+	{ NULL, NULL } /* NOLINT */
 };
 
-static const int NumTests = CM_CAST(int,
-  sizeof(cmakeGeneratedFunctionMapEntries) / sizeof(functionMapEntry)) - 1;
+static const int NumTests =
+    CM_CAST(int, sizeof(cmakeGeneratedFunctionMapEntries) / sizeof(functionMapEntry)) - 1;
 
 /* Allocate and create a lowercased copy of string
    (note that it has to be free'd manually) */
 static char* lowercase(const char* string)
 {
-  char *new_string, *p;
-  size_t stringSize;
+	char *new_string, *p;
+	size_t stringSize;
 
-  stringSize = CM_CAST(size_t, strlen(string) + 1);
-  new_string = CM_CAST(char*, malloc(sizeof(char) * stringSize));
+	stringSize = CM_CAST(size_t, strlen(string) + 1);
+	new_string = CM_CAST(char*, malloc(sizeof(char) * stringSize));
 
-  if (new_string == NULL) { /* NOLINT */
-    return NULL;            /* NOLINT */
-  }
-  strcpy(new_string, string);
-  for (p = new_string; *p != 0; ++p) {
-    *p = CM_CAST(char, tolower(*p));
-  }
-  return new_string;
+	if (new_string == NULL)
+	{                /* NOLINT */
+		return NULL; /* NOLINT */
+	}
+	strcpy(new_string, string);
+	for (p = new_string; *p != 0; ++p)
+	{
+		*p = CM_CAST(char, tolower(*p));
+	}
+	return new_string;
 }
 
 int main(int ac, char* av[])
 {
-  int i, testNum = 0, partial_match;
-  char *arg;
-  int testToRun = -1;
-
-  
-
-  /* If no test name was given */
-  /* process command line with user function.  */
-  if (ac < 2) {
-    /* Ask for a test.  */
-    printf("Available tests:\n");
-    for (i = 0; i < NumTests; ++i) {
-      printf("%3d. %s\n", i, cmakeGeneratedFunctionMapEntries[i].name);
-    }
-    printf("To run a test, enter the test number: ");
-    fflush(stdout);
-    if (scanf("%d", &testNum) != 1) {
-      printf("Couldn't parse that input as a number\n");
-      return -1;
-    }
-    if (testNum >= NumTests) {
-      printf("%3d is an invalid test number.\n", testNum);
-      return -1;
-    }
-    testToRun = testNum;
-    ac--;
-    av++;
-  }
-  partial_match = 0;
-  arg = NULL; /* NOLINT */
-  /* If partial match is requested.  */
-  if (testToRun == -1 && ac > 1) {
-    partial_match = (strcmp(av[1], "-R") == 0) ? 1 : 0;
-  }
-  if (partial_match != 0 && ac < 3) {
-    printf("-R needs an additional parameter.\n");
-    return -1;
-  }
-  if (testToRun == -1) {
-    arg = lowercase(av[1 + partial_match]);
-  }
-  for (i = 0; i < NumTests && testToRun == -1; ++i) {
-    char *test_name = lowercase(cmakeGeneratedFunctionMapEntries[i].name);
-    if (partial_match != 0 && strstr(test_name, arg) != NULL) { /* NOLINT */
-      testToRun = i;
-      ac -= 2;
-      av += 2;
-    } else if (partial_match == 0 && strcmp(test_name, arg) == 0) {
-      testToRun = i;
-      ac--;
-      av++;
-    }
-    free(test_name);
-  }
-  free(arg);
-  if (testToRun != -1) {
-    int result;
-
-    if (testToRun < 0 || testToRun >= NumTests) {
-      printf("testToRun was modified by TestDriver code to an invalid value: "
-             "%3d.\n",
-             testNum);
-      return -1;
-    }
-    result = (*cmakeGeneratedFunctionMapEntries[testToRun].func)(ac, av);
-
-    return result;
-  }
-
-  /* Nothing was run, display the test names.  */
-  printf("Available tests:\n");
-  for (i = 0; i < NumTests; ++i) {
-    printf("%3d. %s\n", i, cmakeGeneratedFunctionMapEntries[i].name);
-  }
-  printf("Failed: %s is an invalid test name.\n", av[1]);
+	int i, testNum = 0, partial_match;
+	char* arg;
+	int testToRun = -1;
+
+	/* If no test name was given */
+	/* process command line with user function.  */
+	if (ac < 2)
+	{
+		/* Ask for a test.  */
+		printf("Available tests:\n");
+		for (i = 0; i < NumTests; ++i)
+		{
+			printf("%3d. %s\n", i, cmakeGeneratedFunctionMapEntries[i].name);
+		}
+		printf("To run a test, enter the test number: ");
+		fflush(stdout);
+		if (scanf("%d", &testNum) != 1)
+		{
+			printf("Couldn't parse that input as a number\n");
+			return -1;
+		}
+		if (testNum >= NumTests)
+		{
+			printf("%3d is an invalid test number.\n", testNum);
+			return -1;
+		}
+		testToRun = testNum;
+		ac--;
+		av++;
+	}
+	partial_match = 0;
+	arg = NULL; /* NOLINT */
+	/* If partial match is requested.  */
+	if (testToRun == -1 && ac > 1)
+	{
+		partial_match = (strcmp(av[1], "-R") == 0) ? 1 : 0;
+	}
+	if (partial_match != 0 && ac < 3)
+	{
+		printf("-R needs an additional parameter.\n");
+		return -1;
+	}
+	if (testToRun == -1)
+	{
+		arg = lowercase(av[1 + partial_match]);
+	}
+	for (i = 0; i < NumTests && testToRun == -1; ++i)
+	{
+		char* test_name = lowercase(cmakeGeneratedFunctionMapEntries[i].name);
+		if (partial_match != 0 && strstr(test_name, arg) != NULL)
+		{ /* NOLINT */
+			testToRun = i;
+			ac -= 2;
+			av += 2;
+		}
+		else if (partial_match == 0 && strcmp(test_name, arg) == 0)
+		{
+			testToRun = i;
+			ac--;
+			av++;
+		}
+		free(test_name);
+	}
+	free(arg);
+	if (testToRun != -1)
+	{
+		int result;
+
+		if (testToRun < 0 || testToRun >= NumTests)
+		{
+			printf("testToRun was modified by TestDriver code to an invalid value: "
+			       "%3d.\n",
+			       testNum);
+			return -1;
+		}
+		result = (*cmakeGeneratedFunctionMapEntries[testToRun].func)(ac, av);
+
+		return result;
+	}
+
+	/* Nothing was run, display the test names.  */
+	printf("Available tests:\n");
+	for (i = 0; i < NumTests; ++i)
+	{
+		printf("%3d. %s\n", i, cmakeGeneratedFunctionMapEntries[i].name);
+	}
+	printf("Failed: %s is an invalid test name.\n", av[1]);
 
-  return -1;
+	return -1;
 }
diff -urN libfreerdp/codec/test/TestFreeRDPCodecClear.c ../../informatimago/FreeRDP/libfreerdp/codec/test/TestFreeRDPCodecClear.c
--- libfreerdp/codec/test/TestFreeRDPCodecClear.c	2019-07-25 19:51:01.865902400 +0300
+++ ../../informatimago/FreeRDP/libfreerdp/codec/test/TestFreeRDPCodecClear.c	2019-07-25 20:11:25.815972011 +0300
@@ -3,12 +3,9 @@
 
 #include <freerdp/codec/clear.h>
 
-#pragma GCC diagnostic push
-#pragma GCC diagnostic ignored "-Wunused-const-variable"
 /* [MS-RDPEGFX] 4.1.1.1 Example 1 */
 static const BYTE PREPARE_CLEAR_EXAMPLE_1[] = "\x03\xc3\x11\x00";
 static const BYTE TEST_CLEAR_EXAMPLE_1[] = "\x03\xc3\x11\x00";
-#pragma GCC diagnostic pop
 
 /* [MS-RDPEGFX] 4.1.1.1 Example 2 */
 static const BYTE TEST_CLEAR_EXAMPLE_2[] =
@@ -69,9 +66,6 @@
 
 int TestFreeRDPCodecClear(int argc, char* argv[])
 {
-	WINPR_UNUSED(argc);
-	WINPR_UNUSED(argv);
-
 	/* Example 1 needs a filled glyph cache
 	if (!test_ClearDecompressExample(1, 8, 9, TEST_CLEAR_EXAMPLE_1,
 	                                 sizeof(TEST_CLEAR_EXAMPLE_1)))
diff -urN libfreerdp/codec/test/TestFreeRDPCodecInterleaved.c ../../informatimago/FreeRDP/libfreerdp/codec/test/TestFreeRDPCodecInterleaved.c
--- libfreerdp/codec/test/TestFreeRDPCodecInterleaved.c	2019-07-25 19:51:01.869902420 +0300
+++ ../../informatimago/FreeRDP/libfreerdp/codec/test/TestFreeRDPCodecInterleaved.c	2019-07-25 20:11:25.819972031 +0300
@@ -158,8 +158,6 @@
 {
 	BITMAP_INTERLEAVED_CONTEXT *encoder, *decoder;
 	int rc = -1;
-	WINPR_UNUSED(argc);
-	WINPR_UNUSED(argv);
 	encoder = bitmap_interleaved_context_new(TRUE);
 	decoder = bitmap_interleaved_context_new(FALSE);
 
diff -urN libfreerdp/codec/test/TestFreeRDPCodecMppc.c ../../informatimago/FreeRDP/libfreerdp/codec/test/TestFreeRDPCodecMppc.c
--- libfreerdp/codec/test/TestFreeRDPCodecMppc.c	2019-07-25 19:51:01.941902777 +0300
+++ ../../informatimago/FreeRDP/libfreerdp/codec/test/TestFreeRDPCodecMppc.c	2019-07-25 20:11:25.891972388 +0300
@@ -1086,9 +1086,6 @@
 
 int TestFreeRDPCodecMppc(int argc, char* argv[])
 {
-	WINPR_UNUSED(argc);
-	WINPR_UNUSED(argv);
-
 	if (test_MppcCompressIslandRdp5() < 0)
 		return -1;
 
diff -urN libfreerdp/codec/test/TestFreeRDPCodecNCrush.c ../../informatimago/FreeRDP/libfreerdp/codec/test/TestFreeRDPCodecNCrush.c
--- libfreerdp/codec/test/TestFreeRDPCodecNCrush.c	2019-07-25 19:51:01.945902797 +0300
+++ ../../informatimago/FreeRDP/libfreerdp/codec/test/TestFreeRDPCodecNCrush.c	2019-07-25 20:11:25.895972408 +0300
@@ -115,9 +115,6 @@
 
 int TestFreeRDPCodecNCrush(int argc, char* argv[])
 {
-	WINPR_UNUSED(argc);
-	WINPR_UNUSED(argv);
-
 	if (!test_NCrushCompressBells())
 		return -1;
 
diff -urN libfreerdp/codec/test/TestFreeRDPCodecPlanar.c ../../informatimago/FreeRDP/libfreerdp/codec/test/TestFreeRDPCodecPlanar.c
--- libfreerdp/codec/test/TestFreeRDPCodecPlanar.c	2019-07-25 19:51:02.169903907 +0300
+++ ../../informatimago/FreeRDP/libfreerdp/codec/test/TestFreeRDPCodecPlanar.c	2019-07-25 20:11:26.119973519 +0300
@@ -5653,8 +5653,6 @@
 int TestFreeRDPCodecPlanar(int argc, char* argv[])
 {
 	UINT32 x;
-	WINPR_UNUSED(argc);
-	WINPR_UNUSED(argv);
 
 	for (x = 0; x < colorFormatCount; x++)
 	{
diff -urN libfreerdp/codec/test/TestFreeRDPCodecProgressive.c ../../informatimago/FreeRDP/libfreerdp/codec/test/TestFreeRDPCodecProgressive.c
--- libfreerdp/codec/test/TestFreeRDPCodecProgressive.c	2019-07-25 19:51:02.193904027 +0300
+++ ../../informatimago/FreeRDP/libfreerdp/codec/test/TestFreeRDPCodecProgressive.c	2019-07-25 20:11:26.147973658 +0300
@@ -1022,8 +1022,6 @@
 	char* ms_sample_path;
 	char name[8192];
 	SYSTEMTIME systemTime;
-	WINPR_UNUSED(argc);
-	WINPR_UNUSED(argv);
 	GetSystemTime(&systemTime);
 	sprintf_s(name, sizeof(name),
 	          "EGFX_PROGRESSIVE_MS_SAMPLE-%04" PRIu16 "%02" PRIu16 "%02" PRIu16 "%02" PRIu16
diff -urN libfreerdp/codec/test/TestFreeRDPCodecXCrush.c ../../informatimago/FreeRDP/libfreerdp/codec/test/TestFreeRDPCodecXCrush.c
--- libfreerdp/codec/test/TestFreeRDPCodecXCrush.c	2019-07-25 19:51:02.565905871 +0300
+++ ../../informatimago/FreeRDP/libfreerdp/codec/test/TestFreeRDPCodecXCrush.c	2019-07-25 20:11:26.519975502 +0300
@@ -138,9 +138,6 @@
 
 int TestFreeRDPCodecXCrush(int argc, char* argv[])
 {
-	WINPR_UNUSED(argc);
-	WINPR_UNUSED(argv);
-
 	// if (test_XCrushCompressBells() < 0)
 	//	return -1;
 	if (test_XCrushCompressIsland() < 0)
diff -urN libfreerdp/codec/test/TestFreeRDPCodecZGfx.c ../../informatimago/FreeRDP/libfreerdp/codec/test/TestFreeRDPCodecZGfx.c
--- libfreerdp/codec/test/TestFreeRDPCodecZGfx.c	2019-07-25 19:51:02.569905891 +0300
+++ ../../informatimago/FreeRDP/libfreerdp/codec/test/TestFreeRDPCodecZGfx.c	2019-07-25 20:11:26.523975522 +0300
@@ -254,9 +254,6 @@
 
 int TestFreeRDPCodecZGfx(int argc, char* argv[])
 {
-	WINPR_UNUSED(argc);
-	WINPR_UNUSED(argv);
-
 	if (test_ZGfxCompressFox() < 0)
 		return -1;
 
diff -urN libfreerdp/codec/test/TestFreeRDPRegion.c ../../informatimago/FreeRDP/libfreerdp/codec/test/TestFreeRDPRegion.c
--- libfreerdp/codec/test/TestFreeRDPRegion.c	2019-07-25 19:51:02.585905970 +0300
+++ ../../informatimago/FreeRDP/libfreerdp/codec/test/TestFreeRDPRegion.c	2019-07-25 20:11:26.539975601 +0300
@@ -842,8 +842,6 @@
 {
 	int i, testNb = 0;
 	int retCode = -1;
-	WINPR_UNUSED(argc);
-	WINPR_UNUSED(argv);
 
 	for (i = 0; tests[i].func; i++)
 	{
diff -urN libfreerdp/codec/yuv.c ../../informatimago/FreeRDP/libfreerdp/codec/yuv.c
--- libfreerdp/codec/yuv.c	2019-07-25 19:51:02.605906069 +0300
+++ ../../informatimago/FreeRDP/libfreerdp/codec/yuv.c	2019-07-25 20:11:26.559975700 +0300
@@ -108,7 +108,7 @@
 	UINT32 y, nobjects, i;
 	PTP_WORK* work_objects = NULL;
 	YUV_PROCESS_WORK_PARAM* params;
-	UINT32 waitCount = 0;
+	int waitCount = 0;
 	BOOL ret = TRUE;
 
 	if (!context->useThreads)
diff -urN libfreerdp/codec/zgfx.c ../../informatimago/FreeRDP/libfreerdp/codec/zgfx.c
--- libfreerdp/codec/zgfx.c	2019-07-25 19:51:02.625906169 +0300
+++ ../../informatimago/FreeRDP/libfreerdp/codec/zgfx.c	2019-07-25 20:11:26.583975820 +0300
@@ -174,16 +174,16 @@
 {
 	UINT32 front;
 	UINT32 index;
-	INT32 bytes;
+	UINT32 bytes;
 	UINT32 valid;
-	INT32 bytesLeft;
+	UINT32 bytesLeft;
 	BYTE* dptr = dst;
 	BYTE* origDst = dst;
 
-	if ((count <= 0) || (count > INT32_MAX))
+	if (count <= 0)
 		return;
 
-	bytesLeft = (INT32)count;
+	bytesLeft = count;
 	index = (zgfx->HistoryIndex + zgfx->HistoryBufferSize - offset) % zgfx->HistoryBufferSize;
 	bytes = MIN(bytesLeft, offset);
 
@@ -223,8 +223,8 @@
 	BYTE flags;
 	UINT32 extra = 0;
 	int opIndex;
-	UINT32 haveBits;
-	UINT32 inPrefix;
+	int haveBits;
+	int inPrefix;
 	UINT32 count;
 	UINT32 distance;
 	BYTE* pbSegment;
diff -urN libfreerdp/common/addin.c ../../informatimago/FreeRDP/libfreerdp/common/addin.c
--- libfreerdp/common/addin.c	2019-07-25 19:51:02.629906188 +0300
+++ ../../informatimago/FreeRDP/libfreerdp/common/addin.c	2019-07-25 20:11:26.587975839 +0300
@@ -233,8 +233,8 @@
 	return entry;
 }
 
-PVIRTUALCHANNELENTRY freerdp_load_dynamic_channel_addin_entry(LPCSTR pszName, LPCSTR pszSubsystem,
-                                                              LPCSTR pszType, DWORD dwFlags)
+PVIRTUALCHANNELENTRY freerdp_load_dynamic_channel_addin_entry(LPCSTR pszName, LPSTR pszSubsystem,
+                                                              LPSTR pszType, DWORD dwFlags)
 {
 	PVIRTUALCHANNELENTRY entry;
 	LPSTR pszFileName;
@@ -331,8 +331,8 @@
 	return 0;
 }
 
-PVIRTUALCHANNELENTRY freerdp_load_channel_addin_entry(LPCSTR pszName, LPCSTR pszSubsystem,
-                                                      LPCSTR pszType, DWORD dwFlags)
+PVIRTUALCHANNELENTRY freerdp_load_channel_addin_entry(LPCSTR pszName, LPSTR pszSubsystem,
+                                                      LPSTR pszType, DWORD dwFlags)
 {
 	PVIRTUALCHANNELENTRY entry = NULL;
 
diff -urN libfreerdp/common/assistance.c ../../informatimago/FreeRDP/libfreerdp/common/assistance.c
--- libfreerdp/common/assistance.c	2019-07-25 19:51:02.645906268 +0300
+++ ../../informatimago/FreeRDP/libfreerdp/common/assistance.c	2019-07-25 20:11:26.603975919 +0300
@@ -28,7 +28,6 @@
 #include <winpr/crypto.h>
 #include <winpr/print.h>
 #include <winpr/windows.h>
-#include <winpr/ssl.h>
 
 #include <freerdp/log.h>
 #include <freerdp/client/file.h>
@@ -170,11 +169,7 @@
 	p = strtoul(port, NULL, 0);
 
 	if ((errno != 0) || (p == 0) || (p > UINT16_MAX))
-	{
-		WLog_ERR(TAG, "Failed to parse ASSISTANCE file: ConnectionString2 invalid port value %s",
-		         port);
 		return FALSE;
-	}
 
 	return reallocate(file, host, (UINT16)p);
 }
@@ -316,16 +311,10 @@
 	str = file->ConnectionString2;
 
 	if (!strstr(str, "<E>"))
-	{
-		WLog_ERR(TAG, "Failed to parse ASSISTANCE file: ConnectionString2 missing field <E>");
 		return FALSE;
-	}
 
 	if (!strstr(str, "<C>"))
-	{
-		WLog_ERR(TAG, "Failed to parse ASSISTANCE file: ConnectionString2 missing field <C>");
 		return FALSE;
-	}
 
 	str = _strdup(file->ConnectionString2);
 
@@ -333,10 +322,7 @@
 		goto out_fail;
 
 	if (!(tag = strstr(str, "<A")))
-	{
-		WLog_ERR(TAG, "Failed to parse ASSISTANCE file: ConnectionString2 missing field <A");
 		goto out_fail;
-	}
 
 	/* Parse Auth String Node (<A>) */
 	end = strstr(tag, "/>");
@@ -355,11 +341,7 @@
 		q = strchr(p, '"');
 
 		if (!q)
-		{
-			WLog_ERR(TAG, "Failed to parse ASSISTANCE file: ConnectionString2 invalid field KH=%s",
-			         q);
 			goto out_fail;
-		}
 
 		length = q - p;
 		free(file->RASpecificParams);
@@ -382,11 +364,7 @@
 		q = strchr(p, '"');
 
 		if (!q)
-		{
-			WLog_ERR(TAG, "Failed to parse ASSISTANCE file: ConnectionString2 invalid field ID=%s",
-			         q);
 			goto out_fail;
-		}
 
 		length = q - p;
 		free(file->RASessionId);
@@ -412,11 +390,7 @@
 		q = strchr(p, '"');
 
 		if (!q)
-		{
-			WLog_ERR(TAG,
-			         "Failed to parse ASSISTANCE file: ConnectionString2 invalid field <L P=%s", q);
 			goto out_fail;
-		}
 
 		q[0] = '\0';
 		q++;
@@ -424,21 +398,13 @@
 		p = strstr(q, " N=\"");
 
 		if (!p)
-		{
-			WLog_ERR(TAG, "Failed to parse ASSISTANCE file: ConnectionString2 invalid field N=%s",
-			         p);
 			goto out_fail;
-		}
 
 		p += sizeof(" N=\"") - 1;
 		q = strchr(p, '"');
 
 		if (!q)
-		{
-			WLog_ERR(TAG, "Failed to parse ASSISTANCE file: ConnectionString2 invalid field N=%s",
-			         q);
 			goto out_fail;
-		}
 
 		q[0] = '\0';
 		q++;
@@ -631,10 +597,7 @@
 	status = ConvertToUnicode(CP_UTF8, 0, password, -1, &PasswordW, 0);
 
 	if (status <= 0)
-	{
-		WLog_ERR(TAG, "Failed to parse ASSISTANCE file: Conversion from UCS2 to UTF8 failed");
 		return FALSE;
-	}
 
 	cbPasswordW = (size_t)(status - 1) * 2UL;
 
@@ -683,10 +646,7 @@
 	    ConvertFromUnicode(CP_UTF8, 0, pbOutW, cchOutW, &file->ConnectionString2, 0, NULL, NULL);
 
 	if (status <= 0)
-	{
-		WLog_ERR(TAG, "Failed to parse ASSISTANCE file: Conversion from UCS2 to UTF8 failed");
 		goto fail;
-	}
 
 	if (!freerdp_assistance_parse_connection_string2(file))
 		goto fail;
@@ -700,12 +660,11 @@
 	return rc;
 }
 
-BYTE* freerdp_assistance_hex_string_to_bin(const void* raw, size_t* size)
+BYTE* freerdp_assistance_hex_string_to_bin(const char* str, size_t* size)
 {
 	size_t length;
 	BYTE* buffer;
 	size_t i;
-	const char* str = (const char*)raw;
 	length = strlen(str);
 
 	if ((length % 2) != 0)
@@ -747,12 +706,11 @@
 	return buffer;
 }
 
-char* freerdp_assistance_bin_to_hex_string(const void* raw, size_t size)
+char* freerdp_assistance_bin_to_hex_string(const BYTE* data, size_t size)
 {
 	size_t i;
 	char* p;
 	int ln, hn;
-	const char* data = (const char*)raw;
 	char bin2hex[] = "0123456789ABCDEF";
 	p = (char*)calloc((size + 1), 2);
 
@@ -786,18 +744,12 @@
 		p = strstr(p + sizeof("UPLOADINFO") - 1, "TYPE=\"");
 
 		if (!p)
-		{
-			WLog_ERR(TAG, "Failed to parse ASSISTANCE file: Missing UPLOADINFO TYPE");
 			return -1;
-		}
 
 		p = strstr(buffer, "UPLOADDATA");
 
 		if (!p)
-		{
-			WLog_ERR(TAG, "Failed to parse ASSISTANCE file: Missing UPLOADDATA");
 			return -1;
-		}
 
 		/* Parse USERNAME */
 		p = strstr(buffer, "USERNAME=\"");
@@ -808,10 +760,7 @@
 			q = strchr(p, '"');
 
 			if (!q)
-			{
-				WLog_ERR(TAG, "Failed to parse ASSISTANCE file: Invalid USERNAME=%s", p);
 				return -1;
-			}
 
 			length = q - p;
 			file->Username = (char*)malloc(length + 1);
@@ -832,10 +781,7 @@
 			q = strchr(p, '"');
 
 			if (!q)
-			{
-				WLog_ERR(TAG, "Failed to parse ASSISTANCE file: Invalid LHTICKET=%s", p);
 				return -1;
-			}
 
 			length = q - p;
 			file->LHTicket = (char*)malloc(length + 1);
@@ -856,10 +802,7 @@
 			q = strchr(p, '"');
 
 			if (!q)
-			{
-				WLog_ERR(TAG, "Failed to parse ASSISTANCE file: Invalid RCTICKET=%s", p);
 				return -1;
-			}
 
 			length = q - p;
 			file->RCTicket = (char*)malloc(length + 1);
@@ -880,10 +823,7 @@
 			q = strchr(p, '"');
 
 			if (!q)
-			{
-				WLog_ERR(TAG, "Failed to parse ASSISTANCE file: Invalid RCTICKETENCRYPTED=%s", p);
 				return -1;
-			}
 
 			length = q - p;
 
@@ -900,10 +840,7 @@
 			q = strchr(p, '"');
 
 			if (!q)
-			{
-				WLog_ERR(TAG, "Failed to parse ASSISTANCE file: Invalid PassStub=%s", p);
 				return -1;
-			}
 
 			length = q - p;
 			file->PassStub = (char*)malloc(length + 1);
@@ -924,10 +861,7 @@
 			q = strchr(p, '"');
 
 			if (!q)
-			{
-				WLog_ERR(TAG, "Failed to parse ASSISTANCE file: Invalid DtStart=%s", p);
 				return -1;
-			}
 
 			length = q - p;
 			r = (char*)malloc(length + 1);
@@ -940,15 +874,11 @@
 			errno = 0;
 			{
 				unsigned long val = strtoul(r, NULL, 0);
+				free(r);
 
 				if ((errno != 0) || (val > UINT32_MAX))
-				{
-					WLog_ERR(TAG, "Failed to parse ASSISTANCE file: Invalid DtStart value %s", r);
-					free(r);
 					return -1;
-				}
 
-				free(r);
 				file->DtStart = val;
 			}
 		}
@@ -962,10 +892,7 @@
 			q = strchr(p, '"');
 
 			if (!q)
-			{
-				WLog_ERR(TAG, "Failed to parse ASSISTANCE file: Invalid DtLength=%s", p);
 				return -1;
-			}
 
 			length = q - p;
 			r = (char*)malloc(length + 1);
@@ -978,15 +905,11 @@
 			errno = 0;
 			{
 				unsigned long val = strtoul(r, NULL, 0);
+				free(r);
 
 				if ((errno != 0) || (val > UINT32_MAX))
-				{
-					WLog_ERR(TAG, "Failed to parse ASSISTANCE file: Invalid DtLength value %s", r);
-					free(r);
 					return -1;
-				}
 
-				free(r);
 				file->DtLength = val;
 			}
 		}
@@ -1000,10 +923,7 @@
 			q = strchr(p, '"');
 
 			if (!q)
-			{
-				WLog_ERR(TAG, "Failed to parse ASSISTANCE file: Invalid L=%s", p);
 				return -1;
-			}
 
 			length = q - p;
 
@@ -1059,18 +979,11 @@
 		q = strstr(buffer, "</E>");
 
 		if (!q)
-		{
-			WLog_ERR(TAG, "Failed to parse ASSISTANCE file: Missing </E> tag");
 			return -1;
-		}
 
 		q += sizeof("</E>") - 1;
 		length = q - p;
 		file->ConnectionString2 = (char*)malloc(length + 1);
-
-		if (!file->ConnectionString2)
-			return -1;
-
 		CopyMemory(file->ConnectionString2, p, length);
 		file->ConnectionString2[length] = '\0';
 
@@ -1080,7 +993,6 @@
 		return 1;
 	}
 
-	WLog_ERR(TAG, "Failed to parse ASSISTANCE file: Neither UPLOADINFO nor <E> found");
 	return -1;
 }
 
@@ -1093,10 +1005,7 @@
 	INT64 fileSize;
 
 	if (!name)
-	{
-		WLog_ERR(TAG, "ASSISTANCE file %s invalid name", name);
 		return -1;
-	}
 
 	free(file->filename);
 	free(file->password);
@@ -1105,10 +1014,7 @@
 	fp = fopen(name, "r");
 
 	if (!fp)
-	{
-		WLog_ERR(TAG, "Failed to open ASSISTANCE file %s ", name);
 		return -1;
-	}
 
 	_fseeki64(fp, 0, SEEK_END);
 	fileSize = _ftelli64(fp);
@@ -1116,7 +1022,6 @@
 
 	if (fileSize < 1)
 	{
-		WLog_ERR(TAG, "Failed to read ASSISTANCE file %s ", name);
 		fclose(fp);
 		return -1;
 	}
@@ -1141,7 +1046,6 @@
 
 	if (readSize < 1)
 	{
-		WLog_ERR(TAG, "Failed to read ASSISTANCE file %s ", name);
 		free(buffer);
 		buffer = NULL;
 		return -1;
@@ -1158,57 +1062,52 @@
                                                                rdpSettings* settings)
 {
 	UINT32 i;
-
-	if (!freerdp_settings_set_bool(settings, FreeRDP_RemoteAssistanceMode, TRUE))
-		return FALSE;
+	freerdp_set_param_bool(settings, FreeRDP_RemoteAssistanceMode, TRUE);
 
 	if (!file->RASessionId || !file->MachineAddresses)
 		return FALSE;
 
-	if (!freerdp_settings_set_string(settings, FreeRDP_RemoteAssistanceSessionId,
-	                                 file->RASessionId))
+	if (freerdp_set_param_string(settings, FreeRDP_RemoteAssistanceSessionId, file->RASessionId) !=
+	    0)
 		return FALSE;
 
 	if (file->RCTicket)
 	{
-		if (!freerdp_settings_set_string(settings, FreeRDP_RemoteAssistanceRCTicket,
-		                                 file->RCTicket))
+		if (freerdp_set_param_string(settings, FreeRDP_RemoteAssistanceRCTicket, file->RCTicket) !=
+		    0)
 			return FALSE;
 	}
 	else
 	{
-		if (!freerdp_settings_set_string(settings, FreeRDP_RemoteAssistanceRCTicket,
-		                                 file->ConnectionString2))
+		if (freerdp_set_param_string(settings, FreeRDP_RemoteAssistanceRCTicket,
+		                             file->ConnectionString2) != 0)
 			return FALSE;
 	}
 
 	if (file->PassStub)
 	{
-		if (!freerdp_settings_set_string(settings, FreeRDP_RemoteAssistancePassStub,
-		                                 file->PassStub))
+		if (freerdp_set_param_string(settings, FreeRDP_RemoteAssistancePassStub, file->PassStub) !=
+		    0)
 			return FALSE;
 	}
 
-	if (!freerdp_settings_set_string(settings, FreeRDP_ServerHostname, file->MachineAddresses[0]))
+	if (freerdp_set_param_string(settings, FreeRDP_ServerHostname, file->MachineAddresses[0]) != 0)
 		return FALSE;
 
-	if (!freerdp_settings_set_string(settings, FreeRDP_AssistanceFile, file->filename))
+	if (freerdp_set_param_string(settings, FreeRDP_AssistanceFile, file->filename) != 0)
 		return FALSE;
 
-	if (!freerdp_settings_set_string(settings, FreeRDP_RemoteAssistancePassword, file->password))
+	if (freerdp_set_param_string(settings, FreeRDP_RemoteAssistancePassword, file->password) != 0)
 		return FALSE;
 
 	if (file->Username)
 	{
-		if (!freerdp_settings_set_string(settings, FreeRDP_Username, file->Username))
+		if (freerdp_set_param_string(settings, FreeRDP_Username, file->Username) != 0)
 			return FALSE;
 	}
 
 	settings->RemoteAssistanceMode = TRUE;
-
-	if (!freerdp_settings_set_uint32(settings, FreeRDP_ServerPort, file->MachinePorts[0]))
-		return FALSE;
-
+	freerdp_set_param_uint32(settings, FreeRDP_ServerPort, file->MachinePorts[0]);
 	freerdp_target_net_addresses_free(settings);
 	settings->TargetNetAddressCount = file->MachineCount;
 
@@ -1235,7 +1134,6 @@
 
 rdpAssistanceFile* freerdp_assistance_file_new(void)
 {
-	winpr_InitializeSSL(WINPR_SSL_INIT_DEFAULT);
 	return (rdpAssistanceFile*)calloc(1, sizeof(rdpAssistanceFile));
 }
 
diff -urN libfreerdp/common/CMakeLists.txt ../../informatimago/FreeRDP/libfreerdp/common/CMakeLists.txt
--- libfreerdp/common/CMakeLists.txt	2019-07-24 06:11:52.470197578 +0300
+++ ../../informatimago/FreeRDP/libfreerdp/common/CMakeLists.txt	2019-07-19 20:00:17.425205655 +0300
@@ -21,7 +21,6 @@
 set(${MODULE_PREFIX}_SRCS
 	addin.c
 	settings.c
-	settings_getters.c
 	assistance.c)
 
 freerdp_module_add(${${MODULE_PREFIX}_SRCS})
diff -urN libfreerdp/common/settings.c ../../informatimago/FreeRDP/libfreerdp/common/settings.c
--- libfreerdp/common/settings.c	2019-07-25 19:51:02.657906327 +0300
+++ ../../informatimago/FreeRDP/libfreerdp/common/settings.c	2019-07-25 20:11:26.635976077 +0300
@@ -696,28 +696,24 @@
 	settings->DisableThemes = (settings->PerformanceFlags & PERF_DISABLE_THEMING) ? TRUE : FALSE;
 }
 
-BOOL freerdp_set_gateway_usage_method(rdpSettings* settings, UINT32 GatewayUsageMethod)
+void freerdp_set_gateway_usage_method(rdpSettings* settings, UINT32 GatewayUsageMethod)
 {
-	if (!freerdp_settings_set_uint32(settings, FreeRDP_GatewayUsageMethod, GatewayUsageMethod))
-		return FALSE;
+	freerdp_set_param_uint32(settings, FreeRDP_GatewayUsageMethod, GatewayUsageMethod);
 
 	if (GatewayUsageMethod == TSC_PROXY_MODE_NONE_DIRECT)
 	{
-		if (!freerdp_settings_set_bool(settings, FreeRDP_GatewayEnabled, FALSE) ||
-		    !freerdp_settings_set_bool(settings, FreeRDP_GatewayBypassLocal, FALSE))
-			return FALSE;
+		freerdp_set_param_bool(settings, FreeRDP_GatewayEnabled, FALSE);
+		freerdp_set_param_bool(settings, FreeRDP_GatewayBypassLocal, FALSE);
 	}
 	else if (GatewayUsageMethod == TSC_PROXY_MODE_DIRECT)
 	{
-		if (!freerdp_settings_set_bool(settings, FreeRDP_GatewayEnabled, TRUE) ||
-		    !freerdp_settings_set_bool(settings, FreeRDP_GatewayBypassLocal, FALSE))
-			return FALSE;
+		freerdp_set_param_bool(settings, FreeRDP_GatewayEnabled, TRUE);
+		freerdp_set_param_bool(settings, FreeRDP_GatewayBypassLocal, FALSE);
 	}
 	else if (GatewayUsageMethod == TSC_PROXY_MODE_DETECT)
 	{
-		if (!freerdp_settings_set_bool(settings, FreeRDP_GatewayEnabled, TRUE) ||
-		    !freerdp_settings_set_bool(settings, FreeRDP_GatewayBypassLocal, TRUE))
-			return FALSE;
+		freerdp_set_param_bool(settings, FreeRDP_GatewayEnabled, TRUE);
+		freerdp_set_param_bool(settings, FreeRDP_GatewayBypassLocal, TRUE);
 	}
 	else if (GatewayUsageMethod == TSC_PROXY_MODE_DEFAULT)
 	{
@@ -726,18 +722,14 @@
 		 * which means the client attempts to use gateway group policy settings
 		 * http://technet.microsoft.com/en-us/library/cc770601.aspx
 		 */
-		if (!freerdp_settings_set_bool(settings, FreeRDP_GatewayEnabled, FALSE) ||
-		    !freerdp_settings_set_bool(settings, FreeRDP_GatewayBypassLocal, FALSE))
-			return FALSE;
+		freerdp_set_param_bool(settings, FreeRDP_GatewayEnabled, FALSE);
+		freerdp_set_param_bool(settings, FreeRDP_GatewayBypassLocal, FALSE);
 	}
 	else if (GatewayUsageMethod == TSC_PROXY_MODE_NONE_DETECT)
 	{
-		if (!freerdp_settings_set_bool(settings, FreeRDP_GatewayEnabled, FALSE) ||
-		    !freerdp_settings_set_bool(settings, FreeRDP_GatewayBypassLocal, FALSE))
-			return FALSE;
+		freerdp_set_param_bool(settings, FreeRDP_GatewayEnabled, FALSE);
+		freerdp_set_param_bool(settings, FreeRDP_GatewayBypassLocal, FALSE);
 	}
-
-	return TRUE;
 }
 
 void freerdp_update_gateway_usage_method(rdpSettings* settings, UINT32 GatewayEnabled,
@@ -755,52 +747,2042 @@
 	freerdp_set_gateway_usage_method(settings, GatewayUsageMethod);
 }
 
+/**
+ * Partially Generated Code
+ */
+
 BOOL freerdp_get_param_bool(rdpSettings* settings, int id)
 {
-	return freerdp_settings_get_bool(settings, (size_t)id);
+	switch (id)
+	{
+	case FreeRDP_ServerMode:
+		return settings->ServerMode;
+
+	case FreeRDP_NetworkAutoDetect:
+		return settings->NetworkAutoDetect;
+
+	case FreeRDP_SupportAsymetricKeys:
+		return settings->SupportAsymetricKeys;
+
+	case FreeRDP_SupportErrorInfoPdu:
+		return settings->SupportErrorInfoPdu;
+
+	case FreeRDP_SupportStatusInfoPdu:
+		return settings->SupportStatusInfoPdu;
+
+	case FreeRDP_SupportMonitorLayoutPdu:
+		return settings->SupportMonitorLayoutPdu;
+
+	case FreeRDP_SupportGraphicsPipeline:
+		return settings->SupportGraphicsPipeline;
+
+	case FreeRDP_SupportDynamicTimeZone:
+		return settings->SupportDynamicTimeZone;
+
+	case FreeRDP_UseRdpSecurityLayer:
+		return settings->UseRdpSecurityLayer;
+
+	case FreeRDP_ConsoleSession:
+		return settings->ConsoleSession;
+
+	case FreeRDP_SpanMonitors:
+		return settings->SpanMonitors;
+
+	case FreeRDP_UseMultimon:
+		return settings->UseMultimon;
+
+	case FreeRDP_ForceMultimon:
+		return settings->ForceMultimon;
+
+	case FreeRDP_AutoLogonEnabled:
+		return settings->AutoLogonEnabled;
+
+	case FreeRDP_CompressionEnabled:
+		return settings->CompressionEnabled;
+
+	case FreeRDP_DisableCtrlAltDel:
+		return settings->DisableCtrlAltDel;
+
+	case FreeRDP_EnableWindowsKey:
+		return settings->EnableWindowsKey;
+
+	case FreeRDP_MaximizeShell:
+		return settings->MaximizeShell;
+
+	case FreeRDP_LogonNotify:
+		return settings->LogonNotify;
+
+	case FreeRDP_LogonErrors:
+		return settings->LogonErrors;
+
+	case FreeRDP_MouseAttached:
+		return settings->MouseAttached;
+
+	case FreeRDP_MouseHasWheel:
+		return settings->MouseHasWheel;
+
+	case FreeRDP_RemoteConsoleAudio:
+		return settings->RemoteConsoleAudio;
+
+	case FreeRDP_AudioPlayback:
+		return settings->AudioPlayback;
+
+	case FreeRDP_AudioCapture:
+		return settings->AudioCapture;
+
+	case FreeRDP_VideoDisable:
+		return settings->VideoDisable;
+
+	case FreeRDP_PasswordIsSmartcardPin:
+		return settings->PasswordIsSmartcardPin;
+
+	case FreeRDP_UsingSavedCredentials:
+		return settings->UsingSavedCredentials;
+
+	case FreeRDP_ForceEncryptedCsPdu:
+		return settings->ForceEncryptedCsPdu;
+
+	case FreeRDP_HiDefRemoteApp:
+		return settings->HiDefRemoteApp;
+
+	case FreeRDP_IPv6Enabled:
+		return settings->IPv6Enabled;
+
+	case FreeRDP_AutoReconnectionEnabled:
+		return settings->AutoReconnectionEnabled;
+
+	case FreeRDP_DynamicDaylightTimeDisabled:
+		return settings->DynamicDaylightTimeDisabled;
+
+	case FreeRDP_AllowFontSmoothing:
+		return settings->AllowFontSmoothing;
+
+	case FreeRDP_DisableWallpaper:
+		return settings->DisableWallpaper;
+
+	case FreeRDP_DisableFullWindowDrag:
+		return settings->DisableFullWindowDrag;
+
+	case FreeRDP_DisableMenuAnims:
+		return settings->DisableMenuAnims;
+
+	case FreeRDP_DisableThemes:
+		return settings->DisableThemes;
+
+	case FreeRDP_DisableCursorShadow:
+		return settings->DisableCursorShadow;
+
+	case FreeRDP_DisableCursorBlinking:
+		return settings->DisableCursorBlinking;
+
+	case FreeRDP_AllowDesktopComposition:
+		return settings->AllowDesktopComposition;
+
+	case FreeRDP_RemoteAssistanceMode:
+		return settings->RemoteAssistanceMode;
+
+	case FreeRDP_TlsSecurity:
+		return settings->TlsSecurity;
+
+	case FreeRDP_NlaSecurity:
+		return settings->NlaSecurity;
+
+	case FreeRDP_RdpSecurity:
+		return settings->RdpSecurity;
+
+	case FreeRDP_ExtSecurity:
+		return settings->ExtSecurity;
+
+	case FreeRDP_Authentication:
+		return settings->Authentication;
+
+	case FreeRDP_NegotiateSecurityLayer:
+		return settings->NegotiateSecurityLayer;
+
+	case FreeRDP_RestrictedAdminModeRequired:
+		return settings->RestrictedAdminModeRequired;
+
+	case FreeRDP_DisableCredentialsDelegation:
+		return settings->DisableCredentialsDelegation;
+
+	case FreeRDP_AuthenticationLevel:
+		return settings->AuthenticationLevel;
+
+	case FreeRDP_VmConnectMode:
+		return settings->VmConnectMode;
+
+	case FreeRDP_MstscCookieMode:
+		return settings->MstscCookieMode;
+
+	case FreeRDP_SendPreconnectionPdu:
+		return settings->SendPreconnectionPdu;
+
+	case FreeRDP_IgnoreCertificate:
+		return settings->IgnoreCertificate;
+
+	case FreeRDP_AutoAcceptCertificate:
+		return settings->AutoAcceptCertificate;
+
+	case FreeRDP_ExternalCertificateManagement:
+		return settings->ExternalCertificateManagement;
+
+	case FreeRDP_FIPSMode:
+		return settings->FIPSMode;
+
+	case FreeRDP_Workarea:
+		return settings->Workarea;
+
+	case FreeRDP_Fullscreen:
+		return settings->Fullscreen;
+
+	case FreeRDP_GrabKeyboard:
+		return settings->GrabKeyboard;
+
+	case FreeRDP_Decorations:
+		return settings->Decorations;
+
+	case FreeRDP_SmartSizing:
+		return settings->SmartSizing;
+
+	case FreeRDP_MouseMotion:
+		return settings->MouseMotion;
+
+	case FreeRDP_AsyncInput:
+		return settings->AsyncInput;
+
+	case FreeRDP_AsyncUpdate:
+		return settings->AsyncUpdate;
+
+	case FreeRDP_AsyncChannels:
+		return settings->AsyncChannels;
+
+	case FreeRDP_ToggleFullscreen:
+		return settings->ToggleFullscreen;
+
+	case FreeRDP_SoftwareGdi:
+		return settings->SoftwareGdi;
+
+	case FreeRDP_LocalConnection:
+		return settings->LocalConnection;
+
+	case FreeRDP_AuthenticationOnly:
+		return settings->AuthenticationOnly;
+
+	case FreeRDP_CredentialsFromStdin:
+		return settings->CredentialsFromStdin;
+
+	case FreeRDP_DumpRemoteFx:
+		return settings->DumpRemoteFx;
+
+	case FreeRDP_PlayRemoteFx:
+		return settings->PlayRemoteFx;
+
+	case FreeRDP_GatewayUseSameCredentials:
+		return settings->GatewayUseSameCredentials;
+
+	case FreeRDP_GatewayEnabled:
+		return settings->GatewayEnabled;
+
+	case FreeRDP_GatewayBypassLocal:
+		return settings->GatewayBypassLocal;
+
+	case FreeRDP_GatewayRpcTransport:
+		return settings->GatewayRpcTransport;
+
+	case FreeRDP_GatewayHttpTransport:
+		return settings->GatewayHttpTransport;
+
+	case FreeRDP_GatewayUdpTransport:
+		return settings->GatewayUdpTransport;
+
+	case FreeRDP_RemoteApplicationMode:
+		return settings->RemoteApplicationMode;
+
+	case FreeRDP_DisableRemoteAppCapsCheck:
+		return settings->DisableRemoteAppCapsCheck;
+
+	case FreeRDP_RemoteAppLanguageBarSupported:
+		return settings->RemoteAppLanguageBarSupported;
+
+	case FreeRDP_RefreshRect:
+		return settings->RefreshRect;
+
+	case FreeRDP_SuppressOutput:
+		return settings->SuppressOutput;
+
+	case FreeRDP_FastPathOutput:
+		return settings->FastPathOutput;
+
+	case FreeRDP_SaltedChecksum:
+		return settings->SaltedChecksum;
+
+	case FreeRDP_LongCredentialsSupported:
+		return settings->LongCredentialsSupported;
+
+	case FreeRDP_NoBitmapCompressionHeader:
+		return settings->NoBitmapCompressionHeader;
+
+	case FreeRDP_BitmapCompressionDisabled:
+		return settings->BitmapCompressionDisabled;
+
+	case FreeRDP_DesktopResize:
+		return settings->DesktopResize;
+
+	case FreeRDP_DrawAllowDynamicColorFidelity:
+		return settings->DrawAllowDynamicColorFidelity;
+
+	case FreeRDP_DrawAllowColorSubsampling:
+		return settings->DrawAllowColorSubsampling;
+
+	case FreeRDP_DrawAllowSkipAlpha:
+		return settings->DrawAllowSkipAlpha;
+
+	case FreeRDP_BitmapCacheV3Enabled:
+		return settings->BitmapCacheV3Enabled;
+
+	case FreeRDP_AltSecFrameMarkerSupport:
+		return settings->AltSecFrameMarkerSupport;
+
+	case FreeRDP_BitmapCacheEnabled:
+		return settings->BitmapCacheEnabled;
+
+	case FreeRDP_AllowCacheWaitingList:
+		return settings->AllowCacheWaitingList;
+
+	case FreeRDP_BitmapCachePersistEnabled:
+		return settings->BitmapCachePersistEnabled;
+
+	case FreeRDP_ColorPointerFlag:
+		return settings->ColorPointerFlag;
+
+	case FreeRDP_UnicodeInput:
+		return settings->UnicodeInput;
+
+	case FreeRDP_FastPathInput:
+		return settings->FastPathInput;
+
+	case FreeRDP_MultiTouchInput:
+		return settings->MultiTouchInput;
+
+	case FreeRDP_MultiTouchGestures:
+		return settings->MultiTouchGestures;
+
+	case FreeRDP_SoundBeepsEnabled:
+		return settings->SoundBeepsEnabled;
+
+	case FreeRDP_SurfaceCommandsEnabled:
+		return settings->SurfaceCommandsEnabled;
+
+	case FreeRDP_FrameMarkerCommandEnabled:
+		return settings->FrameMarkerCommandEnabled;
+
+	case FreeRDP_RemoteFxOnly:
+		return settings->RemoteFxOnly;
+
+	case FreeRDP_RemoteFxCodec:
+		return settings->RemoteFxCodec;
+
+	case FreeRDP_RemoteFxImageCodec:
+		return settings->RemoteFxImageCodec;
+
+	case FreeRDP_NSCodec:
+		return settings->NSCodec;
+
+	case FreeRDP_NSCodecAllowSubsampling:
+		return settings->NSCodecAllowSubsampling;
+
+	case FreeRDP_NSCodecAllowDynamicColorFidelity:
+		return settings->NSCodecAllowDynamicColorFidelity;
+
+	case FreeRDP_JpegCodec:
+		return settings->JpegCodec;
+
+	case FreeRDP_GfxThinClient:
+		return settings->GfxThinClient;
+
+	case FreeRDP_GfxSmallCache:
+		return settings->GfxSmallCache;
+
+	case FreeRDP_GfxProgressive:
+		return settings->GfxProgressive;
+
+	case FreeRDP_GfxProgressiveV2:
+		return settings->GfxProgressiveV2;
+
+	case FreeRDP_GfxH264:
+		return settings->GfxH264;
+
+	case FreeRDP_GfxAVC444:
+		return settings->GfxAVC444;
+
+	case FreeRDP_DrawNineGridEnabled:
+		return settings->DrawNineGridEnabled;
+
+	case FreeRDP_DrawGdiPlusEnabled:
+		return settings->DrawGdiPlusEnabled;
+
+	case FreeRDP_DrawGdiPlusCacheEnabled:
+		return settings->DrawGdiPlusCacheEnabled;
+
+	case FreeRDP_DeviceRedirection:
+		return settings->DeviceRedirection;
+
+	case FreeRDP_RedirectDrives:
+		return settings->RedirectDrives;
+
+	case FreeRDP_RedirectHomeDrive:
+		return settings->RedirectHomeDrive;
+
+	case FreeRDP_RedirectSmartCards:
+		return settings->RedirectSmartCards;
+
+	case FreeRDP_RedirectPrinters:
+		return settings->RedirectPrinters;
+
+	case FreeRDP_RedirectSerialPorts:
+		return settings->RedirectSerialPorts;
+
+	case FreeRDP_RedirectParallelPorts:
+		return settings->RedirectParallelPorts;
+
+	case FreeRDP_RedirectClipboard:
+		return settings->RedirectClipboard;
+
+	case FreeRDP_SmartcardLogon:
+		return settings->SmartcardLogon;
+
+	default:
+		WLog_ERR(TAG, "freerdp_get_param_bool: unknown id: %d", id);
+		return -1;
+	}
 }
 
 int freerdp_set_param_bool(rdpSettings* settings, int id, BOOL param)
 {
-	return freerdp_settings_set_bool(settings, (size_t)id, param) ? 0 : -1;
+	switch (id)
+	{
+	case FreeRDP_ServerMode:
+		settings->ServerMode = param;
+		break;
+
+	case FreeRDP_NetworkAutoDetect:
+		settings->NetworkAutoDetect = param;
+		break;
+
+	case FreeRDP_SupportAsymetricKeys:
+		settings->SupportAsymetricKeys = param;
+		break;
+
+	case FreeRDP_SupportErrorInfoPdu:
+		settings->SupportErrorInfoPdu = param;
+		break;
+
+	case FreeRDP_SupportStatusInfoPdu:
+		settings->SupportStatusInfoPdu = param;
+		break;
+
+	case FreeRDP_SupportMonitorLayoutPdu:
+		settings->SupportMonitorLayoutPdu = param;
+		break;
+
+	case FreeRDP_SupportGraphicsPipeline:
+		settings->SupportGraphicsPipeline = param;
+		break;
+
+	case FreeRDP_SupportDynamicTimeZone:
+		settings->SupportDynamicTimeZone = param;
+		break;
+
+	case FreeRDP_UseRdpSecurityLayer:
+		settings->UseRdpSecurityLayer = param;
+		break;
+
+	case FreeRDP_ConsoleSession:
+		settings->ConsoleSession = param;
+		break;
+
+	case FreeRDP_SpanMonitors:
+		settings->SpanMonitors = param;
+		break;
+
+	case FreeRDP_UseMultimon:
+		settings->UseMultimon = param;
+		break;
+
+	case FreeRDP_ForceMultimon:
+		settings->ForceMultimon = param;
+		break;
+
+	case FreeRDP_AutoLogonEnabled:
+		settings->AutoLogonEnabled = param;
+		break;
+
+	case FreeRDP_CompressionEnabled:
+		settings->CompressionEnabled = param;
+		break;
+
+	case FreeRDP_DisableCtrlAltDel:
+		settings->DisableCtrlAltDel = param;
+		break;
+
+	case FreeRDP_EnableWindowsKey:
+		settings->EnableWindowsKey = param;
+		break;
+
+	case FreeRDP_MaximizeShell:
+		settings->MaximizeShell = param;
+		break;
+
+	case FreeRDP_LogonNotify:
+		settings->LogonNotify = param;
+		break;
+
+	case FreeRDP_LogonErrors:
+		settings->LogonErrors = param;
+		break;
+
+	case FreeRDP_MouseAttached:
+		settings->MouseAttached = param;
+		break;
+
+	case FreeRDP_MouseHasWheel:
+		settings->MouseHasWheel = param;
+		break;
+
+	case FreeRDP_RemoteConsoleAudio:
+		settings->RemoteConsoleAudio = param;
+		break;
+
+	case FreeRDP_AudioPlayback:
+		settings->AudioPlayback = param;
+		break;
+
+	case FreeRDP_AudioCapture:
+		settings->AudioCapture = param;
+		break;
+
+	case FreeRDP_VideoDisable:
+		settings->VideoDisable = param;
+		break;
+
+	case FreeRDP_PasswordIsSmartcardPin:
+		settings->PasswordIsSmartcardPin = param;
+		break;
+
+	case FreeRDP_UsingSavedCredentials:
+		settings->UsingSavedCredentials = param;
+		break;
+
+	case FreeRDP_ForceEncryptedCsPdu:
+		settings->ForceEncryptedCsPdu = param;
+		break;
+
+	case FreeRDP_HiDefRemoteApp:
+		settings->HiDefRemoteApp = param;
+		break;
+
+	case FreeRDP_IPv6Enabled:
+		settings->IPv6Enabled = param;
+		break;
+
+	case FreeRDP_AutoReconnectionEnabled:
+		settings->AutoReconnectionEnabled = param;
+		break;
+
+	case FreeRDP_DynamicDaylightTimeDisabled:
+		settings->DynamicDaylightTimeDisabled = param;
+		break;
+
+	case FreeRDP_AllowFontSmoothing:
+		settings->AllowFontSmoothing = param;
+		break;
+
+	case FreeRDP_DisableWallpaper:
+		settings->DisableWallpaper = param;
+		break;
+
+	case FreeRDP_DisableFullWindowDrag:
+		settings->DisableFullWindowDrag = param;
+		break;
+
+	case FreeRDP_DisableMenuAnims:
+		settings->DisableMenuAnims = param;
+		break;
+
+	case FreeRDP_DisableThemes:
+		settings->DisableThemes = param;
+		break;
+
+	case FreeRDP_DisableCursorShadow:
+		settings->DisableCursorShadow = param;
+		break;
+
+	case FreeRDP_DisableCursorBlinking:
+		settings->DisableCursorBlinking = param;
+		break;
+
+	case FreeRDP_AllowDesktopComposition:
+		settings->AllowDesktopComposition = param;
+		break;
+
+	case FreeRDP_RemoteAssistanceMode:
+		settings->RemoteAssistanceMode = param;
+		break;
+
+	case FreeRDP_TlsSecurity:
+		settings->TlsSecurity = param;
+		break;
+
+	case FreeRDP_NlaSecurity:
+		settings->NlaSecurity = param;
+		break;
+
+	case FreeRDP_RdpSecurity:
+		settings->RdpSecurity = param;
+		break;
+
+	case FreeRDP_ExtSecurity:
+		settings->ExtSecurity = param;
+		break;
+
+	case FreeRDP_Authentication:
+		settings->Authentication = param;
+		break;
+
+	case FreeRDP_NegotiateSecurityLayer:
+		settings->NegotiateSecurityLayer = param;
+		break;
+
+	case FreeRDP_RestrictedAdminModeRequired:
+		settings->RestrictedAdminModeRequired = param;
+		break;
+
+	case FreeRDP_DisableCredentialsDelegation:
+		settings->DisableCredentialsDelegation = param;
+		break;
+
+	case FreeRDP_AuthenticationLevel:
+		settings->AuthenticationLevel = param;
+		break;
+
+	case FreeRDP_VmConnectMode:
+		settings->VmConnectMode = param;
+		break;
+
+	case FreeRDP_MstscCookieMode:
+		settings->MstscCookieMode = param;
+		break;
+
+	case FreeRDP_SendPreconnectionPdu:
+		settings->SendPreconnectionPdu = param;
+		break;
+
+	case FreeRDP_IgnoreCertificate:
+		settings->IgnoreCertificate = param;
+		break;
+
+	case FreeRDP_AutoAcceptCertificate:
+		settings->AutoAcceptCertificate = param;
+		break;
+
+	case FreeRDP_ExternalCertificateManagement:
+		settings->ExternalCertificateManagement = param;
+		break;
+
+	case FreeRDP_FIPSMode:
+		settings->FIPSMode = param;
+		break;
+
+	case FreeRDP_Workarea:
+		settings->Workarea = param;
+		break;
+
+	case FreeRDP_Fullscreen:
+		settings->Fullscreen = param;
+		break;
+
+	case FreeRDP_GrabKeyboard:
+		settings->GrabKeyboard = param;
+		break;
+
+	case FreeRDP_Decorations:
+		settings->Decorations = param;
+		break;
+
+	case FreeRDP_SmartSizing:
+		settings->SmartSizing = param;
+		break;
+
+	case FreeRDP_MouseMotion:
+		settings->MouseMotion = param;
+		break;
+
+	case FreeRDP_AsyncInput:
+		settings->AsyncInput = param;
+		break;
+
+	case FreeRDP_AsyncUpdate:
+		settings->AsyncUpdate = param;
+		break;
+
+	case FreeRDP_AsyncChannels:
+		settings->AsyncChannels = param;
+		break;
+
+	case FreeRDP_ToggleFullscreen:
+		settings->ToggleFullscreen = param;
+		break;
+
+	case FreeRDP_SoftwareGdi:
+		settings->SoftwareGdi = param;
+		break;
+
+	case FreeRDP_LocalConnection:
+		settings->LocalConnection = param;
+		break;
+
+	case FreeRDP_AuthenticationOnly:
+		settings->AuthenticationOnly = param;
+		break;
+
+	case FreeRDP_CredentialsFromStdin:
+		settings->CredentialsFromStdin = param;
+		break;
+
+	case FreeRDP_DumpRemoteFx:
+		settings->DumpRemoteFx = param;
+		break;
+
+	case FreeRDP_PlayRemoteFx:
+		settings->PlayRemoteFx = param;
+		break;
+
+	case FreeRDP_GatewayUseSameCredentials:
+		settings->GatewayUseSameCredentials = param;
+		break;
+
+	case FreeRDP_GatewayEnabled:
+		settings->GatewayEnabled = param;
+		break;
+
+	case FreeRDP_GatewayBypassLocal:
+		settings->GatewayBypassLocal = param;
+		break;
+
+	case FreeRDP_GatewayRpcTransport:
+		settings->GatewayRpcTransport = param;
+		break;
+
+	case FreeRDP_GatewayHttpTransport:
+		settings->GatewayHttpTransport = param;
+		break;
+
+	case FreeRDP_GatewayUdpTransport:
+		settings->GatewayUdpTransport = param;
+		break;
+
+	case FreeRDP_RemoteApplicationMode:
+		settings->RemoteApplicationMode = param;
+		break;
+
+	case FreeRDP_DisableRemoteAppCapsCheck:
+		settings->DisableRemoteAppCapsCheck = param;
+		break;
+
+	case FreeRDP_RemoteAppLanguageBarSupported:
+		settings->RemoteAppLanguageBarSupported = param;
+		break;
+
+	case FreeRDP_RefreshRect:
+		settings->RefreshRect = param;
+		break;
+
+	case FreeRDP_SuppressOutput:
+		settings->SuppressOutput = param;
+		break;
+
+	case FreeRDP_FastPathOutput:
+		settings->FastPathOutput = param;
+		break;
+
+	case FreeRDP_SaltedChecksum:
+		settings->SaltedChecksum = param;
+		break;
+
+	case FreeRDP_LongCredentialsSupported:
+		settings->LongCredentialsSupported = param;
+		break;
+
+	case FreeRDP_NoBitmapCompressionHeader:
+		settings->NoBitmapCompressionHeader = param;
+		break;
+
+	case FreeRDP_BitmapCompressionDisabled:
+		settings->BitmapCompressionDisabled = param;
+		break;
+
+	case FreeRDP_DesktopResize:
+		settings->DesktopResize = param;
+		break;
+
+	case FreeRDP_DrawAllowDynamicColorFidelity:
+		settings->DrawAllowDynamicColorFidelity = param;
+		break;
+
+	case FreeRDP_DrawAllowColorSubsampling:
+		settings->DrawAllowColorSubsampling = param;
+		break;
+
+	case FreeRDP_DrawAllowSkipAlpha:
+		settings->DrawAllowSkipAlpha = param;
+		break;
+
+	case FreeRDP_BitmapCacheV3Enabled:
+		settings->BitmapCacheV3Enabled = param;
+		break;
+
+	case FreeRDP_AltSecFrameMarkerSupport:
+		settings->AltSecFrameMarkerSupport = param;
+		break;
+
+	case FreeRDP_BitmapCacheEnabled:
+		settings->BitmapCacheEnabled = param;
+		break;
+
+	case FreeRDP_AllowCacheWaitingList:
+		settings->AllowCacheWaitingList = param;
+		break;
+
+	case FreeRDP_BitmapCachePersistEnabled:
+		settings->BitmapCachePersistEnabled = param;
+		break;
+
+	case FreeRDP_ColorPointerFlag:
+		settings->ColorPointerFlag = param;
+		break;
+
+	case FreeRDP_UnicodeInput:
+		settings->UnicodeInput = param;
+		break;
+
+	case FreeRDP_FastPathInput:
+		settings->FastPathInput = param;
+		break;
+
+	case FreeRDP_MultiTouchInput:
+		settings->MultiTouchInput = param;
+		break;
+
+	case FreeRDP_MultiTouchGestures:
+		settings->MultiTouchGestures = param;
+		break;
+
+	case FreeRDP_SoundBeepsEnabled:
+		settings->SoundBeepsEnabled = param;
+		break;
+
+	case FreeRDP_SurfaceCommandsEnabled:
+		settings->SurfaceCommandsEnabled = param;
+		break;
+
+	case FreeRDP_FrameMarkerCommandEnabled:
+		settings->FrameMarkerCommandEnabled = param;
+		break;
+
+	case FreeRDP_RemoteFxOnly:
+		settings->RemoteFxOnly = param;
+		break;
+
+	case FreeRDP_RemoteFxCodec:
+		settings->RemoteFxCodec = param;
+		break;
+
+	case FreeRDP_RemoteFxImageCodec:
+		settings->RemoteFxImageCodec = param;
+		break;
+
+	case FreeRDP_NSCodec:
+		settings->NSCodec = param;
+		break;
+
+	case FreeRDP_NSCodecAllowSubsampling:
+		settings->NSCodecAllowSubsampling = param;
+		break;
+
+	case FreeRDP_NSCodecAllowDynamicColorFidelity:
+		settings->NSCodecAllowDynamicColorFidelity = param;
+		break;
+
+	case FreeRDP_JpegCodec:
+		settings->JpegCodec = param;
+		break;
+
+	case FreeRDP_GfxThinClient:
+		settings->GfxThinClient = param;
+		break;
+
+	case FreeRDP_GfxSmallCache:
+		settings->GfxSmallCache = param;
+		break;
+
+	case FreeRDP_GfxProgressive:
+		settings->GfxProgressive = param;
+		break;
+
+	case FreeRDP_GfxProgressiveV2:
+		settings->GfxProgressiveV2 = param;
+		break;
+
+	case FreeRDP_GfxH264:
+		settings->GfxH264 = param;
+		break;
+
+	case FreeRDP_GfxAVC444:
+		settings->GfxAVC444 = param;
+		break;
+
+	case FreeRDP_GfxSendQoeAck:
+		settings->GfxSendQoeAck = param;
+		break;
+
+	case FreeRDP_DrawNineGridEnabled:
+		settings->DrawNineGridEnabled = param;
+		break;
+
+	case FreeRDP_DrawGdiPlusEnabled:
+		settings->DrawGdiPlusEnabled = param;
+		break;
+
+	case FreeRDP_DrawGdiPlusCacheEnabled:
+		settings->DrawGdiPlusCacheEnabled = param;
+		break;
+
+	case FreeRDP_DeviceRedirection:
+		settings->DeviceRedirection = param;
+		break;
+
+	case FreeRDP_RedirectDrives:
+		settings->RedirectDrives = param;
+		break;
+
+	case FreeRDP_RedirectHomeDrive:
+		settings->RedirectHomeDrive = param;
+		break;
+
+	case FreeRDP_RedirectSmartCards:
+		settings->RedirectSmartCards = param;
+		break;
+
+	case FreeRDP_RedirectPrinters:
+		settings->RedirectPrinters = param;
+		break;
+
+	case FreeRDP_RedirectSerialPorts:
+		settings->RedirectSerialPorts = param;
+		break;
+
+	case FreeRDP_RedirectParallelPorts:
+		settings->RedirectParallelPorts = param;
+		break;
+
+	case FreeRDP_RedirectClipboard:
+		settings->RedirectClipboard = param;
+		break;
+
+	case FreeRDP_SmartcardLogon:
+		settings->SmartcardLogon = param;
+		break;
+
+	default:
+		WLog_ERR(TAG, "freerdp_set_param_bool: unknown id %d (param = %" PRId32 ")", id, param);
+		return -1;
+	}
+
+	/* Mark field as modified */
+	settings->SettingsModified[id] = 1;
+	return -1;
 }
 
 int freerdp_get_param_int(rdpSettings* settings, int id)
 {
-	return freerdp_settings_get_int32(settings, (size_t)id);
+	switch (id)
+	{
+	case FreeRDP_XPan:
+		return settings->XPan;
+
+	case FreeRDP_YPan:
+		return settings->YPan;
+
+	default:
+		WLog_ERR(TAG, "freerdp_get_param_int: unknown id: %d", id);
+		return 0;
+	}
 }
 
 int freerdp_set_param_int(rdpSettings* settings, int id, int param)
 {
-	return freerdp_settings_set_int32(settings, (size_t)id, param) ? 0 : -1;
+	switch (id)
+	{
+	case FreeRDP_XPan:
+		settings->XPan = param;
+		break;
+
+	case FreeRDP_YPan:
+		settings->YPan = param;
+		break;
+
+	default:
+		WLog_ERR(TAG, "freerdp_set_param_int: unknown id %d (param = %d)", id, param);
+		return -1;
+	}
+
+	settings->SettingsModified[id] = 1;
+	return 0;
 }
 
 UINT32 freerdp_get_param_uint32(rdpSettings* settings, int id)
 {
-	return freerdp_settings_get_uint32(settings, (size_t)id);
+	switch (id)
+	{
+	case FreeRDP_ShareId:
+		return settings->ShareId;
+
+	case FreeRDP_PduSource:
+		return settings->PduSource;
+
+	case FreeRDP_ServerPort:
+		return settings->ServerPort;
+
+	case FreeRDP_RdpVersion:
+		return settings->RdpVersion;
+
+	case FreeRDP_DesktopWidth:
+		return settings->DesktopWidth;
+
+	case FreeRDP_DesktopHeight:
+		return settings->DesktopHeight;
+
+	case FreeRDP_ColorDepth:
+		return settings->ColorDepth;
+
+	case FreeRDP_ConnectionType:
+		return settings->ConnectionType;
+
+	case FreeRDP_ClientBuild:
+		return settings->ClientBuild;
+
+	case FreeRDP_EarlyCapabilityFlags:
+		return settings->EarlyCapabilityFlags;
+
+	case FreeRDP_EncryptionMethods:
+		return settings->EncryptionMethods;
+
+	case FreeRDP_ExtEncryptionMethods:
+		return settings->ExtEncryptionMethods;
+
+	case FreeRDP_EncryptionLevel:
+		return settings->EncryptionLevel;
+
+	case FreeRDP_ServerRandomLength:
+		return settings->ServerRandomLength;
+
+	case FreeRDP_ClientRandomLength:
+		return settings->ClientRandomLength;
+
+	case FreeRDP_ChannelCount:
+		return settings->ChannelCount;
+
+	case FreeRDP_ChannelDefArraySize:
+		return settings->ChannelDefArraySize;
+
+	case FreeRDP_ClusterInfoFlags:
+		return settings->ClusterInfoFlags;
+
+	case FreeRDP_RedirectedSessionId:
+		return settings->RedirectedSessionId;
+
+	case FreeRDP_MonitorDefArraySize:
+		return settings->MonitorDefArraySize;
+
+	case FreeRDP_DesktopPosX:
+		return settings->DesktopPosX;
+
+	case FreeRDP_DesktopPosY:
+		return settings->DesktopPosY;
+
+	case FreeRDP_MultitransportFlags:
+		return settings->MultitransportFlags;
+
+	case FreeRDP_CompressionLevel:
+		return settings->CompressionLevel;
+
+	case FreeRDP_AutoReconnectMaxRetries:
+		return settings->AutoReconnectMaxRetries;
+
+	case FreeRDP_PerformanceFlags:
+		return settings->PerformanceFlags;
+
+	case FreeRDP_RequestedProtocols:
+		return settings->RequestedProtocols;
+
+	case FreeRDP_SelectedProtocol:
+		return settings->SelectedProtocol;
+
+	case FreeRDP_NegotiationFlags:
+		return settings->NegotiationFlags;
+
+	case FreeRDP_CookieMaxLength:
+		return settings->CookieMaxLength;
+
+	case FreeRDP_PreconnectionId:
+		return settings->PreconnectionId;
+
+	case FreeRDP_RedirectionFlags:
+		return settings->RedirectionFlags;
+
+	case FreeRDP_LoadBalanceInfoLength:
+		return settings->LoadBalanceInfoLength;
+
+	case FreeRDP_RedirectionPasswordLength:
+		return settings->RedirectionPasswordLength;
+
+	case FreeRDP_RedirectionTsvUrlLength:
+		return settings->RedirectionTsvUrlLength;
+
+	case FreeRDP_TargetNetAddressCount:
+		return settings->TargetNetAddressCount;
+
+	case FreeRDP_PercentScreen:
+		return settings->PercentScreen;
+
+	case FreeRDP_PercentScreenUseWidth:
+		return settings->PercentScreenUseWidth;
+
+	case FreeRDP_PercentScreenUseHeight:
+		return settings->PercentScreenUseHeight;
+
+	case FreeRDP_GatewayUsageMethod:
+		return settings->GatewayUsageMethod;
+
+	case FreeRDP_GatewayPort:
+		return settings->GatewayPort;
+
+	case FreeRDP_GatewayCredentialsSource:
+		return settings->GatewayCredentialsSource;
+
+	case FreeRDP_ProxyType:
+		return settings->ProxyType;
+
+	case FreeRDP_ProxyPort:
+		return settings->ProxyPort;
+
+	case FreeRDP_RemoteAppNumIconCaches:
+		return settings->RemoteAppNumIconCaches;
+
+	case FreeRDP_RemoteAppNumIconCacheEntries:
+		return settings->RemoteAppNumIconCacheEntries;
+
+	case FreeRDP_ReceivedCapabilitiesSize:
+		return settings->ReceivedCapabilitiesSize;
+
+	case FreeRDP_OsMajorType:
+		return settings->OsMajorType;
+
+	case FreeRDP_OsMinorType:
+		return settings->OsMinorType;
+
+	case FreeRDP_BitmapCacheVersion:
+		return settings->BitmapCacheVersion;
+
+	case FreeRDP_BitmapCacheV2NumCells:
+		return settings->BitmapCacheV2NumCells;
+
+	case FreeRDP_PointerCacheSize:
+		return settings->PointerCacheSize;
+
+	case FreeRDP_KeyboardLayout:
+		return settings->KeyboardLayout;
+
+	case FreeRDP_KeyboardType:
+		return settings->KeyboardType;
+
+	case FreeRDP_KeyboardSubType:
+		return settings->KeyboardSubType;
+
+	case FreeRDP_KeyboardFunctionKey:
+		return settings->KeyboardFunctionKey;
+
+	case FreeRDP_KeyboardHook:
+		return settings->KeyboardHook;
+		break;
+
+	case FreeRDP_BrushSupportLevel:
+		return settings->BrushSupportLevel;
+
+	case FreeRDP_GlyphSupportLevel:
+		return settings->GlyphSupportLevel;
+
+	case FreeRDP_OffscreenSupportLevel:
+		return settings->OffscreenSupportLevel;
+
+	case FreeRDP_OffscreenCacheSize:
+		return settings->OffscreenCacheSize;
+
+	case FreeRDP_OffscreenCacheEntries:
+		return settings->OffscreenCacheEntries;
+
+	case FreeRDP_VirtualChannelCompressionFlags:
+		return settings->VirtualChannelCompressionFlags;
+
+	case FreeRDP_VirtualChannelChunkSize:
+		return settings->VirtualChannelChunkSize;
+
+	case FreeRDP_MultifragMaxRequestSize:
+		return settings->MultifragMaxRequestSize;
+
+	case FreeRDP_LargePointerFlag:
+		return settings->LargePointerFlag;
+
+	case FreeRDP_CompDeskSupportLevel:
+		return settings->CompDeskSupportLevel;
+
+	case FreeRDP_RemoteFxCodecId:
+		return settings->RemoteFxCodecId;
+
+	case FreeRDP_RemoteFxCodecMode:
+		return settings->RemoteFxCodecMode;
+
+	case FreeRDP_NSCodecId:
+		return settings->NSCodecId;
+
+	case FreeRDP_FrameAcknowledge:
+		return settings->FrameAcknowledge;
+
+	case FreeRDP_NSCodecColorLossLevel:
+		return settings->NSCodecColorLossLevel;
+
+	case FreeRDP_JpegCodecId:
+		return settings->JpegCodecId;
+
+	case FreeRDP_JpegQuality:
+		return settings->JpegQuality;
+
+	case FreeRDP_BitmapCacheV3CodecId:
+		return settings->BitmapCacheV3CodecId;
+
+	case FreeRDP_DrawNineGridCacheSize:
+		return settings->DrawNineGridCacheSize;
+
+	case FreeRDP_DrawNineGridCacheEntries:
+		return settings->DrawNineGridCacheEntries;
+
+	case FreeRDP_DeviceCount:
+		return settings->DeviceCount;
+
+	case FreeRDP_DeviceArraySize:
+		return settings->DeviceArraySize;
+
+	case FreeRDP_StaticChannelCount:
+		return settings->StaticChannelCount;
+
+	case FreeRDP_StaticChannelArraySize:
+		return settings->StaticChannelArraySize;
+
+	case FreeRDP_DynamicChannelCount:
+		return settings->DynamicChannelCount;
+
+	case FreeRDP_DynamicChannelArraySize:
+		return settings->DynamicChannelArraySize;
+
+	case FreeRDP_SmartSizingWidth:
+		return settings->SmartSizingWidth;
+
+	case FreeRDP_SmartSizingHeight:
+		return settings->SmartSizingHeight;
+
+	case FreeRDP_TlsSecLevel:
+		return settings->TlsSecLevel;
+
+	default:
+		WLog_ERR(TAG, "freerdp_get_param_uint32: unknown id: %d", id);
+		return 0;
+	}
 }
 
 int freerdp_set_param_uint32(rdpSettings* settings, int id, UINT32 param)
 {
-	return freerdp_settings_set_uint32(settings, (size_t)id, param) ? 0 : -1;
+	switch (id)
+	{
+	case FreeRDP_ShareId:
+		settings->ShareId = param;
+		break;
+
+	case FreeRDP_PduSource:
+		settings->PduSource = param;
+		break;
+
+	case FreeRDP_ServerPort:
+		settings->ServerPort = param;
+		break;
+
+	case FreeRDP_RdpVersion:
+		settings->RdpVersion = param;
+		break;
+
+	case FreeRDP_DesktopWidth:
+		settings->DesktopWidth = param;
+		break;
+
+	case FreeRDP_DesktopHeight:
+		settings->DesktopHeight = param;
+		break;
+
+	case FreeRDP_ColorDepth:
+		settings->ColorDepth = param;
+		break;
+
+	case FreeRDP_ConnectionType:
+		settings->ConnectionType = param;
+		break;
+
+	case FreeRDP_ClientBuild:
+		settings->ClientBuild = param;
+		break;
+
+	case FreeRDP_EarlyCapabilityFlags:
+		settings->EarlyCapabilityFlags = param;
+		break;
+
+	case FreeRDP_EncryptionMethods:
+		settings->EncryptionMethods = param;
+		break;
+
+	case FreeRDP_ExtEncryptionMethods:
+		settings->ExtEncryptionMethods = param;
+		break;
+
+	case FreeRDP_EncryptionLevel:
+		settings->EncryptionLevel = param;
+		break;
+
+	case FreeRDP_ServerRandomLength:
+		settings->ServerRandomLength = param;
+		break;
+
+	case FreeRDP_ClientRandomLength:
+		settings->ClientRandomLength = param;
+		break;
+
+	case FreeRDP_ChannelCount:
+		settings->ChannelCount = param;
+		break;
+
+	case FreeRDP_ChannelDefArraySize:
+		settings->ChannelDefArraySize = param;
+		break;
+
+	case FreeRDP_ClusterInfoFlags:
+		settings->ClusterInfoFlags = param;
+		break;
+
+	case FreeRDP_RedirectedSessionId:
+		settings->RedirectedSessionId = param;
+		break;
+
+	case FreeRDP_MonitorDefArraySize:
+		settings->MonitorDefArraySize = param;
+		break;
+
+	case FreeRDP_DesktopPosX:
+		settings->DesktopPosX = param;
+		break;
+
+	case FreeRDP_DesktopPosY:
+		settings->DesktopPosY = param;
+		break;
+
+	case FreeRDP_MultitransportFlags:
+		settings->MultitransportFlags = param;
+		break;
+
+	case FreeRDP_CompressionLevel:
+		settings->CompressionLevel = param;
+		break;
+
+	case FreeRDP_AutoReconnectMaxRetries:
+		settings->AutoReconnectMaxRetries = param;
+		break;
+
+	case FreeRDP_PerformanceFlags:
+		settings->PerformanceFlags = param;
+		break;
+
+	case FreeRDP_RequestedProtocols:
+		settings->RequestedProtocols = param;
+		break;
+
+	case FreeRDP_SelectedProtocol:
+		settings->SelectedProtocol = param;
+		break;
+
+	case FreeRDP_NegotiationFlags:
+		settings->NegotiationFlags = param;
+		break;
+
+	case FreeRDP_CookieMaxLength:
+		settings->CookieMaxLength = param;
+		break;
+
+	case FreeRDP_PreconnectionId:
+		settings->PreconnectionId = param;
+		break;
+
+	case FreeRDP_RedirectionFlags:
+		settings->RedirectionFlags = param;
+		break;
+
+	case FreeRDP_LoadBalanceInfoLength:
+		settings->LoadBalanceInfoLength = param;
+		break;
+
+	case FreeRDP_RedirectionPasswordLength:
+		settings->RedirectionPasswordLength = param;
+		break;
+
+	case FreeRDP_RedirectionTsvUrlLength:
+		settings->RedirectionTsvUrlLength = param;
+		break;
+
+	case FreeRDP_TargetNetAddressCount:
+		settings->TargetNetAddressCount = param;
+		break;
+
+	case FreeRDP_PercentScreen:
+		settings->PercentScreen = param;
+		break;
+
+	case FreeRDP_PercentScreenUseWidth:
+		settings->PercentScreenUseWidth = param;
+		break;
+
+	case FreeRDP_PercentScreenUseHeight:
+		settings->PercentScreenUseHeight = param;
+		break;
+
+	case FreeRDP_GatewayUsageMethod:
+		settings->GatewayUsageMethod = param;
+		break;
+
+	case FreeRDP_GatewayPort:
+		settings->GatewayPort = param;
+		break;
+
+	case FreeRDP_GatewayCredentialsSource:
+		settings->GatewayCredentialsSource = param;
+		break;
+
+	case FreeRDP_ProxyType:
+		settings->ProxyType = param;
+		break;
+
+	case FreeRDP_ProxyPort:
+		settings->ProxyPort = param;
+		break;
+
+	case FreeRDP_RemoteAppNumIconCaches:
+		settings->RemoteAppNumIconCaches = param;
+		break;
+
+	case FreeRDP_RemoteAppNumIconCacheEntries:
+		settings->RemoteAppNumIconCacheEntries = param;
+		break;
+
+	case FreeRDP_ReceivedCapabilitiesSize:
+		settings->ReceivedCapabilitiesSize = param;
+		break;
+
+	case FreeRDP_OsMajorType:
+		settings->OsMajorType = param;
+		break;
+
+	case FreeRDP_OsMinorType:
+		settings->OsMinorType = param;
+		break;
+
+	case FreeRDP_BitmapCacheVersion:
+		settings->BitmapCacheVersion = param;
+		break;
+
+	case FreeRDP_BitmapCacheV2NumCells:
+		settings->BitmapCacheV2NumCells = param;
+		break;
+
+	case FreeRDP_PointerCacheSize:
+		settings->PointerCacheSize = param;
+		break;
+
+	case FreeRDP_KeyboardLayout:
+		settings->KeyboardLayout = param;
+		break;
+
+	case FreeRDP_KeyboardType:
+		settings->KeyboardType = param;
+		break;
+
+	case FreeRDP_KeyboardSubType:
+		settings->KeyboardSubType = param;
+		break;
+
+	case FreeRDP_KeyboardFunctionKey:
+		settings->KeyboardFunctionKey = param;
+		break;
+
+	case FreeRDP_KeyboardHook:
+		settings->KeyboardHook = param;
+		break;
+
+	case FreeRDP_BrushSupportLevel:
+		settings->BrushSupportLevel = param;
+		break;
+
+	case FreeRDP_GlyphSupportLevel:
+		settings->GlyphSupportLevel = param;
+		break;
+
+	case FreeRDP_OffscreenSupportLevel:
+		settings->OffscreenSupportLevel = param;
+		break;
+
+	case FreeRDP_OffscreenCacheSize:
+		settings->OffscreenCacheSize = param;
+		break;
+
+	case FreeRDP_OffscreenCacheEntries:
+		settings->OffscreenCacheEntries = param;
+		break;
+
+	case FreeRDP_VirtualChannelCompressionFlags:
+		settings->VirtualChannelCompressionFlags = param;
+		break;
+
+	case FreeRDP_VirtualChannelChunkSize:
+		settings->VirtualChannelChunkSize = param;
+		break;
+
+	case FreeRDP_MultifragMaxRequestSize:
+		settings->MultifragMaxRequestSize = param;
+		break;
+
+	case FreeRDP_LargePointerFlag:
+		settings->LargePointerFlag = param;
+		break;
+
+	case FreeRDP_CompDeskSupportLevel:
+		settings->CompDeskSupportLevel = param;
+		break;
+
+	case FreeRDP_RemoteFxCodecId:
+		settings->RemoteFxCodecId = param;
+		break;
+
+	case FreeRDP_RemoteFxCodecMode:
+		settings->RemoteFxCodecMode = param;
+		break;
+
+	case FreeRDP_NSCodecId:
+		settings->NSCodecId = param;
+		break;
+
+	case FreeRDP_FrameAcknowledge:
+		settings->FrameAcknowledge = param;
+		break;
+
+	case FreeRDP_NSCodecColorLossLevel:
+		settings->NSCodecColorLossLevel = param;
+		break;
+
+	case FreeRDP_JpegCodecId:
+		settings->JpegCodecId = param;
+		break;
+
+	case FreeRDP_JpegQuality:
+		settings->JpegQuality = param;
+		break;
+
+	case FreeRDP_BitmapCacheV3CodecId:
+		settings->BitmapCacheV3CodecId = param;
+		break;
+
+	case FreeRDP_DrawNineGridCacheSize:
+		settings->DrawNineGridCacheSize = param;
+		break;
+
+	case FreeRDP_DrawNineGridCacheEntries:
+		settings->DrawNineGridCacheEntries = param;
+		break;
+
+	case FreeRDP_DeviceCount:
+		settings->DeviceCount = param;
+		break;
+
+	case FreeRDP_DeviceArraySize:
+		settings->DeviceArraySize = param;
+		break;
+
+	case FreeRDP_StaticChannelCount:
+		settings->StaticChannelCount = param;
+		break;
+
+	case FreeRDP_StaticChannelArraySize:
+		settings->StaticChannelArraySize = param;
+		break;
+
+	case FreeRDP_DynamicChannelCount:
+		settings->DynamicChannelCount = param;
+		break;
+
+	case FreeRDP_DynamicChannelArraySize:
+		settings->DynamicChannelArraySize = param;
+		break;
+
+	case FreeRDP_TlsSecLevel:
+		settings->TlsSecLevel = param;
+
+	default:
+		WLog_ERR(TAG, "freerdp_set_param_uint32: unknown id %d (param = %" PRIu32 ")", id, param);
+		return -1;
+	}
+
+	/* Mark field as modified */
+	settings->SettingsModified[id] = 1;
+	return 0;
 }
 
 UINT64 freerdp_get_param_uint64(rdpSettings* settings, int id)
 {
-	return freerdp_settings_get_uint64(settings, (size_t)id);
+	switch (id)
+	{
+	case FreeRDP_ParentWindowId:
+		return settings->ParentWindowId;
+
+	default:
+		WLog_ERR(TAG, "freerdp_get_param_uint64: unknown id: %d", id);
+		return -1;
+	}
 }
 
 int freerdp_set_param_uint64(rdpSettings* settings, int id, UINT64 param)
 {
-	return freerdp_settings_set_uint64(settings, (size_t)id, param) ? 0 : -1;
+	switch (id)
+	{
+	case FreeRDP_ParentWindowId:
+		settings->ParentWindowId = param;
+		break;
+
+	default:
+		WLog_ERR(TAG, "freerdp_set_param_uint64: unknown id %d (param = %" PRIu64 ")", id, param);
+		return -1;
+	}
+
+	/* Mark field as modified */
+	settings->SettingsModified[id] = 1;
+	return 0;
 }
 
 char* freerdp_get_param_string(rdpSettings* settings, int id)
 {
-	return (char*)freerdp_settings_get_string(settings, (size_t)id);
+	switch (id)
+	{
+	case FreeRDP_ServerHostname:
+		return settings->ServerHostname;
+
+	case FreeRDP_Username:
+		return settings->Username;
+
+	case FreeRDP_Password:
+		return settings->Password;
+
+	case FreeRDP_Domain:
+		return settings->Domain;
+
+	case FreeRDP_PasswordHash:
+		return settings->PasswordHash;
+
+	case FreeRDP_ClientHostname:
+		return settings->ClientHostname;
+
+	case FreeRDP_ClientProductId:
+		return settings->ClientProductId;
+
+	case FreeRDP_AlternateShell:
+		return settings->AlternateShell;
+
+	case FreeRDP_ShellWorkingDirectory:
+		return settings->ShellWorkingDirectory;
+
+	case FreeRDP_ClientAddress:
+		return settings->ClientAddress;
+
+	case FreeRDP_ClientDir:
+		return settings->ClientDir;
+
+	case FreeRDP_DynamicDSTTimeZoneKeyName:
+		return settings->DynamicDSTTimeZoneKeyName;
+
+	case FreeRDP_RemoteAssistanceSessionId:
+		return settings->RemoteAssistanceSessionId;
+
+	case FreeRDP_RemoteAssistancePassStub:
+		return settings->RemoteAssistancePassStub;
+
+	case FreeRDP_RemoteAssistancePassword:
+		return settings->RemoteAssistancePassword;
+
+	case FreeRDP_RemoteAssistanceRCTicket:
+		return settings->RemoteAssistanceRCTicket;
+
+	case FreeRDP_AuthenticationServiceClass:
+		return settings->AuthenticationServiceClass;
+
+	case FreeRDP_AllowedTlsCiphers:
+		return settings->AllowedTlsCiphers;
+
+	case FreeRDP_NtlmSamFile:
+		return settings->NtlmSamFile;
+
+	case FreeRDP_PreconnectionBlob:
+		return settings->PreconnectionBlob;
+
+	case FreeRDP_KerberosKdc:
+		return settings->KerberosKdc;
+
+	case FreeRDP_KerberosRealm:
+		return settings->KerberosRealm;
+
+	case FreeRDP_CertificateName:
+		return settings->CertificateName;
+
+	case FreeRDP_CertificateFile:
+		return settings->CertificateFile;
+
+	case FreeRDP_PrivateKeyFile:
+		return settings->PrivateKeyFile;
+
+	case FreeRDP_RdpKeyFile:
+		return settings->RdpKeyFile;
+
+	case FreeRDP_CertificateContent:
+		return settings->CertificateContent;
+
+	case FreeRDP_PrivateKeyContent:
+		return settings->PrivateKeyContent;
+
+	case FreeRDP_RdpKeyContent:
+		return settings->RdpKeyContent;
+
+	case FreeRDP_WindowTitle:
+		return settings->WindowTitle;
+
+	case FreeRDP_ComputerName:
+		return settings->ComputerName;
+
+	case FreeRDP_ConnectionFile:
+		return settings->ConnectionFile;
+
+	case FreeRDP_AssistanceFile:
+		return settings->AssistanceFile;
+
+	case FreeRDP_HomePath:
+		return settings->HomePath;
+
+	case FreeRDP_ConfigPath:
+		return settings->ConfigPath;
+
+	case FreeRDP_CurrentPath:
+		return settings->CurrentPath;
+
+	case FreeRDP_DumpRemoteFxFile:
+		return settings->DumpRemoteFxFile;
+
+	case FreeRDP_PlayRemoteFxFile:
+		return settings->PlayRemoteFxFile;
+
+	case FreeRDP_GatewayHostname:
+		return settings->GatewayHostname;
+
+	case FreeRDP_GatewayUsername:
+		return settings->GatewayUsername;
+
+	case FreeRDP_GatewayPassword:
+		return settings->GatewayPassword;
+
+	case FreeRDP_GatewayDomain:
+		return settings->GatewayDomain;
+
+	case FreeRDP_GatewayAccessToken:
+		return settings->GatewayAccessToken;
+
+	case FreeRDP_ProxyHostname:
+		return settings->ProxyHostname;
+
+	case FreeRDP_RemoteApplicationName:
+		return settings->RemoteApplicationName;
+
+	case FreeRDP_RemoteApplicationIcon:
+		return settings->RemoteApplicationIcon;
+
+	case FreeRDP_RemoteApplicationProgram:
+		return settings->RemoteApplicationProgram;
+
+	case FreeRDP_RemoteApplicationFile:
+		return settings->RemoteApplicationFile;
+
+	case FreeRDP_RemoteApplicationGuid:
+		return settings->RemoteApplicationGuid;
+
+	case FreeRDP_RemoteApplicationCmdLine:
+		return settings->RemoteApplicationCmdLine;
+
+	case FreeRDP_ImeFileName:
+		return settings->ImeFileName;
+
+	case FreeRDP_DrivesToRedirect:
+		return settings->DrivesToRedirect;
+
+	default:
+		WLog_ERR(TAG, "freerdp_get_param_string: unknown id: %d", id);
+		return NULL;
+	}
 }
 
 int freerdp_set_param_string(rdpSettings* settings, int id, const char* param)
 {
-	return freerdp_settings_set_string(settings, (size_t)id, param) ? 0 : -1;
+	char** tmp = NULL;
+
+	if (!param)
+		return -1;
+
+	switch (id)
+	{
+	case FreeRDP_ServerHostname:
+		tmp = &settings->ServerHostname;
+		break;
+
+	case FreeRDP_Username:
+		tmp = &settings->Username;
+		break;
+
+	case FreeRDP_Password:
+		tmp = &settings->Password;
+		break;
+
+	case FreeRDP_Domain:
+		tmp = &settings->Domain;
+		break;
+
+	case FreeRDP_PasswordHash:
+		tmp = &settings->PasswordHash;
+		break;
+
+	case FreeRDP_ClientHostname:
+		tmp = &settings->ClientHostname;
+		break;
+
+	case FreeRDP_ClientProductId:
+		tmp = &settings->ClientProductId;
+		break;
+
+	case FreeRDP_AlternateShell:
+		tmp = &settings->AlternateShell;
+		break;
+
+	case FreeRDP_ShellWorkingDirectory:
+		tmp = &settings->ShellWorkingDirectory;
+		break;
+
+	case FreeRDP_ClientAddress:
+		tmp = &settings->ClientAddress;
+		break;
+
+	case FreeRDP_ClientDir:
+		tmp = &settings->ClientDir;
+		break;
+
+	case FreeRDP_DynamicDSTTimeZoneKeyName:
+		tmp = &settings->DynamicDSTTimeZoneKeyName;
+		break;
+
+	case FreeRDP_RemoteAssistanceSessionId:
+		tmp = &settings->RemoteAssistanceSessionId;
+		break;
+
+	case FreeRDP_RemoteAssistancePassStub:
+		tmp = &settings->RemoteAssistancePassStub;
+		break;
+
+	case FreeRDP_RemoteAssistancePassword:
+		tmp = &settings->RemoteAssistancePassword;
+		break;
+
+	case FreeRDP_RemoteAssistanceRCTicket:
+		tmp = &settings->RemoteAssistanceRCTicket;
+		break;
+
+	case FreeRDP_AuthenticationServiceClass:
+		tmp = &settings->AuthenticationServiceClass;
+		break;
+
+	case FreeRDP_AllowedTlsCiphers:
+		tmp = &settings->AllowedTlsCiphers;
+		break;
+
+	case FreeRDP_NtlmSamFile:
+		tmp = &settings->NtlmSamFile;
+		break;
+
+	case FreeRDP_PreconnectionBlob:
+		tmp = &settings->PreconnectionBlob;
+		break;
+
+	case FreeRDP_KerberosKdc:
+		tmp = &settings->KerberosKdc;
+		break;
+
+	case FreeRDP_KerberosRealm:
+		tmp = &settings->KerberosRealm;
+		break;
+
+	case FreeRDP_CertificateName:
+		tmp = &settings->CertificateName;
+		break;
+
+	case FreeRDP_CertificateFile:
+		tmp = &settings->CertificateFile;
+		break;
+
+	case FreeRDP_PrivateKeyFile:
+		tmp = &settings->PrivateKeyFile;
+		break;
+
+	case FreeRDP_CertificateContent:
+		tmp = &settings->CertificateContent;
+		break;
+
+	case FreeRDP_PrivateKeyContent:
+		tmp = &settings->PrivateKeyContent;
+		break;
+
+	case FreeRDP_RdpKeyContent:
+		tmp = &settings->RdpKeyContent;
+		break;
+
+	case FreeRDP_RdpKeyFile:
+		tmp = &settings->RdpKeyFile;
+		break;
+
+	case FreeRDP_WindowTitle:
+		tmp = &settings->WindowTitle;
+		break;
+
+	case FreeRDP_ComputerName:
+		tmp = &settings->ComputerName;
+		break;
+
+	case FreeRDP_ConnectionFile:
+		tmp = &settings->ConnectionFile;
+		break;
+
+	case FreeRDP_AssistanceFile:
+		tmp = &settings->AssistanceFile;
+		break;
+
+	case FreeRDP_HomePath:
+		tmp = &settings->HomePath;
+		break;
+
+	case FreeRDP_ConfigPath:
+		tmp = &settings->ConfigPath;
+		break;
+
+	case FreeRDP_CurrentPath:
+		tmp = &settings->CurrentPath;
+		break;
+
+	case FreeRDP_DumpRemoteFxFile:
+		tmp = &settings->DumpRemoteFxFile;
+		break;
+
+	case FreeRDP_PlayRemoteFxFile:
+		tmp = &settings->PlayRemoteFxFile;
+		break;
+
+	case FreeRDP_GatewayHostname:
+		tmp = &settings->GatewayHostname;
+		break;
+
+	case FreeRDP_GatewayUsername:
+		tmp = &settings->GatewayUsername;
+		break;
+
+	case FreeRDP_GatewayPassword:
+		tmp = &settings->GatewayPassword;
+		break;
+
+	case FreeRDP_GatewayDomain:
+		tmp = &settings->GatewayDomain;
+		break;
+
+	case FreeRDP_GatewayAccessToken:
+		tmp = &settings->GatewayAccessToken;
+		break;
+
+	case FreeRDP_ProxyHostname:
+		tmp = &settings->ProxyHostname;
+		break;
+
+	case FreeRDP_RemoteApplicationName:
+		tmp = &settings->RemoteApplicationName;
+		break;
+
+	case FreeRDP_RemoteApplicationIcon:
+		tmp = &settings->RemoteApplicationIcon;
+		break;
+
+	case FreeRDP_RemoteApplicationProgram:
+		tmp = &settings->RemoteApplicationProgram;
+		break;
+
+	case FreeRDP_RemoteApplicationFile:
+		tmp = &settings->RemoteApplicationFile;
+		break;
+
+	case FreeRDP_RemoteApplicationGuid:
+		tmp = &settings->RemoteApplicationGuid;
+		break;
+
+	case FreeRDP_RemoteApplicationCmdLine:
+		tmp = &settings->RemoteApplicationCmdLine;
+		break;
+
+	case FreeRDP_ImeFileName:
+		tmp = &settings->ImeFileName;
+		break;
+
+	case FreeRDP_DrivesToRedirect:
+		tmp = &settings->DrivesToRedirect;
+		break;
+
+	default:
+		WLog_ERR(TAG, "unknown id %d (param = %s)", id, param);
+		return -1;
+	}
+
+	free(*tmp);
+
+	if (!(*tmp = _strdup(param)))
+		return -1;
+
+	/* Mark field as modified */
+	settings->SettingsModified[id] = 1;
+	return 0;
 }
diff -urN libfreerdp/common/settings_getters.c ../../informatimago/FreeRDP/libfreerdp/common/settings_getters.c
--- libfreerdp/common/settings_getters.c	2019-07-25 19:51:02.685906466 +0300
+++ ../../informatimago/FreeRDP/libfreerdp/common/settings_getters.c	1970-01-01 03:00:00.000000000 +0300
@@ -1,2745 +0,0 @@
-/* Generated by  */
-
-#include <freerdp/settings.h>
-#include <freerdp/log.h>
-
-#define TAG FREERDP_TAG("common.settings")
-
-BOOL freerdp_settings_get_bool(rdpSettings* settings, size_t id)
-{
-	if (!settings)
-		return FALSE;
-
-	switch (id)
-	{
-	case FreeRDP_ServerMode:
-		return settings->ServerMode;
-
-	case FreeRDP_WaitForOutputBufferFlush:
-		return settings->WaitForOutputBufferFlush;
-
-	case FreeRDP_NetworkAutoDetect:
-		return settings->NetworkAutoDetect;
-
-	case FreeRDP_SupportAsymetricKeys:
-		return settings->SupportAsymetricKeys;
-
-	case FreeRDP_SupportErrorInfoPdu:
-		return settings->SupportErrorInfoPdu;
-
-	case FreeRDP_SupportStatusInfoPdu:
-		return settings->SupportStatusInfoPdu;
-
-	case FreeRDP_SupportMonitorLayoutPdu:
-		return settings->SupportMonitorLayoutPdu;
-
-	case FreeRDP_SupportGraphicsPipeline:
-		return settings->SupportGraphicsPipeline;
-
-	case FreeRDP_SupportDynamicTimeZone:
-		return settings->SupportDynamicTimeZone;
-
-	case FreeRDP_SupportHeartbeatPdu:
-		return settings->SupportHeartbeatPdu;
-
-	case FreeRDP_UseRdpSecurityLayer:
-		return settings->UseRdpSecurityLayer;
-
-	case FreeRDP_ConsoleSession:
-		return settings->ConsoleSession;
-
-	case FreeRDP_SpanMonitors:
-		return settings->SpanMonitors;
-
-	case FreeRDP_UseMultimon:
-		return settings->UseMultimon;
-
-	case FreeRDP_ForceMultimon:
-		return settings->ForceMultimon;
-
-	case FreeRDP_ListMonitors:
-		return settings->ListMonitors;
-
-	case FreeRDP_HasMonitorAttributes:
-		return settings->HasMonitorAttributes;
-
-	case FreeRDP_SupportMultitransport:
-		return settings->SupportMultitransport;
-
-	case FreeRDP_AutoLogonEnabled:
-		return settings->AutoLogonEnabled;
-
-	case FreeRDP_CompressionEnabled:
-		return settings->CompressionEnabled;
-
-	case FreeRDP_DisableCtrlAltDel:
-		return settings->DisableCtrlAltDel;
-
-	case FreeRDP_EnableWindowsKey:
-		return settings->EnableWindowsKey;
-
-	case FreeRDP_MaximizeShell:
-		return settings->MaximizeShell;
-
-	case FreeRDP_LogonNotify:
-		return settings->LogonNotify;
-
-	case FreeRDP_LogonErrors:
-		return settings->LogonErrors;
-
-	case FreeRDP_MouseAttached:
-		return settings->MouseAttached;
-
-	case FreeRDP_MouseHasWheel:
-		return settings->MouseHasWheel;
-
-	case FreeRDP_RemoteConsoleAudio:
-		return settings->RemoteConsoleAudio;
-
-	case FreeRDP_AudioPlayback:
-		return settings->AudioPlayback;
-
-	case FreeRDP_AudioCapture:
-		return settings->AudioCapture;
-
-	case FreeRDP_VideoDisable:
-		return settings->VideoDisable;
-
-	case FreeRDP_PasswordIsSmartcardPin:
-		return settings->PasswordIsSmartcardPin;
-
-	case FreeRDP_UsingSavedCredentials:
-		return settings->UsingSavedCredentials;
-
-	case FreeRDP_ForceEncryptedCsPdu:
-		return settings->ForceEncryptedCsPdu;
-
-	case FreeRDP_HiDefRemoteApp:
-		return settings->HiDefRemoteApp;
-
-	case FreeRDP_IPv6Enabled:
-		return settings->IPv6Enabled;
-
-	case FreeRDP_AutoReconnectionEnabled:
-		return settings->AutoReconnectionEnabled;
-
-	case FreeRDP_PrintReconnectCookie:
-		return settings->PrintReconnectCookie;
-
-	case FreeRDP_DynamicDaylightTimeDisabled:
-		return settings->DynamicDaylightTimeDisabled;
-
-	case FreeRDP_AllowFontSmoothing:
-		return settings->AllowFontSmoothing;
-
-	case FreeRDP_DisableWallpaper:
-		return settings->DisableWallpaper;
-
-	case FreeRDP_DisableFullWindowDrag:
-		return settings->DisableFullWindowDrag;
-
-	case FreeRDP_DisableMenuAnims:
-		return settings->DisableMenuAnims;
-
-	case FreeRDP_DisableThemes:
-		return settings->DisableThemes;
-
-	case FreeRDP_DisableCursorShadow:
-		return settings->DisableCursorShadow;
-
-	case FreeRDP_DisableCursorBlinking:
-		return settings->DisableCursorBlinking;
-
-	case FreeRDP_AllowDesktopComposition:
-		return settings->AllowDesktopComposition;
-
-	case FreeRDP_RemoteAssistanceMode:
-		return settings->RemoteAssistanceMode;
-
-	case FreeRDP_EncomspVirtualChannel:
-		return settings->EncomspVirtualChannel;
-
-	case FreeRDP_RemdeskVirtualChannel:
-		return settings->RemdeskVirtualChannel;
-
-	case FreeRDP_LyncRdpMode:
-		return settings->LyncRdpMode;
-
-	case FreeRDP_TlsSecurity:
-		return settings->TlsSecurity;
-
-	case FreeRDP_NlaSecurity:
-		return settings->NlaSecurity;
-
-	case FreeRDP_RdpSecurity:
-		return settings->RdpSecurity;
-
-	case FreeRDP_ExtSecurity:
-		return settings->ExtSecurity;
-
-	case FreeRDP_Authentication:
-		return settings->Authentication;
-
-	case FreeRDP_NegotiateSecurityLayer:
-		return settings->NegotiateSecurityLayer;
-
-	case FreeRDP_RestrictedAdminModeRequired:
-		return settings->RestrictedAdminModeRequired;
-
-	case FreeRDP_DisableCredentialsDelegation:
-		return settings->DisableCredentialsDelegation;
-
-	case FreeRDP_VmConnectMode:
-		return settings->VmConnectMode;
-
-	case FreeRDP_FIPSMode:
-		return settings->FIPSMode;
-
-	case FreeRDP_MstscCookieMode:
-		return settings->MstscCookieMode;
-
-	case FreeRDP_SendPreconnectionPdu:
-		return settings->SendPreconnectionPdu;
-
-	case FreeRDP_SmartcardLogon:
-		return settings->SmartcardLogon;
-
-	case FreeRDP_PromptForCredentials:
-		return settings->PromptForCredentials;
-
-	case FreeRDP_IgnoreCertificate:
-		return settings->IgnoreCertificate;
-
-	case FreeRDP_ExternalCertificateManagement:
-		return settings->ExternalCertificateManagement;
-
-	case FreeRDP_AutoAcceptCertificate:
-		return settings->AutoAcceptCertificate;
-
-	case FreeRDP_AutoDenyCertificate:
-		return settings->AutoDenyCertificate;
-
-	case FreeRDP_Workarea:
-		return settings->Workarea;
-
-	case FreeRDP_Fullscreen:
-		return settings->Fullscreen;
-
-	case FreeRDP_GrabKeyboard:
-		return settings->GrabKeyboard;
-
-	case FreeRDP_Decorations:
-		return settings->Decorations;
-
-	case FreeRDP_MouseMotion:
-		return settings->MouseMotion;
-
-	case FreeRDP_AsyncInput:
-		return settings->AsyncInput;
-
-	case FreeRDP_AsyncUpdate:
-		return settings->AsyncUpdate;
-
-	case FreeRDP_AsyncChannels:
-		return settings->AsyncChannels;
-
-	case FreeRDP_ToggleFullscreen:
-		return settings->ToggleFullscreen;
-
-	case FreeRDP_EmbeddedWindow:
-		return settings->EmbeddedWindow;
-
-	case FreeRDP_SmartSizing:
-		return settings->SmartSizing;
-
-	case FreeRDP_PercentScreenUseWidth:
-		return settings->PercentScreenUseWidth;
-
-	case FreeRDP_PercentScreenUseHeight:
-		return settings->PercentScreenUseHeight;
-
-	case FreeRDP_DynamicResolutionUpdate:
-		return settings->DynamicResolutionUpdate;
-
-	case FreeRDP_SoftwareGdi:
-		return settings->SoftwareGdi;
-
-	case FreeRDP_LocalConnection:
-		return settings->LocalConnection;
-
-	case FreeRDP_AuthenticationOnly:
-		return settings->AuthenticationOnly;
-
-	case FreeRDP_CredentialsFromStdin:
-		return settings->CredentialsFromStdin;
-
-	case FreeRDP_UnmapButtons:
-		return settings->UnmapButtons;
-
-	case FreeRDP_OldLicenseBehaviour:
-		return settings->OldLicenseBehaviour;
-
-	case FreeRDP_DumpRemoteFx:
-		return settings->DumpRemoteFx;
-
-	case FreeRDP_PlayRemoteFx:
-		return settings->PlayRemoteFx;
-
-	case FreeRDP_GatewayUseSameCredentials:
-		return settings->GatewayUseSameCredentials;
-
-	case FreeRDP_GatewayEnabled:
-		return settings->GatewayEnabled;
-
-	case FreeRDP_GatewayBypassLocal:
-		return settings->GatewayBypassLocal;
-
-	case FreeRDP_GatewayRpcTransport:
-		return settings->GatewayRpcTransport;
-
-	case FreeRDP_GatewayHttpTransport:
-		return settings->GatewayHttpTransport;
-
-	case FreeRDP_GatewayUdpTransport:
-		return settings->GatewayUdpTransport;
-
-	case FreeRDP_RemoteApplicationMode:
-		return settings->RemoteApplicationMode;
-
-	case FreeRDP_DisableRemoteAppCapsCheck:
-		return settings->DisableRemoteAppCapsCheck;
-
-	case FreeRDP_RemoteAppLanguageBarSupported:
-		return settings->RemoteAppLanguageBarSupported;
-
-	case FreeRDP_RefreshRect:
-		return settings->RefreshRect;
-
-	case FreeRDP_SuppressOutput:
-		return settings->SuppressOutput;
-
-	case FreeRDP_FastPathOutput:
-		return settings->FastPathOutput;
-
-	case FreeRDP_SaltedChecksum:
-		return settings->SaltedChecksum;
-
-	case FreeRDP_LongCredentialsSupported:
-		return settings->LongCredentialsSupported;
-
-	case FreeRDP_NoBitmapCompressionHeader:
-		return settings->NoBitmapCompressionHeader;
-
-	case FreeRDP_BitmapCompressionDisabled:
-		return settings->BitmapCompressionDisabled;
-
-	case FreeRDP_DesktopResize:
-		return settings->DesktopResize;
-
-	case FreeRDP_DrawAllowDynamicColorFidelity:
-		return settings->DrawAllowDynamicColorFidelity;
-
-	case FreeRDP_DrawAllowColorSubsampling:
-		return settings->DrawAllowColorSubsampling;
-
-	case FreeRDP_DrawAllowSkipAlpha:
-		return settings->DrawAllowSkipAlpha;
-
-	case FreeRDP_BitmapCacheV3Enabled:
-		return settings->BitmapCacheV3Enabled;
-
-	case FreeRDP_AltSecFrameMarkerSupport:
-		return settings->AltSecFrameMarkerSupport;
-
-	case FreeRDP_AllowUnanouncedOrdersFromServer:
-		return settings->AllowUnanouncedOrdersFromServer;
-
-	case FreeRDP_BitmapCacheEnabled:
-		return settings->BitmapCacheEnabled;
-
-	case FreeRDP_AllowCacheWaitingList:
-		return settings->AllowCacheWaitingList;
-
-	case FreeRDP_BitmapCachePersistEnabled:
-		return settings->BitmapCachePersistEnabled;
-
-	case FreeRDP_ColorPointerFlag:
-		return settings->ColorPointerFlag;
-
-	case FreeRDP_UnicodeInput:
-		return settings->UnicodeInput;
-
-	case FreeRDP_FastPathInput:
-		return settings->FastPathInput;
-
-	case FreeRDP_MultiTouchInput:
-		return settings->MultiTouchInput;
-
-	case FreeRDP_MultiTouchGestures:
-		return settings->MultiTouchGestures;
-
-	case FreeRDP_HasHorizontalWheel:
-		return settings->HasHorizontalWheel;
-
-	case FreeRDP_HasExtendedMouseEvent:
-		return settings->HasExtendedMouseEvent;
-
-	case FreeRDP_SoundBeepsEnabled:
-		return settings->SoundBeepsEnabled;
-
-	case FreeRDP_SurfaceCommandsEnabled:
-		return settings->SurfaceCommandsEnabled;
-
-	case FreeRDP_FrameMarkerCommandEnabled:
-		return settings->FrameMarkerCommandEnabled;
-
-	case FreeRDP_SurfaceFrameMarkerEnabled:
-		return settings->SurfaceFrameMarkerEnabled;
-
-	case FreeRDP_RemoteFxOnly:
-		return settings->RemoteFxOnly;
-
-	case FreeRDP_RemoteFxCodec:
-		return settings->RemoteFxCodec;
-
-	case FreeRDP_RemoteFxImageCodec:
-		return settings->RemoteFxImageCodec;
-
-	case FreeRDP_NSCodec:
-		return settings->NSCodec;
-
-	case FreeRDP_NSCodecAllowSubsampling:
-		return settings->NSCodecAllowSubsampling;
-
-	case FreeRDP_NSCodecAllowDynamicColorFidelity:
-		return settings->NSCodecAllowDynamicColorFidelity;
-
-	case FreeRDP_JpegCodec:
-		return settings->JpegCodec;
-
-	case FreeRDP_GfxThinClient:
-		return settings->GfxThinClient;
-
-	case FreeRDP_GfxSmallCache:
-		return settings->GfxSmallCache;
-
-	case FreeRDP_GfxProgressive:
-		return settings->GfxProgressive;
-
-	case FreeRDP_GfxProgressiveV2:
-		return settings->GfxProgressiveV2;
-
-	case FreeRDP_GfxH264:
-		return settings->GfxH264;
-
-	case FreeRDP_GfxAVC444:
-		return settings->GfxAVC444;
-
-	case FreeRDP_GfxSendQoeAck:
-		return settings->GfxSendQoeAck;
-
-	case FreeRDP_GfxAVC444v2:
-		return settings->GfxAVC444v2;
-
-	case FreeRDP_DrawNineGridEnabled:
-		return settings->DrawNineGridEnabled;
-
-	case FreeRDP_DrawGdiPlusEnabled:
-		return settings->DrawGdiPlusEnabled;
-
-	case FreeRDP_DrawGdiPlusCacheEnabled:
-		return settings->DrawGdiPlusCacheEnabled;
-
-	case FreeRDP_DeviceRedirection:
-		return settings->DeviceRedirection;
-
-	case FreeRDP_RedirectDrives:
-		return settings->RedirectDrives;
-
-	case FreeRDP_RedirectHomeDrive:
-		return settings->RedirectHomeDrive;
-
-	case FreeRDP_RedirectSmartCards:
-		return settings->RedirectSmartCards;
-
-	case FreeRDP_RedirectPrinters:
-		return settings->RedirectPrinters;
-
-	case FreeRDP_RedirectSerialPorts:
-		return settings->RedirectSerialPorts;
-
-	case FreeRDP_RedirectParallelPorts:
-		return settings->RedirectParallelPorts;
-
-	case FreeRDP_PreferIPv6OverIPv4:
-		return settings->PreferIPv6OverIPv4;
-
-	case FreeRDP_RedirectClipboard:
-		return settings->RedirectClipboard;
-
-	case FreeRDP_SupportDynamicChannels:
-		return settings->SupportDynamicChannels;
-
-	case FreeRDP_SupportEchoChannel:
-		return settings->SupportEchoChannel;
-
-	case FreeRDP_SupportDisplayControl:
-		return settings->SupportDisplayControl;
-
-	case FreeRDP_SupportGeometryTracking:
-		return settings->SupportGeometryTracking;
-
-	case FreeRDP_SupportSSHAgentChannel:
-		return settings->SupportSSHAgentChannel;
-
-	case FreeRDP_SupportVideoOptimized:
-		return settings->SupportVideoOptimized;
-
-	default:
-		WLog_ERR(TAG, "[%s] Invalid key index %" PRIuz, __FUNCTION__, id);
-		return FALSE;
-	}
-}
-
-BOOL freerdp_settings_set_bool(rdpSettings* settings, size_t id, BOOL val)
-{
-	if (!settings)
-		return FALSE;
-
-	switch (id)
-	{
-	case FreeRDP_ServerMode:
-		settings->ServerMode = val;
-		break;
-
-	case FreeRDP_WaitForOutputBufferFlush:
-		settings->WaitForOutputBufferFlush = val;
-		break;
-
-	case FreeRDP_NetworkAutoDetect:
-		settings->NetworkAutoDetect = val;
-		break;
-
-	case FreeRDP_SupportAsymetricKeys:
-		settings->SupportAsymetricKeys = val;
-		break;
-
-	case FreeRDP_SupportErrorInfoPdu:
-		settings->SupportErrorInfoPdu = val;
-		break;
-
-	case FreeRDP_SupportStatusInfoPdu:
-		settings->SupportStatusInfoPdu = val;
-		break;
-
-	case FreeRDP_SupportMonitorLayoutPdu:
-		settings->SupportMonitorLayoutPdu = val;
-		break;
-
-	case FreeRDP_SupportGraphicsPipeline:
-		settings->SupportGraphicsPipeline = val;
-		break;
-
-	case FreeRDP_SupportDynamicTimeZone:
-		settings->SupportDynamicTimeZone = val;
-		break;
-
-	case FreeRDP_SupportHeartbeatPdu:
-		settings->SupportHeartbeatPdu = val;
-		break;
-
-	case FreeRDP_UseRdpSecurityLayer:
-		settings->UseRdpSecurityLayer = val;
-		break;
-
-	case FreeRDP_ConsoleSession:
-		settings->ConsoleSession = val;
-		break;
-
-	case FreeRDP_SpanMonitors:
-		settings->SpanMonitors = val;
-		break;
-
-	case FreeRDP_UseMultimon:
-		settings->UseMultimon = val;
-		break;
-
-	case FreeRDP_ForceMultimon:
-		settings->ForceMultimon = val;
-		break;
-
-	case FreeRDP_ListMonitors:
-		settings->ListMonitors = val;
-		break;
-
-	case FreeRDP_HasMonitorAttributes:
-		settings->HasMonitorAttributes = val;
-		break;
-
-	case FreeRDP_SupportMultitransport:
-		settings->SupportMultitransport = val;
-		break;
-
-	case FreeRDP_AutoLogonEnabled:
-		settings->AutoLogonEnabled = val;
-		break;
-
-	case FreeRDP_CompressionEnabled:
-		settings->CompressionEnabled = val;
-		break;
-
-	case FreeRDP_DisableCtrlAltDel:
-		settings->DisableCtrlAltDel = val;
-		break;
-
-	case FreeRDP_EnableWindowsKey:
-		settings->EnableWindowsKey = val;
-		break;
-
-	case FreeRDP_MaximizeShell:
-		settings->MaximizeShell = val;
-		break;
-
-	case FreeRDP_LogonNotify:
-		settings->LogonNotify = val;
-		break;
-
-	case FreeRDP_LogonErrors:
-		settings->LogonErrors = val;
-		break;
-
-	case FreeRDP_MouseAttached:
-		settings->MouseAttached = val;
-		break;
-
-	case FreeRDP_MouseHasWheel:
-		settings->MouseHasWheel = val;
-		break;
-
-	case FreeRDP_RemoteConsoleAudio:
-		settings->RemoteConsoleAudio = val;
-		break;
-
-	case FreeRDP_AudioPlayback:
-		settings->AudioPlayback = val;
-		break;
-
-	case FreeRDP_AudioCapture:
-		settings->AudioCapture = val;
-		break;
-
-	case FreeRDP_VideoDisable:
-		settings->VideoDisable = val;
-		break;
-
-	case FreeRDP_PasswordIsSmartcardPin:
-		settings->PasswordIsSmartcardPin = val;
-		break;
-
-	case FreeRDP_UsingSavedCredentials:
-		settings->UsingSavedCredentials = val;
-		break;
-
-	case FreeRDP_ForceEncryptedCsPdu:
-		settings->ForceEncryptedCsPdu = val;
-		break;
-
-	case FreeRDP_HiDefRemoteApp:
-		settings->HiDefRemoteApp = val;
-		break;
-
-	case FreeRDP_IPv6Enabled:
-		settings->IPv6Enabled = val;
-		break;
-
-	case FreeRDP_AutoReconnectionEnabled:
-		settings->AutoReconnectionEnabled = val;
-		break;
-
-	case FreeRDP_PrintReconnectCookie:
-		settings->PrintReconnectCookie = val;
-		break;
-
-	case FreeRDP_DynamicDaylightTimeDisabled:
-		settings->DynamicDaylightTimeDisabled = val;
-		break;
-
-	case FreeRDP_AllowFontSmoothing:
-		settings->AllowFontSmoothing = val;
-		break;
-
-	case FreeRDP_DisableWallpaper:
-		settings->DisableWallpaper = val;
-		break;
-
-	case FreeRDP_DisableFullWindowDrag:
-		settings->DisableFullWindowDrag = val;
-		break;
-
-	case FreeRDP_DisableMenuAnims:
-		settings->DisableMenuAnims = val;
-		break;
-
-	case FreeRDP_DisableThemes:
-		settings->DisableThemes = val;
-		break;
-
-	case FreeRDP_DisableCursorShadow:
-		settings->DisableCursorShadow = val;
-		break;
-
-	case FreeRDP_DisableCursorBlinking:
-		settings->DisableCursorBlinking = val;
-		break;
-
-	case FreeRDP_AllowDesktopComposition:
-		settings->AllowDesktopComposition = val;
-		break;
-
-	case FreeRDP_RemoteAssistanceMode:
-		settings->RemoteAssistanceMode = val;
-		break;
-
-	case FreeRDP_EncomspVirtualChannel:
-		settings->EncomspVirtualChannel = val;
-		break;
-
-	case FreeRDP_RemdeskVirtualChannel:
-		settings->RemdeskVirtualChannel = val;
-		break;
-
-	case FreeRDP_LyncRdpMode:
-		settings->LyncRdpMode = val;
-		break;
-
-	case FreeRDP_TlsSecurity:
-		settings->TlsSecurity = val;
-		break;
-
-	case FreeRDP_NlaSecurity:
-		settings->NlaSecurity = val;
-		break;
-
-	case FreeRDP_RdpSecurity:
-		settings->RdpSecurity = val;
-		break;
-
-	case FreeRDP_ExtSecurity:
-		settings->ExtSecurity = val;
-		break;
-
-	case FreeRDP_Authentication:
-		settings->Authentication = val;
-		break;
-
-	case FreeRDP_NegotiateSecurityLayer:
-		settings->NegotiateSecurityLayer = val;
-		break;
-
-	case FreeRDP_RestrictedAdminModeRequired:
-		settings->RestrictedAdminModeRequired = val;
-		break;
-
-	case FreeRDP_DisableCredentialsDelegation:
-		settings->DisableCredentialsDelegation = val;
-		break;
-
-	case FreeRDP_VmConnectMode:
-		settings->VmConnectMode = val;
-		break;
-
-	case FreeRDP_FIPSMode:
-		settings->FIPSMode = val;
-		break;
-
-	case FreeRDP_MstscCookieMode:
-		settings->MstscCookieMode = val;
-		break;
-
-	case FreeRDP_SendPreconnectionPdu:
-		settings->SendPreconnectionPdu = val;
-		break;
-
-	case FreeRDP_SmartcardLogon:
-		settings->SmartcardLogon = val;
-		break;
-
-	case FreeRDP_PromptForCredentials:
-		settings->PromptForCredentials = val;
-		break;
-
-	case FreeRDP_IgnoreCertificate:
-		settings->IgnoreCertificate = val;
-		break;
-
-	case FreeRDP_ExternalCertificateManagement:
-		settings->ExternalCertificateManagement = val;
-		break;
-
-	case FreeRDP_AutoAcceptCertificate:
-		settings->AutoAcceptCertificate = val;
-		break;
-
-	case FreeRDP_AutoDenyCertificate:
-		settings->AutoDenyCertificate = val;
-		break;
-
-	case FreeRDP_Workarea:
-		settings->Workarea = val;
-		break;
-
-	case FreeRDP_Fullscreen:
-		settings->Fullscreen = val;
-		break;
-
-	case FreeRDP_GrabKeyboard:
-		settings->GrabKeyboard = val;
-		break;
-
-	case FreeRDP_Decorations:
-		settings->Decorations = val;
-		break;
-
-	case FreeRDP_MouseMotion:
-		settings->MouseMotion = val;
-		break;
-
-	case FreeRDP_AsyncInput:
-		settings->AsyncInput = val;
-		break;
-
-	case FreeRDP_AsyncUpdate:
-		settings->AsyncUpdate = val;
-		break;
-
-	case FreeRDP_AsyncChannels:
-		settings->AsyncChannels = val;
-		break;
-
-	case FreeRDP_ToggleFullscreen:
-		settings->ToggleFullscreen = val;
-		break;
-
-	case FreeRDP_EmbeddedWindow:
-		settings->EmbeddedWindow = val;
-		break;
-
-	case FreeRDP_SmartSizing:
-		settings->SmartSizing = val;
-		break;
-
-	case FreeRDP_PercentScreenUseWidth:
-		settings->PercentScreenUseWidth = val;
-		break;
-
-	case FreeRDP_PercentScreenUseHeight:
-		settings->PercentScreenUseHeight = val;
-		break;
-
-	case FreeRDP_DynamicResolutionUpdate:
-		settings->DynamicResolutionUpdate = val;
-		break;
-
-	case FreeRDP_SoftwareGdi:
-		settings->SoftwareGdi = val;
-		break;
-
-	case FreeRDP_LocalConnection:
-		settings->LocalConnection = val;
-		break;
-
-	case FreeRDP_AuthenticationOnly:
-		settings->AuthenticationOnly = val;
-		break;
-
-	case FreeRDP_CredentialsFromStdin:
-		settings->CredentialsFromStdin = val;
-		break;
-
-	case FreeRDP_UnmapButtons:
-		settings->UnmapButtons = val;
-		break;
-
-	case FreeRDP_OldLicenseBehaviour:
-		settings->OldLicenseBehaviour = val;
-		break;
-
-	case FreeRDP_DumpRemoteFx:
-		settings->DumpRemoteFx = val;
-		break;
-
-	case FreeRDP_PlayRemoteFx:
-		settings->PlayRemoteFx = val;
-		break;
-
-	case FreeRDP_GatewayUseSameCredentials:
-		settings->GatewayUseSameCredentials = val;
-		break;
-
-	case FreeRDP_GatewayEnabled:
-		settings->GatewayEnabled = val;
-		break;
-
-	case FreeRDP_GatewayBypassLocal:
-		settings->GatewayBypassLocal = val;
-		break;
-
-	case FreeRDP_GatewayRpcTransport:
-		settings->GatewayRpcTransport = val;
-		break;
-
-	case FreeRDP_GatewayHttpTransport:
-		settings->GatewayHttpTransport = val;
-		break;
-
-	case FreeRDP_GatewayUdpTransport:
-		settings->GatewayUdpTransport = val;
-		break;
-
-	case FreeRDP_RemoteApplicationMode:
-		settings->RemoteApplicationMode = val;
-		break;
-
-	case FreeRDP_DisableRemoteAppCapsCheck:
-		settings->DisableRemoteAppCapsCheck = val;
-		break;
-
-	case FreeRDP_RemoteAppLanguageBarSupported:
-		settings->RemoteAppLanguageBarSupported = val;
-		break;
-
-	case FreeRDP_RefreshRect:
-		settings->RefreshRect = val;
-		break;
-
-	case FreeRDP_SuppressOutput:
-		settings->SuppressOutput = val;
-		break;
-
-	case FreeRDP_FastPathOutput:
-		settings->FastPathOutput = val;
-		break;
-
-	case FreeRDP_SaltedChecksum:
-		settings->SaltedChecksum = val;
-		break;
-
-	case FreeRDP_LongCredentialsSupported:
-		settings->LongCredentialsSupported = val;
-		break;
-
-	case FreeRDP_NoBitmapCompressionHeader:
-		settings->NoBitmapCompressionHeader = val;
-		break;
-
-	case FreeRDP_BitmapCompressionDisabled:
-		settings->BitmapCompressionDisabled = val;
-		break;
-
-	case FreeRDP_DesktopResize:
-		settings->DesktopResize = val;
-		break;
-
-	case FreeRDP_DrawAllowDynamicColorFidelity:
-		settings->DrawAllowDynamicColorFidelity = val;
-		break;
-
-	case FreeRDP_DrawAllowColorSubsampling:
-		settings->DrawAllowColorSubsampling = val;
-		break;
-
-	case FreeRDP_DrawAllowSkipAlpha:
-		settings->DrawAllowSkipAlpha = val;
-		break;
-
-	case FreeRDP_BitmapCacheV3Enabled:
-		settings->BitmapCacheV3Enabled = val;
-		break;
-
-	case FreeRDP_AltSecFrameMarkerSupport:
-		settings->AltSecFrameMarkerSupport = val;
-		break;
-
-	case FreeRDP_AllowUnanouncedOrdersFromServer:
-		settings->AllowUnanouncedOrdersFromServer = val;
-		break;
-
-	case FreeRDP_BitmapCacheEnabled:
-		settings->BitmapCacheEnabled = val;
-		break;
-
-	case FreeRDP_AllowCacheWaitingList:
-		settings->AllowCacheWaitingList = val;
-		break;
-
-	case FreeRDP_BitmapCachePersistEnabled:
-		settings->BitmapCachePersistEnabled = val;
-		break;
-
-	case FreeRDP_ColorPointerFlag:
-		settings->ColorPointerFlag = val;
-		break;
-
-	case FreeRDP_UnicodeInput:
-		settings->UnicodeInput = val;
-		break;
-
-	case FreeRDP_FastPathInput:
-		settings->FastPathInput = val;
-		break;
-
-	case FreeRDP_MultiTouchInput:
-		settings->MultiTouchInput = val;
-		break;
-
-	case FreeRDP_MultiTouchGestures:
-		settings->MultiTouchGestures = val;
-		break;
-
-	case FreeRDP_HasHorizontalWheel:
-		settings->HasHorizontalWheel = val;
-		break;
-
-	case FreeRDP_HasExtendedMouseEvent:
-		settings->HasExtendedMouseEvent = val;
-		break;
-
-	case FreeRDP_SoundBeepsEnabled:
-		settings->SoundBeepsEnabled = val;
-		break;
-
-	case FreeRDP_SurfaceCommandsEnabled:
-		settings->SurfaceCommandsEnabled = val;
-		break;
-
-	case FreeRDP_FrameMarkerCommandEnabled:
-		settings->FrameMarkerCommandEnabled = val;
-		break;
-
-	case FreeRDP_SurfaceFrameMarkerEnabled:
-		settings->SurfaceFrameMarkerEnabled = val;
-		break;
-
-	case FreeRDP_RemoteFxOnly:
-		settings->RemoteFxOnly = val;
-		break;
-
-	case FreeRDP_RemoteFxCodec:
-		settings->RemoteFxCodec = val;
-		break;
-
-	case FreeRDP_RemoteFxImageCodec:
-		settings->RemoteFxImageCodec = val;
-		break;
-
-	case FreeRDP_NSCodec:
-		settings->NSCodec = val;
-		break;
-
-	case FreeRDP_NSCodecAllowSubsampling:
-		settings->NSCodecAllowSubsampling = val;
-		break;
-
-	case FreeRDP_NSCodecAllowDynamicColorFidelity:
-		settings->NSCodecAllowDynamicColorFidelity = val;
-		break;
-
-	case FreeRDP_JpegCodec:
-		settings->JpegCodec = val;
-		break;
-
-	case FreeRDP_GfxThinClient:
-		settings->GfxThinClient = val;
-		break;
-
-	case FreeRDP_GfxSmallCache:
-		settings->GfxSmallCache = val;
-		break;
-
-	case FreeRDP_GfxProgressive:
-		settings->GfxProgressive = val;
-		break;
-
-	case FreeRDP_GfxProgressiveV2:
-		settings->GfxProgressiveV2 = val;
-		break;
-
-	case FreeRDP_GfxH264:
-		settings->GfxH264 = val;
-		break;
-
-	case FreeRDP_GfxAVC444:
-		settings->GfxAVC444 = val;
-		break;
-
-	case FreeRDP_GfxSendQoeAck:
-		settings->GfxSendQoeAck = val;
-		break;
-
-	case FreeRDP_GfxAVC444v2:
-		settings->GfxAVC444v2 = val;
-		break;
-
-	case FreeRDP_DrawNineGridEnabled:
-		settings->DrawNineGridEnabled = val;
-		break;
-
-	case FreeRDP_DrawGdiPlusEnabled:
-		settings->DrawGdiPlusEnabled = val;
-		break;
-
-	case FreeRDP_DrawGdiPlusCacheEnabled:
-		settings->DrawGdiPlusCacheEnabled = val;
-		break;
-
-	case FreeRDP_DeviceRedirection:
-		settings->DeviceRedirection = val;
-		break;
-
-	case FreeRDP_RedirectDrives:
-		settings->RedirectDrives = val;
-		break;
-
-	case FreeRDP_RedirectHomeDrive:
-		settings->RedirectHomeDrive = val;
-		break;
-
-	case FreeRDP_RedirectSmartCards:
-		settings->RedirectSmartCards = val;
-		break;
-
-	case FreeRDP_RedirectPrinters:
-		settings->RedirectPrinters = val;
-		break;
-
-	case FreeRDP_RedirectSerialPorts:
-		settings->RedirectSerialPorts = val;
-		break;
-
-	case FreeRDP_RedirectParallelPorts:
-		settings->RedirectParallelPorts = val;
-		break;
-
-	case FreeRDP_PreferIPv6OverIPv4:
-		settings->PreferIPv6OverIPv4 = val;
-		break;
-
-	case FreeRDP_RedirectClipboard:
-		settings->RedirectClipboard = val;
-		break;
-
-	case FreeRDP_SupportDynamicChannels:
-		settings->SupportDynamicChannels = val;
-		break;
-
-	case FreeRDP_SupportEchoChannel:
-		settings->SupportEchoChannel = val;
-		break;
-
-	case FreeRDP_SupportDisplayControl:
-		settings->SupportDisplayControl = val;
-		break;
-
-	case FreeRDP_SupportGeometryTracking:
-		settings->SupportGeometryTracking = val;
-		break;
-
-	case FreeRDP_SupportSSHAgentChannel:
-		settings->SupportSSHAgentChannel = val;
-		break;
-
-	case FreeRDP_SupportVideoOptimized:
-		settings->SupportVideoOptimized = val;
-		break;
-
-	default:
-		WLog_ERR(TAG, "[%s] Invalid key index %" PRIuz, __FUNCTION__, id);
-		return FALSE;
-	}
-
-	return TRUE;
-}
-
-UINT16 freerdp_settings_get_uint16(rdpSettings* settings, size_t id)
-{
-	if (!settings)
-		return FALSE;
-
-	switch (id)
-	{
-	case FreeRDP_DesktopOrientation:
-		return settings->DesktopOrientation;
-
-	case FreeRDP_ProxyPort:
-		return settings->ProxyPort;
-
-	default:
-		WLog_ERR(TAG, "[%s] Invalid key index %" PRIuz, __FUNCTION__, id);
-		return FALSE;
-	}
-}
-
-BOOL freerdp_settings_set_uint16(rdpSettings* settings, size_t id, UINT16 val)
-{
-	if (!settings)
-		return FALSE;
-
-	switch (id)
-	{
-	case FreeRDP_DesktopOrientation:
-		settings->DesktopOrientation = val;
-		break;
-
-	case FreeRDP_ProxyPort:
-		settings->ProxyPort = val;
-		break;
-
-	default:
-		WLog_ERR(TAG, "[%s] Invalid key index %" PRIuz, __FUNCTION__, id);
-		return FALSE;
-	}
-
-	return TRUE;
-}
-
-INT16 freerdp_settings_get_int16(rdpSettings* settings, size_t id)
-{
-	if (!settings)
-		return FALSE;
-
-	switch (id)
-	{
-	default:
-		WLog_ERR(TAG, "[%s] Invalid key index %" PRIuz, __FUNCTION__, id);
-		return FALSE;
-	}
-}
-
-BOOL freerdp_settings_set_int16(rdpSettings* settings, size_t id, INT16 val)
-{
-	if (!settings)
-		return FALSE;
-
-	switch (id)
-	{
-	default:
-		WLog_ERR(TAG, "[%s] Invalid key index %" PRIuz, __FUNCTION__, id);
-		return FALSE;
-	}
-
-	return TRUE;
-}
-
-UINT32 freerdp_settings_get_uint32(rdpSettings* settings, size_t id)
-{
-	if (!settings)
-		return FALSE;
-
-	switch (id)
-	{
-	case FreeRDP_ShareId:
-		return settings->ShareId;
-
-	case FreeRDP_PduSource:
-		return settings->PduSource;
-
-	case FreeRDP_ServerPort:
-		return settings->ServerPort;
-
-	case FreeRDP_MaxTimeInCheckLoop:
-		return settings->MaxTimeInCheckLoop;
-
-	case FreeRDP_AcceptedCertLength:
-		return settings->AcceptedCertLength;
-
-	case FreeRDP_RdpVersion:
-		return settings->RdpVersion;
-
-	case FreeRDP_DesktopWidth:
-		return settings->DesktopWidth;
-
-	case FreeRDP_DesktopHeight:
-		return settings->DesktopHeight;
-
-	case FreeRDP_ColorDepth:
-		return settings->ColorDepth;
-
-	case FreeRDP_ConnectionType:
-		return settings->ConnectionType;
-
-	case FreeRDP_ClientBuild:
-		return settings->ClientBuild;
-
-	case FreeRDP_EarlyCapabilityFlags:
-		return settings->EarlyCapabilityFlags;
-
-	case FreeRDP_DesktopPhysicalWidth:
-		return settings->DesktopPhysicalWidth;
-
-	case FreeRDP_DesktopPhysicalHeight:
-		return settings->DesktopPhysicalHeight;
-
-	case FreeRDP_DesktopScaleFactor:
-		return settings->DesktopScaleFactor;
-
-	case FreeRDP_DeviceScaleFactor:
-		return settings->DeviceScaleFactor;
-
-	case FreeRDP_EncryptionMethods:
-		return settings->EncryptionMethods;
-
-	case FreeRDP_ExtEncryptionMethods:
-		return settings->ExtEncryptionMethods;
-
-	case FreeRDP_EncryptionLevel:
-		return settings->EncryptionLevel;
-
-	case FreeRDP_ServerRandomLength:
-		return settings->ServerRandomLength;
-
-	case FreeRDP_ServerCertificateLength:
-		return settings->ServerCertificateLength;
-
-	case FreeRDP_ClientRandomLength:
-		return settings->ClientRandomLength;
-
-	case FreeRDP_ChannelCount:
-		return settings->ChannelCount;
-
-	case FreeRDP_ChannelDefArraySize:
-		return settings->ChannelDefArraySize;
-
-	case FreeRDP_ClusterInfoFlags:
-		return settings->ClusterInfoFlags;
-
-	case FreeRDP_RedirectedSessionId:
-		return settings->RedirectedSessionId;
-
-	case FreeRDP_MonitorCount:
-		return settings->MonitorCount;
-
-	case FreeRDP_MonitorDefArraySize:
-		return settings->MonitorDefArraySize;
-
-	case FreeRDP_DesktopPosX:
-		return settings->DesktopPosX;
-
-	case FreeRDP_DesktopPosY:
-		return settings->DesktopPosY;
-
-	case FreeRDP_NumMonitorIds:
-		return settings->NumMonitorIds;
-
-	case FreeRDP_MonitorLocalShiftX:
-		return settings->MonitorLocalShiftX;
-
-	case FreeRDP_MonitorLocalShiftY:
-		return settings->MonitorLocalShiftY;
-
-	case FreeRDP_MultitransportFlags:
-		return settings->MultitransportFlags;
-
-	case FreeRDP_CompressionLevel:
-		return settings->CompressionLevel;
-
-	case FreeRDP_AutoReconnectMaxRetries:
-		return settings->AutoReconnectMaxRetries;
-
-	case FreeRDP_PerformanceFlags:
-		return settings->PerformanceFlags;
-
-	case FreeRDP_RequestedProtocols:
-		return settings->RequestedProtocols;
-
-	case FreeRDP_SelectedProtocol:
-		return settings->SelectedProtocol;
-
-	case FreeRDP_NegotiationFlags:
-		return settings->NegotiationFlags;
-
-	case FreeRDP_AuthenticationLevel:
-		return settings->AuthenticationLevel;
-
-	case FreeRDP_TlsSecLevel:
-		return settings->TlsSecLevel;
-
-	case FreeRDP_CookieMaxLength:
-		return settings->CookieMaxLength;
-
-	case FreeRDP_PreconnectionId:
-		return settings->PreconnectionId;
-
-	case FreeRDP_RedirectionFlags:
-		return settings->RedirectionFlags;
-
-	case FreeRDP_LoadBalanceInfoLength:
-		return settings->LoadBalanceInfoLength;
-
-	case FreeRDP_RedirectionPasswordLength:
-		return settings->RedirectionPasswordLength;
-
-	case FreeRDP_RedirectionTsvUrlLength:
-		return settings->RedirectionTsvUrlLength;
-
-	case FreeRDP_TargetNetAddressCount:
-		return settings->TargetNetAddressCount;
-
-	case FreeRDP_RedirectionAcceptedCertLength:
-		return settings->RedirectionAcceptedCertLength;
-
-	case FreeRDP_RedirectionPreferType:
-		return settings->RedirectionPreferType;
-
-	case FreeRDP_Password51Length:
-		return settings->Password51Length;
-
-	case FreeRDP_PercentScreen:
-		return settings->PercentScreen;
-
-	case FreeRDP_SmartSizingWidth:
-		return settings->SmartSizingWidth;
-
-	case FreeRDP_SmartSizingHeight:
-		return settings->SmartSizingHeight;
-
-	case FreeRDP_GatewayUsageMethod:
-		return settings->GatewayUsageMethod;
-
-	case FreeRDP_GatewayPort:
-		return settings->GatewayPort;
-
-	case FreeRDP_GatewayCredentialsSource:
-		return settings->GatewayCredentialsSource;
-
-	case FreeRDP_GatewayAcceptedCertLength:
-		return settings->GatewayAcceptedCertLength;
-
-	case FreeRDP_ProxyType:
-		return settings->ProxyType;
-
-	case FreeRDP_RemoteApplicationExpandCmdLine:
-		return settings->RemoteApplicationExpandCmdLine;
-
-	case FreeRDP_RemoteApplicationExpandWorkingDir:
-		return settings->RemoteApplicationExpandWorkingDir;
-
-	case FreeRDP_RemoteAppNumIconCaches:
-		return settings->RemoteAppNumIconCaches;
-
-	case FreeRDP_RemoteAppNumIconCacheEntries:
-		return settings->RemoteAppNumIconCacheEntries;
-
-	case FreeRDP_RemoteWndSupportLevel:
-		return settings->RemoteWndSupportLevel;
-
-	case FreeRDP_RemoteApplicationSupportLevel:
-		return settings->RemoteApplicationSupportLevel;
-
-	case FreeRDP_RemoteApplicationSupportMask:
-		return settings->RemoteApplicationSupportMask;
-
-	case FreeRDP_ReceivedCapabilitiesSize:
-		return settings->ReceivedCapabilitiesSize;
-
-	case FreeRDP_OsMajorType:
-		return settings->OsMajorType;
-
-	case FreeRDP_OsMinorType:
-		return settings->OsMinorType;
-
-	case FreeRDP_BitmapCacheVersion:
-		return settings->BitmapCacheVersion;
-
-	case FreeRDP_BitmapCacheV2NumCells:
-		return settings->BitmapCacheV2NumCells;
-
-	case FreeRDP_PointerCacheSize:
-		return settings->PointerCacheSize;
-
-	case FreeRDP_KeyboardLayout:
-		return settings->KeyboardLayout;
-
-	case FreeRDP_KeyboardType:
-		return settings->KeyboardType;
-
-	case FreeRDP_KeyboardSubType:
-		return settings->KeyboardSubType;
-
-	case FreeRDP_KeyboardFunctionKey:
-		return settings->KeyboardFunctionKey;
-
-	case FreeRDP_KeyboardHook:
-		return settings->KeyboardHook;
-
-	case FreeRDP_BrushSupportLevel:
-		return settings->BrushSupportLevel;
-
-	case FreeRDP_GlyphSupportLevel:
-		return settings->GlyphSupportLevel;
-
-	case FreeRDP_OffscreenSupportLevel:
-		return settings->OffscreenSupportLevel;
-
-	case FreeRDP_OffscreenCacheSize:
-		return settings->OffscreenCacheSize;
-
-	case FreeRDP_OffscreenCacheEntries:
-		return settings->OffscreenCacheEntries;
-
-	case FreeRDP_VirtualChannelCompressionFlags:
-		return settings->VirtualChannelCompressionFlags;
-
-	case FreeRDP_VirtualChannelChunkSize:
-		return settings->VirtualChannelChunkSize;
-
-	case FreeRDP_MultifragMaxRequestSize:
-		return settings->MultifragMaxRequestSize;
-
-	case FreeRDP_LargePointerFlag:
-		return settings->LargePointerFlag;
-
-	case FreeRDP_CompDeskSupportLevel:
-		return settings->CompDeskSupportLevel;
-
-	case FreeRDP_RemoteFxCodecId:
-		return settings->RemoteFxCodecId;
-
-	case FreeRDP_RemoteFxCodecMode:
-		return settings->RemoteFxCodecMode;
-
-	case FreeRDP_RemoteFxCaptureFlags:
-		return settings->RemoteFxCaptureFlags;
-
-	case FreeRDP_NSCodecId:
-		return settings->NSCodecId;
-
-	case FreeRDP_FrameAcknowledge:
-		return settings->FrameAcknowledge;
-
-	case FreeRDP_NSCodecColorLossLevel:
-		return settings->NSCodecColorLossLevel;
-
-	case FreeRDP_JpegCodecId:
-		return settings->JpegCodecId;
-
-	case FreeRDP_JpegQuality:
-		return settings->JpegQuality;
-
-	case FreeRDP_GfxCapsFilter:
-		return settings->GfxCapsFilter;
-
-	case FreeRDP_BitmapCacheV3CodecId:
-		return settings->BitmapCacheV3CodecId;
-
-	case FreeRDP_DrawNineGridCacheSize:
-		return settings->DrawNineGridCacheSize;
-
-	case FreeRDP_DrawNineGridCacheEntries:
-		return settings->DrawNineGridCacheEntries;
-
-	case FreeRDP_DeviceCount:
-		return settings->DeviceCount;
-
-	case FreeRDP_DeviceArraySize:
-		return settings->DeviceArraySize;
-
-	case FreeRDP_StaticChannelCount:
-		return settings->StaticChannelCount;
-
-	case FreeRDP_StaticChannelArraySize:
-		return settings->StaticChannelArraySize;
-
-	case FreeRDP_DynamicChannelCount:
-		return settings->DynamicChannelCount;
-
-	case FreeRDP_DynamicChannelArraySize:
-		return settings->DynamicChannelArraySize;
-
-	default:
-		WLog_ERR(TAG, "[%s] Invalid key index %" PRIuz, __FUNCTION__, id);
-		return FALSE;
-	}
-}
-
-BOOL freerdp_settings_set_uint32(rdpSettings* settings, size_t id, UINT32 val)
-{
-	if (!settings)
-		return FALSE;
-
-	switch (id)
-	{
-	case FreeRDP_ShareId:
-		settings->ShareId = val;
-		break;
-
-	case FreeRDP_PduSource:
-		settings->PduSource = val;
-		break;
-
-	case FreeRDP_ServerPort:
-		settings->ServerPort = val;
-		break;
-
-	case FreeRDP_MaxTimeInCheckLoop:
-		settings->MaxTimeInCheckLoop = val;
-		break;
-
-	case FreeRDP_AcceptedCertLength:
-		settings->AcceptedCertLength = val;
-		break;
-
-	case FreeRDP_RdpVersion:
-		settings->RdpVersion = val;
-		break;
-
-	case FreeRDP_DesktopWidth:
-		settings->DesktopWidth = val;
-		break;
-
-	case FreeRDP_DesktopHeight:
-		settings->DesktopHeight = val;
-		break;
-
-	case FreeRDP_ColorDepth:
-		settings->ColorDepth = val;
-		break;
-
-	case FreeRDP_ConnectionType:
-		settings->ConnectionType = val;
-		break;
-
-	case FreeRDP_ClientBuild:
-		settings->ClientBuild = val;
-		break;
-
-	case FreeRDP_EarlyCapabilityFlags:
-		settings->EarlyCapabilityFlags = val;
-		break;
-
-	case FreeRDP_DesktopPhysicalWidth:
-		settings->DesktopPhysicalWidth = val;
-		break;
-
-	case FreeRDP_DesktopPhysicalHeight:
-		settings->DesktopPhysicalHeight = val;
-		break;
-
-	case FreeRDP_DesktopScaleFactor:
-		settings->DesktopScaleFactor = val;
-		break;
-
-	case FreeRDP_DeviceScaleFactor:
-		settings->DeviceScaleFactor = val;
-		break;
-
-	case FreeRDP_EncryptionMethods:
-		settings->EncryptionMethods = val;
-		break;
-
-	case FreeRDP_ExtEncryptionMethods:
-		settings->ExtEncryptionMethods = val;
-		break;
-
-	case FreeRDP_EncryptionLevel:
-		settings->EncryptionLevel = val;
-		break;
-
-	case FreeRDP_ServerRandomLength:
-		settings->ServerRandomLength = val;
-		break;
-
-	case FreeRDP_ServerCertificateLength:
-		settings->ServerCertificateLength = val;
-		break;
-
-	case FreeRDP_ClientRandomLength:
-		settings->ClientRandomLength = val;
-		break;
-
-	case FreeRDP_ChannelCount:
-		settings->ChannelCount = val;
-		break;
-
-	case FreeRDP_ChannelDefArraySize:
-		settings->ChannelDefArraySize = val;
-		break;
-
-	case FreeRDP_ClusterInfoFlags:
-		settings->ClusterInfoFlags = val;
-		break;
-
-	case FreeRDP_RedirectedSessionId:
-		settings->RedirectedSessionId = val;
-		break;
-
-	case FreeRDP_MonitorCount:
-		settings->MonitorCount = val;
-		break;
-
-	case FreeRDP_MonitorDefArraySize:
-		settings->MonitorDefArraySize = val;
-		break;
-
-	case FreeRDP_DesktopPosX:
-		settings->DesktopPosX = val;
-		break;
-
-	case FreeRDP_DesktopPosY:
-		settings->DesktopPosY = val;
-		break;
-
-	case FreeRDP_NumMonitorIds:
-		settings->NumMonitorIds = val;
-		break;
-
-	case FreeRDP_MonitorLocalShiftX:
-		settings->MonitorLocalShiftX = val;
-		break;
-
-	case FreeRDP_MonitorLocalShiftY:
-		settings->MonitorLocalShiftY = val;
-		break;
-
-	case FreeRDP_MultitransportFlags:
-		settings->MultitransportFlags = val;
-		break;
-
-	case FreeRDP_CompressionLevel:
-		settings->CompressionLevel = val;
-		break;
-
-	case FreeRDP_AutoReconnectMaxRetries:
-		settings->AutoReconnectMaxRetries = val;
-		break;
-
-	case FreeRDP_PerformanceFlags:
-		settings->PerformanceFlags = val;
-		break;
-
-	case FreeRDP_RequestedProtocols:
-		settings->RequestedProtocols = val;
-		break;
-
-	case FreeRDP_SelectedProtocol:
-		settings->SelectedProtocol = val;
-		break;
-
-	case FreeRDP_NegotiationFlags:
-		settings->NegotiationFlags = val;
-		break;
-
-	case FreeRDP_AuthenticationLevel:
-		settings->AuthenticationLevel = val;
-		break;
-
-	case FreeRDP_TlsSecLevel:
-		settings->TlsSecLevel = val;
-		break;
-
-	case FreeRDP_CookieMaxLength:
-		settings->CookieMaxLength = val;
-		break;
-
-	case FreeRDP_PreconnectionId:
-		settings->PreconnectionId = val;
-		break;
-
-	case FreeRDP_RedirectionFlags:
-		settings->RedirectionFlags = val;
-		break;
-
-	case FreeRDP_LoadBalanceInfoLength:
-		settings->LoadBalanceInfoLength = val;
-		break;
-
-	case FreeRDP_RedirectionPasswordLength:
-		settings->RedirectionPasswordLength = val;
-		break;
-
-	case FreeRDP_RedirectionTsvUrlLength:
-		settings->RedirectionTsvUrlLength = val;
-		break;
-
-	case FreeRDP_TargetNetAddressCount:
-		settings->TargetNetAddressCount = val;
-		break;
-
-	case FreeRDP_RedirectionAcceptedCertLength:
-		settings->RedirectionAcceptedCertLength = val;
-		break;
-
-	case FreeRDP_RedirectionPreferType:
-		settings->RedirectionPreferType = val;
-		break;
-
-	case FreeRDP_Password51Length:
-		settings->Password51Length = val;
-		break;
-
-	case FreeRDP_PercentScreen:
-		settings->PercentScreen = val;
-		break;
-
-	case FreeRDP_SmartSizingWidth:
-		settings->SmartSizingWidth = val;
-		break;
-
-	case FreeRDP_SmartSizingHeight:
-		settings->SmartSizingHeight = val;
-		break;
-
-	case FreeRDP_GatewayUsageMethod:
-		settings->GatewayUsageMethod = val;
-		break;
-
-	case FreeRDP_GatewayPort:
-		settings->GatewayPort = val;
-		break;
-
-	case FreeRDP_GatewayCredentialsSource:
-		settings->GatewayCredentialsSource = val;
-		break;
-
-	case FreeRDP_GatewayAcceptedCertLength:
-		settings->GatewayAcceptedCertLength = val;
-		break;
-
-	case FreeRDP_ProxyType:
-		settings->ProxyType = val;
-		break;
-
-	case FreeRDP_RemoteApplicationExpandCmdLine:
-		settings->RemoteApplicationExpandCmdLine = val;
-		break;
-
-	case FreeRDP_RemoteApplicationExpandWorkingDir:
-		settings->RemoteApplicationExpandWorkingDir = val;
-		break;
-
-	case FreeRDP_RemoteAppNumIconCaches:
-		settings->RemoteAppNumIconCaches = val;
-		break;
-
-	case FreeRDP_RemoteAppNumIconCacheEntries:
-		settings->RemoteAppNumIconCacheEntries = val;
-		break;
-
-	case FreeRDP_RemoteWndSupportLevel:
-		settings->RemoteWndSupportLevel = val;
-		break;
-
-	case FreeRDP_RemoteApplicationSupportLevel:
-		settings->RemoteApplicationSupportLevel = val;
-		break;
-
-	case FreeRDP_RemoteApplicationSupportMask:
-		settings->RemoteApplicationSupportMask = val;
-		break;
-
-	case FreeRDP_ReceivedCapabilitiesSize:
-		settings->ReceivedCapabilitiesSize = val;
-		break;
-
-	case FreeRDP_OsMajorType:
-		settings->OsMajorType = val;
-		break;
-
-	case FreeRDP_OsMinorType:
-		settings->OsMinorType = val;
-		break;
-
-	case FreeRDP_BitmapCacheVersion:
-		settings->BitmapCacheVersion = val;
-		break;
-
-	case FreeRDP_BitmapCacheV2NumCells:
-		settings->BitmapCacheV2NumCells = val;
-		break;
-
-	case FreeRDP_PointerCacheSize:
-		settings->PointerCacheSize = val;
-		break;
-
-	case FreeRDP_KeyboardLayout:
-		settings->KeyboardLayout = val;
-		break;
-
-	case FreeRDP_KeyboardType:
-		settings->KeyboardType = val;
-		break;
-
-	case FreeRDP_KeyboardSubType:
-		settings->KeyboardSubType = val;
-		break;
-
-	case FreeRDP_KeyboardFunctionKey:
-		settings->KeyboardFunctionKey = val;
-		break;
-
-	case FreeRDP_KeyboardHook:
-		settings->KeyboardHook = val;
-		break;
-
-	case FreeRDP_BrushSupportLevel:
-		settings->BrushSupportLevel = val;
-		break;
-
-	case FreeRDP_GlyphSupportLevel:
-		settings->GlyphSupportLevel = val;
-		break;
-
-	case FreeRDP_OffscreenSupportLevel:
-		settings->OffscreenSupportLevel = val;
-		break;
-
-	case FreeRDP_OffscreenCacheSize:
-		settings->OffscreenCacheSize = val;
-		break;
-
-	case FreeRDP_OffscreenCacheEntries:
-		settings->OffscreenCacheEntries = val;
-		break;
-
-	case FreeRDP_VirtualChannelCompressionFlags:
-		settings->VirtualChannelCompressionFlags = val;
-		break;
-
-	case FreeRDP_VirtualChannelChunkSize:
-		settings->VirtualChannelChunkSize = val;
-		break;
-
-	case FreeRDP_MultifragMaxRequestSize:
-		settings->MultifragMaxRequestSize = val;
-		break;
-
-	case FreeRDP_LargePointerFlag:
-		settings->LargePointerFlag = val;
-		break;
-
-	case FreeRDP_CompDeskSupportLevel:
-		settings->CompDeskSupportLevel = val;
-		break;
-
-	case FreeRDP_RemoteFxCodecId:
-		settings->RemoteFxCodecId = val;
-		break;
-
-	case FreeRDP_RemoteFxCodecMode:
-		settings->RemoteFxCodecMode = val;
-		break;
-
-	case FreeRDP_RemoteFxCaptureFlags:
-		settings->RemoteFxCaptureFlags = val;
-		break;
-
-	case FreeRDP_NSCodecId:
-		settings->NSCodecId = val;
-		break;
-
-	case FreeRDP_FrameAcknowledge:
-		settings->FrameAcknowledge = val;
-		break;
-
-	case FreeRDP_NSCodecColorLossLevel:
-		settings->NSCodecColorLossLevel = val;
-		break;
-
-	case FreeRDP_JpegCodecId:
-		settings->JpegCodecId = val;
-		break;
-
-	case FreeRDP_JpegQuality:
-		settings->JpegQuality = val;
-		break;
-
-	case FreeRDP_GfxCapsFilter:
-		settings->GfxCapsFilter = val;
-		break;
-
-	case FreeRDP_BitmapCacheV3CodecId:
-		settings->BitmapCacheV3CodecId = val;
-		break;
-
-	case FreeRDP_DrawNineGridCacheSize:
-		settings->DrawNineGridCacheSize = val;
-		break;
-
-	case FreeRDP_DrawNineGridCacheEntries:
-		settings->DrawNineGridCacheEntries = val;
-		break;
-
-	case FreeRDP_DeviceCount:
-		settings->DeviceCount = val;
-		break;
-
-	case FreeRDP_DeviceArraySize:
-		settings->DeviceArraySize = val;
-		break;
-
-	case FreeRDP_StaticChannelCount:
-		settings->StaticChannelCount = val;
-		break;
-
-	case FreeRDP_StaticChannelArraySize:
-		settings->StaticChannelArraySize = val;
-		break;
-
-	case FreeRDP_DynamicChannelCount:
-		settings->DynamicChannelCount = val;
-		break;
-
-	case FreeRDP_DynamicChannelArraySize:
-		settings->DynamicChannelArraySize = val;
-		break;
-
-	default:
-		WLog_ERR(TAG, "[%s] Invalid key index %" PRIuz, __FUNCTION__, id);
-		return FALSE;
-	}
-
-	return TRUE;
-}
-
-INT32 freerdp_settings_get_int32(rdpSettings* settings, size_t id)
-{
-	if (!settings)
-		return FALSE;
-
-	switch (id)
-	{
-	case FreeRDP_XPan:
-		return settings->XPan;
-
-	case FreeRDP_YPan:
-		return settings->YPan;
-
-	default:
-		WLog_ERR(TAG, "[%s] Invalid key index %" PRIuz, __FUNCTION__, id);
-		return FALSE;
-	}
-}
-
-BOOL freerdp_settings_set_int32(rdpSettings* settings, size_t id, INT32 val)
-{
-	if (!settings)
-		return FALSE;
-
-	switch (id)
-	{
-	case FreeRDP_XPan:
-		settings->XPan = val;
-		break;
-
-	case FreeRDP_YPan:
-		settings->YPan = val;
-		break;
-
-	default:
-		WLog_ERR(TAG, "[%s] Invalid key index %" PRIuz, __FUNCTION__, id);
-		return FALSE;
-	}
-
-	return TRUE;
-}
-
-UINT64 freerdp_settings_get_uint64(rdpSettings* settings, size_t id)
-{
-	if (!settings)
-		return FALSE;
-
-	switch (id)
-	{
-	case FreeRDP_ParentWindowId:
-		return settings->ParentWindowId;
-
-	default:
-		WLog_ERR(TAG, "[%s] Invalid key index %" PRIuz, __FUNCTION__, id);
-		return FALSE;
-	}
-}
-
-BOOL freerdp_settings_set_uint64(rdpSettings* settings, size_t id, UINT64 val)
-{
-	if (!settings)
-		return FALSE;
-
-	switch (id)
-	{
-	case FreeRDP_ParentWindowId:
-		settings->ParentWindowId = val;
-		break;
-
-	default:
-		WLog_ERR(TAG, "[%s] Invalid key index %" PRIuz, __FUNCTION__, id);
-		return FALSE;
-	}
-
-	return TRUE;
-}
-
-INT64 freerdp_settings_get_int64(rdpSettings* settings, size_t id)
-{
-	if (!settings)
-		return FALSE;
-
-	switch (id)
-	{
-	default:
-		WLog_ERR(TAG, "[%s] Invalid key index %" PRIuz, __FUNCTION__, id);
-		return FALSE;
-	}
-}
-
-BOOL freerdp_settings_set_int64(rdpSettings* settings, size_t id, INT64 val)
-{
-	if (!settings)
-		return FALSE;
-
-	switch (id)
-	{
-	default:
-		WLog_ERR(TAG, "[%s] Invalid key index %" PRIuz, __FUNCTION__, id);
-		return FALSE;
-	}
-
-	return TRUE;
-}
-
-const char* freerdp_settings_get_string(rdpSettings* settings, size_t id)
-{
-	if (!settings)
-		return FALSE;
-
-	switch (id)
-	{
-	case FreeRDP_ServerHostname:
-		return settings->ServerHostname;
-
-	case FreeRDP_Username:
-		return settings->Username;
-
-	case FreeRDP_Password:
-		return settings->Password;
-
-	case FreeRDP_Domain:
-		return settings->Domain;
-
-	case FreeRDP_PasswordHash:
-		return settings->PasswordHash;
-
-	case FreeRDP_AcceptedCert:
-		return settings->AcceptedCert;
-
-	case FreeRDP_ClientHostname:
-		return settings->ClientHostname;
-
-	case FreeRDP_ClientProductId:
-		return settings->ClientProductId;
-
-	case FreeRDP_AlternateShell:
-		return settings->AlternateShell;
-
-	case FreeRDP_ShellWorkingDirectory:
-		return settings->ShellWorkingDirectory;
-
-	case FreeRDP_ClientAddress:
-		return settings->ClientAddress;
-
-	case FreeRDP_ClientDir:
-		return settings->ClientDir;
-
-	case FreeRDP_DynamicDSTTimeZoneKeyName:
-		return settings->DynamicDSTTimeZoneKeyName;
-
-	case FreeRDP_RemoteAssistanceSessionId:
-		return settings->RemoteAssistanceSessionId;
-
-	case FreeRDP_RemoteAssistancePassStub:
-		return settings->RemoteAssistancePassStub;
-
-	case FreeRDP_RemoteAssistancePassword:
-		return settings->RemoteAssistancePassword;
-
-	case FreeRDP_RemoteAssistanceRCTicket:
-		return settings->RemoteAssistanceRCTicket;
-
-	case FreeRDP_AuthenticationServiceClass:
-		return settings->AuthenticationServiceClass;
-
-	case FreeRDP_AllowedTlsCiphers:
-		return settings->AllowedTlsCiphers;
-
-	case FreeRDP_NtlmSamFile:
-		return settings->NtlmSamFile;
-
-	case FreeRDP_PreconnectionBlob:
-		return settings->PreconnectionBlob;
-
-	case FreeRDP_TargetNetAddress:
-		return settings->TargetNetAddress;
-
-	case FreeRDP_RedirectionUsername:
-		return settings->RedirectionUsername;
-
-	case FreeRDP_RedirectionDomain:
-		return settings->RedirectionDomain;
-
-	case FreeRDP_RedirectionTargetFQDN:
-		return settings->RedirectionTargetFQDN;
-
-	case FreeRDP_RedirectionTargetNetBiosName:
-		return settings->RedirectionTargetNetBiosName;
-
-	case FreeRDP_RedirectionAcceptedCert:
-		return settings->RedirectionAcceptedCert;
-
-	case FreeRDP_KerberosKdc:
-		return settings->KerberosKdc;
-
-	case FreeRDP_KerberosRealm:
-		return settings->KerberosRealm;
-
-	case FreeRDP_CertificateName:
-		return settings->CertificateName;
-
-	case FreeRDP_CertificateFile:
-		return settings->CertificateFile;
-
-	case FreeRDP_PrivateKeyFile:
-		return settings->PrivateKeyFile;
-
-	case FreeRDP_RdpKeyFile:
-		return settings->RdpKeyFile;
-
-	case FreeRDP_CertificateContent:
-		return settings->CertificateContent;
-
-	case FreeRDP_PrivateKeyContent:
-		return settings->PrivateKeyContent;
-
-	case FreeRDP_RdpKeyContent:
-		return settings->RdpKeyContent;
-
-	case FreeRDP_WindowTitle:
-		return settings->WindowTitle;
-
-	case FreeRDP_WmClass:
-		return settings->WmClass;
-
-	case FreeRDP_ComputerName:
-		return settings->ComputerName;
-
-	case FreeRDP_ConnectionFile:
-		return settings->ConnectionFile;
-
-	case FreeRDP_AssistanceFile:
-		return settings->AssistanceFile;
-
-	case FreeRDP_HomePath:
-		return settings->HomePath;
-
-	case FreeRDP_ConfigPath:
-		return settings->ConfigPath;
-
-	case FreeRDP_CurrentPath:
-		return settings->CurrentPath;
-
-	case FreeRDP_DumpRemoteFxFile:
-		return settings->DumpRemoteFxFile;
-
-	case FreeRDP_PlayRemoteFxFile:
-		return settings->PlayRemoteFxFile;
-
-	case FreeRDP_GatewayHostname:
-		return settings->GatewayHostname;
-
-	case FreeRDP_GatewayUsername:
-		return settings->GatewayUsername;
-
-	case FreeRDP_GatewayPassword:
-		return settings->GatewayPassword;
-
-	case FreeRDP_GatewayDomain:
-		return settings->GatewayDomain;
-
-	case FreeRDP_GatewayAccessToken:
-		return settings->GatewayAccessToken;
-
-	case FreeRDP_GatewayAcceptedCert:
-		return settings->GatewayAcceptedCert;
-
-	case FreeRDP_ProxyHostname:
-		return settings->ProxyHostname;
-
-	case FreeRDP_ProxyUsername:
-		return settings->ProxyUsername;
-
-	case FreeRDP_ProxyPassword:
-		return settings->ProxyPassword;
-
-	case FreeRDP_RemoteApplicationName:
-		return settings->RemoteApplicationName;
-
-	case FreeRDP_RemoteApplicationIcon:
-		return settings->RemoteApplicationIcon;
-
-	case FreeRDP_RemoteApplicationProgram:
-		return settings->RemoteApplicationProgram;
-
-	case FreeRDP_RemoteApplicationFile:
-		return settings->RemoteApplicationFile;
-
-	case FreeRDP_RemoteApplicationGuid:
-		return settings->RemoteApplicationGuid;
-
-	case FreeRDP_RemoteApplicationCmdLine:
-		return settings->RemoteApplicationCmdLine;
-
-	case FreeRDP_RemoteApplicationWorkingDir:
-		return settings->RemoteApplicationWorkingDir;
-
-	case FreeRDP_ImeFileName:
-		return settings->ImeFileName;
-
-	case FreeRDP_DrivesToRedirect:
-		return settings->DrivesToRedirect;
-
-	case FreeRDP_RDP2TCPArgs:
-		return settings->RDP2TCPArgs;
-
-	default:
-		WLog_ERR(TAG, "[%s] Invalid key index %" PRIuz, __FUNCTION__, id);
-		return FALSE;
-	}
-}
-
-BOOL freerdp_settings_set_string(rdpSettings* settings, size_t id, const char* val)
-{
-	if (!settings)
-		return FALSE;
-
-	switch (id)
-	{
-	case FreeRDP_ServerHostname:
-		free(settings->ServerHostname);
-		settings->ServerHostname = _strdup(val);
-		return settings->ServerHostname != NULL;
-
-	case FreeRDP_Username:
-		free(settings->Username);
-		settings->Username = _strdup(val);
-		return settings->Username != NULL;
-
-	case FreeRDP_Password:
-		free(settings->Password);
-		settings->Password = _strdup(val);
-		return settings->Password != NULL;
-
-	case FreeRDP_Domain:
-		free(settings->Domain);
-		settings->Domain = _strdup(val);
-		return settings->Domain != NULL;
-
-	case FreeRDP_PasswordHash:
-		free(settings->PasswordHash);
-		settings->PasswordHash = _strdup(val);
-		return settings->PasswordHash != NULL;
-
-	case FreeRDP_AcceptedCert:
-		free(settings->AcceptedCert);
-		settings->AcceptedCert = _strdup(val);
-		return settings->AcceptedCert != NULL;
-
-	case FreeRDP_ClientHostname:
-		free(settings->ClientHostname);
-		settings->ClientHostname = _strdup(val);
-		return settings->ClientHostname != NULL;
-
-	case FreeRDP_ClientProductId:
-		free(settings->ClientProductId);
-		settings->ClientProductId = _strdup(val);
-		return settings->ClientProductId != NULL;
-
-	case FreeRDP_AlternateShell:
-		free(settings->AlternateShell);
-		settings->AlternateShell = _strdup(val);
-		return settings->AlternateShell != NULL;
-
-	case FreeRDP_ShellWorkingDirectory:
-		free(settings->ShellWorkingDirectory);
-		settings->ShellWorkingDirectory = _strdup(val);
-		return settings->ShellWorkingDirectory != NULL;
-
-	case FreeRDP_ClientAddress:
-		free(settings->ClientAddress);
-		settings->ClientAddress = _strdup(val);
-		return settings->ClientAddress != NULL;
-
-	case FreeRDP_ClientDir:
-		free(settings->ClientDir);
-		settings->ClientDir = _strdup(val);
-		return settings->ClientDir != NULL;
-
-	case FreeRDP_DynamicDSTTimeZoneKeyName:
-		free(settings->DynamicDSTTimeZoneKeyName);
-		settings->DynamicDSTTimeZoneKeyName = _strdup(val);
-		return settings->DynamicDSTTimeZoneKeyName != NULL;
-
-	case FreeRDP_RemoteAssistanceSessionId:
-		free(settings->RemoteAssistanceSessionId);
-		settings->RemoteAssistanceSessionId = _strdup(val);
-		return settings->RemoteAssistanceSessionId != NULL;
-
-	case FreeRDP_RemoteAssistancePassStub:
-		free(settings->RemoteAssistancePassStub);
-		settings->RemoteAssistancePassStub = _strdup(val);
-		return settings->RemoteAssistancePassStub != NULL;
-
-	case FreeRDP_RemoteAssistancePassword:
-		free(settings->RemoteAssistancePassword);
-		settings->RemoteAssistancePassword = _strdup(val);
-		return settings->RemoteAssistancePassword != NULL;
-
-	case FreeRDP_RemoteAssistanceRCTicket:
-		free(settings->RemoteAssistanceRCTicket);
-		settings->RemoteAssistanceRCTicket = _strdup(val);
-		return settings->RemoteAssistanceRCTicket != NULL;
-
-	case FreeRDP_AuthenticationServiceClass:
-		free(settings->AuthenticationServiceClass);
-		settings->AuthenticationServiceClass = _strdup(val);
-		return settings->AuthenticationServiceClass != NULL;
-
-	case FreeRDP_AllowedTlsCiphers:
-		free(settings->AllowedTlsCiphers);
-		settings->AllowedTlsCiphers = _strdup(val);
-		return settings->AllowedTlsCiphers != NULL;
-
-	case FreeRDP_NtlmSamFile:
-		free(settings->NtlmSamFile);
-		settings->NtlmSamFile = _strdup(val);
-		return settings->NtlmSamFile != NULL;
-
-	case FreeRDP_PreconnectionBlob:
-		free(settings->PreconnectionBlob);
-		settings->PreconnectionBlob = _strdup(val);
-		return settings->PreconnectionBlob != NULL;
-
-	case FreeRDP_TargetNetAddress:
-		free(settings->TargetNetAddress);
-		settings->TargetNetAddress = _strdup(val);
-		return settings->TargetNetAddress != NULL;
-
-	case FreeRDP_RedirectionUsername:
-		free(settings->RedirectionUsername);
-		settings->RedirectionUsername = _strdup(val);
-		return settings->RedirectionUsername != NULL;
-
-	case FreeRDP_RedirectionDomain:
-		free(settings->RedirectionDomain);
-		settings->RedirectionDomain = _strdup(val);
-		return settings->RedirectionDomain != NULL;
-
-	case FreeRDP_RedirectionTargetFQDN:
-		free(settings->RedirectionTargetFQDN);
-		settings->RedirectionTargetFQDN = _strdup(val);
-		return settings->RedirectionTargetFQDN != NULL;
-
-	case FreeRDP_RedirectionTargetNetBiosName:
-		free(settings->RedirectionTargetNetBiosName);
-		settings->RedirectionTargetNetBiosName = _strdup(val);
-		return settings->RedirectionTargetNetBiosName != NULL;
-
-	case FreeRDP_RedirectionAcceptedCert:
-		free(settings->RedirectionAcceptedCert);
-		settings->RedirectionAcceptedCert = _strdup(val);
-		return settings->RedirectionAcceptedCert != NULL;
-
-	case FreeRDP_KerberosKdc:
-		free(settings->KerberosKdc);
-		settings->KerberosKdc = _strdup(val);
-		return settings->KerberosKdc != NULL;
-
-	case FreeRDP_KerberosRealm:
-		free(settings->KerberosRealm);
-		settings->KerberosRealm = _strdup(val);
-		return settings->KerberosRealm != NULL;
-
-	case FreeRDP_CertificateName:
-		free(settings->CertificateName);
-		settings->CertificateName = _strdup(val);
-		return settings->CertificateName != NULL;
-
-	case FreeRDP_CertificateFile:
-		free(settings->CertificateFile);
-		settings->CertificateFile = _strdup(val);
-		return settings->CertificateFile != NULL;
-
-	case FreeRDP_PrivateKeyFile:
-		free(settings->PrivateKeyFile);
-		settings->PrivateKeyFile = _strdup(val);
-		return settings->PrivateKeyFile != NULL;
-
-	case FreeRDP_RdpKeyFile:
-		free(settings->RdpKeyFile);
-		settings->RdpKeyFile = _strdup(val);
-		return settings->RdpKeyFile != NULL;
-
-	case FreeRDP_CertificateContent:
-		free(settings->CertificateContent);
-		settings->CertificateContent = _strdup(val);
-		return settings->CertificateContent != NULL;
-
-	case FreeRDP_PrivateKeyContent:
-		free(settings->PrivateKeyContent);
-		settings->PrivateKeyContent = _strdup(val);
-		return settings->PrivateKeyContent != NULL;
-
-	case FreeRDP_RdpKeyContent:
-		free(settings->RdpKeyContent);
-		settings->RdpKeyContent = _strdup(val);
-		return settings->RdpKeyContent != NULL;
-
-	case FreeRDP_WindowTitle:
-		free(settings->WindowTitle);
-		settings->WindowTitle = _strdup(val);
-		return settings->WindowTitle != NULL;
-
-	case FreeRDP_WmClass:
-		free(settings->WmClass);
-		settings->WmClass = _strdup(val);
-		return settings->WmClass != NULL;
-
-	case FreeRDP_ComputerName:
-		free(settings->ComputerName);
-		settings->ComputerName = _strdup(val);
-		return settings->ComputerName != NULL;
-
-	case FreeRDP_ConnectionFile:
-		free(settings->ConnectionFile);
-		settings->ConnectionFile = _strdup(val);
-		return settings->ConnectionFile != NULL;
-
-	case FreeRDP_AssistanceFile:
-		free(settings->AssistanceFile);
-		settings->AssistanceFile = _strdup(val);
-		return settings->AssistanceFile != NULL;
-
-	case FreeRDP_HomePath:
-		free(settings->HomePath);
-		settings->HomePath = _strdup(val);
-		return settings->HomePath != NULL;
-
-	case FreeRDP_ConfigPath:
-		free(settings->ConfigPath);
-		settings->ConfigPath = _strdup(val);
-		return settings->ConfigPath != NULL;
-
-	case FreeRDP_CurrentPath:
-		free(settings->CurrentPath);
-		settings->CurrentPath = _strdup(val);
-		return settings->CurrentPath != NULL;
-
-	case FreeRDP_DumpRemoteFxFile:
-		free(settings->DumpRemoteFxFile);
-		settings->DumpRemoteFxFile = _strdup(val);
-		return settings->DumpRemoteFxFile != NULL;
-
-	case FreeRDP_PlayRemoteFxFile:
-		free(settings->PlayRemoteFxFile);
-		settings->PlayRemoteFxFile = _strdup(val);
-		return settings->PlayRemoteFxFile != NULL;
-
-	case FreeRDP_GatewayHostname:
-		free(settings->GatewayHostname);
-		settings->GatewayHostname = _strdup(val);
-		return settings->GatewayHostname != NULL;
-
-	case FreeRDP_GatewayUsername:
-		free(settings->GatewayUsername);
-		settings->GatewayUsername = _strdup(val);
-		return settings->GatewayUsername != NULL;
-
-	case FreeRDP_GatewayPassword:
-		free(settings->GatewayPassword);
-		settings->GatewayPassword = _strdup(val);
-		return settings->GatewayPassword != NULL;
-
-	case FreeRDP_GatewayDomain:
-		free(settings->GatewayDomain);
-		settings->GatewayDomain = _strdup(val);
-		return settings->GatewayDomain != NULL;
-
-	case FreeRDP_GatewayAccessToken:
-		free(settings->GatewayAccessToken);
-		settings->GatewayAccessToken = _strdup(val);
-		return settings->GatewayAccessToken != NULL;
-
-	case FreeRDP_GatewayAcceptedCert:
-		free(settings->GatewayAcceptedCert);
-		settings->GatewayAcceptedCert = _strdup(val);
-		return settings->GatewayAcceptedCert != NULL;
-
-	case FreeRDP_ProxyHostname:
-		free(settings->ProxyHostname);
-		settings->ProxyHostname = _strdup(val);
-		return settings->ProxyHostname != NULL;
-
-	case FreeRDP_ProxyUsername:
-		free(settings->ProxyUsername);
-		settings->ProxyUsername = _strdup(val);
-		return settings->ProxyUsername != NULL;
-
-	case FreeRDP_ProxyPassword:
-		free(settings->ProxyPassword);
-		settings->ProxyPassword = _strdup(val);
-		return settings->ProxyPassword != NULL;
-
-	case FreeRDP_RemoteApplicationName:
-		free(settings->RemoteApplicationName);
-		settings->RemoteApplicationName = _strdup(val);
-		return settings->RemoteApplicationName != NULL;
-
-	case FreeRDP_RemoteApplicationIcon:
-		free(settings->RemoteApplicationIcon);
-		settings->RemoteApplicationIcon = _strdup(val);
-		return settings->RemoteApplicationIcon != NULL;
-
-	case FreeRDP_RemoteApplicationProgram:
-		free(settings->RemoteApplicationProgram);
-		settings->RemoteApplicationProgram = _strdup(val);
-		return settings->RemoteApplicationProgram != NULL;
-
-	case FreeRDP_RemoteApplicationFile:
-		free(settings->RemoteApplicationFile);
-		settings->RemoteApplicationFile = _strdup(val);
-		return settings->RemoteApplicationFile != NULL;
-
-	case FreeRDP_RemoteApplicationGuid:
-		free(settings->RemoteApplicationGuid);
-		settings->RemoteApplicationGuid = _strdup(val);
-		return settings->RemoteApplicationGuid != NULL;
-
-	case FreeRDP_RemoteApplicationCmdLine:
-		free(settings->RemoteApplicationCmdLine);
-		settings->RemoteApplicationCmdLine = _strdup(val);
-		return settings->RemoteApplicationCmdLine != NULL;
-
-	case FreeRDP_RemoteApplicationWorkingDir:
-		free(settings->RemoteApplicationWorkingDir);
-		settings->RemoteApplicationWorkingDir = _strdup(val);
-		return settings->RemoteApplicationWorkingDir != NULL;
-
-	case FreeRDP_ImeFileName:
-		free(settings->ImeFileName);
-		settings->ImeFileName = _strdup(val);
-		return settings->ImeFileName != NULL;
-
-	case FreeRDP_DrivesToRedirect:
-		free(settings->DrivesToRedirect);
-		settings->DrivesToRedirect = _strdup(val);
-		return settings->DrivesToRedirect != NULL;
-
-	case FreeRDP_RDP2TCPArgs:
-		free(settings->RDP2TCPArgs);
-		settings->RDP2TCPArgs = _strdup(val);
-		return settings->RDP2TCPArgs != NULL;
-
-	default:
-		WLog_ERR(TAG, "[%s] Invalid key index %" PRIuz, __FUNCTION__, id);
-		return FALSE;
-	}
-
-	return TRUE;
-}
-
-const void* freerdp_settings_get_pointer(rdpSettings* settings, size_t id)
-{
-	if (!settings)
-		return FALSE;
-
-	switch (id)
-	{
-	case FreeRDP_instance:
-		return settings->instance;
-
-	case FreeRDP_RdpServerCertificate:
-		return settings->RdpServerCertificate;
-
-	case FreeRDP_ServerAutoReconnectCookie:
-		return settings->ServerAutoReconnectCookie;
-
-	case FreeRDP_BitmapCacheV2CellInfo:
-		return settings->BitmapCacheV2CellInfo;
-
-	case FreeRDP_RdpServerRsaKey:
-		return settings->RdpServerRsaKey;
-
-	case FreeRDP_MonitorIds:
-		return settings->MonitorIds;
-
-	case FreeRDP_TargetNetPorts:
-		return settings->TargetNetPorts;
-
-	case FreeRDP_MonitorDefArray:
-		return settings->MonitorDefArray;
-
-	case FreeRDP_ChannelDefArray:
-		return settings->ChannelDefArray;
-
-	case FreeRDP_ClientAutoReconnectCookie:
-		return settings->ClientAutoReconnectCookie;
-
-	case FreeRDP_TargetNetAddresses:
-		return settings->TargetNetAddresses;
-
-	case FreeRDP_StaticChannelArray:
-		return settings->StaticChannelArray;
-
-	case FreeRDP_DynamicChannelArray:
-		return settings->DynamicChannelArray;
-
-	case FreeRDP_DeviceArray:
-		return settings->DeviceArray;
-
-	case FreeRDP_GlyphCache:
-		return settings->GlyphCache;
-
-	case FreeRDP_FragCache:
-		return settings->FragCache;
-
-	case FreeRDP_ClientTimeZone:
-		return settings->ClientTimeZone;
-
-	case FreeRDP_ServerRandom:
-		return settings->ServerRandom;
-
-	case FreeRDP_ServerCertificate:
-		return settings->ServerCertificate;
-
-	case FreeRDP_ClientRandom:
-		return settings->ClientRandom;
-
-	case FreeRDP_LoadBalanceInfo:
-		return settings->LoadBalanceInfo;
-
-	case FreeRDP_RedirectionPassword:
-		return settings->RedirectionPassword;
-
-	case FreeRDP_RedirectionTsvUrl:
-		return settings->RedirectionTsvUrl;
-
-	case FreeRDP_Password51:
-		return settings->Password51;
-
-	case FreeRDP_ReceivedCapabilities:
-		return settings->ReceivedCapabilities;
-
-	case FreeRDP_OrderSupport:
-		return settings->OrderSupport;
-
-	default:
-		WLog_ERR(TAG, "[%s] Invalid key index %" PRIuz, __FUNCTION__, id);
-		return FALSE;
-	}
-}
diff -urN libfreerdp/common/test/TestCommonAssistance.c ../../informatimago/FreeRDP/libfreerdp/common/test/TestCommonAssistance.c
--- libfreerdp/common/test/TestCommonAssistance.c	2019-07-25 19:51:02.697906525 +0300
+++ ../../informatimago/FreeRDP/libfreerdp/common/test/TestCommonAssistance.c	2019-07-25 20:11:26.639976097 +0300
@@ -21,12 +21,9 @@
     "L=\"0\" />"
     "</UPLOADINFO>";
 
-#pragma GCC diagnostic push
-#pragma GCC diagnostic ignored "-Wunused-const-variable"
 static const BYTE TEST_MSRC_INCIDENT_EXPERT_BLOB_TYPE1[32] =
     "\x3C\x9C\xAE\x0B\xCE\x7A\xB1\x5C\x8A\xAC\x01\xD6\x76\x04\x5E\xDF"
     "\x3F\xFA\xF0\x92\xE2\xDE\x36\x8A\x20\x17\xE6\x8A\x0D\xED\x7C\x90";
-#pragma GCC diagnostic pop
 
 static const char TEST_MSRC_INCIDENT_PASSWORD_TYPE2[] = "48BJQ853X3B4";
 
@@ -166,10 +163,7 @@
 
 int TestCommonAssistance(int argc, char* argv[])
 {
-	wLog* log;
-	WINPR_UNUSED(argc);
-	WINPR_UNUSED(argv);
-	log = WLog_Get(__FUNCTION__);
+	wLog* log = WLog_Get(__FUNCTION__);
 	winpr_InitializeSSL(WINPR_SSL_INIT_DEFAULT);
 
 	if (!test_msrsc_incident_file_type1(log))
diff -urN libfreerdp/common/test/TestCommon.c ../../informatimago/FreeRDP/libfreerdp/common/test/TestCommon.c
--- libfreerdp/common/test/TestCommon.c	2019-07-25 20:17:16.437710730 +0300
+++ ../../informatimago/FreeRDP/libfreerdp/common/test/TestCommon.c	2019-07-25 20:11:26.639976097 +0300
@@ -4,139 +4,147 @@
 #include <string.h> /* NOLINT */
 
 #if defined(_MSC_VER)
-#pragma warning(disable : 4996) /* deprecation */
+#	pragma warning(disable : 4996) /* deprecation */
 #endif
 
-
-
 /* Forward declare test functions. */
 int TestCommonAssistance(int, char*[]);
 
-
 #ifdef __cplusplus
-#define CM_CAST(TYPE, EXPR) static_cast<TYPE>(EXPR)
+#	define CM_CAST(TYPE, EXPR) static_cast<TYPE>(EXPR)
 #else
-#define CM_CAST(TYPE, EXPR) (TYPE)(EXPR)
+#	define CM_CAST(TYPE, EXPR) (TYPE)(EXPR)
 #endif
 
 /* Create map.  */
 
-typedef int (*MainFuncPointer)(int, char* []); /* NOLINT */
-typedef struct /* NOLINT */
+typedef int (*MainFuncPointer)(int, char*[]); /* NOLINT */
+typedef struct                                /* NOLINT */
 {
-  const char* name;
-  MainFuncPointer func;
+	const char* name;
+	MainFuncPointer func;
 } functionMapEntry;
 
 static functionMapEntry cmakeGeneratedFunctionMapEntries[] = {
-    {
-    "TestCommonAssistance",
-    TestCommonAssistance
-  },
+	{ "TestCommonAssistance", TestCommonAssistance },
 
-  { NULL, NULL } /* NOLINT */
+	{ NULL, NULL } /* NOLINT */
 };
 
-static const int NumTests = CM_CAST(int,
-  sizeof(cmakeGeneratedFunctionMapEntries) / sizeof(functionMapEntry)) - 1;
+static const int NumTests =
+    CM_CAST(int, sizeof(cmakeGeneratedFunctionMapEntries) / sizeof(functionMapEntry)) - 1;
 
 /* Allocate and create a lowercased copy of string
    (note that it has to be free'd manually) */
 static char* lowercase(const char* string)
 {
-  char *new_string, *p;
-  size_t stringSize;
+	char *new_string, *p;
+	size_t stringSize;
 
-  stringSize = CM_CAST(size_t, strlen(string) + 1);
-  new_string = CM_CAST(char*, malloc(sizeof(char) * stringSize));
+	stringSize = CM_CAST(size_t, strlen(string) + 1);
+	new_string = CM_CAST(char*, malloc(sizeof(char) * stringSize));
 
-  if (new_string == NULL) { /* NOLINT */
-    return NULL;            /* NOLINT */
-  }
-  strcpy(new_string, string);
-  for (p = new_string; *p != 0; ++p) {
-    *p = CM_CAST(char, tolower(*p));
-  }
-  return new_string;
+	if (new_string == NULL)
+	{                /* NOLINT */
+		return NULL; /* NOLINT */
+	}
+	strcpy(new_string, string);
+	for (p = new_string; *p != 0; ++p)
+	{
+		*p = CM_CAST(char, tolower(*p));
+	}
+	return new_string;
 }
 
 int main(int ac, char* av[])
 {
-  int i, testNum = 0, partial_match;
-  char *arg;
-  int testToRun = -1;
-
-  
-
-  /* If no test name was given */
-  /* process command line with user function.  */
-  if (ac < 2) {
-    /* Ask for a test.  */
-    printf("Available tests:\n");
-    for (i = 0; i < NumTests; ++i) {
-      printf("%3d. %s\n", i, cmakeGeneratedFunctionMapEntries[i].name);
-    }
-    printf("To run a test, enter the test number: ");
-    fflush(stdout);
-    if (scanf("%d", &testNum) != 1) {
-      printf("Couldn't parse that input as a number\n");
-      return -1;
-    }
-    if (testNum >= NumTests) {
-      printf("%3d is an invalid test number.\n", testNum);
-      return -1;
-    }
-    testToRun = testNum;
-    ac--;
-    av++;
-  }
-  partial_match = 0;
-  arg = NULL; /* NOLINT */
-  /* If partial match is requested.  */
-  if (testToRun == -1 && ac > 1) {
-    partial_match = (strcmp(av[1], "-R") == 0) ? 1 : 0;
-  }
-  if (partial_match != 0 && ac < 3) {
-    printf("-R needs an additional parameter.\n");
-    return -1;
-  }
-  if (testToRun == -1) {
-    arg = lowercase(av[1 + partial_match]);
-  }
-  for (i = 0; i < NumTests && testToRun == -1; ++i) {
-    char *test_name = lowercase(cmakeGeneratedFunctionMapEntries[i].name);
-    if (partial_match != 0 && strstr(test_name, arg) != NULL) { /* NOLINT */
-      testToRun = i;
-      ac -= 2;
-      av += 2;
-    } else if (partial_match == 0 && strcmp(test_name, arg) == 0) {
-      testToRun = i;
-      ac--;
-      av++;
-    }
-    free(test_name);
-  }
-  free(arg);
-  if (testToRun != -1) {
-    int result;
-
-    if (testToRun < 0 || testToRun >= NumTests) {
-      printf("testToRun was modified by TestDriver code to an invalid value: "
-             "%3d.\n",
-             testNum);
-      return -1;
-    }
-    result = (*cmakeGeneratedFunctionMapEntries[testToRun].func)(ac, av);
-
-    return result;
-  }
-
-  /* Nothing was run, display the test names.  */
-  printf("Available tests:\n");
-  for (i = 0; i < NumTests; ++i) {
-    printf("%3d. %s\n", i, cmakeGeneratedFunctionMapEntries[i].name);
-  }
-  printf("Failed: %s is an invalid test name.\n", av[1]);
+	int i, testNum = 0, partial_match;
+	char* arg;
+	int testToRun = -1;
+
+	/* If no test name was given */
+	/* process command line with user function.  */
+	if (ac < 2)
+	{
+		/* Ask for a test.  */
+		printf("Available tests:\n");
+		for (i = 0; i < NumTests; ++i)
+		{
+			printf("%3d. %s\n", i, cmakeGeneratedFunctionMapEntries[i].name);
+		}
+		printf("To run a test, enter the test number: ");
+		fflush(stdout);
+		if (scanf("%d", &testNum) != 1)
+		{
+			printf("Couldn't parse that input as a number\n");
+			return -1;
+		}
+		if (testNum >= NumTests)
+		{
+			printf("%3d is an invalid test number.\n", testNum);
+			return -1;
+		}
+		testToRun = testNum;
+		ac--;
+		av++;
+	}
+	partial_match = 0;
+	arg = NULL; /* NOLINT */
+	/* If partial match is requested.  */
+	if (testToRun == -1 && ac > 1)
+	{
+		partial_match = (strcmp(av[1], "-R") == 0) ? 1 : 0;
+	}
+	if (partial_match != 0 && ac < 3)
+	{
+		printf("-R needs an additional parameter.\n");
+		return -1;
+	}
+	if (testToRun == -1)
+	{
+		arg = lowercase(av[1 + partial_match]);
+	}
+	for (i = 0; i < NumTests && testToRun == -1; ++i)
+	{
+		char* test_name = lowercase(cmakeGeneratedFunctionMapEntries[i].name);
+		if (partial_match != 0 && strstr(test_name, arg) != NULL)
+		{ /* NOLINT */
+			testToRun = i;
+			ac -= 2;
+			av += 2;
+		}
+		else if (partial_match == 0 && strcmp(test_name, arg) == 0)
+		{
+			testToRun = i;
+			ac--;
+			av++;
+		}
+		free(test_name);
+	}
+	free(arg);
+	if (testToRun != -1)
+	{
+		int result;
+
+		if (testToRun < 0 || testToRun >= NumTests)
+		{
+			printf("testToRun was modified by TestDriver code to an invalid value: "
+			       "%3d.\n",
+			       testNum);
+			return -1;
+		}
+		result = (*cmakeGeneratedFunctionMapEntries[testToRun].func)(ac, av);
+
+		return result;
+	}
+
+	/* Nothing was run, display the test names.  */
+	printf("Available tests:\n");
+	for (i = 0; i < NumTests; ++i)
+	{
+		printf("%3d. %s\n", i, cmakeGeneratedFunctionMapEntries[i].name);
+	}
+	printf("Failed: %s is an invalid test name.\n", av[1]);
 
-  return -1;
+	return -1;
 }
diff -urN libfreerdp/core/activation.c ../../informatimago/FreeRDP/libfreerdp/core/activation.c
--- libfreerdp/core/activation.c	2019-07-25 19:51:02.705906565 +0300
+++ ../../informatimago/FreeRDP/libfreerdp/core/activation.c	2019-07-25 20:11:26.647976137 +0300
@@ -22,7 +22,6 @@
 #endif
 
 #include "activation.h"
-#include "display.h"
 
 /*
 static const char* const CTRLACTION_STRINGS[] =
@@ -290,8 +289,6 @@
 
 		if (freerdp_shall_disconnect(rdp->instance))
 			break;
-
-		SwitchToThread();
 	}
 
 	return TRUE;
@@ -341,25 +338,22 @@
 	    peer->AdjustMonitorsLayout(peer))
 	{
 		/* client supports the monitorLayout PDU, let's send him the monitors if any */
-		MONITOR_DEF* monitors = (MONITOR_DEF*)calloc(settings->MonitorCount, sizeof(MONITOR_DEF));
+		wStream* st = rdp_data_pdu_init(rdp);
+		BOOL r;
 
-		if (!monitors)
+		if (!st)
 			return FALSE;
 
-		if (!display_convert_rdp_monitor_to_monitor_def(settings->MonitorCount,
-		                                                settings->MonitorDefArray, &monitors))
+		if (!rdp_write_monitor_layout_pdu(st, settings->MonitorCount, settings->MonitorDefArray))
 		{
-			free(monitors);
+			Stream_Release(st);
 			return FALSE;
 		}
 
-		if (!freerdp_display_send_monitor_layout(rdp->context, settings->MonitorCount, monitors))
-		{
-			free(monitors);
-			return FALSE;
-		}
+		r = rdp_send_data_pdu(rdp, st, DATA_PDU_TYPE_MONITOR_LAYOUT, 0);
 
-		free(monitors);
+		if (!r)
+			return FALSE;
 	}
 
 	if (!rdp_send_server_font_map_pdu(rdp))
diff -urN libfreerdp/core/bulk.c ../../informatimago/FreeRDP/libfreerdp/core/bulk.c
--- libfreerdp/core/bulk.c	2019-07-25 19:51:02.725906664 +0300
+++ ../../informatimago/FreeRDP/libfreerdp/core/bulk.c	2019-07-25 20:11:26.667976236 +0300
@@ -176,8 +176,6 @@
 			         CompressedBytes, UncompressedBytes, metrics->TotalCompressionRatio,
 			         metrics->TotalCompressedBytes, metrics->TotalUncompressedBytes);
 		}
-#else
-		WINPR_UNUSED(CompressionRatio);
 #endif
 	}
 	else
@@ -245,8 +243,6 @@
 			         metrics->TotalCompressionRatio, metrics->TotalCompressedBytes,
 			         metrics->TotalUncompressedBytes);
 		}
-#else
-		WINPR_UNUSED(CompressionRatio);
 #endif
 	}
 
diff -urN libfreerdp/core/capabilities.c ../../informatimago/FreeRDP/libfreerdp/core/capabilities.c
--- libfreerdp/core/capabilities.c	2019-07-25 19:51:02.789906981 +0300
+++ ../../informatimago/FreeRDP/libfreerdp/core/capabilities.c	2019-07-25 20:11:26.731976553 +0300
@@ -119,17 +119,18 @@
 	Stream_Write_UINT16(s, length); /* lengthCapability */
 }
 
-static size_t rdp_capability_set_start(wStream* s)
+static int rdp_capability_set_start(wStream* s)
 {
-	size_t header = Stream_GetPosition(s);
+	size_t header;
+	header = Stream_GetPosition(s);
 	Stream_Zero(s, CAPSET_HEADER_LENGTH);
 	return header;
 }
 
-static void rdp_capability_set_finish(wStream* s, size_t header, UINT16 type)
+static void rdp_capability_set_finish(wStream* s, int header, UINT16 type)
 {
 	size_t footer;
-	size_t length;
+	UINT16 length;
 	footer = Stream_GetPosition(s);
 	length = footer - header;
 	Stream_SetPosition(s, header);
@@ -207,9 +208,9 @@
  * @param settings settings
  */
 
-static BOOL rdp_write_general_capability_set(wStream* s, const rdpSettings* settings)
+static BOOL rdp_write_general_capability_set(wStream* s, rdpSettings* settings)
 {
-	size_t header;
+	int header;
 	UINT16 extraFlags;
 
 	if (!Stream_EnsureRemainingCapacity(s, 64))
@@ -364,9 +365,9 @@
  * @param settings settings
  */
 
-static BOOL rdp_write_bitmap_capability_set(wStream* s, const rdpSettings* settings)
+static BOOL rdp_write_bitmap_capability_set(wStream* s, rdpSettings* settings)
 {
-	size_t header;
+	int header;
 	BYTE drawingFlags = 0;
 	UINT16 preferredBitsPerPixel;
 
@@ -537,9 +538,9 @@
  * @param settings settings
  */
 
-static BOOL rdp_write_order_capability_set(wStream* s, const rdpSettings* settings)
+static BOOL rdp_write_order_capability_set(wStream* s, rdpSettings* settings)
 {
-	size_t header;
+	int header;
 	UINT16 orderFlags;
 	UINT16 orderSupportExFlags;
 	UINT16 textANSICodePage = 0;
@@ -721,10 +722,10 @@
  * @param settings settings
  */
 
-static BOOL rdp_write_bitmap_cache_capability_set(wStream* s, const rdpSettings* settings)
+static BOOL rdp_write_bitmap_cache_capability_set(wStream* s, rdpSettings* settings)
 {
-	UINT16 bpp;
-	size_t header;
+	int bpp;
+	int header;
 	UINT16 size;
 
 	if (!Stream_EnsureRemainingCapacity(s, 64))
@@ -822,9 +823,9 @@
  * @param settings settings
  */
 
-static BOOL rdp_write_control_capability_set(wStream* s, const rdpSettings* settings)
+static BOOL rdp_write_control_capability_set(wStream* s, rdpSettings* settings)
 {
-	size_t header;
+	int header;
 
 	if (!Stream_EnsureRemainingCapacity(s, 32))
 		return FALSE;
@@ -890,9 +891,9 @@
  * @param settings settings
  */
 
-static BOOL rdp_write_window_activation_capability_set(wStream* s, const rdpSettings* settings)
+static BOOL rdp_write_window_activation_capability_set(wStream* s, rdpSettings* settings)
 {
-	size_t header;
+	int header;
 
 	if (!Stream_EnsureRemainingCapacity(s, 32))
 		return FALSE;
@@ -974,9 +975,9 @@
  * @param settings settings
  */
 
-static BOOL rdp_write_pointer_capability_set(wStream* s, const rdpSettings* settings)
+static BOOL rdp_write_pointer_capability_set(wStream* s, rdpSettings* settings)
 {
-	size_t header;
+	int header;
 	UINT16 colorPointerFlag;
 
 	if (!Stream_EnsureRemainingCapacity(s, 32))
@@ -1042,9 +1043,9 @@
  * @param settings settings
  */
 
-static BOOL rdp_write_share_capability_set(wStream* s, const rdpSettings* settings)
+static BOOL rdp_write_share_capability_set(wStream* s, rdpSettings* settings)
 {
-	size_t header;
+	int header;
 	UINT16 nodeId;
 
 	if (!Stream_EnsureRemainingCapacity(s, 32))
@@ -1101,9 +1102,9 @@
  * @param settings settings
  */
 
-static BOOL rdp_write_color_cache_capability_set(wStream* s, const rdpSettings* settings)
+static BOOL rdp_write_color_cache_capability_set(wStream* s, rdpSettings* settings)
 {
-	size_t header;
+	int header;
 
 	if (!Stream_EnsureRemainingCapacity(s, 32))
 		return FALSE;
@@ -1161,9 +1162,9 @@
  * @param settings settings
  */
 
-static BOOL rdp_write_sound_capability_set(wStream* s, const rdpSettings* settings)
+static BOOL rdp_write_sound_capability_set(wStream* s, rdpSettings* settings)
 {
-	size_t header;
+	int header;
 	UINT16 soundFlags;
 
 	if (!Stream_EnsureRemainingCapacity(s, 32))
@@ -1266,9 +1267,9 @@
  * @param settings settings
  */
 
-static BOOL rdp_write_input_capability_set(wStream* s, const rdpSettings* settings)
+static BOOL rdp_write_input_capability_set(wStream* s, rdpSettings* settings)
 {
-	size_t header;
+	int header;
 	UINT16 inputFlags;
 
 	if (!Stream_EnsureRemainingCapacity(s, 128))
@@ -1360,9 +1361,9 @@
  * @param settings settings
  */
 
-static BOOL rdp_write_font_capability_set(wStream* s, const rdpSettings* settings)
+static BOOL rdp_write_font_capability_set(wStream* s, rdpSettings* settings)
 {
-	size_t header;
+	int header;
 
 	if (!Stream_EnsureRemainingCapacity(s, 32))
 		return FALSE;
@@ -1417,9 +1418,9 @@
  * @param settings settings
  */
 
-static BOOL rdp_write_brush_capability_set(wStream* s, const rdpSettings* settings)
+static BOOL rdp_write_brush_capability_set(wStream* s, rdpSettings* settings)
 {
-	size_t header;
+	int header;
 
 	if (!Stream_EnsureRemainingCapacity(s, 32))
 		return FALSE;
@@ -1506,9 +1507,9 @@
  * @param settings settings
  */
 
-static BOOL rdp_write_glyph_cache_capability_set(wStream* s, const rdpSettings* settings)
+static BOOL rdp_write_glyph_cache_capability_set(wStream* s, rdpSettings* settings)
 {
-	size_t header;
+	int header;
 
 	if (!Stream_EnsureRemainingCapacity(s, 64))
 		return FALSE;
@@ -1619,10 +1620,10 @@
  * @param settings settings
  */
 
-static BOOL rdp_write_offscreen_bitmap_cache_capability_set(wStream* s, const rdpSettings* settings)
+static BOOL rdp_write_offscreen_bitmap_cache_capability_set(wStream* s, rdpSettings* settings)
 {
-	size_t header;
-	UINT32 offscreenSupportLevel = 0x00;
+	int header;
+	UINT32 offscreenSupportLevel = FALSE;
 
 	if (!Stream_EnsureRemainingCapacity(s, 32))
 		return FALSE;
@@ -1630,16 +1631,11 @@
 	header = rdp_capability_set_start(s);
 
 	if (settings->OffscreenSupportLevel)
-	{
-		offscreenSupportLevel = 0x01;
-		Stream_Write_UINT32(s, offscreenSupportLevel);        /* offscreenSupportLevel (4 bytes) */
-		Stream_Write_UINT16(s, settings->OffscreenCacheSize); /* offscreenCacheSize (2 bytes) */
-		Stream_Write_UINT16(s,
-		                    settings->OffscreenCacheEntries); /* offscreenCacheEntries (2 bytes) */
-	}
-	else
-		Stream_Zero(s, 8);
+		offscreenSupportLevel = TRUE;
 
+	Stream_Write_UINT32(s, offscreenSupportLevel);           /* offscreenSupportLevel (4 bytes) */
+	Stream_Write_UINT16(s, settings->OffscreenCacheSize);    /* offscreenCacheSize (2 bytes) */
+	Stream_Write_UINT16(s, settings->OffscreenCacheEntries); /* offscreenCacheEntries (2 bytes) */
 	rdp_capability_set_finish(s, header, CAPSET_TYPE_OFFSCREEN_CACHE);
 	return TRUE;
 }
@@ -1698,10 +1694,9 @@
  * @param settings settings
  */
 
-static BOOL rdp_write_bitmap_cache_host_support_capability_set(wStream* s,
-                                                               const rdpSettings* settings)
+static BOOL rdp_write_bitmap_cache_host_support_capability_set(wStream* s, rdpSettings* settings)
 {
-	size_t header;
+	int header;
 
 	if (!Stream_EnsureRemainingCapacity(s, 32))
 		return FALSE;
@@ -1791,9 +1786,9 @@
  * @param settings settings
  */
 
-static BOOL rdp_write_bitmap_cache_v2_capability_set(wStream* s, const rdpSettings* settings)
+static BOOL rdp_write_bitmap_cache_v2_capability_set(wStream* s, rdpSettings* settings)
 {
-	size_t header;
+	int header;
 	UINT16 cacheFlags;
 
 	if (!Stream_EnsureRemainingCapacity(s, 64))
@@ -1903,9 +1898,9 @@
  * @param settings settings
  */
 
-static BOOL rdp_write_virtual_channel_capability_set(wStream* s, const rdpSettings* settings)
+static BOOL rdp_write_virtual_channel_capability_set(wStream* s, rdpSettings* settings)
 {
-	size_t header;
+	int header;
 	UINT32 flags;
 
 	if (!Stream_EnsureRemainingCapacity(s, 32))
@@ -1977,9 +1972,9 @@
  * @param settings settings
  */
 
-static BOOL rdp_write_draw_nine_grid_cache_capability_set(wStream* s, const rdpSettings* settings)
+static BOOL rdp_write_draw_nine_grid_cache_capability_set(wStream* s, rdpSettings* settings)
 {
-	size_t header;
+	int header;
 	UINT32 drawNineGridSupportLevel;
 
 	if (!Stream_EnsureRemainingCapacity(s, 32))
@@ -2081,9 +2076,9 @@
  * @param settings settings
  */
 
-static BOOL rdp_write_draw_gdiplus_cache_capability_set(wStream* s, const rdpSettings* settings)
+static BOOL rdp_write_draw_gdiplus_cache_capability_set(wStream* s, rdpSettings* settings)
 {
-	size_t header;
+	int header;
 	UINT32 drawGDIPlusSupportLevel;
 	UINT32 drawGdiplusCacheLevel;
 
@@ -2154,14 +2149,6 @@
 		}
 	}
 
-	/* 2.2.2.2.3 HandshakeEx PDU (TS_RAIL_ORDER_HANDSHAKE_EX)
-	 * the handshake ex pdu is supported when both, client and server announce
-	 * it OR if we are ready to begin enhanced remoteAPP mode. */
-	if (settings->RemoteApplicationMode)
-		railSupportLevel |= RAIL_LEVEL_HANDSHAKE_EX_SUPPORTED;
-
-	settings->RemoteApplicationSupportLevel =
-	    railSupportLevel & settings->RemoteApplicationSupportMask;
 	return TRUE;
 }
 
@@ -2172,9 +2159,9 @@
  * @param settings settings
  */
 
-static BOOL rdp_write_remote_programs_capability_set(wStream* s, const rdpSettings* settings)
+static BOOL rdp_write_remote_programs_capability_set(wStream* s, rdpSettings* settings)
 {
-	size_t header;
+	int header;
 	UINT32 railSupportLevel;
 
 	if (!Stream_EnsureRemainingCapacity(s, 64))
@@ -2183,20 +2170,9 @@
 	header = rdp_capability_set_start(s);
 	railSupportLevel = RAIL_LEVEL_SUPPORTED;
 
-	if (settings->RemoteApplicationSupportLevel & RAIL_LEVEL_DOCKED_LANGBAR_SUPPORTED)
-	{
-		if (settings->RemoteAppLanguageBarSupported)
-			railSupportLevel |= RAIL_LEVEL_DOCKED_LANGBAR_SUPPORTED;
-	}
+	if (settings->RemoteAppLanguageBarSupported)
+		railSupportLevel |= RAIL_LEVEL_DOCKED_LANGBAR_SUPPORTED;
 
-	railSupportLevel |= RAIL_LEVEL_SHELL_INTEGRATION_SUPPORTED;
-	railSupportLevel |= RAIL_LEVEL_LANGUAGE_IME_SYNC_SUPPORTED;
-	railSupportLevel |= RAIL_LEVEL_SERVER_TO_CLIENT_IME_SYNC_SUPPORTED;
-	railSupportLevel |= RAIL_LEVEL_HIDE_MINIMIZED_APPS_SUPPORTED;
-	railSupportLevel |= RAIL_LEVEL_WINDOW_CLOAKING_SUPPORTED;
-	railSupportLevel |= RAIL_LEVEL_HANDSHAKE_EX_SUPPORTED;
-	/* Mask out everything the server does not support. */
-	railSupportLevel &= settings->RemoteApplicationSupportLevel;
 	Stream_Write_UINT32(s, railSupportLevel); /* railSupportLevel (4 bytes) */
 	rdp_capability_set_finish(s, header, CAPSET_TYPE_RAIL);
 	return TRUE;
@@ -2244,9 +2220,9 @@
  * @param settings settings
  */
 
-static BOOL rdp_write_window_list_capability_set(wStream* s, const rdpSettings* settings)
+static BOOL rdp_write_window_list_capability_set(wStream* s, rdpSettings* settings)
 {
-	size_t header;
+	int header;
 
 	if (!Stream_EnsureRemainingCapacity(s, 32))
 		return FALSE;
@@ -2306,9 +2282,9 @@
  * @param settings settings
  */
 
-static BOOL rdp_write_desktop_composition_capability_set(wStream* s, const rdpSettings* settings)
+static BOOL rdp_write_desktop_composition_capability_set(wStream* s, rdpSettings* settings)
 {
-	size_t header;
+	int header;
 	UINT16 compDeskSupportLevel;
 
 	if (!Stream_EnsureRemainingCapacity(s, 32))
@@ -2417,7 +2393,7 @@
 
 static BOOL rdp_write_multifragment_update_capability_set(wStream* s, rdpSettings* settings)
 {
-	size_t header;
+	int header;
 
 	if (!Stream_EnsureRemainingCapacity(s, 32))
 		return FALSE;
@@ -2490,9 +2466,9 @@
  * @param settings settings
  */
 
-static BOOL rdp_write_large_pointer_capability_set(wStream* s, const rdpSettings* settings)
+static BOOL rdp_write_large_pointer_capability_set(wStream* s, rdpSettings* settings)
 {
-	size_t header;
+	int header;
 	UINT16 largePointerSupportFlags;
 
 	if (!Stream_EnsureRemainingCapacity(s, 32))
@@ -2550,9 +2526,9 @@
  * @param settings settings
  */
 
-static BOOL rdp_write_surface_commands_capability_set(wStream* s, const rdpSettings* settings)
+static BOOL rdp_write_surface_commands_capability_set(wStream* s, rdpSettings* settings)
 {
-	size_t header;
+	int header;
 	UINT32 cmdFlags;
 
 	if (!Stream_EnsureRemainingCapacity(s, 32))
@@ -2868,7 +2844,7 @@
  * @param s stream
  * @param settings settings
  */
-static BOOL rdp_write_rfx_client_capability_container(wStream* s, const rdpSettings* settings)
+static BOOL rdp_write_rfx_client_capability_container(wStream* s, rdpSettings* settings)
 {
 	UINT32 captureFlags;
 	BYTE codecMode;
@@ -2916,7 +2892,7 @@
  * @param s stream
  * @param settings settings
  */
-static BOOL rdp_write_nsc_client_capability_container(wStream* s, const rdpSettings* settings)
+static BOOL rdp_write_nsc_client_capability_container(wStream* s, rdpSettings* settings)
 {
 	BYTE colorLossLevel;
 	BYTE fAllowSubsampling;
@@ -2959,7 +2935,7 @@
  * @param s stream
  * @param settings settings
  */
-static BOOL rdp_write_rfx_server_capability_container(wStream* s, const rdpSettings* settings)
+static BOOL rdp_write_rfx_server_capability_container(wStream* s, rdpSettings* settings)
 {
 	if (!Stream_EnsureRemainingCapacity(s, 8))
 		return FALSE;
@@ -2984,7 +2960,7 @@
  * @param s stream
  * @param settings settings
  */
-static BOOL rdp_write_nsc_server_capability_container(wStream* s, const rdpSettings* settings)
+static BOOL rdp_write_nsc_server_capability_container(wStream* s, rdpSettings* settings)
 {
 	if (!Stream_EnsureRemainingCapacity(s, 8))
 		return FALSE;
@@ -3001,9 +2977,9 @@
  * @param settings settings
  */
 
-static BOOL rdp_write_bitmap_codecs_capability_set(wStream* s, const rdpSettings* settings)
+static BOOL rdp_write_bitmap_codecs_capability_set(wStream* s, rdpSettings* settings)
 {
-	size_t header;
+	int header;
 	BYTE bitmapCodecCount;
 
 	if (!Stream_EnsureRemainingCapacity(s, 64))
@@ -3193,9 +3169,9 @@
  * @param settings settings
  */
 
-static BOOL rdp_write_frame_acknowledge_capability_set(wStream* s, const rdpSettings* settings)
+static BOOL rdp_write_frame_acknowledge_capability_set(wStream* s, rdpSettings* settings)
 {
-	size_t header;
+	int header;
 
 	if (!Stream_EnsureRemainingCapacity(s, 32))
 		return FALSE;
@@ -3233,10 +3209,9 @@
 	return TRUE;
 }
 
-static BOOL rdp_write_bitmap_cache_v3_codec_id_capability_set(wStream* s,
-                                                              const rdpSettings* settings)
+static BOOL rdp_write_bitmap_cache_v3_codec_id_capability_set(wStream* s, rdpSettings* settings)
 {
-	size_t header;
+	int header;
 
 	if (!Stream_EnsureRemainingCapacity(s, 32))
 		return FALSE;
@@ -3857,7 +3832,7 @@
 	return TRUE;
 }
 
-static BOOL rdp_write_demand_active(wStream* s, rdpSettings* settings)
+BOOL rdp_write_demand_active(wStream* s, rdpSettings* settings)
 {
 	size_t bm, em, lm;
 	UINT16 numberCapabilities;
diff -urN libfreerdp/core/capabilities.h ../../informatimago/FreeRDP/libfreerdp/core/capabilities.h
--- libfreerdp/core/capabilities.h	2019-07-25 19:51:02.793907002 +0300
+++ ../../informatimago/FreeRDP/libfreerdp/core/capabilities.h	2019-07-25 20:11:26.735976573 +0300
@@ -135,6 +135,14 @@
 #define DRAW_GDIPLUS_CACHE_LEVEL_DEFAULT 0x00000000
 #define DRAW_GDIPLUS_CACHE_LEVEL_ONE 0x00000001
 
+/* RAIL Support Level */
+#define RAIL_LEVEL_SUPPORTED 0x00000001
+#define RAIL_LEVEL_DOCKED_LANGBAR_SUPPORTED 0x00000002
+#define RAIL_LEVEL_SHELL_INTEGRATION_SUPPORTED 0x00000004
+#define RAIL_LEVEL_LANGUAGE_IME_SYNC_SUPPORTED 0x00000008
+#define RAIL_LEVEL_SERVER_TO_CLIENT_IME_SYNC_SUPPORTED 0x00000010
+#define RAIL_LEVEL_HIDE_MINIMIZED_APPS_SUPPORTED 0x00000020
+
 /* Window Support Level */
 #define WINDOW_LEVEL_NOT_SUPPORTED 0x00000000
 #define WINDOW_LEVEL_SUPPORTED 0x00000001
@@ -166,6 +174,7 @@
 
 FREERDP_LOCAL BOOL rdp_recv_get_active_header(rdpRdp* rdp, wStream* s, UINT16* pChannelId);
 FREERDP_LOCAL BOOL rdp_recv_demand_active(rdpRdp* rdp, wStream* s);
+FREERDP_LOCAL BOOL rdp_write_demand_active(wStream* s, rdpSettings* settings);
 FREERDP_LOCAL BOOL rdp_send_demand_active(rdpRdp* rdp);
 FREERDP_LOCAL BOOL rdp_recv_confirm_active(rdpRdp* rdp, wStream* s);
 FREERDP_LOCAL BOOL rdp_write_confirm_active(wStream* s, rdpSettings* settings);
diff -urN libfreerdp/core/certificate.c ../../informatimago/FreeRDP/libfreerdp/core/certificate.c
--- libfreerdp/core/certificate.c	2019-07-25 19:51:02.805907060 +0300
+++ ../../informatimago/FreeRDP/libfreerdp/core/certificate.c	2019-07-25 20:11:26.747976632 +0300
@@ -276,13 +276,10 @@
 
 	error++;
 
-	if (modulus_length > UINT32_MAX)
+	if (((int)Stream_GetRemainingLength(s)) < modulus_length)
 		goto error1;
 
-	if ((Stream_GetRemainingLength(s)) < modulus_length)
-		goto error1;
-
-	info->ModulusLength = (UINT32)modulus_length;
+	info->ModulusLength = modulus_length;
 	info->Modulus = (BYTE*)malloc(info->ModulusLength);
 
 	if (!info->Modulus)
@@ -296,7 +293,7 @@
 
 	error++;
 
-	if (((Stream_GetRemainingLength(s)) < exponent_length) || (exponent_length > 4))
+	if ((((int)Stream_GetRemainingLength(s)) < exponent_length) || (exponent_length > 4))
 		goto error2;
 
 	Stream_Read(s, &info->exponent[4 - exponent_length], exponent_length);
@@ -828,43 +825,6 @@
 	return NULL;
 }
 
-rdpRsaKey* key_clone(const rdpRsaKey* key)
-{
-	rdpRsaKey* _key = (rdpRsaKey*)calloc(1, sizeof(rdpRsaKey));
-
-	if (!_key)
-		return NULL;
-
-	CopyMemory(_key, key, sizeof(rdpRsaKey));
-
-	if (key->Modulus)
-	{
-		_key->Modulus = (BYTE*)malloc(key->ModulusLength);
-
-		if (!_key->Modulus)
-			goto out_fail;
-
-		CopyMemory(_key->Modulus, key->Modulus, key->ModulusLength);
-	}
-
-	if (key->PrivateExponent)
-	{
-		_key->PrivateExponent = (BYTE*)malloc(key->PrivateExponentLength);
-
-		if (!_key->PrivateExponent)
-			goto out_fail;
-
-		CopyMemory(_key->PrivateExponent, key->PrivateExponent, key->PrivateExponentLength);
-	}
-
-	return _key;
-out_fail:
-	free(_key->Modulus);
-	free(_key->PrivateExponent);
-	free(_key);
-	return NULL;
-}
-
 void key_free(rdpRsaKey* key)
 {
 	if (!key)
@@ -877,7 +837,7 @@
 
 rdpCertificate* certificate_clone(rdpCertificate* certificate)
 {
-	UINT32 index;
+	int index;
 	rdpCertificate* _certificate = (rdpCertificate*)calloc(1, sizeof(rdpCertificate));
 
 	if (!_certificate)
@@ -927,10 +887,10 @@
 
 					if (!_certificate->x509_cert_chain->array[index].data)
 					{
-						for (; index > 0; --index)
+						for (--index; index >= 0; --index)
 						{
-							if (certificate->x509_cert_chain->array[index - 1].length)
-								free(_certificate->x509_cert_chain->array[index - 1].data);
+							if (certificate->x509_cert_chain->array[index].length)
+								free(_certificate->x509_cert_chain->array[index].data);
 						}
 
 						goto out_fail;
diff -urN libfreerdp/core/certificate.h ../../informatimago/FreeRDP/libfreerdp/core/certificate.h
--- libfreerdp/core/certificate.h	2019-07-25 19:51:02.809907081 +0300
+++ ../../informatimago/FreeRDP/libfreerdp/core/certificate.h	2019-07-25 20:11:26.747976632 +0300
@@ -56,7 +56,6 @@
 FREERDP_LOCAL rdpRsaKey* key_new(const char* keyfile);
 FREERDP_LOCAL rdpRsaKey* key_new_from_content(const char* keycontent, const char* keyfile);
 FREERDP_LOCAL void key_free(rdpRsaKey* key);
-FREERDP_LOCAL rdpRsaKey* key_clone(const rdpRsaKey* key);
 
 #define CERTIFICATE_TAG FREERDP_TAG("core.certificate")
 #ifdef WITH_DEBUG_CERTIFICATE
diff -urN libfreerdp/core/client.c ../../informatimago/FreeRDP/libfreerdp/core/client.c
--- libfreerdp/core/client.c	2019-07-25 19:51:02.833907200 +0300
+++ ../../informatimago/FreeRDP/libfreerdp/core/client.c	2019-07-25 20:11:26.771976752 +0300
@@ -349,7 +349,7 @@
 UINT freerdp_channels_post_connect(rdpChannels* channels, freerdp* instance)
 {
 	UINT error = CHANNEL_RC_OK;
-	int index;
+	UINT index;
 	char* hostname;
 	size_t hostnameLength;
 	CHANNEL_CLIENT_DATA* pChannelClientData;
diff -urN libfreerdp/core/CMakeLists.txt ../../informatimago/FreeRDP/libfreerdp/core/CMakeLists.txt
--- libfreerdp/core/CMakeLists.txt	2019-07-24 06:11:52.470197578 +0300
+++ ../../informatimago/FreeRDP/libfreerdp/core/CMakeLists.txt	2019-07-19 20:00:34.121156386 +0300
@@ -15,6 +15,7 @@
 # See the License for the specific language governing permissions and
 # limitations under the License.
 
+
 set(MODULE_NAME "freerdp-core")
 set(MODULE_PREFIX "FREERDP_CORE")
 
@@ -128,10 +129,12 @@
 	window.h
 	listener.c
 	listener.h
+    smartcardlogon.c
+    smartcardlogon.h
+    tscredentials.c
+    tscredentials.h
 	peer.c
-	peer.h
-	display.c
-	display.h)
+	peer.h)
 
 set(${MODULE_PREFIX}_SRCS ${${MODULE_PREFIX}_SRCS} ${${MODULE_PREFIX}_GATEWAY_SRCS})
 
diff -urN libfreerdp/core/connection.c ../../informatimago/FreeRDP/libfreerdp/core/connection.c
--- libfreerdp/core/connection.c	2019-07-25 19:51:02.857907319 +0300
+++ ../../informatimago/FreeRDP/libfreerdp/core/connection.c	2019-07-25 20:11:26.795976870 +0300
@@ -305,7 +305,7 @@
 
 	nego_set_cookie_max_length(rdp->nego, settings->CookieMaxLength);
 
-	if (settings->LoadBalanceInfo && (settings->LoadBalanceInfoLength > 0))
+	if (settings->LoadBalanceInfo)
 	{
 		if (!nego_set_routing_token(rdp->nego, settings->LoadBalanceInfo,
 		                            settings->LoadBalanceInfoLength))
@@ -355,8 +355,6 @@
 
 			return FALSE;
 		}
-
-		SwitchToThread();
 	}
 
 	return TRUE;
@@ -364,11 +362,13 @@
 
 BOOL rdp_client_disconnect(rdpRdp* rdp)
 {
+	rdpSettings* settings;
 	rdpContext* context;
 
 	if (!rdp || !rdp->settings || !rdp->context)
 		return FALSE;
 
+	settings = rdp->settings;
 	context = rdp->context;
 
 	if (!nego_disconnect(rdp->nego))
@@ -402,11 +402,13 @@
 {
 	BOOL status = FALSE;
 	rdpContext* context;
+	rdpChannels* channels;
 
 	if (!rdp || !rdp->context || !rdp->context->channels)
 		return FALSE;
 
 	context = rdp->context;
+	channels = context->channels;
 
 	if (context->instance->ConnectionCallbackState == CLIENT_STATE_INITIAL)
 		return FALSE;
@@ -502,11 +504,15 @@
 {
 	BOOL status;
 	rdpSettings* settings;
+	rdpContext* context;
+	rdpChannels* channels;
 
-	if (!rdp || !rdp->settings)
+	if (!rdp || !rdp->context || !rdp->context->channels)
 		return FALSE;
 
 	settings = rdp->settings;
+	context = rdp->context;
+	channels = context->channels;
 
 	if (!rdp_client_disconnect_and_clear(rdp))
 		return FALSE;
@@ -516,12 +522,9 @@
 
 	if (settings->RedirectionFlags & LB_LOAD_BALANCE_INFO)
 	{
-		if (settings->LoadBalanceInfo && (settings->LoadBalanceInfoLength > 0))
-		{
-			if (!nego_set_routing_token(rdp->nego, settings->LoadBalanceInfo,
-			                            settings->LoadBalanceInfoLength))
-				return FALSE;
-		}
+		if (!nego_set_routing_token(rdp->nego, settings->LoadBalanceInfo,
+		                            settings->LoadBalanceInfoLength))
+			return FALSE;
 	}
 	else
 	{
@@ -576,10 +579,15 @@
 BOOL rdp_client_reconnect(rdpRdp* rdp)
 {
 	BOOL status;
+	rdpContext* context;
+	rdpChannels* channels;
 
 	if (!rdp || !rdp->context || !rdp->context->channels)
 		return FALSE;
 
+	context = rdp->context;
+	channels = context->channels;
+
 	if (!rdp_client_disconnect_and_clear(rdp))
 		return FALSE;
 
diff -urN libfreerdp/core/display.c ../../informatimago/FreeRDP/libfreerdp/core/display.c
--- libfreerdp/core/display.c	2019-07-25 19:51:02.861907339 +0300
+++ ../../informatimago/FreeRDP/libfreerdp/core/display.c	1970-01-01 03:00:00.000000000 +0300
@@ -1,84 +0,0 @@
-/**
- * FreeRDP: A Remote Desktop Protocol Implementation
- * Display update notifications
- *
- * Copyright 2019 Kobi Mizrachi <kmizrachi18@gmail.com>
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-#include "display.h"
-
-BOOL display_write_monitor_layout_pdu(wStream* s, UINT32 monitorCount,
-                                      const MONITOR_DEF* monitorDefArray)
-{
-	UINT32 index;
-	const MONITOR_DEF* monitor;
-
-	if (!Stream_EnsureRemainingCapacity(s, 4 + (monitorCount * 20)))
-		return FALSE;
-
-	Stream_Write_UINT32(s, monitorCount); /* monitorCount (4 bytes) */
-
-	for (index = 0, monitor = monitorDefArray; index < monitorCount; index++, monitor++)
-	{
-		Stream_Write_UINT32(s, monitor->left);   /* left (4 bytes) */
-		Stream_Write_UINT32(s, monitor->top);    /* top (4 bytes) */
-		Stream_Write_UINT32(s, monitor->right);  /* right (4 bytes) */
-		Stream_Write_UINT32(s, monitor->bottom); /* bottom (4 bytes) */
-		Stream_Write_UINT32(s, monitor->flags);  /* flags (4 bytes) */
-	}
-
-	return TRUE;
-}
-
-BOOL display_convert_rdp_monitor_to_monitor_def(UINT32 monitorCount,
-                                                const rdpMonitor* monitorDefArray,
-                                                MONITOR_DEF** result)
-{
-	UINT32 index;
-	const rdpMonitor* monitor;
-
-	if (!monitorDefArray || !(*result))
-		return FALSE;
-
-	for (index = 0, monitor = monitorDefArray; index < monitorCount; index++, monitor++)
-	{
-		MONITOR_DEF* current = (*result + index);
-		current->left = monitor->x;                                   /* left (4 bytes) */
-		current->top = monitor->y;                                    /* top (4 bytes) */
-		current->right = monitor->x + monitor->width - 1;             /* right (4 bytes) */
-		current->bottom = monitor->y + monitor->height - 1;           /* bottom (4 bytes) */
-		current->flags = monitor->is_primary ? MONITOR_PRIMARY : 0x0; /* flags (4 bytes) */
-	}
-
-	return TRUE;
-}
-
-BOOL freerdp_display_send_monitor_layout(rdpContext* context, UINT32 monitorCount,
-                                         const MONITOR_DEF* monitorDefArray)
-{
-	rdpRdp* rdp = context->rdp;
-	wStream* st = rdp_data_pdu_init(rdp);
-
-	if (!st)
-		return FALSE;
-
-	if (!display_write_monitor_layout_pdu(st, monitorCount, monitorDefArray))
-	{
-		Stream_Release(st);
-		return FALSE;
-	}
-
-	return rdp_send_data_pdu(rdp, st, DATA_PDU_TYPE_MONITOR_LAYOUT, 0);
-}
diff -urN libfreerdp/core/display.h ../../informatimago/FreeRDP/libfreerdp/core/display.h
--- libfreerdp/core/display.h	2019-07-25 19:51:02.861907339 +0300
+++ ../../informatimago/FreeRDP/libfreerdp/core/display.h	1970-01-01 03:00:00.000000000 +0300
@@ -1,30 +0,0 @@
-/**
- * FreeRDP: A Remote Desktop Protocol Implementation
- * Display update notifications
- *
- * Copyright 2019 Kobi Mizrachi <kmizrachi18@gmail.com>
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-#ifndef FREERDP_LIB_CORE_DISPLAY_H
-#define FREERDP_LIB_CORE_DISPLAY_H
-
-#include <freerdp/display.h>
-#include "rdp.h"
-
-FREERDP_LOCAL BOOL display_convert_rdp_monitor_to_monitor_def(UINT32 monitorCount,
-                                                              const rdpMonitor* monitorDefArray,
-                                                              MONITOR_DEF** result);
-
-#endif /* FREERDP_LIB_CORE_DISPLAY_H */
diff -urN libfreerdp/core/fastpath.c ../../informatimago/FreeRDP/libfreerdp/core/fastpath.c
--- libfreerdp/core/fastpath.c	2019-07-25 19:51:02.901907537 +0300
+++ ../../informatimago/FreeRDP/libfreerdp/core/fastpath.c	2019-07-25 20:11:26.835977069 +0300
@@ -632,7 +632,6 @@
 
 int fastpath_recv_updates(rdpFastPath* fastpath, wStream* s)
 {
-	int rc = -2;
 	rdpUpdate* update;
 
 	if (!fastpath || !fastpath->rdp || !fastpath->rdp->update || !s)
@@ -640,26 +639,22 @@
 
 	update = fastpath->rdp->update;
 
-	if (!update_begin_paint(update))
-		goto fail;
+	if (!IFCALLRESULT(TRUE, update->BeginPaint, update->context))
+		return -2;
 
 	while (Stream_GetRemainingLength(s) >= 3)
 	{
 		if (fastpath_recv_update_data(fastpath, s) < 0)
 		{
 			WLog_ERR(TAG, "fastpath_recv_update_data() fail");
-			rc = -3;
-			goto fail;
+			return -3;
 		}
 	}
 
-	rc = 0;
-fail:
-
-	if (!update_end_paint(update))
+	if (!IFCALLRESULT(FALSE, update->EndPaint, update->context))
 		return -4;
 
-	return rc;
+	return 0;
 }
 
 static BOOL fastpath_read_input_event_header(wStream* s, BYTE* eventFlags, BYTE* eventCode)
@@ -703,9 +698,6 @@
 	if ((eventFlags & FASTPATH_INPUT_KBDFLAGS_EXTENDED))
 		flags |= KBD_FLAGS_EXTENDED;
 
-	if ((eventFlags & FASTPATH_INPUT_KBDFLAGS_PREFIX_E1))
-		flags |= KBD_FLAGS_EXTENDED1;
-
 	return IFCALLRESULT(TRUE, input->KeyboardEvent, input, flags, code);
 }
 
diff -urN libfreerdp/core/freerdp.c ../../informatimago/FreeRDP/libfreerdp/core/freerdp.c
--- libfreerdp/core/freerdp.c	2019-07-25 19:51:02.917907617 +0300
+++ ../../informatimago/FreeRDP/libfreerdp/core/freerdp.c	2019-07-25 20:11:26.851977148 +0300
@@ -267,16 +267,12 @@
 			Stream_SetLength(s, record.length);
 			Stream_SetPosition(s, 0);
 
-			if (!update_begin_paint(update))
+			if (!update->BeginPaint(update->context))
+				status = FALSE;
+			else if (update_recv_surfcmds(update, s) < 0)
+				status = FALSE;
+			else if (!update->EndPaint(update->context))
 				status = FALSE;
-			else
-			{
-				if (update_recv_surfcmds(update, s) < 0)
-					status = FALSE;
-
-				if (!update_end_paint(update))
-					status = FALSE;
-			}
 
 			Stream_Release(s);
 		}
@@ -774,14 +770,6 @@
 	rdp_set_error_info(rdp, error);
 }
 
-BOOL freerdp_send_error_info(rdpRdp* rdp)
-{
-	if (!rdp)
-		return FALSE;
-
-	return rdp_send_error_info(rdp);
-}
-
 UINT32 freerdp_get_last_error(rdpContext* context)
 {
 	return context->LastError;
@@ -985,6 +973,11 @@
  */
 void freerdp_free(freerdp* instance)
 {
+	if (instance->saved_identity != NULL)
+	{
+		instance->saved_identity->free(instance->saved_identity);
+	}
+
 	free(instance);
 }
 
@@ -998,40 +991,6 @@
 	return written;
 }
 
-BOOL freerdp_nla_impersonate(rdpContext* context)
-{
-	rdpNla* nla;
-
-	if (!context)
-		return FALSE;
-
-	if (!context->rdp)
-		return FALSE;
-
-	if (!context->rdp->transport)
-		return FALSE;
-
-	nla = context->rdp->transport->nla;
-	return nla_impersonate(nla);
-}
-
-BOOL freerdp_nla_revert_to_self(rdpContext* context)
-{
-	rdpNla* nla;
-
-	if (!context)
-		return FALSE;
-
-	if (!context->rdp)
-		return FALSE;
-
-	if (!context->rdp->transport)
-		return FALSE;
-
-	nla = context->rdp->transport->nla;
-	return nla_revert_to_self(nla);
-}
-
 HANDLE getChannelErrorEventHandle(rdpContext* context)
 {
 	return context->channelErrorEvent;
@@ -1078,10 +1037,12 @@
 	SetEvent(context->channelErrorEvent);
 }
 
-const char* freerdp_nego_get_routing_token(rdpContext* context, DWORD* length)
+freerdp_blob* freerdp_saved_identity(freerdp* instance)
 {
-	if (!context || !context->rdp)
-		return NULL;
+	return instance->saved_identity;
+}
 
-	return (const char*)nego_get_routing_token(context->rdp->nego, length);
+void freerdp_save_identity(freerdp* instance, freerdp_blob* identity)
+{
+	instance->saved_identity = identity;
 }
diff -urN libfreerdp/core/gateway/http.c ../../informatimago/FreeRDP/libfreerdp/core/gateway/http.c
--- libfreerdp/core/gateway/http.c	2019-07-25 19:51:02.929907675 +0300
+++ ../../informatimago/FreeRDP/libfreerdp/core/gateway/http.c	2019-07-25 20:11:26.863977208 +0300
@@ -738,14 +738,6 @@
 	return FALSE;
 }
 
-static int print_bio_error(const char* str, size_t len, void* bp)
-{
-	WINPR_UNUSED(len);
-	WINPR_UNUSED(bp);
-	WLog_ERR(TAG, "%s", str);
-	return len;
-}
-
 HttpResponse* http_response_recv(rdpTls* tls, BOOL readContentLength)
 {
 	size_t size;
@@ -774,7 +766,6 @@
 			if (!BIO_should_retry(tls->bio))
 			{
 				WLog_ERR(TAG, "%s: Retries exceeded", __FUNCTION__);
-				ERR_print_errors_cb(print_bio_error, NULL);
 				goto out_error;
 			}
 
@@ -890,7 +881,6 @@
 				if (!BIO_should_retry(tls->bio))
 				{
 					WLog_ERR(TAG, "%s: Retries exceeded", __FUNCTION__);
-					ERR_print_errors_cb(print_bio_error, NULL);
 					goto out_error;
 				}
 
diff -urN libfreerdp/core/gateway/ncacn_http.c ../../informatimago/FreeRDP/libfreerdp/core/gateway/ncacn_http.c
--- libfreerdp/core/gateway/ncacn_http.c	2019-07-25 19:51:02.933907696 +0300
+++ ../../informatimago/FreeRDP/libfreerdp/core/gateway/ncacn_http.c	2019-07-25 20:11:26.871977247 +0300
@@ -145,12 +145,7 @@
 	if (!settings->GatewayPassword || !settings->GatewayUsername ||
 	    !strlen(settings->GatewayPassword) || !strlen(settings->GatewayUsername))
 	{
-		if (!instance->settings->PromptForCredentials || !instance->GatewayAuthenticate)
-		{
-			freerdp_set_last_error(context, FREERDP_ERROR_CONNECT_NO_OR_MISSING_CREDENTIALS);
-			return TRUE;
-		}
-		else
+		if (instance->GatewayAuthenticate)
 		{
 			BOOL proceed =
 			    instance->GatewayAuthenticate(instance, &settings->GatewayUsername,
@@ -158,7 +153,7 @@
 
 			if (!proceed)
 			{
-				freerdp_set_last_error(context, FREERDP_ERROR_CONNECT_NO_OR_MISSING_CREDENTIALS);
+				freerdp_set_last_error(context, FREERDP_ERROR_CONNECT_CANCELLED);
 				return TRUE;
 			}
 
diff -urN libfreerdp/core/gateway/rdg.c ../../informatimago/FreeRDP/libfreerdp/core/gateway/rdg.c
--- libfreerdp/core/gateway/rdg.c	2019-07-25 19:51:02.973907894 +0300
+++ ../../informatimago/FreeRDP/libfreerdp/core/gateway/rdg.c	2019-07-25 20:11:26.903977406 +0300
@@ -609,15 +609,13 @@
 static BOOL rdg_skip_seed_payload(rdpTls* tls, SSIZE_T lastResponseLength)
 {
 	BYTE seed_payload[10];
-	const size_t size = sizeof(seed_payload);
-	assert(size < SSIZE_MAX);
 
 	/* Per [MS-TSGU] 3.3.5.1 step 4, after final OK response RDG server sends
 	 * random "seed" payload of limited size. In practice it's 10 bytes.
 	 */
-	if (lastResponseLength < (SSIZE_T)size)
+	if (lastResponseLength < sizeof(seed_payload))
 	{
-		if (!rdg_read_all(tls, seed_payload, size - lastResponseLength))
+		if (!rdg_read_all(tls, seed_payload, sizeof(seed_payload) - lastResponseLength))
 		{
 			return FALSE;
 		}
@@ -863,12 +861,7 @@
 	if (!settings->GatewayPassword || !settings->GatewayUsername ||
 	    !strlen(settings->GatewayPassword) || !strlen(settings->GatewayUsername))
 	{
-		if (!instance->settings->PromptForCredentials || !instance->GatewayAuthenticate)
-		{
-			freerdp_set_last_error(context, FREERDP_ERROR_CONNECT_NO_OR_MISSING_CREDENTIALS);
-			return FALSE;
-		}
-		else
+		if (instance->GatewayAuthenticate)
 		{
 			BOOL proceed =
 			    instance->GatewayAuthenticate(instance, &settings->GatewayUsername,
@@ -876,7 +869,7 @@
 
 			if (!proceed)
 			{
-				freerdp_set_last_error(context, FREERDP_ERROR_CONNECT_NO_OR_MISSING_CREDENTIALS);
+				freerdp_set_last_error(context, FREERDP_ERROR_CONNECT_CANCELLED);
 				return FALSE;
 			}
 
@@ -1022,25 +1015,6 @@
 	tls->port = (int)settings->GatewayPort;
 	tls->isGatewayTransport = TRUE;
 	status = tls_connect(tls, bufferedBio);
-
-	if (status < 1)
-	{
-		rdpContext* context = rdg->context;
-
-		if (status < 0)
-		{
-			if (!freerdp_get_last_error(context))
-				freerdp_set_last_error(context, FREERDP_ERROR_TLS_CONNECT_FAILED);
-		}
-		else
-		{
-			if (!freerdp_get_last_error(context))
-				freerdp_set_last_error(context, FREERDP_ERROR_CONNECT_CANCELLED);
-		}
-
-		return FALSE;
-	}
-
 	return (status >= 1);
 }
 
@@ -1070,9 +1044,7 @@
 
 		StatusCode = http_response_get_status_code(response);
 
-		switch (StatusCode)
-		{
-		case HTTP_STATUS_NOT_FOUND:
+		if (StatusCode == HTTP_STATUS_NOT_FOUND)
 		{
 			WLog_INFO(TAG, "RD Gateway does not support HTTP transport.");
 
@@ -1083,10 +1055,6 @@
 			return FALSE;
 		}
 
-		default:
-			break;
-		}
-
 		if (!rdg_handle_ntlm_challenge(rdg->ntlm, response))
 		{
 			http_response_free(response);
@@ -1111,19 +1079,9 @@
 	http_response_free(response);
 	WLog_DBG(TAG, "%s authorization result: %d", method, statusCode);
 
-	switch (statusCode)
-	{
-	case HTTP_STATUS_OK:
-		break;
-
-	case HTTP_STATUS_DENIED:
-		freerdp_set_last_error(rdg->context, FREERDP_ERROR_CONNECT_ACCESS_DENIED);
+	if (statusCode != HTTP_STATUS_OK)
 		return FALSE;
 
-	default:
-		return FALSE;
-	}
-
 	if (strcmp(method, "RDG_OUT_DATA") == 0)
 	{
 		if (!rdg_skip_seed_payload(tls, bodyLength))
diff -urN libfreerdp/core/gateway/rpc_bind.c ../../informatimago/FreeRDP/libfreerdp/core/gateway/rpc_bind.c
--- libfreerdp/core/gateway/rpc_bind.c	2019-07-25 19:51:03.001908033 +0300
+++ ../../informatimago/FreeRDP/libfreerdp/core/gateway/rpc_bind.c	2019-07-25 20:11:26.935977564 +0300
@@ -133,13 +133,7 @@
 
 	if (promptPassword)
 	{
-		if (!instance->settings->PromptForCredentials || !instance->GatewayAuthenticate)
-		{
-			freerdp_set_last_error(instance->context,
-			                       FREERDP_ERROR_CONNECT_NO_OR_MISSING_CREDENTIALS);
-			return 0;
-		}
-		else
+		if (instance->GatewayAuthenticate)
 		{
 			BOOL proceed =
 			    instance->GatewayAuthenticate(instance, &settings->GatewayUsername,
@@ -147,8 +141,7 @@
 
 			if (!proceed)
 			{
-				freerdp_set_last_error(instance->context,
-				                       FREERDP_ERROR_CONNECT_NO_OR_MISSING_CREDENTIALS);
+				freerdp_set_last_error(instance->context, FREERDP_ERROR_CONNECT_CANCELLED);
 				return 0;
 			}
 
diff -urN libfreerdp/core/gateway/rpc_client.c ../../informatimago/FreeRDP/libfreerdp/core/gateway/rpc_client.c
--- libfreerdp/core/gateway/rpc_client.c	2019-07-25 19:51:03.017908112 +0300
+++ ../../informatimago/FreeRDP/libfreerdp/core/gateway/rpc_client.c	2019-07-25 20:11:26.951977644 +0300
@@ -424,6 +424,9 @@
 		}
 		else
 		{
+			if (rpc->VirtualConnection->State < VIRTUAL_CONNECTION_STATE_OPENED)
+				WLog_ERR(TAG, "warning: unhandled RTS PDU");
+
 			if (rts_recv_out_of_sequence_pdu(rpc, buffer, header->common.frag_length) < 0)
 				return -1;
 		}
@@ -891,7 +894,7 @@
 	UINT32 offset;
 	BYTE* buffer = NULL;
 	UINT32 stub_data_pad;
-	SecBuffer Buffers[2] = { 0 };
+	SecBuffer Buffers[2] = { { 0 } };
 	SecBufferDesc Message;
 	RpcClientCall* clientCall = NULL;
 	rdpNtlm* ntlm;
diff -urN libfreerdp/core/gateway/tsg.c ../../informatimago/FreeRDP/libfreerdp/core/gateway/tsg.c
--- libfreerdp/core/gateway/tsg.c	2019-07-25 19:51:03.617911088 +0300
+++ ../../informatimago/FreeRDP/libfreerdp/core/gateway/tsg.c	2019-07-25 20:11:27.523980480 +0300
@@ -131,18 +131,25 @@
 	INT32 isConsentMandatory;
 	UINT32 msgBytes;
 	WCHAR* msgBuffer;
-} TSG_PACKET_STRING_MESSAGE;
+} TSG_PACKET_STRING_MESSAGE, *PTSG_PACKET_STRING_MESSAGE;
 
 typedef struct TSG_PACKET_REAUTH_MESSAGE
 {
 	UINT64 tunnelContext;
 } TSG_PACKET_REAUTH_MESSAGE, *PTSG_PACKET_REAUTH_MESSAGE;
 
+typedef union {
+	PTSG_PACKET_STRING_MESSAGE consentMessage;
+	PTSG_PACKET_STRING_MESSAGE serviceMessage;
+	PTSG_PACKET_REAUTH_MESSAGE reauthMessage;
+} TSG_PACKET_TYPE_MESSAGE_UNION, *PTSG_PACKET_TYPE_MESSAGE_UNION;
+
 typedef struct _TSG_PACKET_MSG_RESPONSE
 {
 	UINT32 msgID;
 	UINT32 msgType;
 	INT32 isMsgPresent;
+	TSG_PACKET_TYPE_MESSAGE_UNION messagePacket;
 } TSG_PACKET_MSG_RESPONSE, *PTSG_PACKET_MSG_RESPONSE;
 
 typedef struct TSG_PACKET_CAPS_RESPONSE
@@ -1015,46 +1022,18 @@
 	return rpc_client_write_call(rpc, s, TsProxyMakeTunnelCallOpnum);
 }
 
-static BOOL TsProxyReadPacketSTringMessage(rdpTsg* tsg, wStream* s, TSG_PACKET_STRING_MESSAGE* msg)
-{
-	UINT32 Pointer, ActualCount, MaxCount;
-
-	if (!tsg || !s || !msg)
-		return FALSE;
-
-	if (Stream_GetRemainingLength(s) < 32)
-		return FALSE;
-
-	Stream_Read_UINT32(s, Pointer);                /* ConsentMessagePtr (4 bytes) */
-	Stream_Read_INT32(s, msg->isDisplayMandatory); /* IsDisplayMandatory (4 bytes) */
-	Stream_Read_INT32(s, msg->isConsentMandatory); /* IsConsentMandatory (4 bytes) */
-	Stream_Read_UINT32(s, msg->msgBytes);          /* MsgBytes (4 bytes) */
-	Stream_Read_UINT32(s, Pointer);                /* MsgPtr (4 bytes) */
-	Stream_Read_UINT32(s, MaxCount);               /* MaxCount (4 bytes) */
-	Stream_Seek_UINT32(s);                         /* Offset (4 bytes) */
-	Stream_Read_UINT32(s, ActualCount);            /* ActualCount (4 bytes) */
-
-	if (msg->msgBytes < ActualCount * 2)
-		return FALSE;
-
-	if (Stream_GetRemainingLength(s) < msg->msgBytes)
-		return FALSE;
-
-	msg->msgBuffer = (WCHAR*)Stream_Pointer(s);
-	Stream_Seek(s, msg->msgBytes);
-	return TRUE;
-}
-
 static BOOL TsProxyMakeTunnelCallReadResponse(rdpTsg* tsg, RPC_PDU* pdu)
 {
 	BOOL rc = FALSE;
 	UINT32 Pointer;
+	UINT32 MaxCount;
+	UINT32 ActualCount;
 	UINT32 SwitchValue;
-	TSG_PACKET packet;
+	PTSG_PACKET packet;
 	char* messageText = NULL;
-	TSG_PACKET_MSG_RESPONSE packetMsgResponse = { 0 };
-	TSG_PACKET_STRING_MESSAGE packetStringMessage = { 0 };
-	TSG_PACKET_REAUTH_MESSAGE packetReauthMessage = { 0 };
+	PTSG_PACKET_MSG_RESPONSE packetMsgResponse = NULL;
+	PTSG_PACKET_STRING_MESSAGE packetStringMessage = NULL;
+	PTSG_PACKET_REAUTH_MESSAGE packetReauthMessage = NULL;
 	WLog_DBG(TAG, "TsProxyMakeTunnelCallReadResponse");
 
 	/* This is an asynchronous response */
@@ -1062,87 +1041,125 @@
 	if (!pdu)
 		return FALSE;
 
-	if (Stream_GetRemainingLength(pdu->s) < 28)
+	packet = (PTSG_PACKET)calloc(1, sizeof(TSG_PACKET));
+
+	if (!packet)
+		return FALSE;
+
+	if (Stream_GetRemainingLength(pdu->s) < 32)
 		goto fail;
 
-	Stream_Seek_UINT32(pdu->s);                  /* PacketPtr (4 bytes) */
-	Stream_Read_UINT32(pdu->s, packet.packetId); /* PacketId (4 bytes) */
-	Stream_Read_UINT32(pdu->s, SwitchValue);     /* SwitchValue (4 bytes) */
+	Stream_Seek_UINT32(pdu->s);                   /* PacketPtr (4 bytes) */
+	Stream_Read_UINT32(pdu->s, packet->packetId); /* PacketId (4 bytes) */
+	Stream_Read_UINT32(pdu->s, SwitchValue);      /* SwitchValue (4 bytes) */
 
-	if ((packet.packetId != TSG_PACKET_TYPE_MESSAGE_PACKET) ||
+	if ((packet->packetId != TSG_PACKET_TYPE_MESSAGE_PACKET) ||
 	    (SwitchValue != TSG_PACKET_TYPE_MESSAGE_PACKET))
 	{
 		WLog_ERR(TAG,
 		         "Unexpected PacketId: 0x%08" PRIX32 ", Expected TSG_PACKET_TYPE_MESSAGE_PACKET",
-		         packet.packetId);
+		         packet->packetId);
 		goto fail;
 	}
 
-	Stream_Read_UINT32(pdu->s, Pointer);                       /* PacketMsgResponsePtr (4 bytes) */
-	Stream_Read_UINT32(pdu->s, packetMsgResponse.msgID);       /* MsgId (4 bytes) */
-	Stream_Read_UINT32(pdu->s, packetMsgResponse.msgType);     /* MsgType (4 bytes) */
-	Stream_Read_INT32(pdu->s, packetMsgResponse.isMsgPresent); /* IsMsgPresent (4 bytes) */
+	packetMsgResponse = (PTSG_PACKET_MSG_RESPONSE)calloc(1, sizeof(TSG_PACKET_MSG_RESPONSE));
 
-	/* 2.2.9.2.1.9 TSG_PACKET_MSG_RESPONSE: Ignore empty message body. */
-	if (!packetMsgResponse.isMsgPresent)
-	{
-		rc = TRUE;
+	if (!packetMsgResponse)
 		goto fail;
-	}
 
-	Stream_Read_UINT32(pdu->s, SwitchValue); /* SwitchValue (4 bytes) */
+	packet->tsgPacket.packetMsgResponse = packetMsgResponse;
+	Stream_Read_UINT32(pdu->s, Pointer);                        /* PacketMsgResponsePtr (4 bytes) */
+	Stream_Read_UINT32(pdu->s, packetMsgResponse->msgID);       /* MsgId (4 bytes) */
+	Stream_Read_UINT32(pdu->s, packetMsgResponse->msgType);     /* MsgType (4 bytes) */
+	Stream_Read_INT32(pdu->s, packetMsgResponse->isMsgPresent); /* IsMsgPresent (4 bytes) */
+	Stream_Read_UINT32(pdu->s, SwitchValue);                    /* SwitchValue (4 bytes) */
 
 	switch (SwitchValue)
 	{
 	case TSG_ASYNC_MESSAGE_CONSENT_MESSAGE:
-		if (!TsProxyReadPacketSTringMessage(tsg, pdu->s, &packetStringMessage))
+		packetStringMessage =
+		    (PTSG_PACKET_STRING_MESSAGE)calloc(1, sizeof(TSG_PACKET_STRING_MESSAGE));
+
+		if (!packetStringMessage)
 			goto fail;
 
-		ConvertFromUnicode(CP_UTF8, 0, packetStringMessage.msgBuffer,
-		                   packetStringMessage.msgBytes / 2, &messageText, 0, NULL, NULL);
-		WLog_INFO(TAG, "Consent Message: %s", messageText);
-		free(messageText);
+		packetMsgResponse->messagePacket.consentMessage = packetStringMessage;
 
-		if (tsg->rpc && tsg->rpc->context && tsg->rpc->context->instance)
-		{
-			rc = IFCALLRESULT(TRUE, tsg->rpc->context->instance->PresentGatewayMessage,
-			                  tsg->rpc->context->instance, SwitchValue,
-			                  packetStringMessage.isDisplayMandatory != 0,
-			                  packetStringMessage.isConsentMandatory != 0,
-			                  packetStringMessage.msgBytes, packetStringMessage.msgBuffer);
-		}
+		if (Stream_GetRemainingLength(pdu->s) < 32)
+			goto fail;
 
+		Stream_Read_UINT32(pdu->s, Pointer); /* ConsentMessagePtr (4 bytes) */
+		Stream_Read_INT32(
+		    pdu->s, packetStringMessage->isDisplayMandatory); /* IsDisplayMandatory (4 bytes) */
+		Stream_Read_INT32(
+		    pdu->s, packetStringMessage->isConsentMandatory); /* IsConsentMandatory (4 bytes) */
+		Stream_Read_UINT32(pdu->s, packetStringMessage->msgBytes); /* MsgBytes (4 bytes) */
+		Stream_Read_UINT32(pdu->s, Pointer);                       /* MsgPtr (4 bytes) */
+		Stream_Read_UINT32(pdu->s, MaxCount);                      /* MaxCount (4 bytes) */
+		Stream_Seek_UINT32(pdu->s);                                /* Offset (4 bytes) */
+		Stream_Read_UINT32(pdu->s, ActualCount);                   /* ActualCount (4 bytes) */
+
+		if (Stream_GetRemainingLength(pdu->s) < ActualCount * 2)
+			goto fail;
+
+		ConvertFromUnicode(CP_UTF8, 0, (WCHAR*)Stream_Pointer(pdu->s), ActualCount, &messageText, 0,
+		                   NULL, NULL);
+		Stream_Seek(pdu->s, ActualCount * 2);
+		WLog_INFO(TAG, "Consent Message: %s", messageText);
+		free(messageText);
 		break;
 
 	case TSG_ASYNC_MESSAGE_SERVICE_MESSAGE:
-		if (!TsProxyReadPacketSTringMessage(tsg, pdu->s, &packetStringMessage))
+		packetStringMessage =
+		    (PTSG_PACKET_STRING_MESSAGE)calloc(1, sizeof(TSG_PACKET_STRING_MESSAGE));
+
+		if (!packetStringMessage)
 			goto fail;
 
-		ConvertFromUnicode(CP_UTF8, 0, packetStringMessage.msgBuffer,
-		                   packetStringMessage.msgBytes / 2, &messageText, 0, NULL, NULL);
-		WLog_INFO(TAG, "Service Message: %s", messageText);
-		free(messageText);
+		packetMsgResponse->messagePacket.serviceMessage = packetStringMessage;
 
-		if (tsg->rpc && tsg->rpc->context && tsg->rpc->context->instance)
-		{
-			rc = IFCALLRESULT(TRUE, tsg->rpc->context->instance->PresentGatewayMessage,
-			                  tsg->rpc->context->instance, SwitchValue,
-			                  packetStringMessage.isDisplayMandatory != 0,
-			                  packetStringMessage.isConsentMandatory != 0,
-			                  packetStringMessage.msgBytes, packetStringMessage.msgBuffer);
-		}
+		if (Stream_GetRemainingLength(pdu->s) < 32)
+			goto fail;
 
+		Stream_Read_UINT32(pdu->s, Pointer); /* ServiceMessagePtr (4 bytes) */
+		Stream_Read_INT32(
+		    pdu->s, packetStringMessage->isDisplayMandatory); /* IsDisplayMandatory (4 bytes) */
+		Stream_Read_INT32(
+		    pdu->s, packetStringMessage->isConsentMandatory); /* IsConsentMandatory (4 bytes) */
+		Stream_Read_UINT32(pdu->s, packetStringMessage->msgBytes); /* MsgBytes (4 bytes) */
+		Stream_Read_UINT32(pdu->s, Pointer);                       /* MsgPtr (4 bytes) */
+		Stream_Read_UINT32(pdu->s, MaxCount);                      /* MaxCount (4 bytes) */
+		Stream_Seek_UINT32(pdu->s);                                /* Offset (4 bytes) */
+		Stream_Read_UINT32(pdu->s, ActualCount);                   /* ActualCount (4 bytes) */
+
+		if (Stream_GetRemainingLength(pdu->s) < ActualCount * 2)
+			goto fail;
+
+		ConvertFromUnicode(CP_UTF8, 0, (WCHAR*)Stream_Pointer(pdu->s), ActualCount, &messageText, 0,
+		                   NULL, NULL);
+		Stream_Seek(pdu->s, ActualCount * 2);
+		WLog_INFO(TAG, "Service Message: %s", messageText);
+		free(messageText);
 		break;
 
 	case TSG_ASYNC_MESSAGE_REAUTH:
+		packetReauthMessage =
+		    (PTSG_PACKET_REAUTH_MESSAGE)calloc(1, sizeof(TSG_PACKET_REAUTH_MESSAGE));
+
+		if (!packetReauthMessage)
+			goto fail;
+
+		packetMsgResponse->messagePacket.reauthMessage = packetReauthMessage;
+
 		if (Stream_GetRemainingLength(pdu->s) < 20)
 			goto fail;
 
 		Stream_Read_UINT32(pdu->s, Pointer); /* ReauthMessagePtr (4 bytes) */
 		Stream_Seek_UINT32(pdu->s);          /* alignment pad (4 bytes) */
-		Stream_Read_UINT64(pdu->s, packetReauthMessage.tunnelContext); /* TunnelContext (8 bytes) */
-		Stream_Seek_UINT32(pdu->s);                                    /* ReturnValue (4 bytes) */
-		tsg->ReauthTunnelContext = packetReauthMessage.tunnelContext;
+		Stream_Read_UINT64(pdu->s,
+		                   packetReauthMessage->tunnelContext); /* TunnelContext (8 bytes) */
+		Stream_Seek_UINT32(pdu->s);                             /* ReturnValue (4 bytes) */
+		tsg->ReauthTunnelContext = packetReauthMessage->tunnelContext;
 		break;
 
 	default:
@@ -1152,6 +1169,10 @@
 
 	rc = TRUE;
 fail:
+	free(packetStringMessage);
+	free(packetReauthMessage);
+	free(packetMsgResponse);
+	free(packet);
 	return rc;
 }
 
diff -urN libfreerdp/core/gcc.c ../../informatimago/FreeRDP/libfreerdp/core/gcc.c
--- libfreerdp/core/gcc.c	2019-07-25 19:51:03.645911225 +0300
+++ ../../informatimago/FreeRDP/libfreerdp/core/gcc.c	2019-07-25 20:11:27.551980619 +0300
@@ -1735,7 +1735,7 @@
 
 void gcc_write_client_monitor_data(wStream* s, rdpMcs* mcs)
 {
-	UINT32 i;
+	int i;
 	UINT16 length;
 	UINT32 left, top, right, bottom, flags;
 	INT32 baseX = 0, baseY = 0;
diff -urN libfreerdp/core/info.c ../../informatimago/FreeRDP/libfreerdp/core/info.c
--- libfreerdp/core/info.c	2019-07-25 19:51:03.677911384 +0300
+++ ../../informatimago/FreeRDP/libfreerdp/core/info.c	2019-07-25 20:11:27.583980778 +0300
@@ -730,16 +730,14 @@
 		flags |= INFO_AUTOLOGON;
 
 	if (settings->RemoteApplicationMode)
-	{
-		if (settings->HiDefRemoteApp)
-			flags |= INFO_HIDEF_RAIL_SUPPORTED;
-
 		flags |= INFO_RAIL;
-	}
 
 	if (settings->RemoteConsoleAudio)
 		flags |= INFO_REMOTECONSOLEAUDIO;
 
+	if (settings->HiDefRemoteApp)
+		flags |= INFO_HIDEF_RAIL_SUPPORTED;
+
 	if (settings->CompressionEnabled)
 	{
 		flags |= INFO_COMPRESSION;
@@ -772,9 +770,6 @@
 		cbDomain = 0;
 	}
 
-	/* excludes (!) the length of the mandatory null terminator */
-	cbDomain = cbDomain >= 2 ? cbDomain - 2 : cbDomain;
-
 	if (!settings->RemoteAssistanceMode)
 	{
 		cbUserName = ConvertToUnicode(CP_UTF8, 0, settings->Username, -1, &userNameW, 0) * 2;
@@ -785,16 +780,14 @@
 		cbUserName = ConvertToUnicode(CP_UTF8, 0, settings->Username, -1, &userNameW, 0) * 2;
 	}
 
-	/* excludes (!) the length of the mandatory null terminator */
-	cbUserName = cbUserName >= 2 ? cbUserName - 2 : cbUserName;
-
 	if (!settings->RemoteAssistanceMode)
 	{
 		if (settings->RedirectionPassword && settings->RedirectionPasswordLength > 0)
 		{
 			usedPasswordCookie = TRUE;
 			passwordW = (WCHAR*)settings->RedirectionPassword;
-			cbPassword = settings->RedirectionPasswordLength;
+			cbPassword =
+			    settings->RedirectionPasswordLength - 2; /* Strip double zero termination */
 		}
 		else
 		{
@@ -807,9 +800,6 @@
 		cbPassword = ConvertToUnicode(CP_UTF8, 0, "*", -1, &passwordW, 0) * 2;
 	}
 
-	/* excludes (!) the length of the mandatory null terminator */
-	cbPassword = cbPassword >= 2 ? cbPassword - 2 : cbPassword;
-
 	if (!settings->RemoteAssistanceMode)
 	{
 		cbAlternateShell =
@@ -831,9 +821,6 @@
 		}
 	}
 
-	/* excludes (!) the length of the mandatory null terminator */
-	cbAlternateShell = cbAlternateShell >= 2 ? cbAlternateShell - 2 : cbAlternateShell;
-
 	if (!settings->RemoteAssistanceMode)
 	{
 		cbWorkingDir =
@@ -847,8 +834,6 @@
 		    2;
 	}
 
-	/* excludes (!) the length of the mandatory null terminator */
-	cbWorkingDir = cbWorkingDir >= 2 ? cbWorkingDir - 2 : cbWorkingDir;
 	Stream_Write_UINT32(s, 0);                /* CodePage (4 bytes) */
 	Stream_Write_UINT32(s, flags);            /* flags (4 bytes) */
 	Stream_Write_UINT16(s, cbDomain);         /* cbDomain (2 bytes) */
@@ -860,31 +845,26 @@
 	if (cbDomain > 0)
 		Stream_Write(s, domainW, cbDomain);
 
-	/* the mandatory null terminator */
 	Stream_Write_UINT16(s, 0);
 
 	if (cbUserName > 0)
 		Stream_Write(s, userNameW, cbUserName);
 
-	/* the mandatory null terminator */
 	Stream_Write_UINT16(s, 0);
 
 	if (cbPassword > 0)
 		Stream_Write(s, passwordW, cbPassword);
 
-	/* the mandatory null terminator */
 	Stream_Write_UINT16(s, 0);
 
 	if (cbAlternateShell > 0)
 		Stream_Write(s, alternateShellW, cbAlternateShell);
 
-	/* the mandatory null terminator */
 	Stream_Write_UINT16(s, 0);
 
 	if (cbWorkingDir > 0)
 		Stream_Write(s, workingDirW, cbWorkingDir);
 
-	/* the mandatory null terminator */
 	Stream_Write_UINT16(s, 0);
 	free(domainW);
 	free(userNameW);
@@ -1187,7 +1167,7 @@
 	Stream_Read_UINT16(s, Length);        /* Length (2 bytes) */
 	Stream_Read_UINT32(s, fieldsPresent); /* fieldsPresent (4 bytes) */
 
-	if ((Length < 6) || (Stream_GetRemainingLength(s) < (Length - 6U)))
+	if ((Length < 6) || (Stream_GetRemainingLength(s) < (Length - 6)))
 		return FALSE;
 
 	WLog_DBG(TAG, "LogonInfoExtended: fieldsPresent: 0x%08" PRIX32 "", fieldsPresent);
@@ -1483,17 +1463,3 @@
 
 	return status;
 }
-
-BOOL rdp_send_server_status_info(rdpContext* context, UINT32 status)
-{
-	wStream* s;
-	rdpRdp* rdp = context->rdp;
-	s = rdp_data_pdu_init(rdp);
-
-	if (!s)
-		return FALSE;
-
-	Stream_Write_UINT32(s, status);
-	return rdp_send_data_pdu(rdp, s, DATA_PDU_TYPE_STATUS_INFO, rdp->mcs->userId);
-	;
-}
diff -urN libfreerdp/core/info.h ../../informatimago/FreeRDP/libfreerdp/core/info.h
--- libfreerdp/core/info.h	2019-07-25 19:51:03.681911405 +0300
+++ ../../informatimago/FreeRDP/libfreerdp/core/info.h	2019-07-25 20:11:27.583980778 +0300
@@ -63,7 +63,6 @@
 FREERDP_LOCAL BOOL rdp_send_client_info(rdpRdp* rdp);
 FREERDP_LOCAL BOOL rdp_recv_save_session_info(rdpRdp* rdp, wStream* s);
 FREERDP_LOCAL BOOL rdp_send_save_session_info(rdpContext* context, UINT32 type, void* data);
-FREERDP_LOCAL BOOL rdp_send_server_status_info(rdpContext* context, UINT32 status);
 
 FREERDP_LOCAL char* rdp_info_package_flags_description(UINT32 flags);
 
diff -urN libfreerdp/core/input.c ../../informatimago/FreeRDP/libfreerdp/core/input.c
--- libfreerdp/core/input.c	2019-07-25 19:51:03.689911444 +0300
+++ ../../informatimago/FreeRDP/libfreerdp/core/input.c	2019-07-25 20:11:27.595980837 +0300
@@ -130,6 +130,7 @@
 static BOOL input_send_unicode_keyboard_event(rdpInput* input, UINT16 flags, UINT16 code)
 {
 	wStream* s;
+	UINT16 keyboardFlags = 0;
 	rdpRdp* rdp;
 
 	if (!input || !input->context)
@@ -142,6 +143,16 @@
 	}
 
 	rdp = input->context->rdp;
+	/*
+	 * According to the specification, the slow path Unicode Keyboard Event
+	 * (TS_UNICODE_KEYBOARD_EVENT) contains KBD_FLAGS_RELEASE flag when key
+	 * is released, but contains no flags when it is pressed.
+	 * This is different from the slow path Keyboard Event
+	 * (TS_KEYBOARD_EVENT) which does contain KBD_FLAGS_DOWN flag when the
+	 * key is pressed.
+	 * There is no KBD_FLAGS_EXTENDED flag in TS_UNICODE_KEYBOARD_EVENT.
+	 */
+	keyboardFlags |= (flags & KBD_FLAGS_RELEASE) ? KBD_FLAGS_RELEASE : 0;
 	s = rdp_client_input_pdu_init(rdp, INPUT_EVENT_UNICODE);
 
 	if (!s)
@@ -245,8 +256,7 @@
 	 */
 
 	/* Control down (0x1D) */
-	if (!input_send_keyboard_event(input, KBD_FLAGS_EXTENDED1,
-	                               RDP_SCANCODE_CODE(RDP_SCANCODE_LCONTROL)))
+	if (!input_send_keyboard_event(input, 0, RDP_SCANCODE_CODE(RDP_SCANCODE_LCONTROL)))
 		return FALSE;
 
 	/* Numlock down (0x45) */
@@ -254,7 +264,7 @@
 		return FALSE;
 
 	/* Control up (0x1D) */
-	if (!input_send_keyboard_event(input, KBD_FLAGS_RELEASE | KBD_FLAGS_EXTENDED1,
+	if (!input_send_keyboard_event(input, KBD_FLAGS_RELEASE,
 	                               RDP_SCANCODE_CODE(RDP_SCANCODE_LCONTROL)))
 		return FALSE;
 
@@ -293,7 +303,6 @@
 	rdp = input->context->rdp;
 	eventFlags |= (flags & KBD_FLAGS_RELEASE) ? FASTPATH_INPUT_KBDFLAGS_RELEASE : 0;
 	eventFlags |= (flags & KBD_FLAGS_EXTENDED) ? FASTPATH_INPUT_KBDFLAGS_EXTENDED : 0;
-	eventFlags |= (flags & KBD_FLAGS_EXTENDED1) ? FASTPATH_INPUT_KBDFLAGS_PREFIX_E1 : 0;
 	s = fastpath_input_pdu_init(rdp->fastpath, eventFlags, FASTPATH_INPUT_EVENT_SCANCODE);
 
 	if (!s)
diff -urN libfreerdp/core/license.c ../../informatimago/FreeRDP/libfreerdp/core/license.c
--- libfreerdp/core/license.c	2019-07-25 19:51:03.725911623 +0300
+++ ../../informatimago/FreeRDP/libfreerdp/core/license.c	2019-07-25 20:11:27.627980996 +0300
@@ -168,7 +168,7 @@
 	WINPR_DIGEST_CTX* sha1 = NULL;
 	BOOL ret = FALSE;
 	BYTE hash[20];
-	size_t i;
+	int i;
 
 	if (!(sha1 = winpr_Digest_New()))
 		goto out;
@@ -623,11 +623,7 @@
 	}
 	else
 	{
-		wStream s;
 		const char* hostname = license->rdp->settings->ClientHostname;
-		Stream_StaticInit(&s, license->HardwareId, 4);
-		Stream_Write_UINT32(&s, PLATFORMID);
-		Stream_Free(&s, TRUE);
 		hashTarget = (const BYTE*)hostname;
 		targetLen = strlen(hostname);
 	}
@@ -1309,12 +1305,8 @@
 		goto out_free_stream;
 
 	license->state = LICENSE_STATE_COMPLETED;
-	ret = TRUE;
-
-	if (!license->rdp->settings->OldLicenseBehaviour)
-		ret = saveCal(license->rdp->settings, Stream_Pointer(licenseStream), cbLicenseInfo,
-		              license->rdp->settings->ClientHostname);
-
+	ret = saveCal(license->rdp->settings, Stream_Pointer(licenseStream), cbLicenseInfo,
+	              license->rdp->settings->ClientHostname);
 out_free_stream:
 	Stream_Free(licenseStream, FALSE);
 out_free_blob:
@@ -1609,9 +1601,8 @@
  * @param license license module
  */
 
-BOOL license_send_valid_client_error_packet(rdpRdp* rdp)
+BOOL license_send_valid_client_error_packet(rdpLicense* license)
 {
-	rdpLicense* license = rdp->license;
 	wStream* s = license_send_stream_init(license);
 
 	if (!s)
diff -urN libfreerdp/core/license.h ../../informatimago/FreeRDP/libfreerdp/core/license.h
--- libfreerdp/core/license.h	2019-07-25 19:51:03.725911623 +0300
+++ ../../informatimago/FreeRDP/libfreerdp/core/license.h	2019-07-25 20:11:27.631981016 +0300
@@ -30,10 +30,120 @@
 #include <freerdp/freerdp.h>
 #include <freerdp/log.h>
 #include <freerdp/api.h>
-#include <freerdp/license.h>
 
 #include <winpr/stream.h>
 
+/* Licensing Packet Types */
+
+#define LICENSE_REQUEST 0x01
+#define PLATFORM_CHALLENGE 0x02
+#define NEW_LICENSE 0x03
+#define UPGRADE_LICENSE 0x04
+#define LICENSE_INFO 0x12
+#define NEW_LICENSE_REQUEST 0x13
+#define PLATFORM_CHALLENGE_RESPONSE 0x15
+#define ERROR_ALERT 0xFF
+
+#define LICENSE_PKT_CS_MASK \
+	(LICENSE_INFO | NEW_LICENSE_REQUEST | PLATFORM_CHALLENGE_RESPONSE | ERROR_ALERT)
+#define LICENSE_PKT_SC_MASK \
+	(LICENSE_REQUEST | PLATFORM_CHALLENGE | NEW_LICENSE | UPGRADE_LICENSE | ERROR_ALERT)
+#define LICENSE_PKT_MASK (LICENSE_PKT_CS_MASK | LICENSE_PKT_SC_MASK)
+
+#define LICENSE_PREAMBLE_LENGTH 4
+
+/* Cryptographic Lengths */
+
+#define CLIENT_RANDOM_LENGTH 32
+#define SERVER_RANDOM_LENGTH 32
+#define MASTER_SECRET_LENGTH 48
+#define PREMASTER_SECRET_LENGTH 48
+#define SESSION_KEY_BLOB_LENGTH 48
+#define MAC_SALT_KEY_LENGTH 16
+#define LICENSING_ENCRYPTION_KEY_LENGTH 16
+#define HWID_PLATFORM_ID_LENGTH 4
+#define HWID_UNIQUE_DATA_LENGTH 16
+#define HWID_LENGTH 20
+#define LICENSING_PADDING_SIZE 8
+
+/* Preamble Flags */
+
+#define PREAMBLE_VERSION_2_0 0x02
+#define PREAMBLE_VERSION_3_0 0x03
+#define LicenseProtocolVersionMask 0x0F
+#define EXTENDED_ERROR_MSG_SUPPORTED 0x80
+
+/* Binary Blob Types */
+
+#define BB_ANY_BLOB 0x0000
+#define BB_DATA_BLOB 0x0001
+#define BB_RANDOM_BLOB 0x0002
+#define BB_CERTIFICATE_BLOB 0x0003
+#define BB_ERROR_BLOB 0x0004
+#define BB_ENCRYPTED_DATA_BLOB 0x0009
+#define BB_KEY_EXCHG_ALG_BLOB 0x000D
+#define BB_SCOPE_BLOB 0x000E
+#define BB_CLIENT_USER_NAME_BLOB 0x000F
+#define BB_CLIENT_MACHINE_NAME_BLOB 0x0010
+
+/* License Key Exchange Algorithms */
+
+#define KEY_EXCHANGE_ALG_RSA 0x00000001
+
+/* License Error Codes */
+
+#define ERR_INVALID_SERVER_CERTIFICATE 0x00000001
+#define ERR_NO_LICENSE 0x00000002
+#define ERR_INVALID_MAC 0x00000003
+#define ERR_INVALID_SCOPE 0x00000004
+#define ERR_NO_LICENSE_SERVER 0x00000006
+#define STATUS_VALID_CLIENT 0x00000007
+#define ERR_INVALID_CLIENT 0x00000008
+#define ERR_INVALID_PRODUCT_ID 0x0000000B
+#define ERR_INVALID_MESSAGE_LENGTH 0x0000000C
+
+/* State Transition Codes */
+
+#define ST_TOTAL_ABORT 0x00000001
+#define ST_NO_TRANSITION 0x00000002
+#define ST_RESET_PHASE_TO_START 0x00000003
+#define ST_RESEND_LAST_MESSAGE 0x00000004
+
+/* Platform Challenge Types */
+
+#define WIN32_PLATFORM_CHALLENGE_TYPE 0x0100
+#define WIN16_PLATFORM_CHALLENGE_TYPE 0x0200
+#define WINCE_PLATFORM_CHALLENGE_TYPE 0x0300
+#define OTHER_PLATFORM_CHALLENGE_TYPE 0xFF00
+
+/* License Detail Levels */
+
+#define LICENSE_DETAIL_SIMPLE 0x0001
+#define LICENSE_DETAIL_MODERATE 0x0002
+#define LICENSE_DETAIL_DETAIL 0x0003
+
+/*
+ * PlatformId:
+ *
+ * The most significant byte of the PlatformId field contains the operating system version of the
+ * client. The second most significant byte of the PlatformId field identifies the ISV that provided
+ * the client image. The remaining two bytes in the PlatformId field are used by the ISV to identify
+ * the build number of the operating system.
+ *
+ * 0x04010000:
+ *
+ * CLIENT_OS_ID_WINNT_POST_52	(0x04000000)
+ * CLIENT_IMAGE_ID_MICROSOFT	(0x00010000)
+ */
+
+#define CLIENT_OS_ID_WINNT_351 0x01000000
+#define CLIENT_OS_ID_WINNT_40 0x02000000
+#define CLIENT_OS_ID_WINNT_50 0x03000000
+#define CLIENT_OS_ID_WINNT_POST_52 0x04000000
+
+#define CLIENT_IMAGE_ID_MICROSOFT 0x00010000
+#define CLIENT_IMAGE_ID_CITRIX 0x00020000
+
 typedef struct
 {
 	UINT32 dwVersion;
@@ -97,6 +207,8 @@
 
 FREERDP_LOCAL int license_recv(rdpLicense* license, wStream* s);
 
+FREERDP_LOCAL BOOL license_send_valid_client_error_packet(rdpLicense* license);
+
 FREERDP_LOCAL rdpLicense* license_new(rdpRdp* rdp);
 FREERDP_LOCAL void license_free(rdpLicense* license);
 
diff -urN libfreerdp/core/listener.c ../../informatimago/FreeRDP/libfreerdp/core/listener.c
--- libfreerdp/core/listener.c	2019-07-25 19:51:03.733911662 +0300
+++ ../../informatimago/FreeRDP/libfreerdp/core/listener.c	2019-07-25 20:11:27.639981056 +0300
@@ -277,7 +277,7 @@
 	if (listener->num_sockfds < 1)
 		return 0;
 
-	if (listener->num_sockfds > (INT64)nCount)
+	if (listener->num_sockfds > nCount)
 		return 0;
 
 	for (index = 0; index < listener->num_sockfds; index++)
diff -urN libfreerdp/core/mcs.c ../../informatimago/FreeRDP/libfreerdp/core/mcs.c
--- libfreerdp/core/mcs.c	2019-07-25 19:51:03.749911742 +0300
+++ ../../informatimago/FreeRDP/libfreerdp/core/mcs.c	2019-07-25 20:11:27.655981135 +0300
@@ -526,13 +526,13 @@
 		return FALSE;
 
 	/* callingDomainSelector (OCTET_STRING) */
-	if (!ber_read_octet_string_tag(s, &length) || (Stream_GetRemainingLength(s)) < length)
+	if (!ber_read_octet_string_tag(s, &length) || ((int)Stream_GetRemainingLength(s)) < length)
 		return FALSE;
 
 	Stream_Seek(s, length);
 
 	/* calledDomainSelector (OCTET_STRING) */
-	if (!ber_read_octet_string_tag(s, &length) || (Stream_GetRemainingLength(s)) < length)
+	if (!ber_read_octet_string_tag(s, &length) || ((int)Stream_GetRemainingLength(s)) < length)
 		return FALSE;
 
 	Stream_Seek(s, length);
@@ -553,7 +553,7 @@
 	if (!mcs_read_domain_parameters(s, &mcs->maximumParameters))
 		return FALSE;
 
-	if (!ber_read_octet_string_tag(s, &length) || (Stream_GetRemainingLength(s)) < length)
+	if (!ber_read_octet_string_tag(s, &length) || ((int)Stream_GetRemainingLength(s)) < length)
 		return FALSE;
 
 	if (!gcc_read_conference_create_request(s, mcs))
diff -urN libfreerdp/core/message.c ../../informatimago/FreeRDP/libfreerdp/core/message.c
--- libfreerdp/core/message.c	2019-07-25 19:51:03.805912020 +0300
+++ ../../informatimago/FreeRDP/libfreerdp/core/message.c	2019-07-25 20:11:27.711981412 +0300
@@ -1075,8 +1075,8 @@
 
 /* Window Update */
 
-static BOOL update_message_WindowCreate(rdpContext* context, const WINDOW_ORDER_INFO* orderInfo,
-                                        const WINDOW_STATE_ORDER* windowState)
+static BOOL update_message_WindowCreate(rdpContext* context, WINDOW_ORDER_INFO* orderInfo,
+                                        WINDOW_STATE_ORDER* windowState)
 {
 	WINDOW_ORDER_INFO* wParam;
 	WINDOW_STATE_ORDER* lParam;
@@ -1104,8 +1104,8 @@
 	                         (void*)lParam);
 }
 
-static BOOL update_message_WindowUpdate(rdpContext* context, const WINDOW_ORDER_INFO* orderInfo,
-                                        const WINDOW_STATE_ORDER* windowState)
+static BOOL update_message_WindowUpdate(rdpContext* context, WINDOW_ORDER_INFO* orderInfo,
+                                        WINDOW_STATE_ORDER* windowState)
 {
 	WINDOW_ORDER_INFO* wParam;
 	WINDOW_STATE_ORDER* lParam;
@@ -1133,8 +1133,8 @@
 	                         (void*)lParam);
 }
 
-static BOOL update_message_WindowIcon(rdpContext* context, const WINDOW_ORDER_INFO* orderInfo,
-                                      const WINDOW_ICON_ORDER* windowIcon)
+static BOOL update_message_WindowIcon(rdpContext* context, WINDOW_ORDER_INFO* orderInfo,
+                                      WINDOW_ICON_ORDER* windowIcon)
 {
 	WINDOW_ORDER_INFO* wParam;
 	WINDOW_ICON_ORDER* lParam;
@@ -1151,12 +1151,10 @@
 	lParam = (WINDOW_ICON_ORDER*)calloc(1, sizeof(WINDOW_ICON_ORDER));
 
 	if (!lParam)
-		goto out_fail;
-
-	lParam->iconInfo = calloc(1, sizeof(ICON_INFO));
-
-	if (!lParam->iconInfo)
-		goto out_fail;
+	{
+		free(wParam);
+		return FALSE;
+	}
 
 	CopyMemory(lParam, windowIcon, sizeof(WINDOW_ICON_ORDER));
 	WLog_VRB(TAG, "update_message_WindowIcon");
@@ -1197,22 +1195,16 @@
 	return MessageQueue_Post(context->update->queue, (void*)context,
 	                         MakeMessageId(WindowUpdate, WindowIcon), (void*)wParam, (void*)lParam);
 out_fail:
-
-	if (lParam && lParam->iconInfo)
-	{
-		free(lParam->iconInfo->bitsColor);
-		free(lParam->iconInfo->bitsMask);
-		free(lParam->iconInfo->colorTable);
-		free(lParam->iconInfo);
-	}
-
+	free(lParam->iconInfo->bitsColor);
+	free(lParam->iconInfo->bitsMask);
+	free(lParam->iconInfo->colorTable);
 	free(lParam);
 	free(wParam);
 	return FALSE;
 }
 
-static BOOL update_message_WindowCachedIcon(rdpContext* context, const WINDOW_ORDER_INFO* orderInfo,
-                                            const WINDOW_CACHED_ICON_ORDER* windowCachedIcon)
+static BOOL update_message_WindowCachedIcon(rdpContext* context, WINDOW_ORDER_INFO* orderInfo,
+                                            WINDOW_CACHED_ICON_ORDER* windowCachedIcon)
 {
 	WINDOW_ORDER_INFO* wParam;
 	WINDOW_CACHED_ICON_ORDER* lParam;
@@ -1240,7 +1232,7 @@
 	                         (void*)lParam);
 }
 
-static BOOL update_message_WindowDelete(rdpContext* context, const WINDOW_ORDER_INFO* orderInfo)
+static BOOL update_message_WindowDelete(rdpContext* context, WINDOW_ORDER_INFO* orderInfo)
 {
 	WINDOW_ORDER_INFO* wParam;
 
@@ -1257,8 +1249,8 @@
 	                         MakeMessageId(WindowUpdate, WindowDelete), (void*)wParam, NULL);
 }
 
-static BOOL update_message_NotifyIconCreate(rdpContext* context, const WINDOW_ORDER_INFO* orderInfo,
-                                            const NOTIFY_ICON_STATE_ORDER* notifyIconState)
+static BOOL update_message_NotifyIconCreate(rdpContext* context, WINDOW_ORDER_INFO* orderInfo,
+                                            NOTIFY_ICON_STATE_ORDER* notifyIconState)
 {
 	WINDOW_ORDER_INFO* wParam;
 	NOTIFY_ICON_STATE_ORDER* lParam;
@@ -1286,8 +1278,8 @@
 	                         (void*)lParam);
 }
 
-static BOOL update_message_NotifyIconUpdate(rdpContext* context, const WINDOW_ORDER_INFO* orderInfo,
-                                            const NOTIFY_ICON_STATE_ORDER* notifyIconState)
+static BOOL update_message_NotifyIconUpdate(rdpContext* context, WINDOW_ORDER_INFO* orderInfo,
+                                            NOTIFY_ICON_STATE_ORDER* notifyIconState)
 {
 	WINDOW_ORDER_INFO* wParam;
 	NOTIFY_ICON_STATE_ORDER* lParam;
@@ -1315,7 +1307,7 @@
 	                         (void*)lParam);
 }
 
-static BOOL update_message_NotifyIconDelete(rdpContext* context, const WINDOW_ORDER_INFO* orderInfo)
+static BOOL update_message_NotifyIconDelete(rdpContext* context, WINDOW_ORDER_INFO* orderInfo)
 {
 	WINDOW_ORDER_INFO* wParam;
 
@@ -1332,8 +1324,8 @@
 	                         MakeMessageId(WindowUpdate, NotifyIconDelete), (void*)wParam, NULL);
 }
 
-static BOOL update_message_MonitoredDesktop(rdpContext* context, const WINDOW_ORDER_INFO* orderInfo,
-                                            const MONITORED_DESKTOP_ORDER* monitoredDesktop)
+static BOOL update_message_MonitoredDesktop(rdpContext* context, WINDOW_ORDER_INFO* orderInfo,
+                                            MONITORED_DESKTOP_ORDER* monitoredDesktop)
 {
 	WINDOW_ORDER_INFO* wParam;
 	MONITORED_DESKTOP_ORDER* lParam;
@@ -1369,8 +1361,7 @@
 	                         (void*)lParam);
 }
 
-static BOOL update_message_NonMonitoredDesktop(rdpContext* context,
-                                               const WINDOW_ORDER_INFO* orderInfo)
+static BOOL update_message_NonMonitoredDesktop(rdpContext* context, WINDOW_ORDER_INFO* orderInfo)
 {
 	WINDOW_ORDER_INFO* wParam;
 
@@ -2128,7 +2119,6 @@
 		}
 
 		free(orderInfo);
-		free(windowIcon->iconInfo);
 		free(windowIcon);
 	}
 	break;
diff -urN libfreerdp/core/nego.c ../../informatimago/FreeRDP/libfreerdp/core/nego.c
--- libfreerdp/core/nego.c	2019-07-25 19:51:03.829912138 +0300
+++ ../../informatimago/FreeRDP/libfreerdp/core/nego.c	2019-07-25 20:11:27.731981512 +0300
@@ -1429,14 +1429,3 @@
 	nla_free(nego->transport->nla);
 	nego->transport->nla = NULL;
 }
-
-const BYTE* nego_get_routing_token(rdpNego* nego, DWORD* RoutingTokenLength)
-{
-	if (!nego)
-		return NULL;
-
-	if (RoutingTokenLength)
-		*RoutingTokenLength = nego->RoutingTokenLength;
-
-	return nego->RoutingToken;
-}
diff -urN libfreerdp/core/nego.h ../../informatimago/FreeRDP/libfreerdp/core/nego.h
--- libfreerdp/core/nego.h	2019-07-25 19:51:03.833912159 +0300
+++ ../../informatimago/FreeRDP/libfreerdp/core/nego.h	2019-07-25 20:11:27.735981532 +0300
@@ -117,7 +117,6 @@
 FREERDP_LOCAL void nego_enable_tls(rdpNego* nego, BOOL enable_tls);
 FREERDP_LOCAL void nego_enable_nla(rdpNego* nego, BOOL enable_nla);
 FREERDP_LOCAL void nego_enable_ext(rdpNego* nego, BOOL enable_ext);
-FREERDP_LOCAL const BYTE* nego_get_routing_token(rdpNego* nego, DWORD* RoutingTokenLength);
 FREERDP_LOCAL BOOL nego_set_routing_token(rdpNego* nego, BYTE* RoutingToken,
                                           DWORD RoutingTokenLength);
 FREERDP_LOCAL BOOL nego_set_cookie(rdpNego* nego, char* cookie);
diff -urN libfreerdp/core/nla.c ../../informatimago/FreeRDP/libfreerdp/core/nla.c
--- libfreerdp/core/nla.c	2019-07-25 19:51:03.889912436 +0300
+++ ../../informatimago/FreeRDP/libfreerdp/core/nla.c	2019-07-25 20:11:27.827981988 +0300
@@ -42,61 +42,38 @@
 #include <winpr/print.h>
 #include <winpr/tchar.h>
 #include <winpr/dsparse.h>
+#include <winpr/strlst.h>
 #include <winpr/library.h>
 #include <winpr/registry.h>
 
+#include "../mit-krb5-pkinit/kinit.h"
 #include "nla.h"
+#include "smartcardlogon.h"
+#include "tscredentials.h"
 
 #define TAG FREERDP_TAG("core.nla")
 
 #define SERVER_KEY "Software\\" FREERDP_VENDOR_STRING "\\" FREERDP_PRODUCT_STRING "\\Server"
 
-/**
- * TSRequest ::= SEQUENCE {
- * 	version    [0] INTEGER,
- * 	negoTokens [1] NegoData OPTIONAL,
- * 	authInfo   [2] OCTET STRING OPTIONAL,
- * 	pubKeyAuth [3] OCTET STRING OPTIONAL,
- * 	errorCode  [4] INTEGER OPTIONAL
- * }
- *
- * NegoData ::= SEQUENCE OF NegoDataItem
- *
- * NegoDataItem ::= SEQUENCE {
- * 	negoToken [0] OCTET STRING
- * }
- *
- * TSCredentials ::= SEQUENCE {
- * 	credType    [0] INTEGER,
- * 	credentials [1] OCTET STRING
- * }
- *
- * TSPasswordCreds ::= SEQUENCE {
- * 	domainName  [0] OCTET STRING,
- * 	userName    [1] OCTET STRING,
- * 	password    [2] OCTET STRING
- * }
- *
- * TSSmartCardCreds ::= SEQUENCE {
- * 	pin        [0] OCTET STRING,
- * 	cspData    [1] TSCspDataDetail,
- * 	userHint   [2] OCTET STRING OPTIONAL,
- * 	domainHint [3] OCTET STRING OPTIONAL
- * }
- *
- * TSCspDataDetail ::= SEQUENCE {
- * 	keySpec       [0] INTEGER,
- * 	cardName      [1] OCTET STRING OPTIONAL,
- * 	readerName    [2] OCTET STRING OPTIONAL,
- * 	containerName [3] OCTET STRING OPTIONAL,
- * 	cspName       [4] OCTET STRING OPTIONAL
- * }
- *
- */
+#define TERMSRV_SPN_PREFIX "TERMSRV/"
+#define PREFIX_CONTAINER_NAME "0x"
+#define PREFIX_PIN_GLOBAL "CredProv&PIN Global&"
 
 #define NLA_PKG_NAME NEGO_SSP_NAME
 
-#define TERMSRV_SPN_PREFIX "TERMSRV/"
+#ifdef WITH_GSSAPI /* KERBEROS SSP */
+#	define PACKAGE_NAME KERBEROS_SSP_NAME
+#else /* NTLM SSP */
+#	define PACKAGE_NAME NLA_PKG_NAME
+#endif
+
+#ifdef UNICODE
+#	define INIT_SECURITY_INTERFACE_NAME "InitSecurityInterfaceW"
+#else
+#	define INIT_SECURITY_INTERFACE_NAME "InitSecurityInterfaceA"
+#endif
+
+#define NLA_PKG_NAME NEGO_SSP_NAME
 
 struct rdp_nla
 {
@@ -139,9 +116,9 @@
 	SecBuffer PublicKey;
 	SecBuffer tsCredentials;
 	LPTSTR ServicePrincipalName;
-	SEC_WINNT_AUTH_IDENTITY* identity;
 	PSecurityFunctionTable table;
 	SecPkgContext_Sizes ContextSizes;
+	auth_identity* identity;
 };
 
 static BOOL nla_send(rdpNla* nla);
@@ -154,14 +131,6 @@
 static SECURITY_STATUS nla_decrypt_public_key_hash(rdpNla* nla);
 static SECURITY_STATUS nla_encrypt_ts_credentials(rdpNla* nla);
 static SECURITY_STATUS nla_decrypt_ts_credentials(rdpNla* nla);
-static BOOL nla_read_ts_password_creds(rdpNla* nla, wStream* s);
-static void nla_identity_free(SEC_WINNT_AUTH_IDENTITY* identity);
-
-#define ber_sizeof_sequence_octet_string(length) \
-	ber_sizeof_contextual_tag(ber_sizeof_octet_string(length)) + ber_sizeof_octet_string(length)
-#define ber_write_sequence_octet_string(stream, context, value, length)                \
-	ber_write_contextual_tag(stream, context, ber_sizeof_octet_string(length), TRUE) + \
-	    ber_write_octet_string(stream, value, length)
 
 /* CredSSP Client-To-Server Binding Hash\0 */
 static const BYTE ClientServerHashMagic[] = { 0x43, 0x72, 0x65, 0x64, 0x53, 0x53, 0x50, 0x20,
@@ -179,212 +148,513 @@
 
 static const UINT32 NonceLength = 32;
 
-void nla_identity_free(SEC_WINNT_AUTH_IDENTITY* identity)
+/* ============================================================ */
+
+#define CHECK_MEMORY(pointer, result, description, ...)                                 \
+	do                                                                                  \
+	{                                                                                   \
+		if (!(pointer))                                                                 \
+		{                                                                               \
+			WLog_ERR(TAG, "%s:%d: %s() " description, __FILE__, __LINE__, __FUNCTION__, \
+			         ##__VA_ARGS__);                                                    \
+			return result;                                                              \
+		}                                                                               \
+	} while (0)
+
+/* ============================================================ */
+
+/*
+Duplicate the cstring, or convert it to WCHAR,  depending on UNICODE.
+*/
+LPTSTR stringX_from_cstring(const char* cstring)
 {
-	if (identity)
+	LPTSTR result = NULL;
+
+	if (cstring != NULL)
 	{
-		/* Password authentication */
-		if (identity->User)
-		{
-			memset(identity->User, 0, identity->UserLength * 2);
-			free(identity->User);
-		}
+#ifdef UNICODE
+		ConvertToUnicode(CP_UTF8, 0, cstring, -1, &result, 0);
+		CHECK_MEMORY(result, NULL, "Could not allocate %d bytes.", 2 * (1 + strlen(cstring)));
+#else
+		result = strdup(cstring);
+		CHECK_MEMORY(result, NULL, "Could not allocate %d bytes.", 1 + strlen(cstring));
+#endif
+	}
 
-		if (identity->Password)
-		{
-			size_t len = identity->PasswordLength;
+	return result;
+}
 
-			if (len > LB_PASSWORD_MAX_LENGTH) /* [pth] Password hash */
-				len -= LB_PASSWORD_MAX_LENGTH;
+/**
+ * Returns whether the username is found in the SAM database.
+ * @param username: C string.
+ */
 
-			memset(identity->Password, 0, len * 2);
-			free(identity->Password);
-		}
+static BOOL user_is_in_sam_database(const char* username)
+{
+	char mutable_username[128]; /*  greater than the max of 104 on MS-Windows 2000,  and 20 on
+	                               MS-Windows 2003 */
+	WINPR_SAM* sam = SamOpen(NULL, TRUE);
+	BOOL is_in = FALSE;
+
+	if (sizeof(mutable_username) - 1 < strlen(username))
+	{
+		return FALSE;
+	}
+
+	strcpy(mutable_username, username);
 
-		if (identity->Domain)
+	if (sam)
+	{
+		WINPR_SAM_ENTRY* entry =
+		    SamLookupUserA(sam, mutable_username, strlen(mutable_username), NULL, 0);
+
+		if (entry)
 		{
-			memset(identity->Domain, 0, identity->DomainLength * 2);
-			free(identity->Domain);
+			is_in = TRUE;
+			SamFreeEntry(sam, entry);
 		}
+
+		SamClose(sam);
+	}
+
+	return is_in;
+}
+
+/* ============================================================ */
+
+static void free_identity_blob(freerdp_blob* blob)
+{
+	if (blob != NULL)
+	{
+		auth_identity_free(blob->data);
+		free(blob);
 	}
+}
 
-	free(identity);
+static void save_identity(rdpNla* nla)
+{
+	auth_identity* saved_identity = auth_identity_deepcopy(nla->identity);
+	freerdp_blob* blob = malloc(sizeof(*blob));
+
+	if (blob != NULL)
+	{
+		blob->data = saved_identity;
+		blob->free = free_identity_blob;
+		freerdp_save_identity(nla->instance, blob);
+	}
 }
 
 /**
- * Initialize NTLM/Kerberos SSP authentication module (client).
- * @param credssp
+ * Returns whether the username is found in the SAM database.
+ * @param username: C string.
  */
 
-static int nla_client_init(rdpNla* nla)
+static int nla_client_init_smartcard_logon(rdpNla* nla)
 {
-	char* spn;
-	size_t length;
-	rdpTls* tls = NULL;
-	BOOL PromptPassword = FALSE;
-	freerdp* instance = nla->instance;
+	csp_data_detail* csp_data = NULL;
+	smartcard_creds* smartcard_creds = NULL;
 	rdpSettings* settings = nla->settings;
-	WINPR_SAM* sam;
-	WINPR_SAM_ENTRY* entry;
-	nla->state = NLA_STATE_INITIAL;
+	/*
+	In case of redirection we don't need to re-establish the identity
+	(notably with kerberos), we used the one we saved previously.
+	*/
+	freerdp_blob* blob = freerdp_saved_identity(nla->instance);
+	auth_identity* saved_identity = (blob == NULL) ? NULL : blob->data;
+
+	if (saved_identity != NULL)
+	{
+		if (nla->identity != NULL)
+		{
+			auth_identity_free(nla->identity);
+		}
+
+		nla->identity = auth_identity_deepcopy(saved_identity);
+		return 0;
+	}
 
-	if (settings->RestrictedAdminModeRequired)
-		settings->DisableCredentialsDelegation = TRUE;
+#if defined(WITH_PKCS11H) && defined(WITH_GSSAPI)
 
-	if ((!settings->Username) || (!strlen(settings->Username)) ||
-	    ((!settings->Password) && (!settings->RedirectionPassword)))
+	/* gets the UPN settings->UserPrincipalName */
+	if (get_info_smartcard(settings) != 0)
 	{
-		PromptPassword = TRUE;
+		WLog_ERR(TAG, "Failed to retrieve UPN !");
+		return -1;
 	}
 
-	if (PromptPassword && settings->Username && strlen(settings->Username))
+#	if defined(WITH_KERBEROS)
+	WLog_INFO(TAG, "WITH_KERBEROS");
+
+	if (0 == kerberos_get_tgt(settings))
 	{
-		sam = SamOpen(NULL, TRUE);
+		WLog_INFO(TAG, "Got Ticket Granting Ticket for %s", settings->CanonicalizedUserHint);
+	}
+	else
+	{
+		WLog_ERR(TAG, "Failed to get Ticket Granting Ticket from KDC!");
+		return -1;
+	}
 
-		if (sam)
-		{
-			entry = SamLookupUserA(sam, settings->Username, strlen(settings->Username), NULL, 0);
+#	else
+	/* TODO: try to get the CanonicalizedUserHint from klist? */
+	WLog_INFO(TAG, "NOT WITH_KERBEROS");
+#	endif
+#else
+	WLog_ERR(
+	    TAG,
+	    "Recompile with the PKCS11H and GSSAPI features enabled to authenticate via smartcard.");
+	return -1;
+#endif
 
-			if (entry)
-			{
-				/**
-				 * The user could be found in SAM database.
-				 * Use entry in SAM database later instead of prompt
-				 */
-				PromptPassword = FALSE;
-				SamFreeEntry(sam, entry);
-			}
+	if (settings->PinPadIsPresent)
+	{
+		/* The middleware talking to the card performs PIN caching and will provide
+		 * to its CSP (Cryptographic Service Provider) the PIN code
+		 * when asked. If PIN caching fails, or is not handled by the middleware,
+		 * the PIN code will be asked one more time before opening the session.
+		 * Thus, entering PIN code on pinpad does not give the PIN code explicitly to the CSP.
+		 * That's why we set it here to "0000".
+		 * The PIN code is not communicated to any software module, nor central processing unit.
+		 * Contrary to /pin option in command line or with getpass() which are less secure,
+		 * because the PIN code is communicated (at the present) in clear and transit via the code.
+		 */
+		settings->Password = string_concatenate(PREFIX_PIN_GLOBAL, "0000", NULL);
+	}
+	else if (settings->Pin)
+	{
+		settings->Password = string_concatenate(PREFIX_PIN_GLOBAL, settings->Pin, NULL);
+	}
+	else
+	{
+		settings->Password = strdup("");
+	}
 
-			SamClose(sam);
-		}
+	CHECK_MEMORY(settings->Password, -1, "Could not allocate memory for password.");
+	settings->Username = NULL;
+
+	if (settings->UserPrincipalName != NULL)
+	{
+		settings->Username = strdup(settings->UserPrincipalName);
+		CHECK_MEMORY(settings->Username, -1, "Could not strdup the UserPrincipalName (length = %d)",
+		             strlen(settings->UserPrincipalName));
 	}
 
-#ifndef _WIN32
+	if (settings->Domain == NULL)
+	{
+		WLog_ERR(TAG, "Missing domain.");
+		return -1;
+	}
+
+	CHECK_MEMORY(settings->DomainHint = strdup(settings->Domain), /* They're freed separately! */
+	             -1, "Could not strdup the Domain (length = %d)", strlen(settings->Domain));
 
-	if (PromptPassword)
+	if (settings->CanonicalizedUserHint == NULL)
 	{
-		if (settings->RestrictedAdminModeRequired)
-		{
-			if ((settings->PasswordHash) && (strlen(settings->PasswordHash) > 0))
-				PromptPassword = FALSE;
-		}
+		WLog_ERR(TAG, "Missing Canonicalized User Hint (Domain Hint = %s,  UPN = %s).",
+		         settings->DomainHint, settings->UserPrincipalName);
+		return -1;
 	}
 
-#endif
+	CHECK_MEMORY((settings->UserHint = strdup(settings->CanonicalizedUserHint)), -1,
+	             "Could not strdup the CanonicalizedUserHint (length = %d)",
+	             strlen(settings->CanonicalizedUserHint));
+	WLog_INFO(TAG, "Canonicalized User Hint = %s,  Domain Hint = %s,  UPN = %s",
+	          settings->CanonicalizedUserHint, settings->DomainHint, settings->UserPrincipalName);
+	CHECK_MEMORY((settings->ContainerName =
+	                  string_concatenate(PREFIX_CONTAINER_NAME, settings->IdCertificate, NULL)),
+	             -1, "Could not allocate memory for container name.");
 
-	if (PromptPassword)
+	if ((settings->CspName == NULL) ||
+	    (settings->CspName != NULL && strlen(settings->CspName) == 0))
 	{
-		if (!instance->settings->PromptForCredentials || !instance->Authenticate)
-		{
-			freerdp_set_last_error(instance->context,
-			                       FREERDP_ERROR_CONNECT_NO_OR_MISSING_CREDENTIALS);
-			return 0;
-		}
-		else
-		{
-			BOOL proceed = instance->Authenticate(instance, &settings->Username,
-			                                      &settings->Password, &settings->Domain);
+		WLog_ERR(TAG, "/csp argument is mandatory for smartcard-logon ");
+		return -1;
+	}
 
-			if (!proceed)
-			{
-				freerdp_set_last_error(instance->context,
-				                       FREERDP_ERROR_CONNECT_NO_OR_MISSING_CREDENTIALS);
-				return 0;
-			}
-		}
+	if (!settings->RedirectSmartCards && !settings->DeviceRedirection)
+	{
+		WLog_ERR(TAG, "/smartcard argument is mandatory for smartcard-logon ");
+		return -1;
 	}
 
-	if (!settings->Username)
+	WLog_DBG(TAG, "smartcard ReaderName=%s", settings->ReaderName);
+	csp_data =
+	    csp_data_detail_new(AT_KEYEXCHANGE /*AT_AUTHENTICATE*/, settings->CardName,
+	                        settings->ReaderName, settings->ContainerName, settings->CspName);
+
+	if (csp_data == NULL)
 	{
-		nla_identity_free(nla->identity);
-		nla->identity = NULL;
+		goto failure;
 	}
-	else
+
+	smartcard_creds = smartcard_creds_new(/* Pin: */ settings->Password, settings->UserHint,
+	                                      settings->DomainHint, csp_data);
+	csp_data_detail_free(csp_data);
+
+	if (smartcard_creds == NULL)
 	{
-		if (settings->RedirectionPassword && settings->RedirectionPasswordLength > 0)
-		{
-			if (sspi_SetAuthIdentityWithUnicodePassword(
-			        nla->identity, settings->Username, settings->Domain,
-			        (UINT16*)settings->RedirectionPassword,
-			        settings->RedirectionPasswordLength / sizeof(WCHAR) - 1) < 0)
-				return -1;
-		}
-		else
-		{
-			BOOL usePassword = TRUE;
+		goto failure;
+	}
 
-			if (settings->RestrictedAdminModeRequired)
-			{
-				if (settings->PasswordHash)
-				{
-					if (strlen(settings->PasswordHash) == 32)
-					{
-						if (sspi_SetAuthIdentity(nla->identity, settings->Username,
-						                         settings->Domain, settings->PasswordHash) < 0)
-							return -1;
-
-						/**
-						 * Increase password hash length by LB_PASSWORD_MAX_LENGTH to obtain a
-						 * length exceeding the maximum (LB_PASSWORD_MAX_LENGTH) and use it this for
-						 * hash identification in WinPR.
-						 */
-						nla->identity->PasswordLength += LB_PASSWORD_MAX_LENGTH;
-						usePassword = FALSE;
-					}
-				}
-			}
+	if (nla->identity != NULL)
+	{
+		auth_identity_free(nla->identity);
+	}
 
-			if (usePassword)
-			{
-				if (sspi_SetAuthIdentity(nla->identity, settings->Username, settings->Domain,
-				                         settings->Password) < 0)
-					return -1;
-			}
-		}
+	nla->identity = auth_identity_new_smartcard(smartcard_creds);
+
+	if (nla->identity == NULL)
+	{
+		goto failure;
 	}
 
-	tls = nla->transport->tls;
+	save_identity(nla);
+	return 0;
+failure:
+	WLog_ERR(TAG, "%s:%d: %s() Failed to set smartcard authentication parameters !", __FILE__,
+	         __LINE__, __FUNCTION__);
+	smartcard_creds_free(smartcard_creds);
+	return -1;
+}
 
-	if (!tls)
+static BOOL sspi_SecBufferFill(PSecBuffer buffer, BYTE* data, DWORD size)
+{
+	if (buffer == NULL)
 	{
-		WLog_ERR(TAG, "Unknown NLA transport layer");
-		return -1;
+		return FALSE;
 	}
 
-	if (!sspi_SecBufferAlloc(&nla->PublicKey, tls->PublicKeyLength))
+	CHECK_MEMORY(sspi_SecBufferAlloc(buffer, size), FALSE,
+	             "Failed to allocate sspi SecBuffer %d bytes", size);
+	CopyMemory(buffer->pvBuffer, data, size);
+	return TRUE;
+}
+
+#define EMPTY_SL(field) (((field) == NULL) || ((field##Length) == 0))
+#define EMPTY_S(cstring) (((cstring) == NULL) || (strlen(cstring) == 0))
+#define HAS_SL(field) ((field) != NULL)
+#define HAS_S(cstring) ((cstring) != NULL)
+
+static BOOL should_prompt_password(rdpSettings* settings)
+{
+	BOOL PromptPassword = (!settings->SmartcardLogon &&
+	                       (EMPTY_S(settings->Username) ||
+	                        (!HAS_S(settings->Password) && !HAS_S(settings->RedirectionPassword))));
+#ifndef _WIN32
+
+	if (PromptPassword && settings->RestrictedAdminModeRequired && !EMPTY_S(settings->PasswordHash))
+	{
+		PromptPassword = FALSE;
+	}
+
+#endif
+
+	if (PromptPassword && !EMPTY_S(settings->Username))
+	{
+		/* Use entry in SAM database later instead of prompt when user is in the SAM database */
+		PromptPassword = !user_is_in_sam_database(settings->Username);
+	}
+
+	return PromptPassword;
+}
+
+static LPTSTR service_principal_name(const char* server_hostname)
+{
+	char* spnA = string_concatenate(TERMSRV_SPN_PREFIX, server_hostname, NULL);
+	LPTSTR spnX = stringX_from_cstring(spnA);
+	free(spnA);
+	return spnX;
+}
+
+/*
+nla_client_init
+
+Initialize NTLM/Kerberos SSP authentication module (client).
+
+We prepare the CSSP negotiation, which involves sending three packets:
+
+- TLSencrypted(TSRequest([SPNEGO token]))
+(nla_client_begin)
+using the parameters: nla->credentials, nla->ServicePrincipalName, nla->fContextReq,
+nla->pPackageInfo
+
+- TLSencrypted(TSRequest([SPNego encrypted(client / server hash of public key)]))
+(nla_client_recv->nal_encrypt_public_key_{echo,hash})
+using the parameters: nla->credentials, nla->ServicePrincipalName, nla->fContextReq,
+nla->ClientNonce,  nla->PublicKey
+
+- TLSencrypted(TSRequest([SPNego encrypted(user credentials)]))
+(nla_client_recv->nla_encrypt_ts_credentials)
+using the parameters: nla->credentials, nla->ServicePrincipalName, nla->fContextReq,
+nla->settings->DisableCredentialsDelegation,  nla->identity
+
+
+
+
+INPUT:
+
+nla->instance
+
+nla->settings->RestrictedAdminModeRequired
+nla->settings->SmartcardLogon
+
+nla->settings->ServerHostname
+
+nla->settings->Username
+nla->settings->Password
+nla->settings->Domain
+
+nla->settings->RedirectionPassword
+nla->settings->PasswordHash
+
+{nla->tls->PublicKey,  nla->tls->PublicKeyLength}
+
+OUTPUT:
+
+nla->state = NLA_STATE_INITIAL;
+nla->cred_type = credential_type_default;
+
+nla->identity
+nla->identity->password_creds
+nla->identity->smartcard_creds
+nla->identity->csp_data
+
+
+settings->DisableCredentialsDelegation
+nla->ServicePrincipalName
+
+nla->table
+nla->status
+nla->pPackageInfo
+nla->cbMaxToken
+nla->packageName
+nla->haveContext
+nla->haveInputBuffer
+nla->HavePubKeyAuth
+nla->inputBuffer
+nla->outputBuffer
+nla->ContextSizes
+nla->fContextReq
+nla->credentials
+nla->expiration
+
+RULES:
+
+settings->RestrictedAdminModeRequired => settings->DisableCredentialsDelegation
+
+settings->SmartcardLogon => PromptPin
+(!settings->Username || !settings->Password) && !settings->SmartcardLogon => PromptPassword
+PromptPassword && settings->Username && user_is_in_sam_database(settings->Username) =>
+PromptPassword = FALSE
+!_WIN32 &&  PromptPassword && settings->RestrictedAdminModeRequired && settings->PasswordHash =>
+PromptPassword = FALSE
+
+(PromptPassword || PromptPin) &&  instance->Authenticate => instance->Authenticate(instance,
+&settings->Username, &settings->Password, &settings->Domain)
+
+!settings->UserName => nla->identity->password_creds == NULL
+settings->UserName && settings->RedirectionPassword
+
+nla->ServicePrincipalName =  TERMSRV_SPN_PREFIX + settings->ServerHostname
+
+CALLS:
+
+nla->table->QuerySecurityPackageInfo()
+nla->table->AcquireCredentialsHandle()
+
+*/
+static int nla_client_init(rdpNla* nla)
+{
+	freerdp* instance = nla->instance;
+	rdpSettings* settings = nla->settings;
+	BOOL PromptPassword = should_prompt_password(settings);
+	rdpTls* tls = NULL;
+	nla->state = NLA_STATE_INITIAL;
+	nla->identity = auth_identity_new_password(SEC_WINNT_AUTH_IDENTITY_new(NULL, NULL, NULL));
+
+	if ((nla->identity == NULL) || (nla->identity->creds.password_creds == NULL))
+	{
+		auth_identity_free(nla->identity);
+		return 0;
+	}
+
+	settings->DisableCredentialsDelegation |= settings->RestrictedAdminModeRequired;
+
+	if ((PromptPassword || settings->SmartcardLogon) && (instance->Authenticate != NULL) &&
+	    (!instance->Authenticate(instance, &settings->Username, &settings->Password,
+	                             &settings->Domain)))
+	{
+		freerdp_set_last_error(instance->context, FREERDP_ERROR_CONNECT_NO_OR_MISSING_CREDENTIALS);
+		return 0;
+	}
+
+	if (settings->SmartcardLogon)
+	{
+		if (nla_client_init_smartcard_logon(nla) < 0)
+		{
+			WLog_ERR(TAG, "Could not initialize Smartcard Logon.");
+			return -1;
+		}
+	}
+	else if (!HAS_S(settings->Username))
+	{
+		SEC_WINNT_AUTH_IDENTITY_free(nla->identity->creds.password_creds);
+		nla->identity->creds.password_creds = NULL;
+	}
+	else if (!HAS_S(settings->Domain))
 	{
-		WLog_ERR(TAG, "Failed to allocate sspi secBuffer");
+		/* Perhaps it's too early: it's needed only by NTLM, not by kerberos. */
+		WLog_ERR(TAG, "Missing domain.");
 		return -1;
 	}
+	else if (!EMPTY_SL(settings->RedirectionPassword))
+	{
+		/*  When a broker redirects the connection, it may give a substitute password */
+		if (sspi_SetAuthIdentityWithUnicodePassword(
+		        nla->identity->creds.password_creds, settings->Username, settings->Domain,
+		        (UINT16*)settings->RedirectionPassword,
+		        settings->RedirectionPasswordLength / sizeof(WCHAR) - 1) < 0)
+			return -1;
+	}
+	else if (settings->RestrictedAdminModeRequired && !EMPTY_S(settings->PasswordHash) &&
+	         (strlen(settings->PasswordHash) == 32))
+	{
+		/*  Pass-the-hash hack */
+		if (sspi_SetAuthIdentity(nla->identity->creds.password_creds, settings->Username,
+		                         settings->Domain, settings->PasswordHash) < 0)
+			return -1;
 
-	CopyMemory(nla->PublicKey.pvBuffer, tls->PublicKey, tls->PublicKeyLength);
-	length = sizeof(TERMSRV_SPN_PREFIX) + strlen(settings->ServerHostname);
-	spn = (SEC_CHAR*)malloc(length + 1);
+		/**
+		 * Increase password hash length by LB_PASSWORD_MAX_LENGTH to obtain a length exceeding
+		 * the maximum (LB_PASSWORD_MAX_LENGTH) and use it this for hash identification in WinPR.
+		 */
+		nla->identity->creds.password_creds->PasswordLength += LB_PASSWORD_MAX_LENGTH;
+	}
+	else
+	{
+		/* Normal password */
+		if (sspi_SetAuthIdentity(nla->identity->creds.password_creds, settings->Username,
+		                         settings->Domain, settings->Password) < 0)
+			return -1;
+	}
 
-	if (!spn)
+	if ((tls = nla->transport->tls) == NULL)
+	{
+		WLog_ERR(TAG, "Unknown NLA transport layer");
 		return -1;
+	}
 
-	sprintf_s(spn, length + 1, "%s%s", TERMSRV_SPN_PREFIX, settings->ServerHostname);
-#ifdef UNICODE
-	nla->ServicePrincipalName = NULL;
-	ConvertToUnicode(CP_UTF8, 0, spn, -1, &nla->ServicePrincipalName, 0);
-	free(spn);
-#else
-	nla->ServicePrincipalName = spn;
-#endif
-	nla->table = InitSecurityInterfaceEx(0);
-#ifdef WITH_GSSAPI /* KERBEROS SSP */
-	nla->status = nla->table->QuerySecurityPackageInfo(KERBEROS_SSP_NAME, &nla->pPackageInfo);
+	if (!sspi_SecBufferFill(&nla->PublicKey, tls->PublicKey, tls->PublicKeyLength))
+	{
+		return -1;
+	}
 
-	if (nla->status != SEC_E_OK)
+	if ((nla->ServicePrincipalName = service_principal_name(settings->ServerHostname)) == NULL)
 	{
-		WLog_ERR(TAG, "QuerySecurityPackageInfo status %s [0x%08" PRIX32 "]",
-		         GetSecurityStatusString(nla->status), nla->status);
 		return -1;
 	}
 
-#else /* NTLM SSP */
-	nla->status = nla->table->QuerySecurityPackageInfo(NLA_PKG_NAME, &nla->pPackageInfo);
+	nla->table = InitSecurityInterfaceEx(0);
+	nla->status = nla->table->QuerySecurityPackageInfo(PACKAGE_NAME, &nla->pPackageInfo);
 
 	if (nla->status != SEC_E_OK)
 	{
@@ -393,14 +663,16 @@
 		return -1;
 	}
 
-#endif
 	nla->cbMaxToken = nla->pPackageInfo->cbMaxToken;
 	nla->packageName = nla->pPackageInfo->Name;
-	WLog_DBG(TAG, "%s %" PRIu32 " : packageName=%ls ; cbMaxToken=%d", __FUNCTION__, __LINE__,
+	WLog_DBG(TAG, "%s:%d: %s() packageName=%ls ; cbMaxToken=%d", __FILE__, __LINE__, __FUNCTION__,
 	         nla->packageName, nla->cbMaxToken);
-	nla->status = nla->table->AcquireCredentialsHandle(NULL, NLA_PKG_NAME, SECPKG_CRED_OUTBOUND,
-	                                                   NULL, nla->identity, NULL, NULL,
-	                                                   &nla->credentials, &nla->expiration);
+	nla->status = nla->table->AcquireCredentialsHandle(
+	    NULL, NLA_PKG_NAME, SECPKG_CRED_OUTBOUND, NULL,
+	    ((nla->identity->cred_type == credential_type_password)
+	         ? nla->identity->creds.password_creds
+	         : NULL /* use the default credentials for that package */),
+	    NULL, NULL, &nla->credentials, &nla->expiration);
 
 	if (nla->status != SEC_E_OK)
 	{
@@ -464,6 +736,7 @@
 
 		if (nla->status)
 		{
+			/* Kerberos failed, Switch to NTLM */
 			SECURITY_STATUS status =
 			    nla->table->QuerySecurityPackageInfo(NTLM_SSP_NAME, &nla->pPackageInfo);
 
@@ -494,10 +767,19 @@
 			}
 		}
 
-		if (nla->status == SEC_I_COMPLETE_NEEDED)
+		switch (nla->status)
+		{
+		case SEC_I_COMPLETE_NEEDED:
 			nla->status = SEC_E_OK;
-		else if (nla->status == SEC_I_COMPLETE_AND_CONTINUE)
+			break;
+
+		case SEC_I_COMPLETE_AND_CONTINUE:
 			nla->status = SEC_I_CONTINUE_NEEDED;
+			break;
+
+		default:
+			break;
+		}
 	}
 
 	if (nla->status != SEC_I_CONTINUE_NEEDED)
@@ -508,7 +790,7 @@
 
 	nla->negoToken.pvBuffer = nla->outputBuffer.pvBuffer;
 	nla->negoToken.cbBuffer = nla->outputBuffer.cbBuffer;
-	WLog_DBG(TAG, "Sending Authentication Token");
+	WLog_DBG(TAG, "Sending Authentication Token (1)");
 #if defined(WITH_DEBUG_NLA)
 	winpr_HexDump(TAG, WLOG_DEBUG, nla->negoToken.pvBuffer, nla->negoToken.cbBuffer);
 #endif
@@ -541,7 +823,7 @@
 		nla->outputBufferDesc.pBuffers = &nla->outputBuffer;
 		nla->outputBuffer.BufferType = SECBUFFER_TOKEN;
 		nla->outputBuffer.cbBuffer = nla->cbMaxToken;
-		nla->outputBuffer.pvBuffer = malloc(nla->outputBuffer.cbBuffer);
+		nla->outputBuffer.pvBuffer = calloc(nla->outputBuffer.cbBuffer, 1);
 
 		if (!nla->outputBuffer.pvBuffer)
 			return -1;
@@ -590,6 +872,11 @@
 				return -1;
 			}
 
+#if defined(WITH_DEBUG_NLA)
+			WLog_DBG(TAG, "Encrypting Authentication Token (2)");
+			winpr_HexDump(TAG, WLOG_DEBUG, nla->outputBuffer.pvBuffer, nla->outputBuffer.cbBuffer);
+#endif
+
 			if (nla->peerVersion < 5)
 				nla->status = nla_encrypt_public_key_echo(nla);
 			else
@@ -601,7 +888,7 @@
 
 		nla->negoToken.pvBuffer = nla->outputBuffer.pvBuffer;
 		nla->negoToken.cbBuffer = nla->outputBuffer.cbBuffer;
-		WLog_DBG(TAG, "Sending Authentication Token");
+		WLog_DBG(TAG, "Sending Authentication Token (2)");
 #if defined(WITH_DEBUG_NLA)
 		winpr_HexDump(TAG, WLOG_DEBUG, nla->negoToken.pvBuffer, nla->negoToken.cbBuffer);
 #endif
@@ -855,7 +1142,7 @@
 		nla->outputBufferDesc.pBuffers = &nla->outputBuffer;
 		nla->outputBuffer.BufferType = SECBUFFER_TOKEN;
 		nla->outputBuffer.cbBuffer = nla->cbMaxToken;
-		nla->outputBuffer.pvBuffer = malloc(nla->outputBuffer.cbBuffer);
+		nla->outputBuffer.pvBuffer = calloc(nla->outputBuffer.cbBuffer, 1);
 
 		if (!nla->outputBuffer.pvBuffer)
 			return -1;
@@ -977,8 +1264,8 @@
 		if ((nla->status != SEC_E_OK) && (nla->status != SEC_I_CONTINUE_NEEDED))
 		{
 			/* Special handling of these specific error codes as NTSTATUS_FROM_WIN32
-			   unfortunately does not map directly to the corresponding NTSTATUS values
-			 */
+			unfortunately does not map directly to the corresponding NTSTATUS values
+			*/
 			switch (GetLastError())
 			{
 			case ERROR_PASSWORD_MUST_CHANGE:
@@ -1005,7 +1292,7 @@
 		}
 
 		/* send authentication token */
-		WLog_DBG(TAG, "Sending Authentication Token");
+		WLog_DBG(TAG, "Sending Authentication Token (3)");
 		nla_buffer_print(nla);
 
 		if (!nla_send(nla))
@@ -1296,7 +1583,7 @@
 	ntlm = (_tcsncmp(nla->packageName, NTLM_SSP_NAME, ARRAYSIZE(NTLM_SSP_NAME)) == 0);
 	signature_length = nla->pubKeyAuth.cbBuffer - nla->PublicKey.cbBuffer;
 
-	if ((signature_length < 0) || ((UINT32)signature_length > nla->ContextSizes.cbSecurityTrailer))
+	if ((signature_length < 0) || (signature_length > nla->ContextSizes.cbSecurityTrailer))
 	{
 		WLog_ERR(TAG, "unexpected pubKeyAuth buffer size: %" PRIu32 "", nla->pubKeyAuth.cbBuffer);
 		goto fail;
@@ -1479,250 +1766,86 @@
 	return status;
 }
 
-static size_t nla_sizeof_ts_password_creds(rdpNla* nla)
+/**
+ * Encode TSCredentials structure.
+ * @param credssp
+ */
+
+static BOOL nla_encode_ts_credentials(rdpNla* nla)
 {
+	BOOL result = TRUE;
+	wStream* s = NULL;
 	size_t length = 0;
+	auth_identity* identity = NULL;
 
-	if (nla->identity)
+	if (nla->settings->DisableCredentialsDelegation && nla->identity->creds.password_creds)
 	{
-		length += ber_sizeof_sequence_octet_string(nla->identity->DomainLength * 2);
-		length += ber_sizeof_sequence_octet_string(nla->identity->UserLength * 2);
-		length += ber_sizeof_sequence_octet_string(nla->identity->PasswordLength * 2);
+		char* user = strdup("");
+		char* password = strdup("");
+		char* domain = strdup("");
+		SEC_WINNT_AUTH_IDENTITY* password_creds =
+		    SEC_WINNT_AUTH_IDENTITY_new(user, password, domain);
+		identity = auth_identity_new_password(password_creds);
 	}
-
-	return length;
-}
-
-static size_t nla_sizeof_ts_credentials(rdpNla* nla)
-{
-	size_t size = 0;
-	size += ber_sizeof_integer(1);
-	size += ber_sizeof_contextual_tag(ber_sizeof_integer(1));
-	size +=
-	    ber_sizeof_sequence_octet_string(ber_sizeof_sequence(nla_sizeof_ts_password_creds(nla)));
-	return size;
-}
-
-BOOL nla_read_ts_password_creds(rdpNla* nla, wStream* s)
-{
-	size_t length;
-
-	if (!nla->identity)
+	else
 	{
-		WLog_ERR(TAG, "nla->identity is NULL!");
-		return FALSE;
+		identity = nla->identity;
 	}
 
-	/* TSPasswordCreds (SEQUENCE)
-	 * Initialise to default values. */
-	nla->identity->Flags = SEC_WINNT_AUTH_IDENTITY_UNICODE;
-	nla->identity->UserLength = (UINT32)0;
-	nla->identity->User = NULL;
-	nla->identity->DomainLength = (UINT32)0;
-	nla->identity->Domain = NULL;
-	nla->identity->Password = NULL;
-	nla->identity->PasswordLength = (UINT32)0;
-
-	if (!ber_read_sequence_tag(s, &length))
-		return FALSE;
-
-	/* The sequence is empty, return early,
-	 * TSPasswordCreds (SEQUENCE) is optional. */
-	if (length == 0)
-		return TRUE;
+	length = nla_sizeof_ts_credentials(identity);
 
-	/* [0] domainName (OCTET STRING) */
-	if (!ber_read_contextual_tag(s, 0, &length, TRUE) || !ber_read_octet_string_tag(s, &length))
+	if (!sspi_SecBufferAlloc(&nla->tsCredentials, length))
 	{
-		return FALSE;
+		WLog_ERR(TAG, "sspi_SecBufferAlloc failed!");
+		result = FALSE;
+		goto cleanup;
 	}
 
-	nla->identity->DomainLength = (UINT32)length;
-
-	if (nla->identity->DomainLength > 0)
-	{
-		nla->identity->Domain = (UINT16*)malloc(length);
-
-		if (!nla->identity->Domain)
-			return FALSE;
-
-		CopyMemory(nla->identity->Domain, Stream_Pointer(s), nla->identity->DomainLength);
-		Stream_Seek(s, nla->identity->DomainLength);
-		nla->identity->DomainLength /= 2;
-	}
+	s = Stream_New((BYTE*)nla->tsCredentials.pvBuffer, length);
 
-	/* [1] userName (OCTET STRING) */
-	if (!ber_read_contextual_tag(s, 1, &length, TRUE) || !ber_read_octet_string_tag(s, &length))
+	if (!s)
 	{
-		return FALSE;
+		sspi_SecBufferFree(&nla->tsCredentials);
+		WLog_ERR(TAG, "Stream_New failed!");
+		result = FALSE;
+		goto cleanup;
 	}
 
-	nla->identity->UserLength = (UINT32)length;
-
-	if (nla->identity->UserLength > 0)
-	{
-		nla->identity->User = (UINT16*)malloc(length);
-
-		if (!nla->identity->User)
-			return FALSE;
-
-		CopyMemory(nla->identity->User, Stream_Pointer(s), nla->identity->UserLength);
-		Stream_Seek(s, nla->identity->UserLength);
-		nla->identity->UserLength /= 2;
-	}
+	WLog_INFO(TAG, "TSCredentials: %s", auth_identity_credential_type_label(nla->identity));
+	nla_write_ts_credentials(nla->identity, s);
+	result = TRUE;
+cleanup:
 
-	/* [2] password (OCTET STRING) */
-	if (!ber_read_contextual_tag(s, 2, &length, TRUE) || !ber_read_octet_string_tag(s, &length))
+	if (s)
 	{
-		return FALSE;
+		Stream_Free(s, FALSE);
 	}
 
-	nla->identity->PasswordLength = (UINT32)length;
-
-	if (nla->identity->PasswordLength > 0)
+	if (identity != nla->identity)
 	{
-		nla->identity->Password = (UINT16*)malloc(length);
-
-		if (!nla->identity->Password)
-			return FALSE;
-
-		CopyMemory(nla->identity->Password, Stream_Pointer(s), nla->identity->PasswordLength);
-		Stream_Seek(s, nla->identity->PasswordLength);
-		nla->identity->PasswordLength /= 2;
+		auth_identity_free(identity);
 	}
 
-	return TRUE;
+	return result;
 }
 
-static size_t nla_write_ts_password_creds(rdpNla* nla, wStream* s)
+void dump_ssp(BOOL krb, BOOL nego, BOOL ntlm)
 {
-	size_t size = 0;
-	size_t innerSize = nla_sizeof_ts_password_creds(nla);
-	/* TSPasswordCreds (SEQUENCE) */
-	size += ber_write_sequence_tag(s, innerSize);
-
-	if (nla->identity)
-	{
-		/* [0] domainName (OCTET STRING) */
-		size += ber_write_sequence_octet_string(s, 0, (BYTE*)nla->identity->Domain,
-		                                        nla->identity->DomainLength * 2);
-		/* [1] userName (OCTET STRING) */
-		size += ber_write_sequence_octet_string(s, 1, (BYTE*)nla->identity->User,
-		                                        nla->identity->UserLength * 2);
-		/* [2] password (OCTET STRING) */
-		size += ber_write_sequence_octet_string(s, 2, (BYTE*)nla->identity->Password,
-		                                        nla->identity->PasswordLength * 2);
-	}
-
-	return size;
+	WLog_DBG(TAG, "krb = %d, nego = %d, ntlm = %d\n", krb, nego, ntlm);
 }
 
-static BOOL nla_read_ts_credentials(rdpNla* nla, PSecBuffer ts_credentials)
+void dump_message(SecBufferDesc* message)
 {
-	wStream* s;
-	size_t length;
-	size_t ts_password_creds_length = 0;
-	BOOL ret;
-
-	if (!ts_credentials || !ts_credentials->pvBuffer)
-		return FALSE;
+	WLog_DBG(TAG, "message: buffer count = %d\n", message->cBuffers);
 
-	s = Stream_New(ts_credentials->pvBuffer, ts_credentials->cbBuffer);
-
-	if (!s)
+	for (int i = 0; i < message->cBuffers; i++)
 	{
-		WLog_ERR(TAG, "Stream_New failed!");
-		return FALSE;
+		WLog_DBG(TAG, "message->buffer[%d].BufferType = %d\n", i, message->pBuffers[i].BufferType);
+		WLog_DBG(TAG, "message->buffer[%d].cbBuffer = %d\n", i, message->pBuffers[i].cbBuffer);
+		WLog_DBG(TAG, "message->buffer[%d].pvBuffer = ", i);
+		winpr_HexDump(TAG, WLOG_DEBUG, message->pBuffers[i].pvBuffer,
+		              message->pBuffers[i].cbBuffer);
 	}
-
-	/* TSCredentials (SEQUENCE) */
-	ret = ber_read_sequence_tag(s, &length) &&
-	      /* [0] credType (INTEGER) */
-	      ber_read_contextual_tag(s, 0, &length, TRUE) && ber_read_integer(s, NULL) &&
-	      /* [1] credentials (OCTET STRING) */
-	      ber_read_contextual_tag(s, 1, &length, TRUE) &&
-	      ber_read_octet_string_tag(s, &ts_password_creds_length) &&
-	      nla_read_ts_password_creds(nla, s);
-	Stream_Free(s, FALSE);
-	return ret;
-}
-
-static size_t nla_write_ts_credentials(rdpNla* nla, wStream* s)
-{
-	size_t size = 0;
-	size_t passwordSize;
-	size_t innerSize = nla_sizeof_ts_credentials(nla);
-	/* TSCredentials (SEQUENCE) */
-	size += ber_write_sequence_tag(s, innerSize);
-	/* [0] credType (INTEGER) */
-	size += ber_write_contextual_tag(s, 0, ber_sizeof_integer(1), TRUE);
-	size += ber_write_integer(s, 1);
-	/* [1] credentials (OCTET STRING) */
-	passwordSize = ber_sizeof_sequence(nla_sizeof_ts_password_creds(nla));
-	size += ber_write_contextual_tag(s, 1, ber_sizeof_octet_string(passwordSize), TRUE);
-	size += ber_write_octet_string_tag(s, passwordSize);
-	size += nla_write_ts_password_creds(nla, s);
-	return size;
-}
-
-/**
- * Encode TSCredentials structure.
- * @param credssp
- */
-
-static BOOL nla_encode_ts_credentials(rdpNla* nla)
-{
-	wStream* s;
-	size_t length;
-	int DomainLength = 0;
-	int UserLength = 0;
-	int PasswordLength = 0;
-
-	if (nla->identity)
-	{
-		/* TSPasswordCreds */
-		DomainLength = nla->identity->DomainLength;
-		UserLength = nla->identity->UserLength;
-		PasswordLength = nla->identity->PasswordLength;
-	}
-
-	if (nla->settings->DisableCredentialsDelegation && nla->identity)
-	{
-		/* TSPasswordCreds */
-		nla->identity->DomainLength = 0;
-		nla->identity->UserLength = 0;
-		nla->identity->PasswordLength = 0;
-	}
-
-	length = ber_sizeof_sequence(nla_sizeof_ts_credentials(nla));
-
-	if (!sspi_SecBufferAlloc(&nla->tsCredentials, length))
-	{
-		WLog_ERR(TAG, "sspi_SecBufferAlloc failed!");
-		return FALSE;
-	}
-
-	s = Stream_New((BYTE*)nla->tsCredentials.pvBuffer, length);
-
-	if (!s)
-	{
-		sspi_SecBufferFree(&nla->tsCredentials);
-		WLog_ERR(TAG, "Stream_New failed!");
-		return FALSE;
-	}
-
-	nla_write_ts_credentials(nla, s);
-
-	if (nla->settings->DisableCredentialsDelegation && nla->identity)
-	{
-		/* TSPasswordCreds */
-		nla->identity->DomainLength = DomainLength;
-		nla->identity->UserLength = UserLength;
-		nla->identity->PasswordLength = PasswordLength;
-	}
-
-	Stream_Free(s, FALSE);
-	return TRUE;
 }
 
 static SECURITY_STATUS nla_encrypt_ts_credentials(rdpNla* nla)
@@ -1738,6 +1861,11 @@
 	if (!nla_encode_ts_credentials(nla))
 		return SEC_E_INSUFFICIENT_MEMORY;
 
+#if defined(WITH_DEBUG_NLA)
+	WLog_DBG(TAG, "Encrypting TSCredentials");
+	winpr_HexDump(TAG, WLOG_DEBUG, nla->tsCredentials.pvBuffer, nla->tsCredentials.cbBuffer);
+#endif
+
 	if (!sspi_SecBufferAlloc(&nla->authInfo,
 	                         nla->tsCredentials.cbBuffer + nla->ContextSizes.cbSecurityTrailer))
 		return SEC_E_INSUFFICIENT_MEMORY;
@@ -1835,24 +1963,45 @@
 	Message.pBuffers = (PSecBuffer)&Buffers;
 	status = nla->table->DecryptMessage(&nla->context, &Message, nla->recvSeqNum++, &pfQOP);
 
-	if (status != SEC_E_OK)
+	if (status == SEC_E_OK)
 	{
-		WLog_ERR(TAG, "DecryptMessage failure %s [0x%08" PRIX32 "]",
-		         GetSecurityStatusString(status), status);
-		free(buffer);
-		return status;
-	}
+		auth_identity* identity = nla_read_ts_credentials(&Buffers[1]);
 
-	if (!nla_read_ts_credentials(nla, &Buffers[1]))
-	{
+		if (identity == NULL)
+		{
+			free(buffer);
+			return SEC_E_INSUFFICIENT_MEMORY;
+		}
+
+		auth_identity_free(nla->identity);
+		nla->identity = identity;
 		free(buffer);
-		return SEC_E_INSUFFICIENT_MEMORY;
+		return SEC_E_OK;
 	}
 
+	WLog_ERR(TAG, "DecryptMessage failure %s [0x%08" PRIX32 "]", GetSecurityStatusString(status),
+	         status);
 	free(buffer);
-	return SEC_E_OK;
+	return status;
 }
 
+/**
+ * TSRequest ::= SEQUENCE {
+ * 	version    [0] INTEGER,
+ * 	negoTokens [1] NegoData OPTIONAL,
+ * 	authInfo   [2] OCTET STRING OPTIONAL,
+ * 	pubKeyAuth [3] OCTET STRING OPTIONAL,
+ * 	errorCode  [4] INTEGER OPTIONAL
+ * }
+ *
+ * NegoData ::= SEQUENCE OF NegoDataItem
+ *
+ * NegoDataItem ::= SEQUENCE {
+ * 	negoToken [0] OCTET STRING
+ * }
+ *
+ */
+
 static size_t nla_sizeof_nego_token(size_t length)
 {
 	length = ber_sizeof_octet_string(length);
@@ -2257,16 +2406,9 @@
 {
 	DWORD status;
 	DWORD SpnLength;
-	LPTSTR hostnameX = NULL;
-	LPTSTR ServiceClassX = NULL;
+	LPTSTR hostnameX = stringX_from_cstring(hostname);
+	LPTSTR ServiceClassX = stringX_from_cstring(ServiceClass);
 	LPTSTR ServicePrincipalName = NULL;
-#ifdef UNICODE
-	ConvertToUnicode(CP_UTF8, 0, hostname, -1, &hostnameX, 0);
-	ConvertToUnicode(CP_UTF8, 0, ServiceClass, -1, &ServiceClassX, 0);
-#else
-	hostnameX = _strdup(hostname);
-	ServiceClassX = _strdup(ServiceClass);
-#endif
 
 	if (!hostnameX || !ServiceClassX)
 	{
@@ -2325,19 +2467,8 @@
 
 rdpNla* nla_new(freerdp* instance, rdpTransport* transport, rdpSettings* settings)
 {
-	rdpNla* nla = (rdpNla*)calloc(1, sizeof(rdpNla));
-
-	if (!nla)
-		return NULL;
-
-	nla->identity = calloc(1, sizeof(SEC_WINNT_AUTH_IDENTITY));
-
-	if (!nla->identity)
-	{
-		free(nla);
-		return NULL;
-	}
-
+	rdpNla* nla;
+	CHECK_MEMORY(nla = calloc(1, sizeof(*nla)), NULL, "rdpNla structure");
 	nla->instance = instance;
 	nla->settings = settings;
 	nla->server = settings->ServerMode;
@@ -2417,8 +2548,10 @@
 
 void nla_free(rdpNla* nla)
 {
-	if (!nla)
+	if (nla == NULL)
+	{
 		return;
+	}
 
 	if (nla->table)
 	{
@@ -2446,22 +2579,30 @@
 		}
 	}
 
-	free(nla->SamFile);
-	nla->SamFile = NULL;
 	sspi_SecBufferFree(&nla->ClientNonce);
 	sspi_SecBufferFree(&nla->PublicKey);
 	sspi_SecBufferFree(&nla->tsCredentials);
+	auth_identity_free(nla->identity);
+	free(nla->SamFile);
 	free(nla->ServicePrincipalName);
-	nla_identity_free(nla->identity);
 	free(nla);
 }
 
 SEC_WINNT_AUTH_IDENTITY* nla_get_identity(rdpNla* nla)
 {
-	if (!nla)
+	if ((nla == NULL) || (nla->identity == NULL))
+	{
 		return NULL;
+	}
 
-	return nla->identity;
+	if (nla->identity->cred_type == credential_type_password)
+	{
+		return nla->identity->creds.password_creds;
+	}
+	else
+	{
+		return NULL;
+	}
 }
 
 NLA_STATE nla_get_state(rdpNla* nla)
@@ -2489,25 +2630,3 @@
 	nla->ServicePrincipalName = principal;
 	return TRUE;
 }
-
-BOOL nla_impersonate(rdpNla* nla)
-{
-	if (!nla)
-		return FALSE;
-
-	if (!nla->table || !nla->table->ImpersonateSecurityContext)
-		return FALSE;
-
-	return (nla->table->ImpersonateSecurityContext(&nla->context) == SEC_E_OK);
-}
-
-BOOL nla_revert_to_self(rdpNla* nla)
-{
-	if (!nla)
-		return FALSE;
-
-	if (!nla->table || !nla->table->RevertSecurityContext)
-		return FALSE;
-
-	return (nla->table->RevertSecurityContext(&nla->context) == SEC_E_OK);
-}
diff -urN libfreerdp/core/nla.h ../../informatimago/FreeRDP/libfreerdp/core/nla.h
--- libfreerdp/core/nla.h	2019-07-25 19:51:03.893912455 +0300
+++ ../../informatimago/FreeRDP/libfreerdp/core/nla.h	2019-07-25 20:11:27.831982008 +0300
@@ -60,9 +60,6 @@
 
 FREERDP_LOCAL BOOL nla_set_service_principal(rdpNla* nla, LPSTR principal);
 
-FREERDP_LOCAL BOOL nla_impersonate(rdpNla* nla);
-FREERDP_LOCAL BOOL nla_revert_to_self(rdpNla* nla);
-
 FREERDP_LOCAL rdpNla* nla_new(freerdp* instance, rdpTransport* transport, rdpSettings* settings);
 FREERDP_LOCAL void nla_free(rdpNla* nla);
 
diff -urN libfreerdp/core/peer.c ../../informatimago/FreeRDP/libfreerdp/core/peer.c
--- libfreerdp/core/peer.c	2019-07-25 19:51:03.977912872 +0300
+++ ../../informatimago/FreeRDP/libfreerdp/core/peer.c	2019-07-25 20:11:27.915982424 +0300
@@ -31,6 +31,7 @@
 #include <freerdp/log.h>
 
 #include "rdp.h"
+#include "nla.h"
 #include "peer.h"
 
 #define TAG FREERDP_TAG("core.peer")
@@ -574,45 +575,16 @@
 		break;
 
 	case CONNECTION_STATE_LICENSING:
-	{
-		LicenseCallbackResult res;
-
-		if (!client->LicenseCallback)
-		{
-			WLog_ERR(TAG, "peer_recv_callback: LicenseCallback has been removed, assuming "
-			              "licensing is ok (please fix your app)");
-			res = LICENSE_CB_COMPLETED;
-		}
-		else
-			res = client->LicenseCallback(client, s);
-
-		switch (res)
+		if (!license_send_valid_client_error_packet(rdp->license))
 		{
-		case LICENSE_CB_INTERNAL_ERROR:
-			WLog_ERR(TAG, "peer_recv_callback: CONNECTION_STATE_LICENSING - callback internal "
-			              "error, aborting");
+			WLog_ERR(TAG, "peer_recv_callback: CONNECTION_STATE_LICENSING - "
+			              "license_send_valid_client_error_packet() fail");
 			return -1;
-
-		case LICENSE_CB_ABORT:
-			return -1;
-
-		case LICENSE_CB_IN_PROGRESS:
-			break;
-
-		case LICENSE_CB_COMPLETED:
-			rdp_server_transition_to_state(rdp, CONNECTION_STATE_CAPABILITIES_EXCHANGE);
-			return peer_recv_callback(transport, NULL, extra);
-
-		default:
-			WLog_ERR(TAG,
-			         "peer_recv_callback: CONNECTION_STATE_LICENSING - unknown license callback "
-			         "result %d",
-			         (int)res);
-			break;
 		}
 
+		rdp_server_transition_to_state(rdp, CONNECTION_STATE_CAPABILITIES_EXCHANGE);
+		return peer_recv_callback(transport, NULL, extra);
 		break;
-	}
 
 	case CONNECTION_STATE_CAPABILITIES_EXCHANGE:
 		if (!rdp->AwaitCapabilities)
@@ -701,7 +673,7 @@
 	if (!rdp_send_deactivate_all(client->context->rdp))
 		return FALSE;
 
-	if (freerdp_settings_get_bool(client->settings, FreeRDP_SupportErrorInfoPdu))
+	if (freerdp_get_param_bool(client->settings, FreeRDP_SupportErrorInfoPdu))
 	{
 		rdp_send_error_info(client->context->rdp);
 	}
@@ -738,19 +710,6 @@
 	return peer->context->rdp->transport->haveMoreBytesToRead;
 }
 
-static LicenseCallbackResult freerdp_peer_nolicense(freerdp_peer* peer, wStream* s)
-{
-	rdpRdp* rdp = peer->context->rdp;
-
-	if (!license_send_valid_client_error_packet(rdp))
-	{
-		WLog_ERR(TAG, "freerdp_peer_nolicense: license_send_valid_client_error_packet() failed");
-		return LICENSE_CB_ABORT;
-	}
-
-	return LICENSE_CB_COMPLETED;
-}
-
 BOOL freerdp_peer_context_new(freerdp_peer* client)
 {
 	rdpRdp* rdp;
@@ -804,7 +763,6 @@
 	client->IsWriteBlocked = freerdp_peer_is_write_blocked;
 	client->DrainOutputBuffer = freerdp_peer_drain_output_buffer;
 	client->HasMoreToRead = freerdp_peer_has_more_to_read;
-	client->LicenseCallback = freerdp_peer_nolicense;
 	IFCALLRET(client->ContextNew, ret, client, client->context);
 
 	if (ret)
diff -urN libfreerdp/core/proxy.c ../../informatimago/FreeRDP/libfreerdp/core/proxy.c
--- libfreerdp/core/proxy.c	2019-07-25 19:51:03.989912932 +0300
+++ ../../informatimago/FreeRDP/libfreerdp/core/proxy.c	2019-07-25 20:11:27.927982483 +0300
@@ -387,7 +387,7 @@
 	int status;
 	wStream* s;
 	char port_str[10], recv_buf[256], *eol;
-	size_t resultsize;
+	int resultsize;
 	_itoa_s(port, port_str, sizeof(port_str), 10);
 	s = Stream_New(NULL, 200);
 	Stream_Write(s, "CONNECT ", 8);
@@ -401,7 +401,7 @@
 	Stream_Write(s, CRLF CRLF, 4);
 	status = BIO_write(bufferedBio, Stream_Buffer(s), Stream_GetPosition(s));
 
-	if ((status < 0) || ((size_t)status != Stream_GetPosition(s)))
+	if (status != Stream_GetPosition(s))
 	{
 		Stream_Free(s, TRUE);
 		WLog_ERR(TAG, "HTTP proxy: failed to write CONNECT request");
@@ -623,9 +623,9 @@
 	/* follows DST.PORT in netw. format */
 	buf[hostnlen + 5] = (port >> 8) & 0xff;
 	buf[hostnlen + 6] = port & 0xff;
-	status = BIO_write(bufferedBio, buf, hostnlen + 7U);
+	status = BIO_write(bufferedBio, buf, hostnlen + 7);
 
-	if ((status < 0) || ((size_t)status != (hostnlen + 7U)))
+	if (status != (hostnlen + 7))
 	{
 		WLog_ERR(TAG, "SOCKS proxy: failed to write CONN REQ");
 		return FALSE;
diff -urN libfreerdp/core/rdp.c ../../informatimago/FreeRDP/libfreerdp/core/rdp.c
--- libfreerdp/core/rdp.c	2019-07-25 19:51:04.013913051 +0300
+++ ../../informatimago/FreeRDP/libfreerdp/core/rdp.c	2019-07-25 20:11:27.951982603 +0300
@@ -391,10 +391,10 @@
 
 	MCSPDU = domainMCSPDU;
 
-	if (*length < 8U)
+	if (*length < 8)
 		return FALSE;
 
-	if ((*length - 8U) > Stream_GetRemainingLength(s))
+	if ((*length - 8) > Stream_GetRemainingLength(s))
 		return FALSE;
 
 	if (MCSPDU == DomainMCSPDU_DisconnectProviderUltimatum)
@@ -797,10 +797,6 @@
 		return FALSE;
 
 	Stream_Read_UINT32(s, statusCode); /* statusCode (4 bytes) */
-
-	if (rdp->update->ServerStatusInfo)
-		return rdp->update->ServerStatusInfo(rdp->context, statusCode);
-
 	return TRUE;
 }
 
@@ -839,6 +835,29 @@
 	return ret;
 }
 
+BOOL rdp_write_monitor_layout_pdu(wStream* s, UINT32 monitorCount,
+                                  const rdpMonitor* monitorDefArray)
+{
+	UINT32 index;
+	const rdpMonitor* monitor;
+
+	if (!Stream_EnsureRemainingCapacity(s, 4 + (monitorCount * 20)))
+		return FALSE;
+
+	Stream_Write_UINT32(s, monitorCount); /* monitorCount (4 bytes) */
+
+	for (index = 0, monitor = monitorDefArray; index < monitorCount; index++, monitor++)
+	{
+		Stream_Write_UINT32(s, monitor->x);                        /* left (4 bytes) */
+		Stream_Write_UINT32(s, monitor->y);                        /* top (4 bytes) */
+		Stream_Write_UINT32(s, monitor->x + monitor->width - 1);   /* right (4 bytes) */
+		Stream_Write_UINT32(s, monitor->y + monitor->height - 1);  /* bottom (4 bytes) */
+		Stream_Write_UINT32(s, monitor->is_primary ? 0x01 : 0x00); /* flags (4 bytes) */
+	}
+
+	return TRUE;
+}
+
 int rdp_recv_data_pdu(rdpRdp* rdp, wStream* s)
 {
 	BYTE type;
@@ -1544,7 +1563,7 @@
 			ActivatedEventArgs activatedEvent;
 			rdpContext* context = rdp->context;
 			rdp_client_transition_to_state(rdp, CONNECTION_STATE_ACTIVE);
-			EventArgsInit(&activatedEvent, "libfreerdp");
+			EventArgsInit(&activatedEvent, "xfreerdp");
 			activatedEvent.firstActivation = !rdp->deactivation_reactivation;
 			PubSub_OnActivated(context->pubSub, context, &activatedEvent);
 			return 2;
diff -urN libfreerdp/core/rdp.h ../../informatimago/FreeRDP/libfreerdp/core/rdp.h
--- libfreerdp/core/rdp.h	2019-07-25 19:51:04.021913091 +0300
+++ ../../informatimago/FreeRDP/libfreerdp/core/rdp.h	2019-07-25 20:11:27.959982642 +0300
@@ -216,6 +216,9 @@
 
 FREERDP_LOCAL void rdp_read_flow_control_pdu(wStream* s, UINT16* type);
 
+FREERDP_LOCAL BOOL rdp_write_monitor_layout_pdu(wStream* s, UINT32 monitorCount,
+                                                const rdpMonitor* monitorDefArray);
+
 FREERDP_LOCAL int rdp_recv_callback(rdpTransport* transport, wStream* s, void* extra);
 
 FREERDP_LOCAL int rdp_check_fds(rdpRdp* rdp);
diff -urN libfreerdp/core/server.c ../../informatimago/FreeRDP/libfreerdp/core/server.c
--- libfreerdp/core/server.c	2019-07-25 19:51:04.077913368 +0300
+++ ../../informatimago/FreeRDP/libfreerdp/core/server.c	2019-07-25 20:11:28.015982920 +0300
@@ -217,7 +217,7 @@
 
 		Stream_Write(channel->receiveData, Stream_Pointer(s), length);
 
-		if (Stream_GetPosition(channel->receiveData) >= channel->dvc_total_length)
+		if (Stream_GetPosition(channel->receiveData) >= (int)channel->dvc_total_length)
 		{
 			ret = wts_queue_receive_data(channel, Stream_Buffer(channel->receiveData),
 			                             channel->dvc_total_length);
@@ -356,14 +356,9 @@
 }
 
 static BOOL WTSProcessChannelData(rdpPeerChannel* channel, UINT16 channelId, const BYTE* data,
-                                  int s, int flags, int t)
+                                  int size, int flags, int totalSize)
 {
 	BOOL ret = TRUE;
-	const size_t size = (size_t)s;
-	const size_t totalSize = (size_t)t;
-
-	if ((s < 0) || (t < 0))
-		return FALSE;
 
 	if (flags & CHANNEL_FLAG_FIRST)
 	{
diff -urN libfreerdp/core/settings.c ../../informatimago/FreeRDP/libfreerdp/core/settings.c
--- libfreerdp/core/settings.c	2019-07-25 19:51:04.109913526 +0300
+++ ../../informatimago/FreeRDP/libfreerdp/core/settings.c	2019-07-25 20:11:28.043983059 +0300
@@ -315,13 +315,6 @@
 	if (!settings)
 		return NULL;
 
-	settings->HiDefRemoteApp = FALSE;
-	settings->RemoteApplicationSupportMask =
-	    RAIL_LEVEL_SUPPORTED | RAIL_LEVEL_DOCKED_LANGBAR_SUPPORTED |
-	    RAIL_LEVEL_SHELL_INTEGRATION_SUPPORTED | RAIL_LEVEL_LANGUAGE_IME_SYNC_SUPPORTED |
-	    RAIL_LEVEL_SERVER_TO_CLIENT_IME_SYNC_SUPPORTED | RAIL_LEVEL_HIDE_MINIMIZED_APPS_SUPPORTED |
-	    RAIL_LEVEL_WINDOW_CLOAKING_SUPPORTED | RAIL_LEVEL_HANDSHAKE_EX_SUPPORTED;
-	settings->SupportHeartbeatPdu = TRUE;
 	settings->ServerMode = (flags & FREERDP_SETTINGS_SERVER_MODE) ? TRUE : FALSE;
 	settings->WaitForOutputBufferFlush = TRUE;
 	settings->MaxTimeInCheckLoop = 100;
@@ -331,7 +324,7 @@
 	settings->Fullscreen = FALSE;
 	settings->GrabKeyboard = TRUE;
 	settings->Decorations = TRUE;
-	settings->RdpVersion = RDP_VERSION_10_6;
+	settings->RdpVersion = RDP_VERSION_5_PLUS;
 	settings->ColorDepth = 16;
 	settings->ExtSecurity = FALSE;
 	settings->NlaSecurity = TRUE;
@@ -430,6 +423,9 @@
 	settings->DrawAllowDynamicColorFidelity = FALSE;
 	settings->FrameMarkerCommandEnabled = TRUE;
 	settings->SurfaceFrameMarkerEnabled = TRUE;
+	settings->BitmapCacheV3Enabled = FALSE;
+	settings->BitmapCacheEnabled = TRUE;
+	settings->BitmapCachePersistEnabled = FALSE;
 	settings->AllowCacheWaitingList = TRUE;
 	settings->BitmapCacheV2NumCells = 5;
 	settings->BitmapCacheV2CellInfo =
@@ -484,7 +480,7 @@
 	settings->GlyphCache[9].cacheMaximumCellSize = 256;
 	settings->FragCache->cacheEntries = 256;
 	settings->FragCache->cacheMaximumCellSize = 256;
-	settings->OffscreenSupportLevel = FALSE;
+	settings->OffscreenSupportLevel = TRUE;
 	settings->OffscreenCacheSize = 7680;
 	settings->OffscreenCacheEntries = 2000;
 	settings->DrawNineGridCacheSize = 2560;
@@ -494,7 +490,7 @@
 	if (!settings->ClientDir)
 		goto out_fail;
 
-	settings->RemoteWndSupportLevel = WINDOW_LEVEL_SUPPORTED | WINDOW_LEVEL_SUPPORTED_EX;
+	settings->RemoteWndSupportLevel = WINDOW_LEVEL_SUPPORTED_EX;
 	settings->RemoteAppNumIconCaches = 3;
 	settings->RemoteAppNumIconCacheEntries = 12;
 	settings->VirtualChannelChunkSize = CHANNEL_CHUNK_LENGTH;
@@ -584,7 +580,7 @@
 		}
 		else
 		{
-			size_t i;
+			int i;
 			char product[sizeof(FREERDP_PRODUCT_STRING)];
 			memset(product, 0, sizeof(product));
 
@@ -606,7 +602,6 @@
 
 	settings->ActionScript = _strdup("~/.config/freerdp/action.sh");
 	settings->SmartcardLogon = FALSE;
-	settings->PromptForCredentials = TRUE;
 	settings->TlsSecLevel = 1;
 	settings->OrderSupport = calloc(1, 32);
 
@@ -642,474 +637,378 @@
 	return NULL;
 }
 
-static void freerdp_settings_free_internal(rdpSettings* settings)
-{
-	free(settings->ServerHostname);
-	free(settings->Username);
-	free(settings->Password);
-	free(settings->Domain);
-	free(settings->PasswordHash);
-	free(settings->AcceptedCert);
-	free(settings->AlternateShell);
-	free(settings->ShellWorkingDirectory);
-	free(settings->ComputerName);
-	free(settings->ChannelDefArray);
-	free(settings->MonitorDefArray);
-	free(settings->MonitorIds);
-	free(settings->ClientAddress);
-	free(settings->ClientDir);
-	free(settings->AllowedTlsCiphers);
-	free(settings->NtlmSamFile);
-	free(settings->CertificateFile);
-	free(settings->PrivateKeyFile);
-	free(settings->ConnectionFile);
-	free(settings->AssistanceFile);
-	free(settings->ReceivedCapabilities);
-	free(settings->OrderSupport);
-	free(settings->ClientHostname);
-	free(settings->ClientProductId);
-	free(settings->ServerRandom);
-	free(settings->ClientRandom);
-	free(settings->ServerCertificate);
-	free(settings->RdpKeyFile);
-	certificate_free(settings->RdpServerCertificate);
-	free(settings->CertificateContent);
-	free(settings->PrivateKeyContent);
-	free(settings->RdpKeyContent);
-	free(settings->ClientAutoReconnectCookie);
-	free(settings->ServerAutoReconnectCookie);
-	free(settings->ClientTimeZone);
-	free(settings->BitmapCacheV2CellInfo);
-	free(settings->GlyphCache);
-	free(settings->FragCache);
-	key_free(settings->RdpServerRsaKey);
-	free(settings->ConfigPath);
-	free(settings->CurrentPath);
-	free(settings->HomePath);
-	free(settings->LoadBalanceInfo);
-	free(settings->TargetNetAddress);
-	free(settings->RedirectionTargetFQDN);
-	free(settings->RedirectionTargetNetBiosName);
-	free(settings->RedirectionUsername);
-	free(settings->RedirectionDomain);
-	free(settings->RedirectionPassword);
-	free(settings->RedirectionTsvUrl);
-	free(settings->RedirectionAcceptedCert);
-	free(settings->RemoteAssistanceSessionId);
-	free(settings->RemoteAssistancePassword);
-	free(settings->RemoteAssistancePassStub);
-	free(settings->RemoteAssistanceRCTicket);
-	free(settings->AuthenticationServiceClass);
-	free(settings->GatewayHostname);
-	free(settings->GatewayUsername);
-	free(settings->GatewayPassword);
-	free(settings->GatewayDomain);
-	free(settings->GatewayAccessToken);
-	free(settings->GatewayAcceptedCert);
-	free(settings->CertificateName);
-	free(settings->DynamicDSTTimeZoneKeyName);
-	free(settings->PreconnectionBlob);
-	free(settings->KerberosKdc);
-	free(settings->KerberosRealm);
-	free(settings->DumpRemoteFxFile);
-	free(settings->PlayRemoteFxFile);
-	free(settings->RemoteApplicationName);
-	free(settings->RemoteApplicationIcon);
-	free(settings->RemoteApplicationProgram);
-	free(settings->RemoteApplicationFile);
-	free(settings->RemoteApplicationGuid);
-	free(settings->RemoteApplicationCmdLine);
-	free(settings->ImeFileName);
-	free(settings->DrivesToRedirect);
-	free(settings->WindowTitle);
-	free(settings->WmClass);
-	free(settings->ActionScript);
-	freerdp_target_net_addresses_free(settings);
-	freerdp_device_collection_free(settings);
-	freerdp_static_channel_collection_free(settings);
-	freerdp_dynamic_channel_collection_free(settings);
-	free(settings->SettingsModified);
-	memset(settings, 0, sizeof(rdpSettings));
-}
-
-void freerdp_settings_free(rdpSettings* settings)
-{
-	if (!settings)
-		return;
-
-	freerdp_settings_free_internal(settings);
-	free(settings);
-}
-
-BOOL freerdp_settings_copy(rdpSettings* _settings, const rdpSettings* settings)
+rdpSettings* freerdp_settings_clone(rdpSettings* settings)
 {
 	UINT32 index;
+	rdpSettings* _settings;
+	_settings = (rdpSettings*)calloc(1, sizeof(rdpSettings));
 
-	if (!settings || !_settings)
-		return FALSE;
-
-	freerdp_settings_free_internal(_settings);
-	*_settings = *settings;
-	/* char* values */
+	if (_settings)
+	{
+		CopyMemory(_settings, settings, sizeof(rdpSettings));
+		/* char* values */
 #define CHECKED_STRDUP(name)                                            \
 	if (settings->name && !(_settings->name = _strdup(settings->name))) \
 	goto out_fail
-	CHECKED_STRDUP(ServerHostname);             /* 20 */
-	CHECKED_STRDUP(Username);                   /* 21 */
-	CHECKED_STRDUP(Password);                   /* 22 */
-	CHECKED_STRDUP(Domain);                     /* 23 */
-	CHECKED_STRDUP(PasswordHash);               /* 24 */
-	CHECKED_STRDUP(AcceptedCert);               /* 27 */
-	CHECKED_STRDUP(AlternateShell);             /* 640 */
-	CHECKED_STRDUP(ShellWorkingDirectory);      /* 641 */
-	CHECKED_STRDUP(ClientAddress);              /* 769 */
-	CHECKED_STRDUP(ClientDir);                  /* 770 */
-	CHECKED_STRDUP(DynamicDSTTimeZoneKeyName);  /* 897 */
-	CHECKED_STRDUP(RemoteAssistanceSessionId);  /* 1025 */
-	CHECKED_STRDUP(RemoteAssistancePassStub);   /* 1026 */
-	CHECKED_STRDUP(RemoteAssistancePassword);   /* 1027 */
-	CHECKED_STRDUP(RemoteAssistanceRCTicket);   /* 1028 */
-	CHECKED_STRDUP(AuthenticationServiceClass); /* 1098 */
-	CHECKED_STRDUP(AllowedTlsCiphers);          /* 1101 */
-	CHECKED_STRDUP(NtlmSamFile);                /* 1103 */
-	CHECKED_STRDUP(PreconnectionBlob);          /* 1155 */
-	CHECKED_STRDUP(RedirectionAcceptedCert);    /* 1231 */
-	CHECKED_STRDUP(KerberosKdc);                /* 1344 */
-	CHECKED_STRDUP(KerberosRealm);              /* 1345 */
-	CHECKED_STRDUP(CertificateName);            /* 1409 */
-	CHECKED_STRDUP(CertificateFile);            /* 1410 */
-	CHECKED_STRDUP(PrivateKeyFile);             /* 1411 */
-	CHECKED_STRDUP(RdpKeyFile);                 /* 1412 */
-	CHECKED_STRDUP(CertificateContent);         /* 1416 */
-	CHECKED_STRDUP(PrivateKeyContent);          /* 1417 */
-	CHECKED_STRDUP(RdpKeyContent);              /* 1418 */
-	CHECKED_STRDUP(WindowTitle);                /* 1542 */
-	CHECKED_STRDUP(WmClass);                    /* 1549 */
-	CHECKED_STRDUP(ComputerName);               /* 1664 */
-	CHECKED_STRDUP(ConnectionFile);             /* 1728 */
-	CHECKED_STRDUP(AssistanceFile);             /* 1729 */
-	CHECKED_STRDUP(HomePath);                   /* 1792 */
-	CHECKED_STRDUP(ConfigPath);                 /* 1793 */
-	CHECKED_STRDUP(CurrentPath);                /* 1794 */
-	CHECKED_STRDUP(DumpRemoteFxFile);           /* 1858 */
-	CHECKED_STRDUP(PlayRemoteFxFile);           /* 1859 */
-	CHECKED_STRDUP(GatewayHostname);            /* 1986 */
-	CHECKED_STRDUP(GatewayUsername);            /* 1987 */
-	CHECKED_STRDUP(GatewayPassword);            /* 1988 */
-	CHECKED_STRDUP(GatewayDomain);              /* 1989 */
-	CHECKED_STRDUP(GatewayAccessToken);         /* 1997 */
-	CHECKED_STRDUP(GatewayAcceptedCert);        /* 1998 */
-	CHECKED_STRDUP(ProxyHostname);              /* 2016 */
-	CHECKED_STRDUP(RemoteApplicationName);      /* 2113 */
-	CHECKED_STRDUP(RemoteApplicationIcon);      /* 2114 */
-	CHECKED_STRDUP(RemoteApplicationProgram);   /* 2115 */
-	CHECKED_STRDUP(RemoteApplicationFile);      /* 2116 */
-	CHECKED_STRDUP(RemoteApplicationGuid);      /* 2117 */
-	CHECKED_STRDUP(RemoteApplicationCmdLine);   /* 2118 */
-	CHECKED_STRDUP(ImeFileName);                /* 2628 */
-	CHECKED_STRDUP(DrivesToRedirect);           /* 4290 */
-	CHECKED_STRDUP(ActionScript);
+		CHECKED_STRDUP(ServerHostname);             /* 20 */
+		CHECKED_STRDUP(Username);                   /* 21 */
+		CHECKED_STRDUP(Password);                   /* 22 */
+		CHECKED_STRDUP(Domain);                     /* 23 */
+		CHECKED_STRDUP(PasswordHash);               /* 24 */
+		CHECKED_STRDUP(AcceptedCert);               /* 27 */
+		_settings->ClientHostname = NULL;           /* 134 */
+		_settings->ClientProductId = NULL;          /* 135 */
+		CHECKED_STRDUP(AlternateShell);             /* 640 */
+		CHECKED_STRDUP(ShellWorkingDirectory);      /* 641 */
+		CHECKED_STRDUP(ClientAddress);              /* 769 */
+		CHECKED_STRDUP(ClientDir);                  /* 770 */
+		CHECKED_STRDUP(DynamicDSTTimeZoneKeyName);  /* 897 */
+		CHECKED_STRDUP(RemoteAssistanceSessionId);  /* 1025 */
+		CHECKED_STRDUP(RemoteAssistancePassStub);   /* 1026 */
+		CHECKED_STRDUP(RemoteAssistancePassword);   /* 1027 */
+		CHECKED_STRDUP(RemoteAssistanceRCTicket);   /* 1028 */
+		CHECKED_STRDUP(AuthenticationServiceClass); /* 1098 */
+		CHECKED_STRDUP(AllowedTlsCiphers);          /* 1101 */
+		CHECKED_STRDUP(NtlmSamFile);                /* 1103 */
+		CHECKED_STRDUP(PreconnectionBlob);          /* 1155 */
+		CHECKED_STRDUP(RedirectionAcceptedCert);    /* 1231 */
+		CHECKED_STRDUP(KerberosKdc);                /* 1344 */
+		CHECKED_STRDUP(KerberosRealm);              /* 1345 */
+		CHECKED_STRDUP(CertificateName);            /* 1409 */
+		CHECKED_STRDUP(CertificateFile);            /* 1410 */
+		CHECKED_STRDUP(PrivateKeyFile);             /* 1411 */
+		CHECKED_STRDUP(RdpKeyFile);                 /* 1412 */
+		CHECKED_STRDUP(CertificateContent);         /* 1416 */
+		CHECKED_STRDUP(PrivateKeyContent);          /* 1417 */
+		CHECKED_STRDUP(RdpKeyContent);              /* 1418 */
+		CHECKED_STRDUP(WindowTitle);                /* 1542 */
+		CHECKED_STRDUP(WmClass);                    /* 1549 */
+		CHECKED_STRDUP(ComputerName);               /* 1664 */
+		CHECKED_STRDUP(ConnectionFile);             /* 1728 */
+		CHECKED_STRDUP(AssistanceFile);             /* 1729 */
+		CHECKED_STRDUP(HomePath);                   /* 1792 */
+		CHECKED_STRDUP(ConfigPath);                 /* 1793 */
+		CHECKED_STRDUP(CurrentPath);                /* 1794 */
+		CHECKED_STRDUP(DumpRemoteFxFile);           /* 1858 */
+		CHECKED_STRDUP(PlayRemoteFxFile);           /* 1859 */
+		CHECKED_STRDUP(GatewayHostname);            /* 1986 */
+		CHECKED_STRDUP(GatewayUsername);            /* 1987 */
+		CHECKED_STRDUP(GatewayPassword);            /* 1988 */
+		CHECKED_STRDUP(GatewayDomain);              /* 1989 */
+		CHECKED_STRDUP(GatewayAccessToken);         /* 1997 */
+		CHECKED_STRDUP(GatewayAcceptedCert);        /* 1998 */
+		CHECKED_STRDUP(ProxyHostname);              /* 2016 */
+		CHECKED_STRDUP(RemoteApplicationName);      /* 2113 */
+		CHECKED_STRDUP(RemoteApplicationIcon);      /* 2114 */
+		CHECKED_STRDUP(RemoteApplicationProgram);   /* 2115 */
+		CHECKED_STRDUP(RemoteApplicationFile);      /* 2116 */
+		CHECKED_STRDUP(RemoteApplicationGuid);      /* 2117 */
+		CHECKED_STRDUP(RemoteApplicationCmdLine);   /* 2118 */
+		CHECKED_STRDUP(ImeFileName);                /* 2628 */
+		CHECKED_STRDUP(DrivesToRedirect);           /* 4290 */
+		CHECKED_STRDUP(ActionScript);
+		/**
+		 * Manual Code
+		 */
+		_settings->LoadBalanceInfo = NULL;
+		_settings->LoadBalanceInfoLength = 0;
+		_settings->TargetNetAddress = NULL;
+		_settings->RedirectionTargetFQDN = NULL;
+		_settings->RedirectionTargetNetBiosName = NULL;
+		_settings->RedirectionUsername = NULL;
+		_settings->RedirectionDomain = NULL;
+		_settings->RedirectionPassword = NULL;
+		_settings->RedirectionPasswordLength = 0;
+		_settings->RedirectionTsvUrl = NULL;
+		_settings->RedirectionTsvUrlLength = 0;
+		_settings->TargetNetAddressCount = 0;
+		_settings->TargetNetAddresses = NULL;
+		_settings->TargetNetPorts = NULL;
 
-	if (settings->LoadBalanceInfo && settings->LoadBalanceInfoLength)
-	{
-		_settings->LoadBalanceInfo = (BYTE*)calloc(1, settings->LoadBalanceInfoLength + 2);
+		if (settings->LoadBalanceInfo && settings->LoadBalanceInfoLength)
+		{
+			_settings->LoadBalanceInfo = (BYTE*)calloc(1, settings->LoadBalanceInfoLength + 2);
 
-		if (!_settings->LoadBalanceInfo)
-			goto out_fail;
+			if (!_settings->LoadBalanceInfo)
+				goto out_fail;
 
-		CopyMemory(_settings->LoadBalanceInfo, settings->LoadBalanceInfo,
-		           settings->LoadBalanceInfoLength);
-		_settings->LoadBalanceInfoLength = settings->LoadBalanceInfoLength;
-	}
+			CopyMemory(_settings->LoadBalanceInfo, settings->LoadBalanceInfo,
+			           settings->LoadBalanceInfoLength);
+			_settings->LoadBalanceInfoLength = settings->LoadBalanceInfoLength;
+		}
 
-	if (_settings->ServerRandomLength)
-	{
-		_settings->ServerRandom = (BYTE*)malloc(_settings->ServerRandomLength);
+		if (_settings->ServerRandomLength)
+		{
+			_settings->ServerRandom = (BYTE*)malloc(_settings->ServerRandomLength);
 
-		if (!_settings->ServerRandom)
-			goto out_fail;
+			if (!_settings->ServerRandom)
+				goto out_fail;
 
-		CopyMemory(_settings->ServerRandom, settings->ServerRandom, _settings->ServerRandomLength);
-		_settings->ServerRandomLength = settings->ServerRandomLength;
-	}
+			CopyMemory(_settings->ServerRandom, settings->ServerRandom,
+			           _settings->ServerRandomLength);
+			_settings->ServerRandomLength = settings->ServerRandomLength;
+		}
 
-	if (_settings->ClientRandomLength)
-	{
-		_settings->ClientRandom = (BYTE*)malloc(_settings->ClientRandomLength);
+		if (_settings->ClientRandomLength)
+		{
+			_settings->ClientRandom = (BYTE*)malloc(_settings->ClientRandomLength);
 
-		if (!_settings->ClientRandom)
-			goto out_fail;
+			if (!_settings->ClientRandom)
+				goto out_fail;
 
-		CopyMemory(_settings->ClientRandom, settings->ClientRandom, _settings->ClientRandomLength);
-		_settings->ClientRandomLength = settings->ClientRandomLength;
-	}
+			CopyMemory(_settings->ClientRandom, settings->ClientRandom,
+			           _settings->ClientRandomLength);
+			_settings->ClientRandomLength = settings->ClientRandomLength;
+		}
 
-	if (settings->RdpServerCertificate)
-	{
-		_settings->RdpServerCertificate = certificate_clone(settings->RdpServerCertificate);
+		if (settings->RdpServerCertificate)
+		{
+			_settings->RdpServerCertificate = certificate_clone(settings->RdpServerCertificate);
 
-		if (!_settings->RdpServerCertificate)
-			goto out_fail;
-	}
+			if (!_settings->RdpServerCertificate)
+				goto out_fail;
+		}
 
-	if (settings->RdpServerRsaKey)
-	{
-		_settings->RdpServerRsaKey = key_clone(settings->RdpServerRsaKey);
+		_settings->ChannelCount = settings->ChannelCount;
+		_settings->ChannelDefArraySize = settings->ChannelDefArraySize;
 
-		if (!_settings->RdpServerRsaKey)
-			goto out_fail;
-	}
+		if (_settings->ChannelDefArraySize > 0)
+		{
+			_settings->ChannelDefArray =
+			    (CHANNEL_DEF*)calloc(settings->ChannelDefArraySize, sizeof(CHANNEL_DEF));
 
-	_settings->ChannelCount = settings->ChannelCount;
-	_settings->ChannelDefArraySize = settings->ChannelDefArraySize;
+			if (!_settings->ChannelDefArray)
+				goto out_fail;
 
-	if (_settings->ChannelDefArraySize > 0)
-	{
-		_settings->ChannelDefArray =
-		    (CHANNEL_DEF*)calloc(settings->ChannelDefArraySize, sizeof(CHANNEL_DEF));
+			CopyMemory(_settings->ChannelDefArray, settings->ChannelDefArray,
+			           sizeof(CHANNEL_DEF) * settings->ChannelDefArraySize);
+		}
+		else
+			_settings->ChannelDefArray = NULL;
+
+		_settings->MonitorCount = settings->MonitorCount;
+		_settings->MonitorDefArraySize = settings->MonitorDefArraySize;
 
-		if (!_settings->ChannelDefArray)
+		if (_settings->MonitorDefArraySize > 0)
+		{
+			_settings->MonitorDefArray =
+			    (rdpMonitor*)calloc(settings->MonitorDefArraySize, sizeof(rdpMonitor));
+
+			if (!_settings->MonitorDefArray)
+				goto out_fail;
+
+			CopyMemory(_settings->MonitorDefArray, settings->MonitorDefArray,
+			           sizeof(rdpMonitor) * settings->MonitorDefArraySize);
+		}
+		else
+			_settings->MonitorDefArray = NULL;
+
+		_settings->MonitorIds = (UINT32*)calloc(16, sizeof(UINT32));
+
+		if (!_settings->MonitorIds)
 			goto out_fail;
 
-		CopyMemory(_settings->ChannelDefArray, settings->ChannelDefArray,
-		           sizeof(CHANNEL_DEF) * settings->ChannelDefArraySize);
-	}
-	else
-		_settings->ChannelDefArray = NULL;
+		CopyMemory(_settings->MonitorIds, settings->MonitorIds, 16 * sizeof(UINT32));
+		_settings->ReceivedCapabilities = malloc(32);
 
-	_settings->MonitorCount = settings->MonitorCount;
-	_settings->MonitorDefArraySize = settings->MonitorDefArraySize;
+		if (!_settings->ReceivedCapabilities)
+			goto out_fail;
 
-	if (_settings->MonitorDefArraySize > 0)
-	{
-		_settings->MonitorDefArray =
-		    (rdpMonitor*)calloc(settings->MonitorDefArraySize, sizeof(rdpMonitor));
+		_settings->OrderSupport = malloc(32);
 
-		if (!_settings->MonitorDefArray)
+		if (!_settings->OrderSupport)
 			goto out_fail;
 
-		CopyMemory(_settings->MonitorDefArray, settings->MonitorDefArray,
-		           sizeof(rdpMonitor) * settings->MonitorDefArraySize);
-	}
-	else
-		_settings->MonitorDefArray = NULL;
+		if (!_settings->ReceivedCapabilities || !_settings->OrderSupport)
+			goto out_fail;
 
-	_settings->MonitorIds = (UINT32*)calloc(16, sizeof(UINT32));
+		CopyMemory(_settings->ReceivedCapabilities, settings->ReceivedCapabilities, 32);
+		CopyMemory(_settings->OrderSupport, settings->OrderSupport, 32);
+		_settings->ClientHostname = _strdup(settings->ClientHostname);
 
-	if (!_settings->MonitorIds)
-		goto out_fail;
+		if (!_settings->ClientHostname)
+			goto out_fail;
 
-	CopyMemory(_settings->MonitorIds, settings->MonitorIds, 16 * sizeof(UINT32));
-	_settings->ReceivedCapabilities = malloc(32);
+		_settings->ClientProductId = _strdup(settings->ClientProductId);
 
-	if (!_settings->ReceivedCapabilities)
-		goto out_fail;
+		if (!_settings->ClientProductId)
+			goto out_fail;
 
-	_settings->OrderSupport = malloc(32);
+		_settings->BitmapCacheV2CellInfo =
+		    (BITMAP_CACHE_V2_CELL_INFO*)malloc(sizeof(BITMAP_CACHE_V2_CELL_INFO) * 6);
 
-	if (!_settings->OrderSupport)
-		goto out_fail;
+		if (!_settings->BitmapCacheV2CellInfo)
+			goto out_fail;
 
-	if (!_settings->ReceivedCapabilities || !_settings->OrderSupport)
-		goto out_fail;
+		CopyMemory(_settings->BitmapCacheV2CellInfo, settings->BitmapCacheV2CellInfo,
+		           sizeof(BITMAP_CACHE_V2_CELL_INFO) * 6);
+		_settings->GlyphCache = malloc(sizeof(GLYPH_CACHE_DEFINITION) * 10);
 
-	CopyMemory(_settings->ReceivedCapabilities, settings->ReceivedCapabilities, 32);
-	CopyMemory(_settings->OrderSupport, settings->OrderSupport, 32);
-	_settings->ClientHostname = _strdup(settings->ClientHostname);
+		if (!_settings->GlyphCache)
+			goto out_fail;
 
-	if (!_settings->ClientHostname)
-		goto out_fail;
+		_settings->FragCache = malloc(sizeof(GLYPH_CACHE_DEFINITION));
 
-	_settings->ClientProductId = _strdup(settings->ClientProductId);
+		if (!_settings->FragCache)
+			goto out_fail;
 
-	if (!_settings->ClientProductId)
-		goto out_fail;
+		CopyMemory(_settings->GlyphCache, settings->GlyphCache,
+		           sizeof(GLYPH_CACHE_DEFINITION) * 10);
+		CopyMemory(_settings->FragCache, settings->FragCache, sizeof(GLYPH_CACHE_DEFINITION));
+		_settings->ClientAutoReconnectCookie =
+		    (ARC_CS_PRIVATE_PACKET*)malloc(sizeof(ARC_CS_PRIVATE_PACKET));
 
-	_settings->BitmapCacheV2CellInfo =
-	    (BITMAP_CACHE_V2_CELL_INFO*)malloc(sizeof(BITMAP_CACHE_V2_CELL_INFO) * 6);
+		if (!_settings->ClientAutoReconnectCookie)
+			goto out_fail;
 
-	if (!_settings->BitmapCacheV2CellInfo)
-		goto out_fail;
+		_settings->ServerAutoReconnectCookie =
+		    (ARC_SC_PRIVATE_PACKET*)malloc(sizeof(ARC_SC_PRIVATE_PACKET));
 
-	CopyMemory(_settings->BitmapCacheV2CellInfo, settings->BitmapCacheV2CellInfo,
-	           sizeof(BITMAP_CACHE_V2_CELL_INFO) * 6);
-	_settings->GlyphCache = malloc(sizeof(GLYPH_CACHE_DEFINITION) * 10);
+		if (!_settings->ServerAutoReconnectCookie)
+			goto out_fail;
 
-	if (!_settings->GlyphCache)
-		goto out_fail;
+		CopyMemory(_settings->ClientAutoReconnectCookie, settings->ClientAutoReconnectCookie,
+		           sizeof(ARC_CS_PRIVATE_PACKET));
+		CopyMemory(_settings->ServerAutoReconnectCookie, settings->ServerAutoReconnectCookie,
+		           sizeof(ARC_SC_PRIVATE_PACKET));
+		_settings->ClientTimeZone = (LPTIME_ZONE_INFORMATION)malloc(sizeof(TIME_ZONE_INFORMATION));
 
-	_settings->FragCache = malloc(sizeof(GLYPH_CACHE_DEFINITION));
+		if (!_settings->ClientTimeZone)
+			goto out_fail;
 
-	if (!_settings->FragCache)
-		goto out_fail;
+		CopyMemory(_settings->ClientTimeZone, settings->ClientTimeZone,
+		           sizeof(TIME_ZONE_INFORMATION));
+		_settings->TargetNetAddressCount = settings->TargetNetAddressCount;
 
-	CopyMemory(_settings->GlyphCache, settings->GlyphCache, sizeof(GLYPH_CACHE_DEFINITION) * 10);
-	CopyMemory(_settings->FragCache, settings->FragCache, sizeof(GLYPH_CACHE_DEFINITION));
-	_settings->ClientAutoReconnectCookie =
-	    (ARC_CS_PRIVATE_PACKET*)malloc(sizeof(ARC_CS_PRIVATE_PACKET));
+		if (settings->TargetNetAddressCount > 0)
+		{
+			_settings->TargetNetAddresses =
+			    (char**)calloc(settings->TargetNetAddressCount, sizeof(char*));
 
-	if (!_settings->ClientAutoReconnectCookie)
-		goto out_fail;
+			if (!_settings->TargetNetAddresses)
+			{
+				_settings->TargetNetAddressCount = 0;
+				goto out_fail;
+			}
 
-	_settings->ServerAutoReconnectCookie =
-	    (ARC_SC_PRIVATE_PACKET*)malloc(sizeof(ARC_SC_PRIVATE_PACKET));
+			for (index = 0; index < settings->TargetNetAddressCount; index++)
+			{
+				_settings->TargetNetAddresses[index] = _strdup(settings->TargetNetAddresses[index]);
 
-	if (!_settings->ServerAutoReconnectCookie)
-		goto out_fail;
+				if (!_settings->TargetNetAddresses[index])
+				{
+					while (index)
+						free(_settings->TargetNetAddresses[--index]);
+
+					free(_settings->TargetNetAddresses);
+					_settings->TargetNetAddresses = NULL;
+					_settings->TargetNetAddressCount = 0;
+					goto out_fail;
+				}
+			}
 
-	CopyMemory(_settings->ClientAutoReconnectCookie, settings->ClientAutoReconnectCookie,
-	           sizeof(ARC_CS_PRIVATE_PACKET));
-	CopyMemory(_settings->ServerAutoReconnectCookie, settings->ServerAutoReconnectCookie,
-	           sizeof(ARC_SC_PRIVATE_PACKET));
-	_settings->ClientTimeZone = (LPTIME_ZONE_INFORMATION)malloc(sizeof(TIME_ZONE_INFORMATION));
+			if (settings->TargetNetPorts)
+			{
+				_settings->TargetNetPorts =
+				    (UINT32*)calloc(settings->TargetNetAddressCount, sizeof(UINT32));
 
-	if (!_settings->ClientTimeZone)
-		goto out_fail;
+				if (!_settings->TargetNetPorts)
+					goto out_fail;
 
-	CopyMemory(_settings->ClientTimeZone, settings->ClientTimeZone, sizeof(TIME_ZONE_INFORMATION));
-	_settings->TargetNetAddressCount = settings->TargetNetAddressCount;
+				for (index = 0; index < settings->TargetNetAddressCount; index++)
+					_settings->TargetNetPorts[index] = settings->TargetNetPorts[index];
+			}
+		}
 
-	if (settings->TargetNetAddressCount > 0)
-	{
-		_settings->TargetNetAddresses =
-		    (char**)calloc(settings->TargetNetAddressCount, sizeof(char*));
+		_settings->DeviceCount = settings->DeviceCount;
+		_settings->DeviceArraySize = settings->DeviceArraySize;
+		_settings->DeviceArray =
+		    (RDPDR_DEVICE**)calloc(_settings->DeviceArraySize, sizeof(RDPDR_DEVICE*));
 
-		if (!_settings->TargetNetAddresses)
+		if (!_settings->DeviceArray && _settings->DeviceArraySize)
 		{
-			_settings->TargetNetAddressCount = 0;
+			_settings->DeviceCount = 0;
+			_settings->DeviceArraySize = 0;
 			goto out_fail;
 		}
 
-		for (index = 0; index < settings->TargetNetAddressCount; index++)
+		if (_settings->DeviceArraySize < _settings->DeviceCount)
 		{
-			_settings->TargetNetAddresses[index] = _strdup(settings->TargetNetAddresses[index]);
-
-			if (!_settings->TargetNetAddresses[index])
-			{
-				while (index)
-					free(_settings->TargetNetAddresses[--index]);
-
-				free(_settings->TargetNetAddresses);
-				_settings->TargetNetAddresses = NULL;
-				_settings->TargetNetAddressCount = 0;
-				goto out_fail;
-			}
+			_settings->DeviceCount = 0;
+			_settings->DeviceArraySize = 0;
+			goto out_fail;
 		}
 
-		if (settings->TargetNetPorts)
+		for (index = 0; index < _settings->DeviceCount; index++)
 		{
-			_settings->TargetNetPorts =
-			    (UINT32*)calloc(settings->TargetNetAddressCount, sizeof(UINT32));
+			_settings->DeviceArray[index] = freerdp_device_clone(settings->DeviceArray[index]);
 
-			if (!_settings->TargetNetPorts)
+			if (!_settings->DeviceArray[index])
 				goto out_fail;
-
-			for (index = 0; index < settings->TargetNetAddressCount; index++)
-				_settings->TargetNetPorts[index] = settings->TargetNetPorts[index];
 		}
-	}
-
-	_settings->DeviceCount = settings->DeviceCount;
-	_settings->DeviceArraySize = settings->DeviceArraySize;
-	_settings->DeviceArray =
-	    (RDPDR_DEVICE**)calloc(_settings->DeviceArraySize, sizeof(RDPDR_DEVICE*));
 
-	if (!_settings->DeviceArray && _settings->DeviceArraySize)
-	{
-		_settings->DeviceCount = 0;
-		_settings->DeviceArraySize = 0;
-		goto out_fail;
-	}
+		_settings->StaticChannelCount = settings->StaticChannelCount;
+		_settings->StaticChannelArraySize = settings->StaticChannelArraySize;
+		_settings->StaticChannelArray =
+		    (ADDIN_ARGV**)calloc(_settings->StaticChannelArraySize, sizeof(ADDIN_ARGV*));
 
-	if (_settings->DeviceArraySize < _settings->DeviceCount)
-	{
-		_settings->DeviceCount = 0;
-		_settings->DeviceArraySize = 0;
-		goto out_fail;
-	}
-
-	for (index = 0; index < _settings->DeviceCount; index++)
-	{
-		_settings->DeviceArray[index] = freerdp_device_clone(settings->DeviceArray[index]);
-
-		if (!_settings->DeviceArray[index])
+		if (!_settings->StaticChannelArray && _settings->StaticChannelArraySize)
+		{
+			_settings->StaticChannelArraySize = 0;
+			_settings->ChannelCount = 0;
 			goto out_fail;
-	}
+		}
 
-	_settings->StaticChannelCount = settings->StaticChannelCount;
-	_settings->StaticChannelArraySize = settings->StaticChannelArraySize;
-	_settings->StaticChannelArray =
-	    (ADDIN_ARGV**)calloc(_settings->StaticChannelArraySize, sizeof(ADDIN_ARGV*));
+		if (_settings->StaticChannelArraySize < _settings->StaticChannelCount)
+		{
+			_settings->StaticChannelArraySize = 0;
+			_settings->ChannelCount = 0;
+			goto out_fail;
+		}
 
-	if (!_settings->StaticChannelArray && _settings->StaticChannelArraySize)
-	{
-		_settings->StaticChannelArraySize = 0;
-		_settings->ChannelCount = 0;
-		goto out_fail;
-	}
+		for (index = 0; index < _settings->StaticChannelCount; index++)
+		{
+			_settings->StaticChannelArray[index] =
+			    freerdp_static_channel_clone(settings->StaticChannelArray[index]);
 
-	if (_settings->StaticChannelArraySize < _settings->StaticChannelCount)
-	{
-		_settings->StaticChannelArraySize = 0;
-		_settings->ChannelCount = 0;
-		goto out_fail;
-	}
+			if (!_settings->StaticChannelArray[index])
+				goto out_fail;
+		}
 
-	for (index = 0; index < _settings->StaticChannelCount; index++)
-	{
-		_settings->StaticChannelArray[index] =
-		    freerdp_static_channel_clone(settings->StaticChannelArray[index]);
+		_settings->DynamicChannelCount = settings->DynamicChannelCount;
+		_settings->DynamicChannelArraySize = settings->DynamicChannelArraySize;
+		_settings->DynamicChannelArray =
+		    (ADDIN_ARGV**)calloc(_settings->DynamicChannelArraySize, sizeof(ADDIN_ARGV*));
 
-		if (!_settings->StaticChannelArray[index])
+		if (!_settings->DynamicChannelArray && _settings->DynamicChannelArraySize)
+		{
+			_settings->DynamicChannelCount = 0;
+			_settings->DynamicChannelArraySize = 0;
 			goto out_fail;
-	}
+		}
 
-	_settings->DynamicChannelCount = settings->DynamicChannelCount;
-	_settings->DynamicChannelArraySize = settings->DynamicChannelArraySize;
-	_settings->DynamicChannelArray =
-	    (ADDIN_ARGV**)calloc(_settings->DynamicChannelArraySize, sizeof(ADDIN_ARGV*));
+		if (_settings->DynamicChannelArraySize < _settings->DynamicChannelCount)
+		{
+			_settings->DynamicChannelCount = 0;
+			_settings->DynamicChannelArraySize = 0;
+			goto out_fail;
+		}
 
-	if (!_settings->DynamicChannelArray && _settings->DynamicChannelArraySize)
-	{
-		_settings->DynamicChannelCount = 0;
-		_settings->DynamicChannelArraySize = 0;
-		goto out_fail;
-	}
+		for (index = 0; index < _settings->DynamicChannelCount; index++)
+		{
+			_settings->DynamicChannelArray[index] =
+			    freerdp_dynamic_channel_clone(settings->DynamicChannelArray[index]);
 
-	if (_settings->DynamicChannelArraySize < _settings->DynamicChannelCount)
-	{
-		_settings->DynamicChannelCount = 0;
-		_settings->DynamicChannelArraySize = 0;
-		goto out_fail;
-	}
+			if (!_settings->DynamicChannelArray[index])
+				goto out_fail;
+		}
 
-	for (index = 0; index < _settings->DynamicChannelCount; index++)
-	{
-		_settings->DynamicChannelArray[index] =
-		    freerdp_dynamic_channel_clone(settings->DynamicChannelArray[index]);
+		_settings->SettingsModified = (BYTE*)calloc(1, sizeof(rdpSettings) / 8);
 
-		if (!_settings->DynamicChannelArray[index])
+		if (!_settings->SettingsModified)
 			goto out_fail;
 	}
 
-	_settings->SettingsModified = (BYTE*)calloc(1, sizeof(rdpSettings) / 8);
-
-	if (!_settings->SettingsModified)
-		goto out_fail;
-
-	return TRUE;
-out_fail:
-	freerdp_settings_free_internal(_settings);
-	return FALSE;
-}
-
-rdpSettings* freerdp_settings_clone(const rdpSettings* settings)
-{
-	rdpSettings* _settings = (rdpSettings*)calloc(1, sizeof(rdpSettings));
-
-	if (!freerdp_settings_copy(_settings, settings))
-		goto out_fail;
-
 	return _settings;
 out_fail:
 	/* In case any memory allocation failed during clone, some bytes might leak.
@@ -1121,6 +1020,118 @@
 	free(_settings);
 	return NULL;
 }
+
+void freerdp_settings_free(rdpSettings* settings)
+{
+	if (!settings)
+		return;
+
+	free(settings->ServerHostname);
+	free(settings->Username);
+	free(settings->Password);
+	free(settings->Domain);
+	free(settings->PasswordHash);
+	free(settings->AcceptedCert);
+	free(settings->AlternateShell);
+	free(settings->ShellWorkingDirectory);
+	free(settings->ComputerName);
+	free(settings->ChannelDefArray);
+	free(settings->MonitorDefArray);
+	free(settings->MonitorIds);
+	free(settings->ClientAddress);
+	free(settings->ClientDir);
+	free(settings->AllowedTlsCiphers);
+	free(settings->NtlmSamFile);
+	free(settings->CertificateFile);
+	free(settings->PrivateKeyFile);
+	free(settings->ConnectionFile);
+	free(settings->AssistanceFile);
+	free(settings->ReceivedCapabilities);
+	free(settings->OrderSupport);
+	free(settings->ClientHostname);
+	free(settings->ClientProductId);
+	free(settings->ServerRandom);
+	free(settings->ClientRandom);
+	free(settings->ServerCertificate);
+	free(settings->RdpKeyFile);
+	certificate_free(settings->RdpServerCertificate);
+	free(settings->CertificateContent);
+	free(settings->PrivateKeyContent);
+	free(settings->RdpKeyContent);
+	free(settings->ClientAutoReconnectCookie);
+	free(settings->ServerAutoReconnectCookie);
+	free(settings->ClientTimeZone);
+	free(settings->BitmapCacheV2CellInfo);
+	free(settings->GlyphCache);
+	free(settings->FragCache);
+	key_free(settings->RdpServerRsaKey);
+	free(settings->ConfigPath);
+	free(settings->CurrentPath);
+	free(settings->HomePath);
+	free(settings->LoadBalanceInfo);
+	free(settings->TargetNetAddress);
+	free(settings->RedirectionTargetFQDN);
+	free(settings->RedirectionTargetNetBiosName);
+	free(settings->RedirectionUsername);
+	free(settings->RedirectionDomain);
+	free(settings->RedirectionPassword);
+	free(settings->RedirectionTsvUrl);
+	free(settings->RedirectionAcceptedCert);
+	free(settings->Pkcs11Module);
+	free(settings->Pin);
+	free(settings->CardName);
+	free(settings->ReaderName);
+	free(settings->ContainerName);
+	free(settings->CspName);
+	free(settings->UserHint);
+	free(settings->DomainHint);
+	free(settings->UserPrincipalName);
+	free(settings->CanonicalizedUserHint);
+	free(settings->IdCertificate);
+	free(settings->PkinitIdentity);
+	free(settings->PkinitAnchors);
+	free(settings->KerberosStartTime);
+	free(settings->KerberosLifeTime);
+	free(settings->KerberosRenewableLifeTime);
+	free(settings->TokenLabel);
+	free(settings->PkinitCertificate);
+	free(settings->RemoteAssistanceSessionId);
+	free(settings->RemoteAssistancePassword);
+	free(settings->RemoteAssistancePassStub);
+	free(settings->RemoteAssistanceRCTicket);
+	free(settings->AuthenticationServiceClass);
+	free(settings->GatewayHostname);
+	free(settings->GatewayUsername);
+	free(settings->GatewayPassword);
+	free(settings->GatewayDomain);
+	free(settings->GatewayAccessToken);
+	free(settings->GatewayAcceptedCert);
+	free(settings->CertificateName);
+	free(settings->DynamicDSTTimeZoneKeyName);
+	free(settings->PreconnectionBlob);
+	free(settings->KerberosKdc);
+	free(settings->KerberosRealm);
+	free(settings->DumpRemoteFxFile);
+	free(settings->PlayRemoteFxFile);
+	free(settings->RemoteApplicationName);
+	free(settings->RemoteApplicationIcon);
+	free(settings->RemoteApplicationProgram);
+	free(settings->RemoteApplicationFile);
+	free(settings->RemoteApplicationGuid);
+	free(settings->RemoteApplicationCmdLine);
+	free(settings->ImeFileName);
+	free(settings->DrivesToRedirect);
+	free(settings->WindowTitle);
+	free(settings->WmClass);
+	free(settings->ActionScript);
+	freerdp_target_net_addresses_free(settings);
+	freerdp_device_collection_free(settings);
+	freerdp_static_channel_collection_free(settings);
+	freerdp_dynamic_channel_collection_free(settings);
+	free(settings->SettingsModified);
+	free(settings);
+}
+
 #ifdef _WIN32
 #	pragma warning(pop)
 #endif
diff -urN libfreerdp/core/smartcardlogon.c ../../informatimago/FreeRDP/libfreerdp/core/smartcardlogon.c
--- libfreerdp/core/smartcardlogon.c	1970-01-01 03:00:00.000000000 +0300
+++ ../../informatimago/FreeRDP/libfreerdp/core/smartcardlogon.c	2019-07-25 20:11:28.047983079 +0300
@@ -0,0 +1,59 @@
+#ifdef WITH_PKCS11H
+
+#	include <freerdp/log.h>
+#	include <freerdp/settings.h>
+
+#	include "../scquery/scquery.h"
+#	include "../scquery/scquery_error.h"
+
+#	define TAG CLIENT_TAG("smartcardlogon")
+#	define ORNIL(x) ((x) ? (x) : "(nil)")
+
+static void copy_string(char** old_string, char* new_string)
+{
+	free(*old_string);
+	(*old_string) = NULL;
+
+	if (new_string != NULL)
+	{
+		(*old_string) = check_memory(strdup(new_string), strlen(new_string));
+	}
+}
+
+int get_info_smartcard(rdpSettings* settings)
+{
+	scquery_result identity = NULL;
+
+	if (settings->Pkcs11Module == NULL)
+	{
+		WLog_ERR(TAG, "Missing /pkcs11module");
+		return -1;
+	}
+
+	identity = scquery_X509_user_identities(settings->Pkcs11Module, settings->ReaderName,
+	                                        settings->CardName, settings->Krb5Trace);
+
+	if (identity == NULL)
+	{
+		WLog_ERR(TAG, "Could not get an identity from the smartcard %s (reader %s)",
+		         ORNIL(settings->CardName), ORNIL(settings->ReaderName));
+		return -1;
+	}
+
+	copy_string(&settings->CardName, identity->certificate->token_label);
+	copy_string(&settings->ReaderName, identity->certificate->slot_description);
+	copy_string(&settings->UserPrincipalName, identity->upn);
+	copy_string(&settings->PkinitIdentity, identity->X509_user_identity);
+	copy_string(&settings->TokenLabel, identity->certificate->token_label);
+	copy_string(&settings->IdCertificate, identity->certificate->id);
+	settings->SlotID = identity->certificate->slot_id;
+	settings->IdCertificateLength = strlen(identity->certificate->id);
+	settings->PinPadIsPresent = identity->certificate->protected_authentication_path;
+	WLog_INFO(TAG, "Got identity from the smartcard %s (reader %s): %s (UPN = %s)",
+	          ORNIL(settings->CardName), ORNIL(settings->ReaderName), identity->X509_user_identity,
+	          identity->upn);
+	scquery_result_free(identity);
+	return 0;
+}
+
+#endif
diff -urN libfreerdp/core/smartcardlogon.h ../../informatimago/FreeRDP/libfreerdp/core/smartcardlogon.h
--- libfreerdp/core/smartcardlogon.h	1970-01-01 03:00:00.000000000 +0300
+++ ../../informatimago/FreeRDP/libfreerdp/core/smartcardlogon.h	2019-07-19 20:00:34.129156365 +0300
@@ -0,0 +1,7 @@
+#ifndef LIBFREERDP_CORE_SMARTCARDLOGON_H
+#define LIBFREERDP_CORE_SMARTCARDLOGON_H
+#include <freerdp/settings.h>
+
+int get_info_smartcard(rdpSettings* settings);
+
+#endif
diff -urN libfreerdp/core/tcp.c ../../informatimago/FreeRDP/libfreerdp/core/tcp.c
--- libfreerdp/core/tcp.c	2019-07-25 19:51:04.145913706 +0300
+++ ../../informatimago/FreeRDP/libfreerdp/core/tcp.c	2019-07-25 20:11:28.087983276 +0300
@@ -811,7 +811,7 @@
 	int status = 0;
 	int count = 0;
 	u_long arg = 0;
-	DWORD tout = (timeout > 0) ? (DWORD)timeout * 1000U : INFINITE;
+	DWORD tout = (timeout) ? timeout * 1000 : INFINITE;
 	handles[count] = CreateEvent(NULL, TRUE, FALSE, NULL);
 
 	if (!handles[count])
diff -urN libfreerdp/core/test/CMakeLists.txt ../../informatimago/FreeRDP/libfreerdp/core/test/CMakeLists.txt
--- libfreerdp/core/test/CMakeLists.txt	2019-07-24 06:11:52.482197637 +0300
+++ ../../informatimago/FreeRDP/libfreerdp/core/test/CMakeLists.txt	2019-07-19 20:00:34.129156365 +0300
@@ -6,7 +6,8 @@
 
 set(${MODULE_PREFIX}_TESTS
 	TestVersion.c
-	TestSettings.c)
+	TestSettings.c
+    TestTSCredentials.c)
 
 if(WITH_SAMPLE AND WITH_SERVER)
 	set(${MODULE_PREFIX}_TESTS
diff -urN libfreerdp/core/test/settings_property_lists.h ../../informatimago/FreeRDP/libfreerdp/core/test/settings_property_lists.h
--- libfreerdp/core/test/settings_property_lists.h	2019-07-25 19:51:04.165913805 +0300
+++ ../../informatimago/FreeRDP/libfreerdp/core/test/settings_property_lists.h	1970-01-01 03:00:00.000000000 +0300
@@ -1,395 +0,0 @@
-#ifndef TEST_SETTINGS_PROPERTY_LISTS
-#define TEST_SETTINGS_PROPERTY_LISTS
-
-#define have_bool_list_indices
-static const size_t bool_list_indices[] = {
-	FreeRDP_ServerMode,
-	FreeRDP_WaitForOutputBufferFlush,
-	FreeRDP_NetworkAutoDetect,
-	FreeRDP_SupportAsymetricKeys,
-	FreeRDP_SupportErrorInfoPdu,
-	FreeRDP_SupportStatusInfoPdu,
-	FreeRDP_SupportMonitorLayoutPdu,
-	FreeRDP_SupportGraphicsPipeline,
-	FreeRDP_SupportDynamicTimeZone,
-	FreeRDP_SupportHeartbeatPdu,
-	FreeRDP_UseRdpSecurityLayer,
-	FreeRDP_ConsoleSession,
-	FreeRDP_SpanMonitors,
-	FreeRDP_UseMultimon,
-	FreeRDP_ForceMultimon,
-	FreeRDP_ListMonitors,
-	FreeRDP_HasMonitorAttributes,
-	FreeRDP_SupportMultitransport,
-	FreeRDP_AutoLogonEnabled,
-	FreeRDP_CompressionEnabled,
-	FreeRDP_DisableCtrlAltDel,
-	FreeRDP_EnableWindowsKey,
-	FreeRDP_MaximizeShell,
-	FreeRDP_LogonNotify,
-	FreeRDP_LogonErrors,
-	FreeRDP_MouseAttached,
-	FreeRDP_MouseHasWheel,
-	FreeRDP_RemoteConsoleAudio,
-	FreeRDP_AudioPlayback,
-	FreeRDP_AudioCapture,
-	FreeRDP_VideoDisable,
-	FreeRDP_PasswordIsSmartcardPin,
-	FreeRDP_UsingSavedCredentials,
-	FreeRDP_ForceEncryptedCsPdu,
-	FreeRDP_HiDefRemoteApp,
-	FreeRDP_IPv6Enabled,
-	FreeRDP_AutoReconnectionEnabled,
-	FreeRDP_PrintReconnectCookie,
-	FreeRDP_DynamicDaylightTimeDisabled,
-	FreeRDP_AllowFontSmoothing,
-	FreeRDP_DisableWallpaper,
-	FreeRDP_DisableFullWindowDrag,
-	FreeRDP_DisableMenuAnims,
-	FreeRDP_DisableThemes,
-	FreeRDP_DisableCursorShadow,
-	FreeRDP_DisableCursorBlinking,
-	FreeRDP_AllowDesktopComposition,
-	FreeRDP_RemoteAssistanceMode,
-	FreeRDP_EncomspVirtualChannel,
-	FreeRDP_RemdeskVirtualChannel,
-	FreeRDP_LyncRdpMode,
-	FreeRDP_TlsSecurity,
-	FreeRDP_NlaSecurity,
-	FreeRDP_RdpSecurity,
-	FreeRDP_ExtSecurity,
-	FreeRDP_Authentication,
-	FreeRDP_NegotiateSecurityLayer,
-	FreeRDP_RestrictedAdminModeRequired,
-	FreeRDP_DisableCredentialsDelegation,
-	FreeRDP_VmConnectMode,
-	FreeRDP_FIPSMode,
-	FreeRDP_MstscCookieMode,
-	FreeRDP_SendPreconnectionPdu,
-	FreeRDP_SmartcardLogon,
-	FreeRDP_PromptForCredentials,
-	FreeRDP_IgnoreCertificate,
-	FreeRDP_ExternalCertificateManagement,
-	FreeRDP_AutoAcceptCertificate,
-	FreeRDP_AutoDenyCertificate,
-	FreeRDP_Workarea,
-	FreeRDP_Fullscreen,
-	FreeRDP_GrabKeyboard,
-	FreeRDP_Decorations,
-	FreeRDP_MouseMotion,
-	FreeRDP_AsyncInput,
-	FreeRDP_AsyncUpdate,
-	FreeRDP_AsyncChannels,
-	FreeRDP_ToggleFullscreen,
-	FreeRDP_EmbeddedWindow,
-	FreeRDP_SmartSizing,
-	FreeRDP_PercentScreenUseWidth,
-	FreeRDP_PercentScreenUseHeight,
-	FreeRDP_DynamicResolutionUpdate,
-	FreeRDP_SoftwareGdi,
-	FreeRDP_LocalConnection,
-	FreeRDP_AuthenticationOnly,
-	FreeRDP_CredentialsFromStdin,
-	FreeRDP_UnmapButtons,
-	FreeRDP_OldLicenseBehaviour,
-	FreeRDP_DumpRemoteFx,
-	FreeRDP_PlayRemoteFx,
-	FreeRDP_GatewayUseSameCredentials,
-	FreeRDP_GatewayEnabled,
-	FreeRDP_GatewayBypassLocal,
-	FreeRDP_GatewayRpcTransport,
-	FreeRDP_GatewayHttpTransport,
-	FreeRDP_GatewayUdpTransport,
-	FreeRDP_RemoteApplicationMode,
-	FreeRDP_DisableRemoteAppCapsCheck,
-	FreeRDP_RemoteAppLanguageBarSupported,
-	FreeRDP_RefreshRect,
-	FreeRDP_SuppressOutput,
-	FreeRDP_FastPathOutput,
-	FreeRDP_SaltedChecksum,
-	FreeRDP_LongCredentialsSupported,
-	FreeRDP_NoBitmapCompressionHeader,
-	FreeRDP_BitmapCompressionDisabled,
-	FreeRDP_DesktopResize,
-	FreeRDP_DrawAllowDynamicColorFidelity,
-	FreeRDP_DrawAllowColorSubsampling,
-	FreeRDP_DrawAllowSkipAlpha,
-	FreeRDP_BitmapCacheV3Enabled,
-	FreeRDP_AltSecFrameMarkerSupport,
-	FreeRDP_AllowUnanouncedOrdersFromServer,
-	FreeRDP_BitmapCacheEnabled,
-	FreeRDP_AllowCacheWaitingList,
-	FreeRDP_BitmapCachePersistEnabled,
-	FreeRDP_ColorPointerFlag,
-	FreeRDP_UnicodeInput,
-	FreeRDP_FastPathInput,
-	FreeRDP_MultiTouchInput,
-	FreeRDP_MultiTouchGestures,
-	FreeRDP_HasHorizontalWheel,
-	FreeRDP_HasExtendedMouseEvent,
-	FreeRDP_SoundBeepsEnabled,
-	FreeRDP_SurfaceCommandsEnabled,
-	FreeRDP_FrameMarkerCommandEnabled,
-	FreeRDP_SurfaceFrameMarkerEnabled,
-	FreeRDP_RemoteFxOnly,
-	FreeRDP_RemoteFxCodec,
-	FreeRDP_RemoteFxImageCodec,
-	FreeRDP_NSCodec,
-	FreeRDP_NSCodecAllowSubsampling,
-	FreeRDP_NSCodecAllowDynamicColorFidelity,
-	FreeRDP_JpegCodec,
-	FreeRDP_GfxThinClient,
-	FreeRDP_GfxSmallCache,
-	FreeRDP_GfxProgressive,
-	FreeRDP_GfxProgressiveV2,
-	FreeRDP_GfxH264,
-	FreeRDP_GfxAVC444,
-	FreeRDP_GfxSendQoeAck,
-	FreeRDP_GfxAVC444v2,
-	FreeRDP_DrawNineGridEnabled,
-	FreeRDP_DrawGdiPlusEnabled,
-	FreeRDP_DrawGdiPlusCacheEnabled,
-	FreeRDP_DeviceRedirection,
-	FreeRDP_RedirectDrives,
-	FreeRDP_RedirectHomeDrive,
-	FreeRDP_RedirectSmartCards,
-	FreeRDP_RedirectPrinters,
-	FreeRDP_RedirectSerialPorts,
-	FreeRDP_RedirectParallelPorts,
-	FreeRDP_PreferIPv6OverIPv4,
-	FreeRDP_RedirectClipboard,
-	FreeRDP_SupportDynamicChannels,
-	FreeRDP_SupportEchoChannel,
-	FreeRDP_SupportDisplayControl,
-	FreeRDP_SupportGeometryTracking,
-	FreeRDP_SupportSSHAgentChannel,
-	FreeRDP_SupportVideoOptimized,
-};
-
-#define have_uint16_list_indices
-static const size_t uint16_list_indices[] = {
-	FreeRDP_DesktopOrientation,
-	FreeRDP_ProxyPort,
-};
-
-#define have_uint32_list_indices
-static const size_t uint32_list_indices[] = {
-	FreeRDP_ShareId,
-	FreeRDP_PduSource,
-	FreeRDP_ServerPort,
-	FreeRDP_MaxTimeInCheckLoop,
-	FreeRDP_AcceptedCertLength,
-	FreeRDP_RdpVersion,
-	FreeRDP_DesktopWidth,
-	FreeRDP_DesktopHeight,
-	FreeRDP_ColorDepth,
-	FreeRDP_ConnectionType,
-	FreeRDP_ClientBuild,
-	FreeRDP_EarlyCapabilityFlags,
-	FreeRDP_DesktopPhysicalWidth,
-	FreeRDP_DesktopPhysicalHeight,
-	FreeRDP_DesktopScaleFactor,
-	FreeRDP_DeviceScaleFactor,
-	FreeRDP_EncryptionMethods,
-	FreeRDP_ExtEncryptionMethods,
-	FreeRDP_EncryptionLevel,
-	FreeRDP_ServerRandomLength,
-	FreeRDP_ServerCertificateLength,
-	FreeRDP_ClientRandomLength,
-	FreeRDP_ChannelCount,
-	FreeRDP_ChannelDefArraySize,
-	FreeRDP_ClusterInfoFlags,
-	FreeRDP_RedirectedSessionId,
-	FreeRDP_MonitorCount,
-	FreeRDP_MonitorDefArraySize,
-	FreeRDP_DesktopPosX,
-	FreeRDP_DesktopPosY,
-	FreeRDP_NumMonitorIds,
-	FreeRDP_MonitorLocalShiftX,
-	FreeRDP_MonitorLocalShiftY,
-	FreeRDP_MultitransportFlags,
-	FreeRDP_CompressionLevel,
-	FreeRDP_AutoReconnectMaxRetries,
-	FreeRDP_PerformanceFlags,
-	FreeRDP_RequestedProtocols,
-	FreeRDP_SelectedProtocol,
-	FreeRDP_NegotiationFlags,
-	FreeRDP_AuthenticationLevel,
-	FreeRDP_TlsSecLevel,
-	FreeRDP_CookieMaxLength,
-	FreeRDP_PreconnectionId,
-	FreeRDP_RedirectionFlags,
-	FreeRDP_LoadBalanceInfoLength,
-	FreeRDP_RedirectionPasswordLength,
-	FreeRDP_RedirectionTsvUrlLength,
-	FreeRDP_TargetNetAddressCount,
-	FreeRDP_RedirectionAcceptedCertLength,
-	FreeRDP_RedirectionPreferType,
-	FreeRDP_Password51Length,
-	FreeRDP_PercentScreen,
-	FreeRDP_SmartSizingWidth,
-	FreeRDP_SmartSizingHeight,
-	FreeRDP_GatewayUsageMethod,
-	FreeRDP_GatewayPort,
-	FreeRDP_GatewayCredentialsSource,
-	FreeRDP_GatewayAcceptedCertLength,
-	FreeRDP_ProxyType,
-	FreeRDP_RemoteApplicationExpandCmdLine,
-	FreeRDP_RemoteApplicationExpandWorkingDir,
-	FreeRDP_RemoteAppNumIconCaches,
-	FreeRDP_RemoteAppNumIconCacheEntries,
-	FreeRDP_RemoteWndSupportLevel,
-	FreeRDP_RemoteApplicationSupportLevel,
-	FreeRDP_RemoteApplicationSupportMask,
-	FreeRDP_ReceivedCapabilitiesSize,
-	FreeRDP_OsMajorType,
-	FreeRDP_OsMinorType,
-	FreeRDP_BitmapCacheVersion,
-	FreeRDP_BitmapCacheV2NumCells,
-	FreeRDP_PointerCacheSize,
-	FreeRDP_KeyboardLayout,
-	FreeRDP_KeyboardType,
-	FreeRDP_KeyboardSubType,
-	FreeRDP_KeyboardFunctionKey,
-	FreeRDP_KeyboardHook,
-	FreeRDP_BrushSupportLevel,
-	FreeRDP_GlyphSupportLevel,
-	FreeRDP_OffscreenSupportLevel,
-	FreeRDP_OffscreenCacheSize,
-	FreeRDP_OffscreenCacheEntries,
-	FreeRDP_VirtualChannelCompressionFlags,
-	FreeRDP_VirtualChannelChunkSize,
-	FreeRDP_MultifragMaxRequestSize,
-	FreeRDP_LargePointerFlag,
-	FreeRDP_CompDeskSupportLevel,
-	FreeRDP_RemoteFxCodecId,
-	FreeRDP_RemoteFxCodecMode,
-	FreeRDP_RemoteFxCaptureFlags,
-	FreeRDP_NSCodecId,
-	FreeRDP_FrameAcknowledge,
-	FreeRDP_NSCodecColorLossLevel,
-	FreeRDP_JpegCodecId,
-	FreeRDP_JpegQuality,
-	FreeRDP_GfxCapsFilter,
-	FreeRDP_BitmapCacheV3CodecId,
-	FreeRDP_DrawNineGridCacheSize,
-	FreeRDP_DrawNineGridCacheEntries,
-	FreeRDP_DeviceCount,
-	FreeRDP_DeviceArraySize,
-	FreeRDP_StaticChannelCount,
-	FreeRDP_StaticChannelArraySize,
-	FreeRDP_DynamicChannelCount,
-	FreeRDP_DynamicChannelArraySize,
-};
-
-#define have_int32_list_indices
-static const size_t int32_list_indices[] = {
-	FreeRDP_XPan,
-	FreeRDP_YPan,
-};
-
-#define have_uint64_list_indices
-static const size_t uint64_list_indices[] = {
-	FreeRDP_ParentWindowId,
-};
-
-#define have_string_list_indices
-static const size_t string_list_indices[] = {
-	FreeRDP_ServerHostname,
-	FreeRDP_Username,
-	FreeRDP_Password,
-	FreeRDP_Domain,
-	FreeRDP_PasswordHash,
-	FreeRDP_AcceptedCert,
-	FreeRDP_ClientHostname,
-	FreeRDP_ClientProductId,
-	FreeRDP_AlternateShell,
-	FreeRDP_ShellWorkingDirectory,
-	FreeRDP_ClientAddress,
-	FreeRDP_ClientDir,
-	FreeRDP_DynamicDSTTimeZoneKeyName,
-	FreeRDP_RemoteAssistanceSessionId,
-	FreeRDP_RemoteAssistancePassStub,
-	FreeRDP_RemoteAssistancePassword,
-	FreeRDP_RemoteAssistanceRCTicket,
-	FreeRDP_AuthenticationServiceClass,
-	FreeRDP_AllowedTlsCiphers,
-	FreeRDP_NtlmSamFile,
-	FreeRDP_PreconnectionBlob,
-	FreeRDP_TargetNetAddress,
-	FreeRDP_RedirectionUsername,
-	FreeRDP_RedirectionDomain,
-	FreeRDP_RedirectionTargetFQDN,
-	FreeRDP_RedirectionTargetNetBiosName,
-	FreeRDP_RedirectionAcceptedCert,
-	FreeRDP_KerberosKdc,
-	FreeRDP_KerberosRealm,
-	FreeRDP_CertificateName,
-	FreeRDP_CertificateFile,
-	FreeRDP_PrivateKeyFile,
-	FreeRDP_RdpKeyFile,
-	FreeRDP_CertificateContent,
-	FreeRDP_PrivateKeyContent,
-	FreeRDP_RdpKeyContent,
-	FreeRDP_WindowTitle,
-	FreeRDP_WmClass,
-	FreeRDP_ComputerName,
-	FreeRDP_ConnectionFile,
-	FreeRDP_AssistanceFile,
-	FreeRDP_HomePath,
-	FreeRDP_ConfigPath,
-	FreeRDP_CurrentPath,
-	FreeRDP_DumpRemoteFxFile,
-	FreeRDP_PlayRemoteFxFile,
-	FreeRDP_GatewayHostname,
-	FreeRDP_GatewayUsername,
-	FreeRDP_GatewayPassword,
-	FreeRDP_GatewayDomain,
-	FreeRDP_GatewayAccessToken,
-	FreeRDP_GatewayAcceptedCert,
-	FreeRDP_ProxyHostname,
-	FreeRDP_ProxyUsername,
-	FreeRDP_ProxyPassword,
-	FreeRDP_RemoteApplicationName,
-	FreeRDP_RemoteApplicationIcon,
-	FreeRDP_RemoteApplicationProgram,
-	FreeRDP_RemoteApplicationFile,
-	FreeRDP_RemoteApplicationGuid,
-	FreeRDP_RemoteApplicationCmdLine,
-	FreeRDP_RemoteApplicationWorkingDir,
-	FreeRDP_ImeFileName,
-	FreeRDP_DrivesToRedirect,
-	FreeRDP_RDP2TCPArgs,
-};
-
-#define have_pointer_list_indices
-static const size_t pointer_list_indices[] = {
-	FreeRDP_StaticChannelArray,
-	FreeRDP_DynamicChannelArray,
-	FreeRDP_instance,
-	FreeRDP_RdpServerCertificate,
-	FreeRDP_MonitorIds,
-	FreeRDP_TargetNetPorts,
-	FreeRDP_DeviceArray,
-	FreeRDP_ClientAutoReconnectCookie,
-	FreeRDP_TargetNetAddresses,
-	FreeRDP_MonitorDefArray,
-	FreeRDP_BitmapCacheV2CellInfo,
-	FreeRDP_ServerAutoReconnectCookie,
-	FreeRDP_ServerRandom,
-	FreeRDP_ServerCertificate,
-	FreeRDP_ClientRandom,
-	FreeRDP_LoadBalanceInfo,
-	FreeRDP_RedirectionPassword,
-	FreeRDP_RedirectionTsvUrl,
-	FreeRDP_Password51,
-	FreeRDP_ReceivedCapabilities,
-	FreeRDP_OrderSupport,
-	FreeRDP_RdpServerRsaKey,
-	FreeRDP_GlyphCache,
-	FreeRDP_FragCache,
-	FreeRDP_ClientTimeZone,
-	FreeRDP_ChannelDefArray,
-};
-
-#endif /* TEST_SETTINGS_PROPERTY_LISTS */
diff -urN libfreerdp/core/test/TestConnect.c ../../informatimago/FreeRDP/libfreerdp/core/test/TestConnect.c
--- libfreerdp/core/test/TestConnect.c	2019-07-25 19:51:04.153913745 +0300
+++ ../../informatimago/FreeRDP/libfreerdp/core/test/TestConnect.c	2019-07-25 20:11:28.091983297 +0300
@@ -159,85 +159,110 @@
 
 static int testSuccess(int port)
 {
-	int r;
-	int rc = -2;
+	int rc;
 	STARTUPINFOA si;
 	PROCESS_INFORMATION process;
 	char arg1[] = "/v:127.0.0.1:XXXXX";
 	char* clientArgs[] = { "test", "/v:127.0.0.1:XXXXX", "/cert-ignore", "/rfx", NULL };
-	char* commandLine = NULL;
+	char* commandLine;
 	int commandLineLen;
 	int argc = 4;
-	char* path = NULL;
-	char* wpath = NULL;
-	char* exe = GetCombinedPath(TESTING_OUTPUT_DIRECTORY, "server");
-	char* wexe = GetCombinedPath(TESTING_SRC_DIRECTORY, "server");
+	char* path = TESTING_OUTPUT_DIRECTORY;
+	char* wpath = TESTING_SRC_DIRECTORY;
+	char* exe = GetCombinedPath(path, "server");
+	char* wexe = GetCombinedPath(wpath, "server");
 	_snprintf(arg1, 18, "/v:127.0.0.1:%d", port);
 	clientArgs[1] = arg1;
 
 	if (!exe || !wexe)
-		goto fail;
+	{
+		free(exe);
+		free(wexe);
+		return -2;
+	}
 
 	path = GetCombinedPath(exe, "Sample");
 	wpath = GetCombinedPath(wexe, "Sample");
+	free(exe);
+	free(wexe);
 
 	if (!path || !wpath)
-		goto fail;
+	{
+		free(path);
+		free(wpath);
+		return -2;
+	}
 
 	exe = GetCombinedPath(path, "sfreerdp-server");
 
 	if (!exe)
-		goto fail;
+	{
+		free(path);
+		free(wpath);
+		return -2;
+	}
 
 	printf("Sample Server: %s\n", exe);
 	printf("Workspace: %s\n", wpath);
 
 	if (!PathFileExistsA(exe))
-		goto fail;
+	{
+		free(path);
+		free(wpath);
+		free(exe);
+		return -2;
+	}
 
 	// Start sample server locally.
 	commandLineLen = strlen(exe) + strlen("--local-only --port=XXXXX") + 1;
 	commandLine = malloc(commandLineLen);
 
 	if (!commandLine)
-		goto fail;
+	{
+		free(path);
+		free(wpath);
+		free(exe);
+		return -2;
+	}
 
 	_snprintf(commandLine, commandLineLen, "%s --local-only --port=%d", exe, port);
 	memset(&si, 0, sizeof(si));
 	si.cb = sizeof(si);
 
 	if (!CreateProcessA(exe, commandLine, NULL, NULL, FALSE, 0, NULL, wpath, &si, &process))
-		goto fail;
+	{
+		free(exe);
+		free(path);
+		free(wpath);
+		return -2;
+	}
 
+	free(exe);
+	free(path);
+	free(wpath);
+	free(commandLine);
 	Sleep(1 * 1000); /* let the server start */
-	r = runInstance(argc, clientArgs, NULL);
+	rc = runInstance(argc, clientArgs, NULL);
 
 	if (!TerminateProcess(process.hProcess, 0))
-		goto fail;
+		return -2;
 
 	WaitForSingleObject(process.hProcess, INFINITE);
 	CloseHandle(process.hProcess);
 	CloseHandle(process.hThread);
-	printf("%s: returned %d!\n", __FUNCTION__, r);
-	rc = r;
+	printf("%s: returned %d!\n", __FUNCTION__, rc);
 
-	if (rc == 0)
-		printf("%s: Success!\n", __FUNCTION__);
+	if (rc)
+		return -1;
 
-fail:
-	free(exe);
-	free(path);
-	free(wpath);
-	free(commandLine);
-	return rc;
+	printf("%s: Success!\n", __FUNCTION__);
+	return 0;
 }
 
 int TestConnect(int argc, char* argv[])
 {
 	int randomPort;
 	int random;
-	WINPR_UNUSED(argc);
-	WINPR_UNUSED(argv);
 	winpr_RAND((BYTE*)&random, sizeof(random));
 	randomPort = 3389 + (random % 200);
 
diff -urN libfreerdp/core/test/TestCore.c ../../informatimago/FreeRDP/libfreerdp/core/test/TestCore.c
--- libfreerdp/core/test/TestCore.c	2019-07-25 20:17:16.453710809 +0300
+++ ../../informatimago/FreeRDP/libfreerdp/core/test/TestCore.c	2019-07-25 20:11:28.095983317 +0300
@@ -4,144 +4,151 @@
 #include <string.h> /* NOLINT */
 
 #if defined(_MSC_VER)
-#pragma warning(disable : 4996) /* deprecation */
+#	pragma warning(disable : 4996) /* deprecation */
 #endif
 
-
-
 /* Forward declare test functions. */
 int TestVersion(int, char*[]);
 int TestSettings(int, char*[]);
-
+int TestTSCredentials(int, char*[]);
 
 #ifdef __cplusplus
-#define CM_CAST(TYPE, EXPR) static_cast<TYPE>(EXPR)
+#	define CM_CAST(TYPE, EXPR) static_cast<TYPE>(EXPR)
 #else
-#define CM_CAST(TYPE, EXPR) (TYPE)(EXPR)
+#	define CM_CAST(TYPE, EXPR) (TYPE)(EXPR)
 #endif
 
 /* Create map.  */
 
-typedef int (*MainFuncPointer)(int, char* []); /* NOLINT */
-typedef struct /* NOLINT */
+typedef int (*MainFuncPointer)(int, char*[]); /* NOLINT */
+typedef struct                                /* NOLINT */
 {
-  const char* name;
-  MainFuncPointer func;
+	const char* name;
+	MainFuncPointer func;
 } functionMapEntry;
 
 static functionMapEntry cmakeGeneratedFunctionMapEntries[] = {
-    {
-    "TestVersion",
-    TestVersion
-  },
-  {
-    "TestSettings",
-    TestSettings
-  },
+	{ "TestVersion", TestVersion },
+	{ "TestSettings", TestSettings },
+	{ "TestTSCredentials", TestTSCredentials },
 
-  { NULL, NULL } /* NOLINT */
+	{ NULL, NULL } /* NOLINT */
 };
 
-static const int NumTests = CM_CAST(int,
-  sizeof(cmakeGeneratedFunctionMapEntries) / sizeof(functionMapEntry)) - 1;
+static const int NumTests =
+    CM_CAST(int, sizeof(cmakeGeneratedFunctionMapEntries) / sizeof(functionMapEntry)) - 1;
 
 /* Allocate and create a lowercased copy of string
    (note that it has to be free'd manually) */
 static char* lowercase(const char* string)
 {
-  char *new_string, *p;
-  size_t stringSize;
+	char *new_string, *p;
+	size_t stringSize;
 
-  stringSize = CM_CAST(size_t, strlen(string) + 1);
-  new_string = CM_CAST(char*, malloc(sizeof(char) * stringSize));
+	stringSize = CM_CAST(size_t, strlen(string) + 1);
+	new_string = CM_CAST(char*, malloc(sizeof(char) * stringSize));
 
-  if (new_string == NULL) { /* NOLINT */
-    return NULL;            /* NOLINT */
-  }
-  strcpy(new_string, string);
-  for (p = new_string; *p != 0; ++p) {
-    *p = CM_CAST(char, tolower(*p));
-  }
-  return new_string;
+	if (new_string == NULL)
+	{                /* NOLINT */
+		return NULL; /* NOLINT */
+	}
+	strcpy(new_string, string);
+	for (p = new_string; *p != 0; ++p)
+	{
+		*p = CM_CAST(char, tolower(*p));
+	}
+	return new_string;
 }
 
 int main(int ac, char* av[])
 {
-  int i, testNum = 0, partial_match;
-  char *arg;
-  int testToRun = -1;
-
-  
-
-  /* If no test name was given */
-  /* process command line with user function.  */
-  if (ac < 2) {
-    /* Ask for a test.  */
-    printf("Available tests:\n");
-    for (i = 0; i < NumTests; ++i) {
-      printf("%3d. %s\n", i, cmakeGeneratedFunctionMapEntries[i].name);
-    }
-    printf("To run a test, enter the test number: ");
-    fflush(stdout);
-    if (scanf("%d", &testNum) != 1) {
-      printf("Couldn't parse that input as a number\n");
-      return -1;
-    }
-    if (testNum >= NumTests) {
-      printf("%3d is an invalid test number.\n", testNum);
-      return -1;
-    }
-    testToRun = testNum;
-    ac--;
-    av++;
-  }
-  partial_match = 0;
-  arg = NULL; /* NOLINT */
-  /* If partial match is requested.  */
-  if (testToRun == -1 && ac > 1) {
-    partial_match = (strcmp(av[1], "-R") == 0) ? 1 : 0;
-  }
-  if (partial_match != 0 && ac < 3) {
-    printf("-R needs an additional parameter.\n");
-    return -1;
-  }
-  if (testToRun == -1) {
-    arg = lowercase(av[1 + partial_match]);
-  }
-  for (i = 0; i < NumTests && testToRun == -1; ++i) {
-    char *test_name = lowercase(cmakeGeneratedFunctionMapEntries[i].name);
-    if (partial_match != 0 && strstr(test_name, arg) != NULL) { /* NOLINT */
-      testToRun = i;
-      ac -= 2;
-      av += 2;
-    } else if (partial_match == 0 && strcmp(test_name, arg) == 0) {
-      testToRun = i;
-      ac--;
-      av++;
-    }
-    free(test_name);
-  }
-  free(arg);
-  if (testToRun != -1) {
-    int result;
-
-    if (testToRun < 0 || testToRun >= NumTests) {
-      printf("testToRun was modified by TestDriver code to an invalid value: "
-             "%3d.\n",
-             testNum);
-      return -1;
-    }
-    result = (*cmakeGeneratedFunctionMapEntries[testToRun].func)(ac, av);
-
-    return result;
-  }
-
-  /* Nothing was run, display the test names.  */
-  printf("Available tests:\n");
-  for (i = 0; i < NumTests; ++i) {
-    printf("%3d. %s\n", i, cmakeGeneratedFunctionMapEntries[i].name);
-  }
-  printf("Failed: %s is an invalid test name.\n", av[1]);
+	int i, testNum = 0, partial_match;
+	char* arg;
+	int testToRun = -1;
+
+	/* If no test name was given */
+	/* process command line with user function.  */
+	if (ac < 2)
+	{
+		/* Ask for a test.  */
+		printf("Available tests:\n");
+		for (i = 0; i < NumTests; ++i)
+		{
+			printf("%3d. %s\n", i, cmakeGeneratedFunctionMapEntries[i].name);
+		}
+		printf("To run a test, enter the test number: ");
+		fflush(stdout);
+		if (scanf("%d", &testNum) != 1)
+		{
+			printf("Couldn't parse that input as a number\n");
+			return -1;
+		}
+		if (testNum >= NumTests)
+		{
+			printf("%3d is an invalid test number.\n", testNum);
+			return -1;
+		}
+		testToRun = testNum;
+		ac--;
+		av++;
+	}
+	partial_match = 0;
+	arg = NULL; /* NOLINT */
+	/* If partial match is requested.  */
+	if (testToRun == -1 && ac > 1)
+	{
+		partial_match = (strcmp(av[1], "-R") == 0) ? 1 : 0;
+	}
+	if (partial_match != 0 && ac < 3)
+	{
+		printf("-R needs an additional parameter.\n");
+		return -1;
+	}
+	if (testToRun == -1)
+	{
+		arg = lowercase(av[1 + partial_match]);
+	}
+	for (i = 0; i < NumTests && testToRun == -1; ++i)
+	{
+		char* test_name = lowercase(cmakeGeneratedFunctionMapEntries[i].name);
+		if (partial_match != 0 && strstr(test_name, arg) != NULL)
+		{ /* NOLINT */
+			testToRun = i;
+			ac -= 2;
+			av += 2;
+		}
+		else if (partial_match == 0 && strcmp(test_name, arg) == 0)
+		{
+			testToRun = i;
+			ac--;
+			av++;
+		}
+		free(test_name);
+	}
+	free(arg);
+	if (testToRun != -1)
+	{
+		int result;
+
+		if (testToRun < 0 || testToRun >= NumTests)
+		{
+			printf("testToRun was modified by TestDriver code to an invalid value: "
+			       "%3d.\n",
+			       testNum);
+			return -1;
+		}
+		result = (*cmakeGeneratedFunctionMapEntries[testToRun].func)(ac, av);
+
+		return result;
+	}
+
+	/* Nothing was run, display the test names.  */
+	printf("Available tests:\n");
+	for (i = 0; i < NumTests; ++i)
+	{
+		printf("%3d. %s\n", i, cmakeGeneratedFunctionMapEntries[i].name);
+	}
+	printf("Failed: %s is an invalid test name.\n", av[1]);
 
-  return -1;
+	return -1;
 }
diff -urN libfreerdp/core/test/TestSettings.c ../../informatimago/FreeRDP/libfreerdp/core/test/TestSettings.c
--- libfreerdp/core/test/TestSettings.c	2019-07-25 19:51:04.157913764 +0300
+++ ../../informatimago/FreeRDP/libfreerdp/core/test/TestSettings.c	2019-07-25 20:11:28.095983317 +0300
@@ -1,14 +1,9 @@
 #include <freerdp/settings.h>
-#include "settings_property_lists.h"
 
 int TestSettings(int argc, char* argv[])
 {
-	int rc = -1;
-	size_t x;
 	rdpSettings* settings = NULL;
 	rdpSettings* cloned;
-	WINPR_UNUSED(argc);
-	WINPR_UNUSED(argv);
 	settings = freerdp_settings_new(0);
 
 	if (!settings)
@@ -28,120 +23,7 @@
 		return -1;
 	}
 
-#if defined(have_bool_list_indices)
-
-	for (x = 0; x < ARRAYSIZE(bool_list_indices); x++)
-	{
-		const size_t key = bool_list_indices[x];
-		const BOOL val = freerdp_settings_get_bool(settings, key);
-
-		if (!freerdp_settings_set_bool(settings, key, val))
-			goto fail;
-	}
-
-#endif
-#if defined(have_int16_list_indices)
-
-	for (x = 0; x < ARRAYSIZE(int16_list_indices); x++)
-	{
-		const size_t key = int16_list_indices[x];
-		const INT16 val = freerdp_settings_get_int16(settings, key);
-
-		if (!freerdp_settings_set_int16(settings, key, val))
-			goto fail;
-	}
-
-#endif
-#if defined(have_uint16_list_indices)
-
-	for (x = 0; x < ARRAYSIZE(uint16_list_indices); x++)
-	{
-		const size_t key = uint16_list_indices[x];
-		const UINT16 val = freerdp_settings_get_uint16(settings, key);
-
-		if (!freerdp_settings_set_uint16(settings, key, val))
-			goto fail;
-	}
-
-#endif
-#if defined(have_uint32_list_indices)
-
-	for (x = 0; x < ARRAYSIZE(uint32_list_indices); x++)
-	{
-		const size_t key = uint32_list_indices[x];
-		const UINT32 val = freerdp_settings_get_uint32(settings, key);
-
-		if (!freerdp_settings_set_uint32(settings, key, val))
-			goto fail;
-	}
-
-#endif
-#if defined(have_int32_list_indices)
-
-	for (x = 0; x < ARRAYSIZE(int32_list_indices); x++)
-	{
-		const size_t key = int32_list_indices[x];
-		const INT32 val = freerdp_settings_get_int32(settings, key);
-
-		if (!freerdp_settings_set_int32(settings, key, val))
-			goto fail;
-	}
-
-#endif
-#if defined(have_uint64_list_indices)
-
-	for (x = 0; x < ARRAYSIZE(uint64_list_indices); x++)
-	{
-		const size_t key = uint64_list_indices[x];
-		const UINT64 val = freerdp_settings_get_uint64(settings, key);
-
-		if (!freerdp_settings_set_uint64(settings, key, val))
-			goto fail;
-	}
-
-#endif
-#if defined(have_int64_list_indices)
-
-	for (x = 0; x < ARRAYSIZE(int64_list_indices); x++)
-	{
-		const size_t key = int64_list_indices[x];
-		const INT64 val = freerdp_settings_get_int64(settings, key);
-
-		if (!freerdp_settings_set_int64(settings, key, val))
-			goto fail;
-	}
-
-#endif
-#if defined(have_string_list_indices)
-
-	for (x = 0; x < ARRAYSIZE(string_list_indices); x++)
-	{
-		const size_t key = string_list_indices[x];
-		const char val[] = "test-string";
-		const char* res;
-
-		if (!freerdp_settings_set_string(settings, key, val))
-			goto fail;
-
-		res = freerdp_settings_get_string(settings, key);
-
-		if (strncmp(val, res, sizeof(val)) != 0)
-			goto fail;
-	}
-
-#endif
-#if defined(have_pointer_list_indices)
-
-	for (x = 0; x < ARRAYSIZE(pointer_list_indices); x++)
-	{
-		const size_t key = pointer_list_indices[x];
-		const void* val = freerdp_settings_get_pointer(settings, key);
-	}
-
-#endif
-	rc = 0;
-fail:
 	freerdp_settings_free(cloned);
 	freerdp_settings_free(settings);
-	return rc;
+	return 0;
 }
diff -urN libfreerdp/core/test/TestTSCredentials.c ../../informatimago/FreeRDP/libfreerdp/core/test/TestTSCredentials.c
--- libfreerdp/core/test/TestTSCredentials.c	1970-01-01 03:00:00.000000000 +0300
+++ ../../informatimago/FreeRDP/libfreerdp/core/test/TestTSCredentials.c	2019-07-25 20:11:28.107983376 +0300
@@ -0,0 +1,314 @@
+#include <stdio.h>
+#include <string.h>
+
+#include <winpr/sspi.h>
+#include <winpr/wlog.h>
+#include <winpr/stream.h>
+
+#include <freerdp/log.h>
+#include <freerdp/crypto/ber.h>
+
+#include "../tscredentials.h"
+
+#define TAG FREERDP_TAG("test.TestTSCredentials")
+
+#define printref() printf("%s:%d: in function %-40s:", __FILE__, __LINE__, __FUNCTION__)
+
+#define ERROR(format, ...)                      \
+	do                                          \
+	{                                           \
+		fprintf(stderr, format, ##__VA_ARGS__); \
+		printref();                             \
+		printf(format "\n", ##__VA_ARGS__);     \
+		fflush(stdout);                         \
+		error_count++;                          \
+	} while (0)
+
+#define FAILURE(format, ...)                \
+	do                                      \
+	{                                       \
+		printref();                         \
+		printf(" FAILURE ");                \
+		printf(format "\n", ##__VA_ARGS__); \
+		fflush(stdout);                     \
+		failure_count++;                    \
+	} while (0)
+
+#define TEST(condition, format, ...)                           \
+	if (!(condition))                                          \
+	{                                                          \
+		FAILURE("test %s " format, #condition, ##__VA_ARGS__); \
+	}
+
+size_t min(size_t a, size_t b)
+{
+	return (a < b) ? a : b;
+}
+
+auth_identity* make_test_smartcard_creds()
+{
+	csp_data_detail* csp =
+	    csp_data_detail_new(1, "IAS-ECC", "XIRING Leo v2 (8288830623) 00 00",
+	                        "Clé d'authentification1", "Middleware IAS ECC Cryptographic Provider");
+	auth_identity* identity = auth_identity_new_smartcard(
+	    smartcard_creds_new("0000", "EXAMPLEUSER", "EXAMPLE.DOMAIN", csp));
+	csp_data_detail_free(csp);
+	return identity;
+}
+
+auth_identity* make_test_remote_guard_creds()
+{
+	/*
+	 * ASN.1 value:
+	 *
+	 * value TSRemoteGuardCreds ::= {
+	 *     logonCred {
+	 *         packageName  '4D007900530065006300750072006900740079005000610063006B00610067006500'H
+	 * , credBuffer   '4D7920427265617468204973204D792050617373776F7264'H
+	 *     },
+	 *     supplementalCreds {
+	 *         {
+	 *             packageName
+	 * '41006C007400650072006E0061007400690076006500530065006300750072006900740079005000610063006B00610067006500'H
+	 * , credBuffer  '4D7920427265617468204973204D79204F746865722050617373776F7264'H
+	 *         },
+	 *         {
+	 *             packageName '500041004D00'H ,
+	 *             credBuffer  '666F6F62617262617A2170617373'H
+	 *         }
+	 *     }
+	 * }
+	 *
+	 */
+	char* package_name;
+	char* credentials;
+	remote_guard_creds* remote_guard_creds;
+	package_name = strdup("MySecurityPackage");
+	credentials = strdup("My Breath Is My Password");
+	remote_guard_creds =
+	    remote_guard_creds_new_nocopy(package_name, strlen(credentials), (BYTE*)credentials);
+	package_name = strdup("AlternativeSecurityPackage");
+	credentials = strdup("My Breath Is My Other Password");
+	remote_guard_creds_add_supplemental_cred(
+	    remote_guard_creds, remote_guard_package_cred_new_nocopy(package_name, strlen(credentials),
+	                                                             (BYTE*)credentials));
+	package_name = strdup("PAM");
+	credentials = strdup("foobarbaz!pass");
+	remote_guard_creds_add_supplemental_cred(
+	    remote_guard_creds, remote_guard_package_cred_new_nocopy(package_name, strlen(credentials),
+	                                                             (BYTE*)credentials));
+	return auth_identity_new_remote_guard(remote_guard_creds);
+}
+
+static unsigned failure_count = 0;
+static unsigned error_count = 0;
+
+void reset_counters()
+{
+	failure_count = 0;
+	error_count = 0;
+}
+
+typedef size_t (*writer_pr)(void* data, wStream* s);
+
+size_t stream_size(size_t allocated_size, writer_pr writer, void* data)
+{
+	size_t written_size;
+	size_t result_size;
+	wStream* s;
+	s = Stream_New(NULL, /* some margin: */ 1024 + 2 * allocated_size);
+	written_size = writer(data, s);
+	Stream_SealLength(s);
+	result_size = Stream_Length(s);
+	Stream_Free(s, TRUE);
+	return result_size;
+}
+
+size_t write_csp(void* csp, wStream* s)
+{
+	return nla_write_ts_csp_data_detail(csp, 3, s);
+}
+
+int string_length(char* string); /* in tscredentials.c */
+
+BOOL test_sizeof_smartcard_creds()
+{
+	csp_data_detail* csp;
+	size_t csp_expected_inner;
+	size_t csp_expected;
+	auth_identity* identity = make_test_smartcard_creds();
+	reset_counters();
+	WLog_INFO(TAG, "Testing %s", __FUNCTION__);
+	csp = identity->creds.smartcard_creds->csp_data;
+	csp_expected_inner = (ber_sizeof_contextual_tag(ber_sizeof_integer(csp->KeySpec)) +
+	                      ber_sizeof_integer(csp->KeySpec) +
+	                      ber_sizeof_sequence_octet_string(2 * string_length(csp->CardName)) +
+	                      ber_sizeof_sequence_octet_string(2 * string_length(csp->ReaderName)) +
+	                      ber_sizeof_sequence_octet_string(2 * string_length(csp->ContainerName)) +
+	                      ber_sizeof_sequence_octet_string(2 * string_length(csp->CspName)));
+	csp_expected = ber_sizeof_contextual_tag(ber_sizeof_sequence(csp_expected_inner)) +
+	               ber_sizeof_sequence(csp_expected_inner);
+	{
+		size_t result_inner = nla_sizeof_ts_cspdatadetail_inner(csp);
+		size_t result = nla_sizeof_ts_cspdatadetail(csp);
+		size_t written_size = stream_size(csp_expected, write_csp, csp);
+		TEST(csp_expected_inner == result_inner,
+		     "cspdatadetail_inner expected = %d != %d = result_inner", csp_expected_inner,
+		     result_inner);
+		TEST(csp_expected == result, "cspdatadetail expected = %d != %d = result", csp_expected,
+		     result);
+		TEST(csp_expected == written_size, "cspdatadetail expected = %d != %d = written",
+		     csp_expected, written_size);
+	}
+	{
+		smartcard_creds* creds = identity->creds.smartcard_creds;
+		size_t expected_inner =
+		    (0 + ber_sizeof_sequence_octet_string(2 * string_length(creds->Pin)) + csp_expected +
+		     ber_sizeof_sequence_octet_string(2 * string_length(creds->UserHint)) +
+		     ber_sizeof_sequence_octet_string(2 * string_length(creds->DomainHint)));
+		size_t expected = ber_sizeof_sequence(expected_inner);
+		size_t result_inner = nla_sizeof_ts_smartcard_creds_inner(creds);
+		size_t result = nla_sizeof_ts_smartcard_creds(creds);
+		size_t written_size = stream_size(expected, (writer_pr)nla_write_ts_smartcard_creds, creds);
+		TEST(expected_inner == result_inner, "smartcard_creds_inner expected = %d != %d = result",
+		     expected_inner, result_inner);
+		TEST(expected == result, "smartcard_creds expected = %d != %d = result", expected, result);
+		TEST(expected == written_size, "smartcard_creds expected = %d != %d = written", expected,
+		     written_size);
+	}
+	auth_identity_free(identity);
+	return (failure_count == 0) && (error_count == 0);
+}
+
+BOOL test_sizeof_ts_credentials()
+{
+	auth_identity* identity = make_test_smartcard_creds();
+	reset_counters();
+	WLog_INFO(TAG, "Testing %s", __FUNCTION__);
+	{
+		size_t expected_inner = nla_sizeof_ts_credentials_inner(identity);
+		size_t expected = ber_sizeof_sequence(expected_inner);
+		size_t result_inner = nla_sizeof_ts_credentials_inner(identity);
+		size_t written_size = stream_size(expected, (writer_pr)nla_write_ts_credentials, identity);
+		size_t result = expected;
+		TEST(expected_inner == result_inner, "credentials_inner expected = %d != %d = result",
+		     expected_inner, result_inner);
+		TEST(expected == result, "credentials expected = %d != %d = result", expected, result);
+		TEST(expected == written_size, "credentials expected = %d != %d = written", expected,
+		     written_size);
+	}
+	auth_identity_free(identity);
+	return (failure_count == 0) && (error_count == 0);
+}
+
+void compare_buffers(BYTE* expected_ber, size_t expected_length, BYTE* result_ber,
+                     size_t result_length)
+{
+	TEST(result_length == expected_length, "result length = %d != %d = expected length",
+	     result_length, expected_length);
+	TEST(0 == memcmp(result_ber, expected_ber, min(result_length, expected_length)),
+	     "BER bytes differ");
+
+	if (failure_count > 0)
+	{
+		FAILURE();
+		WLog_ERR(TAG, "==== Expected:");
+		winpr_HexDump(TAG, WLOG_ERROR, expected_ber, expected_length);
+		WLog_ERR(TAG, "==== Result:");
+		winpr_HexDump(TAG, WLOG_ERROR, result_ber, result_length);
+	}
+}
+
+void test_creds(auth_identity* identity, BYTE* expected_ber, size_t expected_length)
+{
+	size_t creds_size;
+	size_t written_size;
+	size_t result_length;
+	BYTE* result_ber;
+	wStream* s;
+	creds_size = nla_sizeof_ts_creds(identity);
+	WLog_INFO(TAG, "ts_creds  size   = %4d", creds_size);
+	s = Stream_New(NULL, creds_size);
+	written_size = nla_write_ts_creds(identity, s);
+	TEST(written_size == creds_size, "written_size = %d ; creds_size = %d", written_size,
+	     creds_size);
+	WLog_INFO(TAG, "written   size   = %4d", written_size);
+	Stream_SealLength(s);
+	result_length = Stream_Length(s);
+	TEST(written_size == result_length, "written_size = %d ; result_length = %d", written_size,
+	     result_length);
+	WLog_INFO(TAG, "expected length  = %4d", expected_length);
+	WLog_INFO(TAG, "result   length  = %4d", result_length);
+	result_ber = Stream_Buffer(s);
+	compare_buffers(expected_ber, expected_length, result_ber, result_length);
+	Stream_Free(s, TRUE);
+}
+
+BOOL test_write_smartcard_creds()
+{
+	static BYTE expected_ber[] = {
+		0x30, 0x82, 0x01, 0x2f, 0xa0, 0x0a, 0x04, 0x08, 0x30, 0x00, 0x30, 0x00, 0x30, 0x00, 0x30,
+		0x00, 0xa1, 0x81, 0xe6, 0x30, 0x81, 0xe3, 0xa0, 0x03, 0x02, 0x01, 0x01, 0xa1, 0x10, 0x04,
+		0x0e, 0x49, 0x00, 0x41, 0x00, 0x53, 0x00, 0x2d, 0x00, 0x45, 0x00, 0x43, 0x00, 0x43, 0x00,
+		0xa2, 0x42, 0x04, 0x40, 0x58, 0x00, 0x49, 0x00, 0x52, 0x00, 0x49, 0x00, 0x4e, 0x00, 0x47,
+		0x00, 0x20, 0x00, 0x4c, 0x00, 0x65, 0x00, 0x6f, 0x00, 0x20, 0x00, 0x76, 0x00, 0x32, 0x00,
+		0x20, 0x00, 0x28, 0x00, 0x38, 0x00, 0x32, 0x00, 0x38, 0x00, 0x38, 0x00, 0x38, 0x00, 0x33,
+		0x00, 0x30, 0x00, 0x36, 0x00, 0x32, 0x00, 0x33, 0x00, 0x29, 0x00, 0x20, 0x00, 0x30, 0x00,
+		0x30, 0x00, 0x20, 0x00, 0x30, 0x00, 0x30, 0x00, 0xa3, 0x30, 0x04, 0x2e, 0x43, 0x00, 0x6c,
+		0x00, 0xe9, 0x00, 0x20, 0x00, 0x64, 0x00, 0x27, 0x00, 0x61, 0x00, 0x75, 0x00, 0x74, 0x00,
+		0x68, 0x00, 0x65, 0x00, 0x6e, 0x00, 0x74, 0x00, 0x69, 0x00, 0x66, 0x00, 0x69, 0x00, 0x63,
+		0x00, 0x61, 0x00, 0x74, 0x00, 0x69, 0x00, 0x6f, 0x00, 0x6e, 0x00, 0x31, 0x00, 0xa4, 0x54,
+		0x04, 0x52, 0x4d, 0x00, 0x69, 0x00, 0x64, 0x00, 0x64, 0x00, 0x6c, 0x00, 0x65, 0x00, 0x77,
+		0x00, 0x61, 0x00, 0x72, 0x00, 0x65, 0x00, 0x20, 0x00, 0x49, 0x00, 0x41, 0x00, 0x53, 0x00,
+		0x20, 0x00, 0x45, 0x00, 0x43, 0x00, 0x43, 0x00, 0x20, 0x00, 0x43, 0x00, 0x72, 0x00, 0x79,
+		0x00, 0x70, 0x00, 0x74, 0x00, 0x6f, 0x00, 0x67, 0x00, 0x72, 0x00, 0x61, 0x00, 0x70, 0x00,
+		0x68, 0x00, 0x69, 0x00, 0x63, 0x00, 0x20, 0x00, 0x50, 0x00, 0x72, 0x00, 0x6f, 0x00, 0x76,
+		0x00, 0x69, 0x00, 0x64, 0x00, 0x65, 0x00, 0x72, 0x00, 0xa2, 0x18, 0x04, 0x16, 0x45, 0x00,
+		0x58, 0x00, 0x41, 0x00, 0x4d, 0x00, 0x50, 0x00, 0x4c, 0x00, 0x45, 0x00, 0x55, 0x00, 0x53,
+		0x00, 0x45, 0x00, 0x52, 0x00, 0xa3, 0x1e, 0x04, 0x1c, 0x45, 0x00, 0x58, 0x00, 0x41, 0x00,
+		0x4d, 0x00, 0x50, 0x00, 0x4c, 0x00, 0x45, 0x00, 0x2e, 0x00, 0x44, 0x00, 0x4f, 0x00, 0x4d,
+		0x00, 0x41, 0x00, 0x49, 0x00, 0x4e, 0x00,
+	};
+	static size_t expected_length = sizeof(expected_ber);
+	auth_identity* identity = make_test_smartcard_creds();
+	reset_counters();
+	WLog_INFO(TAG, "Testing %s", __FUNCTION__);
+	test_creds(identity, expected_ber, expected_length);
+	auth_identity_free(identity);
+	return (failure_count == 0) && (error_count == 0);
+}
+
+BOOL test_write_remote_guard_creds()
+{
+	static BYTE expected_ber[] = {
+		0x30, 0x81, 0xc4, 0xa0, 0x44, 0x30, 0x42, 0xa0, 0x24, 0x04, 0x22, 0x4d, 0x00, 0x79, 0x00,
+		0x53, 0x00, 0x65, 0x00, 0x63, 0x00, 0x75, 0x00, 0x72, 0x00, 0x69, 0x00, 0x74, 0x00, 0x79,
+		0x00, 0x50, 0x00, 0x61, 0x00, 0x63, 0x00, 0x6b, 0x00, 0x61, 0x00, 0x67, 0x00, 0x65, 0x00,
+		0xa1, 0x1a, 0x04, 0x18, 0x4d, 0x79, 0x20, 0x42, 0x72, 0x65, 0x61, 0x74, 0x68, 0x20, 0x49,
+		0x73, 0x20, 0x4d, 0x79, 0x20, 0x50, 0x61, 0x73, 0x73, 0x77, 0x6f, 0x72, 0x64, 0xa1, 0x7c,
+		0x30, 0x7a, 0x30, 0x5a, 0xa0, 0x36, 0x04, 0x34, 0x41, 0x00, 0x6c, 0x00, 0x74, 0x00, 0x65,
+		0x00, 0x72, 0x00, 0x6e, 0x00, 0x61, 0x00, 0x74, 0x00, 0x69, 0x00, 0x76, 0x00, 0x65, 0x00,
+		0x53, 0x00, 0x65, 0x00, 0x63, 0x00, 0x75, 0x00, 0x72, 0x00, 0x69, 0x00, 0x74, 0x00, 0x79,
+		0x00, 0x50, 0x00, 0x61, 0x00, 0x63, 0x00, 0x6b, 0x00, 0x61, 0x00, 0x67, 0x00, 0x65, 0x00,
+		0xa1, 0x20, 0x04, 0x1e, 0x4d, 0x79, 0x20, 0x42, 0x72, 0x65, 0x61, 0x74, 0x68, 0x20, 0x49,
+		0x73, 0x20, 0x4d, 0x79, 0x20, 0x4f, 0x74, 0x68, 0x65, 0x72, 0x20, 0x50, 0x61, 0x73, 0x73,
+		0x77, 0x6f, 0x72, 0x64, 0x30, 0x1c, 0xa0, 0x08, 0x04, 0x06, 0x50, 0x00, 0x41, 0x00, 0x4d,
+		0x00, 0xa1, 0x10, 0x04, 0x0e, 0x66, 0x6f, 0x6f, 0x62, 0x61, 0x72, 0x62, 0x61, 0x7a, 0x21,
+		0x70, 0x61, 0x73, 0x73
+	};
+	static size_t expected_length = sizeof(expected_ber);
+	auth_identity* identity = make_test_remote_guard_creds();
+	reset_counters();
+	WLog_INFO(TAG, "Testing %s", __FUNCTION__);
+	test_creds(identity, expected_ber, expected_length);
+	auth_identity_free(identity);
+	return (failure_count == 0) && (error_count == 0);
+}
+
+int TestTSCredentials(int argc, char* argv[])
+{
+	return ((test_sizeof_smartcard_creds() && test_sizeof_ts_credentials() &&
+	         test_write_smartcard_creds() && test_write_remote_guard_creds())
+	            ? 0
+	            : 1);
+}
diff -urN libfreerdp/core/test/TestVersion.c ../../informatimago/FreeRDP/libfreerdp/core/test/TestVersion.c
--- libfreerdp/core/test/TestVersion.c	2019-07-25 19:51:04.161913785 +0300
+++ ../../informatimago/FreeRDP/libfreerdp/core/test/TestVersion.c	2019-07-25 20:11:28.107983376 +0300
@@ -7,8 +7,6 @@
 	const char* git;
 	const char* build;
 	int major = 0, minor = 0, revision = 0;
-	WINPR_UNUSED(argc);
-	WINPR_UNUSED(argv);
 	freerdp_get_version(&major, &minor, &revision);
 
 	if (major != FREERDP_VERSION_MAJOR)
diff -urN libfreerdp/core/transport.c ../../informatimago/FreeRDP/libfreerdp/core/transport.c
--- libfreerdp/core/transport.c	2019-07-25 19:51:04.193913944 +0300
+++ ../../informatimago/FreeRDP/libfreerdp/core/transport.c	2019-07-25 20:11:28.135983515 +0300
@@ -178,7 +178,8 @@
 				UINT32 kret = 0;
 #ifdef WITH_GSSAPI
 
-				if ((strlen(transport->settings->Domain) != 0) &&
+				if ((transport->settings->Domain != NULL) &&
+				    (strlen(transport->settings->Domain) != 0) &&
 				    (strncmp(transport->settings->Domain, ".", 1) != 0))
 				{
 					kret = transport_krb5_check_account(transport, transport->settings->Username,
@@ -302,7 +303,7 @@
 	}
 
 	transport->frontBio = tls->bio;
-	BIO_callback_ctrl(tls->bio, BIO_CTRL_SET_CALLBACK, (bio_info_cb*)(void*)transport_ssl_cb);
+	BIO_callback_ctrl(tls->bio, BIO_CTRL_SET_CALLBACK, (bio_info_cb*)transport_ssl_cb);
 	SSL_set_app_data(tls->ssl, transport);
 
 	if (!transport->frontBio)
@@ -349,6 +350,8 @@
 			freerdp_set_last_error(context, FREERDP_ERROR_AUTHENTICATION_FAILED);
 
 		transport_set_nla_mode(transport, FALSE);
+		nla_free(rdp->nla);
+		rdp->nla = NULL;
 		return FALSE;
 	}
 
@@ -548,21 +551,20 @@
 	}
 }
 
-SSIZE_T transport_read_layer(rdpTransport* transport, BYTE* data, size_t bytes)
+int transport_read_layer(rdpTransport* transport, BYTE* data, int bytes)
 {
-	SSIZE_T read = 0;
+	int read = 0;
+	int status = -1;
 
-	if (!transport->frontBio || (bytes > SSIZE_MAX))
+	if (!transport->frontBio)
 	{
 		transport->layer = TRANSPORT_LAYER_CLOSED;
 		return -1;
 	}
 
-	while (read < (SSIZE_T)bytes)
+	while (read < bytes)
 	{
-		const SSIZE_T tr = (SSIZE_T)bytes - read;
-		int r = (int)((tr > INT_MAX) ? INT_MAX : tr);
-		int status = status = BIO_read(transport->frontBio, data + read, r);
+		status = BIO_read(transport->frontBio, data + read, bytes - read);
 
 		if (status <= 0)
 		{
@@ -618,20 +620,16 @@
  * @param[in] toRead number of bytes to read
  * @return < 0 on error; 0 if not enough data is available (non blocking mode); 1 toRead bytes read
  */
-static SSIZE_T transport_read_layer_bytes(rdpTransport* transport, wStream* s, size_t toRead)
+static int transport_read_layer_bytes(rdpTransport* transport, wStream* s, unsigned int toRead)
 {
-	SSIZE_T status;
-
-	if (toRead > SSIZE_MAX)
-		return 0;
-
+	int status;
 	status = transport_read_layer(transport, Stream_Pointer(s), toRead);
 
 	if (status <= 0)
 		return status;
 
-	Stream_Seek(s, (size_t)status);
-	return status == (SSIZE_T)toRead ? 1 : 0;
+	Stream_Seek(s, status);
+	return status == toRead ? 1 : 0;
 }
 
 /**
@@ -650,7 +648,7 @@
 {
 	int status;
 	size_t position;
-	size_t pduLength;
+	int pduLength;
 	BYTE* header;
 	pduLength = 0;
 
@@ -738,8 +736,7 @@
 			/* min and max values according to ITU-T Rec. T.123 (01/2007) section 8 */
 			if (pduLength < 7 || pduLength > 0xFFFF)
 			{
-				WLog_Print(transport->log, WLOG_ERROR, "tpkt - invalid pduLength: %" PRIdz,
-				           pduLength);
+				WLog_Print(transport->log, WLOG_ERROR, "tpkt - invalid pduLength: %d", pduLength);
 				return -1;
 			}
 		}
@@ -765,7 +762,7 @@
 			 */
 			if (pduLength < 3 || pduLength > 0x8000)
 			{
-				WLog_Print(transport->log, WLOG_ERROR, "fast path - invalid pduLength: %" PRIdz,
+				WLog_Print(transport->log, WLOG_ERROR, "fast path - invalid pduLength: %d",
 				           pduLength);
 				return -1;
 			}
diff -urN libfreerdp/core/tscredentials.c ../../informatimago/FreeRDP/libfreerdp/core/tscredentials.c
--- libfreerdp/core/tscredentials.c	1970-01-01 03:00:00.000000000 +0300
+++ ../../informatimago/FreeRDP/libfreerdp/core/tscredentials.c	2019-07-25 20:11:28.155983614 +0300
@@ -0,0 +1,1244 @@
+/**
+ * FreeRDP: A Remote Desktop Protocol Implementation
+ * TSCredentials reading and writing.
+ *
+ * Copyright 2010-2012 Marc-Andre Moreau <marcandre.moreau@gmail.com>
+ * Copyright 2015 Thincast Technologies GmbH
+ * Copyright 2015 DI (FH) Martin Haimberger <martin.haimberger@thincast.com>
+ * Copyright 2016 Martin Fleisz <martin.fleisz@thincast.com>
+ * Copyright 2017 Dorian Ducournau <dorian.ducournau@gmail.com>
+ * Copyright 2017 Pascal J. Bourguignon <pjb@informatimago.com>
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *		 http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#ifdef HAVE_CONFIG_H
+#	include "config.h"
+#endif
+
+#include <time.h>
+
+#ifndef _WIN32
+#	include <unistd.h>
+#endif
+
+#include <freerdp/log.h>
+#include <freerdp/crypto/tls.h>
+#include <freerdp/build-config.h>
+#include <freerdp/peer.h>
+
+#include <winpr/crt.h>
+#include <winpr/sam.h>
+#include <winpr/sspi.h>
+#include <winpr/print.h>
+#include <winpr/tchar.h>
+#include <winpr/dsparse.h>
+#include <winpr/strlst.h>
+#include <winpr/library.h>
+#include <winpr/registry.h>
+
+#include "tscredentials.h"
+
+#define TAG FREERDP_TAG("core.tscredentials")
+
+static void memory_clear_and_free(void* memory, size_t size)
+{
+	if (memory)
+	{
+		memset(memory, 0, size);
+		free(memory);
+	}
+}
+
+static void string_clear_and_free(char* string)
+{
+	memory_clear_and_free(string, strlen(string));
+}
+
+static void* memdup(void* source, size_t size)
+{
+	void* destination = malloc(size);
+
+	if (destination != NULL)
+	{
+		memcpy(destination, source, size);
+	}
+
+	return destination;
+}
+
+/**
+ * TSCredentials ::= SEQUENCE {
+ * 	cred_type    [0] INTEGER,
+ * 	credentials [1] OCTET STRING
+ * }
+ *
+ * TSPasswordCreds ::= SEQUENCE {
+ * 	domainName  [0] OCTET STRING,
+ * 	userName    [1] OCTET STRING,
+ * 	password    [2] OCTET STRING
+ * }
+ *
+ * TSSmartCardCreds ::= SEQUENCE {
+ * 	pin        [0] OCTET STRING,
+ * 	cspData    [1] TSCspDataDetail,
+ * 	userHint   [2] OCTET STRING OPTIONAL,
+ * 	domainHint [3] OCTET STRING OPTIONAL
+ * }
+ *
+ * TSCspDataDetail ::= SEQUENCE {
+ * 	keySpec       [0] INTEGER,
+ * 	cardName      [1] OCTET STRING OPTIONAL,
+ * 	readerName    [2] OCTET STRING OPTIONAL,
+ * 	containerName [3] OCTET STRING OPTIONAL,
+ * 	cspName       [4] OCTET STRING OPTIONAL
+ * }
+ *
+ *
+ * TSRemoteGuardCreds ::= SEQUENCE {
+ *     logonCred         [0] TSRemoteGuardPackageCred,
+ *     supplementalCreds [1] SEQUENCE OF TSRemoteGuardPackageCred OPTIONAL,
+ * }
+ *
+ * TSRemoteGuardPackageCred ::=  SEQUENCE {
+ *     packageName [0] OCTET STRING,
+ *     credBuffer  [1] OCTET STRING,
+ * }
+ *
+ */
+
+#define CHECK_MEMORY(pointer, error_action)                                \
+	do                                                                     \
+	{                                                                      \
+		if (!(pointer))                                                    \
+		{                                                                  \
+			WLog_ERR(TAG, "%s:%d: out of memory", __FUNCTION__, __LINE__); \
+			error_action;                                                  \
+		}                                                                  \
+	} while (0)
+
+/* ============================================================ */
+
+/* SEC_WINNT_AUTH_IDENTITY contains only UTF-16 strings,  with length fields. */
+#define WSTRING_LENGTH_CLEAR_AND_FREE(structure, field) \
+	memory_clear_and_free(structure->field, structure->field##Length * 2)
+#define WSTRING_LENGTH_SET_CSTRING(structure, field, cstring)                         \
+	(structure->field##Length =                                                       \
+	     (cstring ? ConvertToUnicode(CP_UTF8, 0, cstring, -1, &(structure->field), 0) \
+	              : (structure->field = NULL, 0)))
+#define WSTRING_LENGTH_COPY(source, destination, field)    \
+	((destination->field##Length = source->field##Length), \
+	 (destination->field =                                 \
+	      ((source->field == NULL) ? NULL : memdup(source->field, source->field##Length))))
+
+SEC_WINNT_AUTH_IDENTITY* SEC_WINNT_AUTH_IDENTITY_new(char* user, char* password, char* domain)
+{
+	SEC_WINNT_AUTH_IDENTITY* password_creds;
+	CHECK_MEMORY(password_creds = malloc(sizeof(*password_creds)), return NULL);
+	password_creds->Flags = SEC_WINNT_AUTH_IDENTITY_UNICODE;
+	WSTRING_LENGTH_SET_CSTRING(password_creds, User, user);
+	WSTRING_LENGTH_SET_CSTRING(password_creds, Domain, domain);
+	WSTRING_LENGTH_SET_CSTRING(password_creds, Password, password);
+	return password_creds;
+}
+
+SEC_WINNT_AUTH_IDENTITY* SEC_WINNT_AUTH_IDENTITY_deepcopy(SEC_WINNT_AUTH_IDENTITY* original)
+{
+	SEC_WINNT_AUTH_IDENTITY* copy;
+	CHECK_MEMORY(copy = calloc(1, sizeof(*copy)), return NULL);
+	copy->Flags = SEC_WINNT_AUTH_IDENTITY_UNICODE;
+	WSTRING_LENGTH_COPY(original, copy, User);
+	WSTRING_LENGTH_COPY(original, copy, Domain);
+	WSTRING_LENGTH_COPY(original, copy, Password);
+
+	if (((original->User != NULL) && (copy->User == NULL)) ||
+	    ((original->Password != NULL) && (copy->Password == NULL)) ||
+	    ((original->Domain != NULL) && (copy->Domain == NULL)))
+	{
+		SEC_WINNT_AUTH_IDENTITY_free(copy);
+		WLog_ERR(TAG,
+		         "%s:%d: %s() Could not allocate the fields of a SEC_WINNT_AUTH_IDENTITY structure",
+		         __FILE__, __LINE__, __FUNCTION__);
+		return NULL;
+	}
+
+	return copy;
+}
+
+void SEC_WINNT_AUTH_IDENTITY_free(SEC_WINNT_AUTH_IDENTITY* password_creds)
+{
+	if (password_creds)
+	{
+		WSTRING_LENGTH_CLEAR_AND_FREE(password_creds, User);
+		WSTRING_LENGTH_CLEAR_AND_FREE(password_creds, Domain);
+		WSTRING_LENGTH_CLEAR_AND_FREE(password_creds, Password);
+	}
+
+	free(password_creds);
+}
+
+/* ============================================================ */
+
+csp_data_detail* csp_data_detail_new_nocopy(UINT32 KeySpec, char* CardName, char* ReaderName,
+                                            char* ContainerName, char* CspName)
+{
+	csp_data_detail* csp;
+	CHECK_MEMORY(csp = malloc(sizeof(*csp)), return NULL);
+	csp->KeySpec = KeySpec;
+	csp->CardName = CardName;
+	csp->ReaderName = ReaderName;
+	csp->ContainerName = ContainerName;
+	csp->CspName = CspName;
+	return csp;
+}
+
+csp_data_detail* csp_data_detail_new(UINT32 KeySpec, char* cardname, char* readername,
+                                     char* containername, char* cspname)
+{
+	char* CardName = strdup(cardname);
+	char* ReaderName = strdup(readername);
+	char* ContainerName = strdup(containername);
+	char* CspName = strdup(cspname);
+
+	if (!CardName || !ReaderName || !ContainerName || !CspName)
+	{
+		free(CardName);
+		free(ReaderName);
+		free(ContainerName);
+		free(CspName);
+		WLog_ERR(TAG,
+		         "%s:%d: %s() Could not allocate CardName, ReaderName, ContainerName or CspName",
+		         __FILE__, __LINE__, __FUNCTION__);
+		return NULL;
+	}
+
+	return csp_data_detail_new_nocopy(KeySpec, CardName, ReaderName, ContainerName, CspName);
+}
+
+csp_data_detail* csp_data_detail_deepcopy(csp_data_detail* original)
+{
+	return csp_data_detail_new(original->KeySpec, original->CardName, original->ReaderName,
+	                           original->ContainerName, original->CspName);
+}
+
+void csp_data_detail_free(csp_data_detail* csp)
+{
+	if (csp == NULL)
+	{
+		return;
+	}
+
+	string_clear_and_free(csp->CardName);
+	string_clear_and_free(csp->ReaderName);
+	string_clear_and_free(csp->ContainerName);
+	string_clear_and_free(csp->CspName);
+	memory_clear_and_free(csp, sizeof(*csp));
+}
+
+/* ============================================================ */
+
+smartcard_creds* smartcard_creds_new_nocopy(char* Pin, char* UserHint, char* DomainHint,
+                                            csp_data_detail* csp_data)
+{
+	smartcard_creds* that;
+	CHECK_MEMORY(that = malloc(sizeof(*that)), return NULL);
+	that->Pin = Pin;
+	that->UserHint = UserHint;
+	that->DomainHint = DomainHint;
+	that->csp_data = csp_data;
+	return that;
+}
+
+smartcard_creds* smartcard_creds_new(char* pin, char* userhint, char* domainhint,
+                                     csp_data_detail* cspdata)
+{
+	char* Pin = strdup(pin);
+	char* UserHint = strdup(userhint);
+	char* DomainHint = strdup(domainhint);
+	csp_data_detail* cspData = csp_data_detail_deepcopy(cspdata);
+
+	if ((Pin == NULL) || (UserHint == NULL) || (DomainHint == NULL) || (cspData == NULL))
+	{
+		free(Pin);
+		free(UserHint);
+		free(DomainHint);
+		csp_data_detail_free(cspData);
+		WLog_ERR(
+		    TAG,
+		    "%s:%d: %s() Could not allocate Pin, UserHint or DomainHint,  or copy CSP Data Details",
+		    __FILE__, __LINE__, __FUNCTION__);
+		return NULL;
+	}
+
+	return smartcard_creds_new_nocopy(Pin, UserHint, DomainHint, cspData);
+}
+
+smartcard_creds* smartcard_creds_deepcopy(smartcard_creds* original)
+{
+	return smartcard_creds_new(original->Pin, original->UserHint, original->DomainHint,
+	                           original->csp_data);
+}
+
+void smartcard_creds_free(smartcard_creds* that)
+{
+	if (that == NULL)
+	{
+		return;
+	}
+
+	string_clear_and_free(that->Pin);
+	string_clear_and_free(that->UserHint);
+	string_clear_and_free(that->DomainHint);
+	csp_data_detail_free(that->csp_data);
+	memory_clear_and_free(that, sizeof(*that));
+}
+
+/* ============================================================ */
+
+remote_guard_package_cred*
+remote_guard_package_cred_new_nocopy(char* package_name, unsigned credential_size, BYTE* credential)
+{
+	remote_guard_package_cred* that;
+	CHECK_MEMORY(that = malloc(sizeof(*that)), return NULL);
+	that->package_name = package_name;
+	that->credential_size = credential_size;
+	that->credential = credential;
+	return that;
+}
+
+void remote_guard_package_cred_free(remote_guard_package_cred* that)
+{
+	if (that == NULL)
+	{
+		return;
+	}
+
+	free(that->package_name);
+	free(that->credential);
+	memset(that, 0, sizeof(*that));
+	free(that);
+}
+
+remote_guard_package_cred* remote_guard_package_cred_deepcopy(remote_guard_package_cred* that)
+{
+	remote_guard_package_cred* copy;
+	CHECK_MEMORY(copy = malloc(sizeof(*copy)), return NULL);
+	copy->package_name = strdup(that->package_name);
+	copy->credential_size = that->credential_size;
+	copy->credential = memdup(that->credential, that->credential_size);
+
+	if ((copy->package_name == NULL) || (copy->credential == NULL))
+	{
+		remote_guard_package_cred_free(copy);
+		CHECK_MEMORY(NULL, return NULL);
+	}
+
+	return copy;
+}
+
+/* ============================================================ */
+
+remote_guard_creds* remote_guard_creds_new_logon_cred(remote_guard_package_cred* logon_cred)
+{
+	remote_guard_creds* that;
+	CHECK_MEMORY(that = malloc(sizeof(*that)), return NULL);
+	that->login_cred = logon_cred;
+	that->supplemental_creds_count = 0;
+	that->supplemental_creds = NULL;
+	return that;
+}
+
+remote_guard_creds* remote_guard_creds_new_nocopy(char* package_name, unsigned credenial_size,
+                                                  BYTE* credential)
+{
+	remote_guard_package_cred* logon_cred =
+	    remote_guard_package_cred_new_nocopy(package_name, credenial_size, credential);
+	CHECK_MEMORY(logon_cred, return NULL);
+	return remote_guard_creds_new_logon_cred(logon_cred);
+}
+
+void remote_guard_creds_add_supplemental_cred(remote_guard_creds* that,
+                                              remote_guard_package_cred* supplemental_cred)
+{
+	remote_guard_package_cred** new_creds =
+	    realloc(that->supplemental_creds,
+	            (that->supplemental_creds_count + 1) * sizeof(that->supplemental_creds[0]));
+	CHECK_MEMORY(new_creds, return );
+	new_creds[that->supplemental_creds_count] = supplemental_cred;
+	that->supplemental_creds = new_creds;
+	that->supplemental_creds_count++;
+}
+
+remote_guard_creds* remote_guard_creds_deepcopy(remote_guard_creds* that)
+{
+	unsigned i;
+	remote_guard_creds* copy;
+	CHECK_MEMORY(copy = malloc(sizeof(*copy)), return NULL);
+	copy->login_cred = remote_guard_package_cred_deepcopy(that->login_cred);
+	copy->supplemental_creds_count = that->supplemental_creds_count;
+	copy->supplemental_creds =
+	    malloc(copy->supplemental_creds_count * sizeof(copy->supplemental_creds[0]));
+
+	for (i = 0; i < copy->supplemental_creds_count; i++)
+	{
+		copy->supplemental_creds[i] =
+		    remote_guard_package_cred_deepcopy(that->supplemental_creds[i]);
+
+		if (copy->supplemental_creds[i] == NULL)
+		{
+			break;
+		}
+	}
+
+	if ((copy->login_cred == NULL) || (copy->supplemental_creds == NULL) ||
+	    (i < copy->supplemental_creds_count))
+	{
+		remote_guard_creds_free(copy);
+		CHECK_MEMORY(NULL, return NULL);
+	}
+
+	return copy;
+}
+
+void remote_guard_creds_free(remote_guard_creds* that)
+{
+	remote_guard_package_cred_free(that->login_cred);
+
+	if (that->supplemental_creds != NULL)
+	{
+		unsigned i;
+
+		for (i = 0; i < that->supplemental_creds_count; i++)
+		{
+			remote_guard_package_cred_free(that->supplemental_creds[i]);
+		}
+
+		memory_clear_and_free(that->supplemental_creds,
+		                      that->supplemental_creds_count * sizeof(that->supplemental_creds[0]));
+	}
+
+	memory_clear_and_free(that, sizeof(*that));
+}
+
+/* ============================================================ */
+
+auth_identity* auth_identity_new_password(SEC_WINNT_AUTH_IDENTITY* password_creds)
+{
+	auth_identity* that;
+	CHECK_MEMORY(that = malloc(sizeof(*that)), return NULL);
+	that->cred_type = credential_type_password;
+	that->creds.password_creds = password_creds;
+	return that;
+}
+
+auth_identity* auth_identity_new_smartcard(smartcard_creds* smartcard_creds)
+{
+	auth_identity* that;
+	CHECK_MEMORY(that = malloc(sizeof(*that)), return NULL);
+	that->cred_type = credential_type_smartcard;
+	that->creds.smartcard_creds = smartcard_creds;
+	return that;
+}
+
+auth_identity* auth_identity_new_remote_guard(remote_guard_creds* remote_guard_creds)
+{
+	auth_identity* that;
+	CHECK_MEMORY(that = malloc(sizeof(*that)), return NULL);
+	that->cred_type = credential_type_remote_guard;
+	that->creds.remote_guard_creds = remote_guard_creds;
+	return that;
+}
+
+void auth_identity_free(auth_identity* that)
+{
+	if (that != NULL)
+	{
+		switch (that->cred_type)
+		{
+		case credential_type_password:
+			SEC_WINNT_AUTH_IDENTITY_free(that->creds.password_creds);
+			break;
+
+		case credential_type_smartcard:
+			smartcard_creds_free(that->creds.smartcard_creds);
+			break;
+
+		case credential_type_remote_guard:
+			remote_guard_creds_free(that->creds.remote_guard_creds);
+			break;
+		}
+
+		memory_clear_and_free(that, sizeof(*that));
+	}
+}
+
+const char* auth_identity_credential_type_label(auth_identity* that)
+{
+	if (that == NULL)
+	{
+		return "NULL";
+	}
+
+	switch (that->cred_type)
+	{
+	case credential_type_password:
+		return "password";
+
+	case credential_type_smartcard:
+		return "smartcard";
+
+	case credential_type_remote_guard:
+		return "remote-guard";
+
+	default:
+		return "unknown";
+	}
+}
+
+auth_identity* auth_identity_deepcopy(auth_identity* that)
+{
+#define CHECK_COPY(field, copier)                        \
+	if (that->creds.field != NULL)                       \
+	{                                                    \
+		if ((field = copier(that->creds.field)) == NULL) \
+		{                                                \
+			goto failure;                                \
+		}                                                \
+	}
+	SEC_WINNT_AUTH_IDENTITY* password_creds = NULL;
+	smartcard_creds* smartcard_creds = NULL;
+	remote_guard_creds* remote_guard_creds = NULL;
+
+	switch (that->cred_type)
+	{
+	case credential_type_password:
+		CHECK_COPY(password_creds, SEC_WINNT_AUTH_IDENTITY_deepcopy);
+		return auth_identity_new_password(password_creds);
+
+	case credential_type_smartcard:
+		CHECK_COPY(smartcard_creds, smartcard_creds_deepcopy);
+		return auth_identity_new_smartcard(smartcard_creds);
+
+	case credential_type_remote_guard:
+		CHECK_COPY(remote_guard_creds, remote_guard_creds_deepcopy);
+		return auth_identity_new_remote_guard(remote_guard_creds);
+	}
+
+failure:
+	SEC_WINNT_AUTH_IDENTITY_free(password_creds);
+	smartcard_creds_free(smartcard_creds);
+	remote_guard_creds_free(remote_guard_creds);
+	return NULL;
+#undef CHECK_COPY
+}
+
+/* ============================================================ */
+
+static BOOL nla_read_octet_string(wStream* s, const char* field_name, int contextual_tag,
+                                  BYTE** field, UINT32* field_length)
+{
+	size_t length = 0;
+
+	if (!ber_read_contextual_tag(s, contextual_tag, &length, TRUE) ||
+	    !ber_read_octet_string_tag(s, &length))
+	{
+		return FALSE;
+	}
+
+	if (length == 0)
+	{
+		CHECK_MEMORY((*field) = calloc(1, 2), return FALSE);
+	}
+	else
+	{
+		CHECK_MEMORY((*field) = malloc(length), return FALSE);
+		CopyMemory((*field), Stream_Pointer(s), length);
+		Stream_Seek(s, length);
+	}
+
+	(*field_length) = (UINT32)length;
+	return TRUE;
+}
+
+static BOOL nla_read_octet_string_field(wStream* s, const char* field_name, int contextual_tag,
+                                        UINT16** field, UINT32* field_length)
+{
+	if (nla_read_octet_string(s, field_name, contextual_tag, (BYTE**)field, field_length))
+	{
+		(*field_length) /= 2;
+		return TRUE;
+	}
+	else
+	{
+		return FALSE;
+	}
+}
+
+static BOOL nla_read_octet_string_string(wStream* s, const char* field_name, int contextual_tag,
+                                         char** string)
+{
+	int result;
+	UINT16* field = NULL;
+	UINT32 field_length = 0;
+	(*string) = NULL;
+
+	if (!nla_read_octet_string_field(s, field_name, contextual_tag, &field, &field_length))
+	{
+		return 0;
+	}
+
+	result = ConvertFromUnicode(CP_UTF8, 0, field, 2 * field_length, string, 0, 0, FALSE);
+	free(field);
+	return 0 <= result;
+}
+
+static size_t nla_write_sequence_octet_string_string(wStream* s, const char* field_name,
+                                                     int contextual_tag, char* string)
+{
+	LPWSTR buffer = NULL;
+	size_t length;
+	int increment;
+
+	if ((length = ConvertToUnicode(CP_UTF8, 0, string, -1, &buffer, 0)) <= 0)
+	{
+		WLog_ERR(TAG, "Cannot ConvertToUnicode '%s'", string);
+		return 0;
+	}
+
+	/* ConvertToUnicode returns the number of codepoints, including the terminating nul! */
+	increment = ber_write_sequence_octet_string(s, contextual_tag, (BYTE*)buffer, (length - 1) * 2);
+	free(buffer);
+	return increment;
+}
+
+/*
+string_length returns the number of characters in the utf-8 string.
+That is, the number of WCHAR in the string converted to "unicode".
+*/
+int string_length(char* string)
+{
+	if (string == NULL)
+	{
+		return 0;
+	}
+	else
+	{
+		LPWSTR wstring = NULL;
+		int length = ConvertToUnicode(CP_UTF8, 0, string, -1, &wstring, 0);
+		free(wstring);
+		/* ConvertToUnicode returns the number of codepoints, including the terminating nul! */
+		return (length <= 0) ? 0 : length - 1;
+	}
+}
+
+/* ============================================================ */
+
+size_t nla_sizeof_ts_password_creds_inner(SEC_WINNT_AUTH_IDENTITY* password_creds)
+{
+	if (password_creds == NULL)
+	{
+		return 0;
+	}
+
+	return (ber_sizeof_sequence_octet_string(password_creds->DomainLength * 2) +
+	        ber_sizeof_sequence_octet_string(password_creds->UserLength * 2) +
+	        ber_sizeof_sequence_octet_string(password_creds->PasswordLength * 2));
+}
+
+size_t nla_sizeof_ts_password_creds(SEC_WINNT_AUTH_IDENTITY* password_creds)
+{
+	size_t inner_size = nla_sizeof_ts_password_creds_inner(password_creds);
+	return ber_sizeof_sequence(inner_size);
+}
+
+size_t nla_sizeof_ts_cspdatadetail_inner(csp_data_detail* csp_data)
+{
+	if (csp_data == NULL)
+	{
+		return 0;
+	}
+
+	return (ber_sizeof_contextual_tag(ber_sizeof_integer(csp_data->KeySpec)) +
+	        ber_sizeof_integer(csp_data->KeySpec) +
+	        ber_sizeof_sequence_octet_string(string_length(csp_data->CardName) * 2) +
+	        ber_sizeof_sequence_octet_string(string_length(csp_data->ReaderName) * 2) +
+	        ber_sizeof_sequence_octet_string(string_length(csp_data->ContainerName) * 2) +
+	        ber_sizeof_sequence_octet_string(string_length(csp_data->CspName) * 2));
+}
+
+size_t nla_sizeof_ts_cspdatadetail(csp_data_detail* csp_data)
+{
+	size_t inner_size = nla_sizeof_ts_cspdatadetail_inner(csp_data);
+	size_t seq_size = ber_sizeof_sequence(inner_size);
+	return (ber_sizeof_contextual_tag(seq_size) + seq_size);
+}
+
+size_t nla_sizeof_ts_smartcard_creds_inner(smartcard_creds* smartcard_creds)
+{
+	if (smartcard_creds == NULL)
+	{
+		return 0;
+	}
+
+	return (ber_sizeof_sequence_octet_string(string_length(smartcard_creds->Pin) * 2) +
+	        nla_sizeof_ts_cspdatadetail(smartcard_creds->csp_data) +
+	        ber_sizeof_sequence_octet_string(string_length(smartcard_creds->UserHint) * 2) +
+	        ber_sizeof_sequence_octet_string(string_length(smartcard_creds->DomainHint) * 2));
+}
+
+size_t nla_sizeof_ts_smartcard_creds(smartcard_creds* smartcard_creds)
+{
+	return ber_sizeof_sequence(nla_sizeof_ts_smartcard_creds_inner(smartcard_creds));
+}
+
+size_t nla_sizeof_ts_remote_guard_package_cred_inner(remote_guard_package_cred* package_cred)
+{
+	return (ber_sizeof_sequence_octet_string(string_length(package_cred->package_name) * 2) +
+	        ber_sizeof_sequence_octet_string(package_cred->credential_size));
+}
+
+size_t nla_sizeof_ts_remote_guard_package_cred(remote_guard_package_cred* package_cred)
+{
+	return ber_sizeof_sequence(nla_sizeof_ts_remote_guard_package_cred_inner(package_cred));
+}
+
+size_t nla_sizeof_ts_remote_guard_creds_inner(remote_guard_creds* remote_guard_creds)
+{
+	size_t size = 0;
+	unsigned i;
+
+	if (remote_guard_creds == NULL)
+	{
+		return 0;
+	}
+
+	/* logonCred         [0] TSRemoteGuardPackageCred, */
+	{
+		size_t login_size = nla_sizeof_ts_remote_guard_package_cred(remote_guard_creds->login_cred);
+		size += ber_sizeof_contextual_tag(login_size);
+		size += login_size;
+	}
+
+	/* supplementalCreds [1] SEQUENCE OF TSRemoteGuardPackageCred OPTIONAL, */
+	if (0 < remote_guard_creds->supplemental_creds_count)
+	{
+		size_t seq_size = 0;
+		size_t supplemental_size = 0;
+
+		for (i = 0; i < remote_guard_creds->supplemental_creds_count; i++)
+		{
+			supplemental_size +=
+			    nla_sizeof_ts_remote_guard_package_cred(remote_guard_creds->supplemental_creds[i]);
+		}
+
+		seq_size = ber_sizeof_sequence(supplemental_size);
+		size += ber_sizeof_contextual_tag(seq_size);
+		size += seq_size;
+	}
+
+	return size;
+}
+
+size_t nla_sizeof_ts_remote_guard_creds(remote_guard_creds* remote_guard_creds)
+{
+	return ber_sizeof_sequence(nla_sizeof_ts_remote_guard_creds_inner(remote_guard_creds));
+}
+
+size_t nla_sizeof_ts_creds(auth_identity* identity)
+{
+	switch (identity->cred_type)
+	{
+	case credential_type_password:
+		return nla_sizeof_ts_password_creds(identity->creds.password_creds);
+
+	case credential_type_smartcard:
+		return nla_sizeof_ts_smartcard_creds(identity->creds.smartcard_creds);
+
+	case credential_type_remote_guard:
+		return nla_sizeof_ts_remote_guard_creds(identity->creds.remote_guard_creds);
+
+	default:
+		return 0;
+	}
+}
+
+size_t nla_sizeof_ts_credentials_inner(auth_identity* identity)
+{
+	return (ber_sizeof_contextual_tag(ber_sizeof_integer(identity->cred_type)) +
+	        ber_sizeof_integer(identity->cred_type) +
+	        ber_sizeof_sequence_octet_string(nla_sizeof_ts_creds(identity)));
+}
+
+size_t nla_sizeof_ts_credentials(auth_identity* identity)
+{
+	return ber_sizeof_sequence(nla_sizeof_ts_credentials_inner(identity));
+}
+
+static SEC_WINNT_AUTH_IDENTITY* nla_read_ts_password_creds(wStream* s, size_t* length)
+{
+	SEC_WINNT_AUTH_IDENTITY* password_creds = NULL;
+
+	/* TSPasswordCreds (SEQUENCE) */
+	if (!ber_read_sequence_tag(s, length))
+	{
+		return NULL;
+	}
+
+	/* The sequence is empty, return early,
+	 * TSPasswordCreds (SEQUENCE) is optional. */
+	if ((*length) == 0)
+	{
+		return NULL;
+	}
+
+	password_creds = SEC_WINNT_AUTH_IDENTITY_new(NULL, NULL, NULL);
+
+	if (nla_read_octet_string_field(s, "[0] domainName (OCTET STRING)", 0, &password_creds->Domain,
+	                                &password_creds->DomainLength) &&
+	    nla_read_octet_string_field(s, "[1] userName (OCTET STRING)", 1, &password_creds->User,
+	                                &password_creds->UserLength) &&
+	    nla_read_octet_string_field(s, "[2] password (OCTET STRING)", 2, &password_creds->Password,
+	                                &password_creds->PasswordLength))
+	{
+		return password_creds;
+	}
+
+	SEC_WINNT_AUTH_IDENTITY_free(password_creds);
+	return NULL;
+}
+
+static csp_data_detail* nla_read_ts_cspdatadetail(wStream* s, size_t* length)
+{
+	csp_data_detail* csp_data = NULL;
+	UINT32 key_spec = 0;
+
+	/* TSCspDataDetail (SEQUENCE)
+	 * Initialise to default values. */
+	if (!ber_read_sequence_tag(s, length))
+	{
+		return NULL;
+	}
+
+	/* The sequence is empty, return early,
+	 * TSCspDataDetail (SEQUENCE) is optional. */
+	if (*length == 0)
+	{
+		return NULL;
+	}
+
+	/* [0] keySpec (INTEGER) */
+	if (!ber_read_contextual_tag(s, 0, length, TRUE) || !ber_read_integer(s, &key_spec))
+	{
+		return NULL;
+	}
+
+	CHECK_MEMORY((csp_data = csp_data_detail_new_nocopy(key_spec, NULL, NULL, NULL, NULL)) == NULL,
+	             return NULL);
+
+	if (nla_read_octet_string_string(s, "[1] cardName (OCTET STRING)", 1, &csp_data->CardName) &&
+	    nla_read_octet_string_string(s, "[2] readerName (OCTET STRING)", 2,
+	                                 &csp_data->ReaderName) &&
+	    nla_read_octet_string_string(s, "[3] containerName (OCTET STRING)", 3,
+	                                 &csp_data->ContainerName) &&
+	    nla_read_octet_string_string(s, "[4] cspName (OCTET STRING)", 4, &csp_data->CspName))
+	{
+		return csp_data;
+	}
+
+	csp_data_detail_free(csp_data);
+	return NULL;
+}
+
+static smartcard_creds* nla_read_ts_smartcard_creds(wStream* s, size_t* length)
+{
+	smartcard_creds* smartcard_creds = NULL;
+
+	/* TSSmartCardCreds (SEQUENCE)
+	 * Initialize to default values. */
+	if (!ber_read_sequence_tag(s, length))
+	{
+		return NULL;
+	}
+
+	/* The sequence is empty, return early,
+	 * TSSmartCardCreds (SEQUENCE) is optional. */
+	if ((*length) == 0)
+	{
+		return NULL;
+	}
+
+	CHECK_MEMORY((smartcard_creds = smartcard_creds_new_nocopy(NULL, NULL, NULL, NULL)),
+	             return NULL);
+
+	if (nla_read_octet_string_string(s, "[0] Pin (OCTET STRING)", 0, &smartcard_creds->Pin))
+	{
+		smartcard_creds->csp_data = nla_read_ts_cspdatadetail(s, length);
+
+		if (nla_read_octet_string_string(s, "[2] UserHint (OCTET STRING)", 2,
+		                                 &smartcard_creds->UserHint) &&
+		    nla_read_octet_string_string(s, "[3] DomainHint (OCTET STRING", 3,
+		                                 &smartcard_creds->DomainHint))
+		{
+			return smartcard_creds;
+		}
+	}
+
+	smartcard_creds_free(smartcard_creds);
+	return NULL;
+}
+
+static remote_guard_package_cred* nla_read_ts_remote_guard_package_cred(wStream* s, size_t* length)
+{
+	remote_guard_package_cred* package_cred = NULL;
+
+	/*
+	 * TSRemoteGuardPackageCred ::=  SEQUENCE {
+	 *     packageName [0] OCTET STRING,
+	 *     credBuffer  [1] OCTET STRING,
+	 * }
+	 */
+
+	if (!ber_read_sequence_tag(s, length))
+	{
+		return NULL;
+	}
+
+	/* The sequence is empty, return early,
+	 * TSRemoteGuardPackageCreds (SEQUENCE) is optional. */
+	if ((*length) == 0)
+	{
+		return NULL;
+	}
+
+	char* package_name;
+	BYTE* cred_buffer;
+	UINT32 cred_buffer_size;
+
+	if (nla_read_octet_string_string(s, "[0] OCTET STRING,", 0, &package_name) &&
+	    nla_read_octet_string(s, "[1] OCTET STRING", 1, &cred_buffer, &cred_buffer_size))
+	{
+		package_cred =
+		    remote_guard_package_cred_new_nocopy(package_name, cred_buffer_size, cred_buffer);
+	}
+
+	if (package_cred == NULL)
+	{
+		free(package_name);
+		free(cred_buffer);
+		CHECK_MEMORY(NULL, return NULL);
+	}
+
+	return package_cred;
+}
+
+static remote_guard_creds* nla_read_ts_remote_guard_creds(wStream* s, size_t* length)
+{
+	/*
+	 * TSRemoteGuardCreds ::= SEQUENCE {
+	 *     logonCred         [0] TSRemoteGuardPackageCred,
+	 *     supplementalCreds [1] SEQUENCE OF TSRemoteGuardPackageCred OPTIONAL,
+	 * }
+	 */
+	remote_guard_creds* remote_guard_creds = NULL;
+	remote_guard_package_cred* logon_cred = NULL;
+	size_t supplemental_length = 0;
+
+	/* TSRemoteGuardCreds (SEQUENCE)
+	 * Initialize to default values. */
+	if (!ber_read_sequence_tag(s, length))
+	{
+		return NULL;
+	}
+
+	/* The sequence is empty, return early,
+	 * TSRemoteGuardCreds (SEQUENCE) is optional. */
+	if ((*length) == 0)
+	{
+		return NULL;
+	}
+
+	logon_cred = nla_read_ts_remote_guard_package_cred(s, length);
+	remote_guard_creds = remote_guard_creds_new_logon_cred(logon_cred);
+
+	if (remote_guard_creds == NULL)
+	{
+		free(logon_cred);
+		return NULL;
+	}
+
+	if (ber_read_sequence_tag(s, &supplemental_length) && (supplemental_length > 0))
+	{
+		remote_guard_package_cred* supplemental_cred =
+		    nla_read_ts_remote_guard_package_cred(s, length);
+
+		while (supplemental_cred != NULL)
+		{
+			remote_guard_creds_add_supplemental_cred(remote_guard_creds, supplemental_cred);
+			supplemental_cred = nla_read_ts_remote_guard_package_cred(s, length);
+		}
+	}
+
+	return remote_guard_creds;
+}
+
+static auth_identity* nla_read_ts_creds(wStream* s, credential_type cred_type, size_t* length)
+{
+	auth_identity* identity = NULL;
+	SEC_WINNT_AUTH_IDENTITY* password_creds = NULL;
+	smartcard_creds* smartcard_creds = NULL;
+	remote_guard_creds* remote_guard_creds = NULL;
+
+	switch (cred_type)
+	{
+	case credential_type_password:
+		if ((password_creds = nla_read_ts_password_creds(s, length)) != NULL)
+		{
+			identity = auth_identity_new_password(password_creds);
+		}
+
+		break;
+
+	case credential_type_smartcard:
+		if ((smartcard_creds = nla_read_ts_smartcard_creds(s, length)) != NULL)
+		{
+			identity = auth_identity_new_smartcard(smartcard_creds);
+		}
+
+		break;
+
+	case credential_type_remote_guard:
+		if ((remote_guard_creds = nla_read_ts_remote_guard_creds(s, length)) != NULL)
+		{
+			identity = auth_identity_new_remote_guard(remote_guard_creds);
+		}
+
+		break;
+
+	default:
+		WLog_ERR(TAG, "cred_type unknown: %d\n", cred_type);
+		return NULL;
+	}
+
+	if (identity != NULL)
+	{
+		return identity;
+	}
+
+	SEC_WINNT_AUTH_IDENTITY_free(password_creds);
+	smartcard_creds_free(smartcard_creds);
+	remote_guard_creds_free(remote_guard_creds);
+	return NULL;
+}
+
+auth_identity* nla_read_ts_credentials(PSecBuffer ts_credentials)
+{
+	auth_identity* identity = NULL;
+	wStream* s;
+	size_t length = 0;
+	size_t ts_creds_length = 0;
+	UINT32* value = NULL;
+
+	if (!ts_credentials || !ts_credentials->pvBuffer)
+		return FALSE;
+
+	s = Stream_New(ts_credentials->pvBuffer, ts_credentials->cbBuffer);
+
+	if (!s)
+	{
+		WLog_ERR(TAG, "Stream_New failed!");
+		return FALSE;
+	}
+
+	/* TSCredentials (SEQUENCE) */
+	if (ber_read_sequence_tag(s, &length) &&
+	    /* [0] credType (INTEGER) */
+	    ber_read_contextual_tag(s, 0, &length, TRUE) && ber_read_integer(s, value) &&
+	    /* [1] credentials (OCTET STRING) */
+	    ber_read_contextual_tag(s, 1, &length, TRUE) &&
+	    ber_read_octet_string_tag(s, &ts_creds_length))
+	{
+		identity = nla_read_ts_creds(s, *value, &length);
+	}
+
+	Stream_Free(s, FALSE);
+	return identity;
+}
+
+size_t nla_write_ts_password_creds(SEC_WINNT_AUTH_IDENTITY* password_creds, wStream* s)
+{
+	size_t size = 0;
+	size_t inner_size = nla_sizeof_ts_password_creds_inner(password_creds);
+	/* TSPasswordCreds (SEQUENCE) */
+	size += ber_write_sequence_tag(s, inner_size);
+
+	if (password_creds != NULL)
+	{
+		/* [0] domainName (OCTET STRING) */
+		size += ber_write_sequence_octet_string(s, 0, (BYTE*)password_creds->Domain,
+		                                        password_creds->DomainLength * 2);
+		/* [1] userName (OCTET STRING) */
+		size += ber_write_sequence_octet_string(s, 1, (BYTE*)password_creds->User,
+		                                        password_creds->UserLength * 2);
+		/* [2] password (OCTET STRING) */
+		size += ber_write_sequence_octet_string(s, 2, (BYTE*)password_creds->Password,
+		                                        password_creds->PasswordLength * 2);
+	}
+
+	return size;
+}
+
+size_t nla_write_ts_csp_data_detail(csp_data_detail* csp_data, int contextual_tag, wStream* s)
+{
+	size_t size = 0;
+
+	if (csp_data != NULL)
+	{
+		size_t inner_size = nla_sizeof_ts_cspdatadetail_inner(csp_data);
+		size += ber_write_contextual_tag(s, contextual_tag, ber_sizeof_sequence(inner_size), TRUE);
+		size += ber_write_sequence_tag(s, inner_size);
+		/* [0] KeySpec (INTEGER) */
+		size += ber_write_contextual_tag(s, 0, ber_sizeof_integer(csp_data->KeySpec), TRUE);
+		size += ber_write_integer(s, csp_data->KeySpec);
+		size += nla_write_sequence_octet_string_string(s, "[1] CardName (OCTET STRING)", 1,
+		                                               csp_data->CardName);
+		size += nla_write_sequence_octet_string_string(s, "[2] ReaderName (OCTET STRING)", 2,
+		                                               csp_data->ReaderName);
+		size += nla_write_sequence_octet_string_string(s, "[3] ContainerName (OCTET STRING)", 3,
+		                                               csp_data->ContainerName);
+		size += nla_write_sequence_octet_string_string(s, "[4] CspName (OCTET STRING)", 4,
+		                                               csp_data->CspName);
+	}
+
+	return size;
+}
+
+size_t nla_write_ts_smartcard_creds(smartcard_creds* smartcard_creds, wStream* s)
+{
+	size_t size = 0;
+	size_t inner_size = nla_sizeof_ts_smartcard_creds_inner(smartcard_creds);
+	/* TSSmartCardCreds (SEQUENCE) */
+	size += ber_write_sequence_tag(s, inner_size);
+
+	if (smartcard_creds != NULL)
+	{
+		size += nla_write_sequence_octet_string_string(s, "[0] Pin (OCTET STRING)", 0,
+		                                               smartcard_creds->Pin);
+		/* [1] CspDataDetail (TSCspDataDetail) (SEQUENCE) */
+		size += nla_write_ts_csp_data_detail(smartcard_creds->csp_data, 1, s);
+		size += nla_write_sequence_octet_string_string(s, "[2] userHint (OCTET STRING)", 2,
+		                                               smartcard_creds->UserHint);
+		size += nla_write_sequence_octet_string_string(s, "[3] domainHint (OCTET STRING)", 3,
+		                                               smartcard_creds->DomainHint);
+	}
+
+	return size;
+}
+
+size_t nla_write_ts_remote_guard_package_cred(remote_guard_package_cred* package_cred, wStream* s)
+{
+	/*
+	 * TSRemoteGuardPackageCred ::=  SEQUENCE {
+	 *     packageName [0] OCTET STRING,
+	 *     credBuffer  [1] OCTET STRING,
+	 * }
+	 */
+	size_t size = 0;
+	size_t inner_size = nla_sizeof_ts_remote_guard_package_cred_inner(package_cred);
+	size += ber_write_sequence_tag(s, inner_size);
+
+	if (package_cred != NULL)
+	{
+		size += nla_write_sequence_octet_string_string(s, "packageName [0] OCTET STRING", 0,
+		                                               package_cred->package_name);
+		/* credBuffer  [1] OCTET STRING, */
+		size += ber_write_sequence_octet_string(s, 1, package_cred->credential,
+		                                        package_cred->credential_size);
+	}
+
+	return size;
+}
+
+size_t nla_write_ts_remote_guard_creds(remote_guard_creds* remote_guard_creds, wStream* s)
+{
+	unsigned i;
+	size_t size = 0;
+	size_t inner_size = nla_sizeof_ts_remote_guard_creds_inner(remote_guard_creds);
+	/* TSRemoteGuardCreds ::= SEQUENCE { */
+	size += ber_write_sequence_tag(s, inner_size);
+	/*     logonCred         [0] TSRemoteGuardPackageCred, */
+	size += ber_write_contextual_tag(
+	    s, 0, nla_sizeof_ts_remote_guard_package_cred(remote_guard_creds->login_cred), TRUE);
+	size += nla_write_ts_remote_guard_package_cred(remote_guard_creds->login_cred, s);
+
+	/*     supplementalCreds [1] SEQUENCE OF TSRemoteGuardPackageCred OPTIONAL, */
+	if (0 < remote_guard_creds->supplemental_creds_count)
+	{
+		unsigned supplemental_size = 0;
+
+		for (i = 0; i < remote_guard_creds->supplemental_creds_count; i++)
+		{
+			supplemental_size +=
+			    nla_sizeof_ts_remote_guard_package_cred(remote_guard_creds->supplemental_creds[i]);
+		}
+
+		size += ber_write_contextual_tag(s, 1, ber_sizeof_sequence(supplemental_size), TRUE);
+		size += ber_write_sequence_tag(s, supplemental_size);
+
+		for (i = 0; i < remote_guard_creds->supplemental_creds_count; i++)
+		{
+			size += nla_write_ts_remote_guard_package_cred(
+			    remote_guard_creds->supplemental_creds[i], s);
+		}
+	}
+
+	return size;
+}
+
+size_t nla_write_ts_creds(auth_identity* identity, wStream* s)
+{
+	switch (identity->cred_type)
+	{
+	case credential_type_password:
+		return nla_write_ts_password_creds(identity->creds.password_creds, s);
+
+	case credential_type_smartcard:
+		return nla_write_ts_smartcard_creds(identity->creds.smartcard_creds, s);
+
+	case credential_type_remote_guard:
+		return nla_write_ts_remote_guard_creds(identity->creds.remote_guard_creds, s);
+
+	default:
+		WLog_ERR(TAG, "cred_type unknown: %d\n", identity->cred_type);
+		return 0;
+	}
+}
+
+size_t nla_write_ts_credentials(auth_identity* identity, wStream* s)
+{
+	size_t size = 0;
+	size_t cred_size = 0;
+	size_t inner_size = nla_sizeof_ts_credentials_inner(identity);
+	/* TSCredentials (SEQUENCE) */
+	size += ber_write_sequence_tag(s, inner_size);
+	/* [0] credType (INTEGER) */
+	size += ber_write_contextual_tag(s, 0, ber_sizeof_integer(identity->cred_type), TRUE);
+	size += ber_write_integer(s, identity->cred_type);
+	/* [1] credentials (OCTET STRING) */
+	cred_size = nla_sizeof_ts_creds(identity);
+	size += ber_write_contextual_tag(s, 1, ber_sizeof_octet_string(cred_size), TRUE);
+	size += ber_write_octet_string_tag(s, cred_size);
+	size += nla_write_ts_creds(identity, s);
+	return size;
+}
+
+/**** THE END ****/
diff -urN libfreerdp/core/tscredentials.h ../../informatimago/FreeRDP/libfreerdp/core/tscredentials.h
--- libfreerdp/core/tscredentials.h	1970-01-01 03:00:00.000000000 +0300
+++ ../../informatimago/FreeRDP/libfreerdp/core/tscredentials.h	2019-07-25 20:11:28.159983634 +0300
@@ -0,0 +1,134 @@
+#ifndef FREERDP_LIB_CORE_TSREQUEST_H
+#define FREERDP_LIB_CORE_TSREQUEST_H
+
+#ifdef HAVE_CONFIG_H
+#	include "config.h"
+#endif
+
+#include <winpr/crt.h>
+#include <winpr/sspi.h>
+#include <winpr/print.h>
+#include <winpr/tchar.h>
+#include <winpr/strlst.h>
+
+typedef struct
+{
+	UINT32 KeySpec;
+	char* CardName;
+	char* ReaderName;
+	char* ContainerName;
+	char* CspName;
+} csp_data_detail;
+
+typedef struct
+{
+	char* Pin;
+	char* UserHint;   /* OPTIONAL */
+	char* DomainHint; /* OPTIONAL */
+	csp_data_detail* csp_data;
+} smartcard_creds;
+
+typedef struct
+{
+	char* package_name;
+	unsigned credential_size;
+	BYTE* credential;
+} remote_guard_package_cred;
+
+typedef struct
+{
+	remote_guard_package_cred* login_cred;
+	unsigned supplemental_creds_count;
+	remote_guard_package_cred** supplemental_creds;
+} remote_guard_creds;
+
+typedef enum
+{
+	credential_type_password = 1,
+	credential_type_smartcard = 2,
+	credential_type_remote_guard = 6,
+	credential_type_default = credential_type_password,
+} credential_type;
+
+typedef struct
+{
+	credential_type cred_type;
+	union {
+		SEC_WINNT_AUTH_IDENTITY* password_creds;
+		smartcard_creds* smartcard_creds;
+		remote_guard_creds* remote_guard_creds;
+	} creds;
+} auth_identity;
+
+SEC_WINNT_AUTH_IDENTITY* SEC_WINNT_AUTH_IDENTITY_new(char* user, char* password, char* domain);
+SEC_WINNT_AUTH_IDENTITY* SEC_WINNT_AUTH_IDENTITY_deepcopy(SEC_WINNT_AUTH_IDENTITY* original);
+void SEC_WINNT_AUTH_IDENTITY_free(SEC_WINNT_AUTH_IDENTITY* password_creds);
+
+csp_data_detail* csp_data_detail_new_nocopy(UINT32 KeySpec, char* CardName, char* ReaderName,
+                                            char* ContainerName, char* CspName);
+csp_data_detail* csp_data_detail_new(UINT32 KeySpec, char* cardname, char* readername,
+                                     char* containername, char* cspname);
+csp_data_detail* csp_data_detail_deepcopy(csp_data_detail* original);
+void csp_data_detail_free(csp_data_detail* csp);
+
+smartcard_creds* smartcard_creds_new_nocopy(char* Pin, char* UserHint, char* DomainHint,
+                                            csp_data_detail* csp_data);
+smartcard_creds* smartcard_creds_new(char* pin, char* userhint, char* domainhint,
+                                     csp_data_detail* cspdata);
+smartcard_creds* smartcard_creds_deepcopy(smartcard_creds* original);
+void smartcard_creds_free(smartcard_creds* that);
+
+remote_guard_package_cred* remote_guard_package_cred_new_nocopy(char* package_name,
+                                                                unsigned credential_size,
+                                                                BYTE* credential);
+remote_guard_package_cred* remote_guard_package_cred_deepcopy(remote_guard_package_cred* that);
+void remote_guard_package_cred_deepfree(remote_guard_package_cred* that);
+
+remote_guard_creds* remote_guard_creds_new_logon_cred(remote_guard_package_cred* logon_cred);
+remote_guard_creds* remote_guard_creds_new_nocopy(char* package_name, unsigned credenial_size,
+                                                  BYTE* credential);
+remote_guard_creds* remote_guard_creds_deepcopy(remote_guard_creds* that);
+void remote_guard_creds_add_supplemental_cred(remote_guard_creds* that,
+                                              remote_guard_package_cred* supplemental_cred);
+void remote_guard_creds_free(remote_guard_creds* that);
+
+auth_identity* auth_identity_new_password(SEC_WINNT_AUTH_IDENTITY* password_creds);
+auth_identity* auth_identity_new_smartcard(smartcard_creds* smartcard_creds);
+auth_identity* auth_identity_new_remote_guard(remote_guard_creds* remote_guard_creds);
+auth_identity* auth_identity_deepcopy(auth_identity* that);
+void auth_identity_free(auth_identity* that);
+const char* auth_identity_credential_type_label(auth_identity* that);
+
+size_t nla_sizeof_ts_creds(auth_identity* identity);
+size_t nla_write_ts_creds(auth_identity* identity, wStream* s);
+size_t nla_sizeof_ts_credentials_inner(auth_identity* identity);
+size_t nla_sizeof_ts_credentials(auth_identity* identity);
+size_t nla_write_ts_credentials(auth_identity* identity, wStream* s);
+auth_identity* nla_read_ts_credentials(PSecBuffer ts_credentials);
+
+#define ber_sizeof_sequence_octet_string(length) \
+	(ber_sizeof_contextual_tag(ber_sizeof_octet_string(length)) + ber_sizeof_octet_string(length))
+
+#define ber_write_sequence_octet_string(stream, context, value, length)                 \
+	(ber_write_contextual_tag(stream, context, ber_sizeof_octet_string(length), TRUE) + \
+	 ber_write_octet_string(stream, value, length))
+
+/* exported for tests */
+size_t nla_sizeof_ts_password_creds_inner(SEC_WINNT_AUTH_IDENTITY* password_creds);
+size_t nla_sizeof_ts_password_creds(SEC_WINNT_AUTH_IDENTITY* password_creds);
+size_t nla_sizeof_ts_cspdatadetail_inner(csp_data_detail* csp_data);
+size_t nla_sizeof_ts_cspdatadetail(csp_data_detail* csp_data);
+size_t nla_sizeof_ts_smartcard_creds_inner(smartcard_creds* smartcard_creds);
+size_t nla_sizeof_ts_smartcard_creds(smartcard_creds* smartcard_creds);
+size_t nla_sizeof_ts_remote_guard_package_cred_inner(remote_guard_package_cred* package_cred);
+size_t nla_sizeof_ts_remote_guard_package_cred(remote_guard_package_cred* package_cred);
+size_t nla_sizeof_ts_remote_guard_creds_inner(remote_guard_creds* remote_guard_creds);
+size_t nla_sizeof_ts_remote_guard_creds(remote_guard_creds* remote_guard_creds);
+
+size_t nla_write_ts_password_creds(SEC_WINNT_AUTH_IDENTITY* password_creds, wStream* s);
+size_t nla_write_ts_csp_data_detail(csp_data_detail* csp_data, int contextual_tag, wStream* s);
+size_t nla_write_ts_smartcard_creds(smartcard_creds* smartcard_creds, wStream* s);
+size_t nla_write_ts_remote_guard_package_cred(remote_guard_package_cred* package_cred, wStream* s);
+size_t nla_write_ts_remote_guard_creds(remote_guard_creds* remote_guard_creds, wStream* s);
+
+#endif
diff -urN libfreerdp/core/update.c ../../informatimago/FreeRDP/libfreerdp/core/update.c
--- libfreerdp/core/update.c	2019-07-25 19:51:04.225914102 +0300
+++ ../../informatimago/FreeRDP/libfreerdp/core/update.c	2019-07-25 20:11:28.191983792 +0300
@@ -85,8 +85,6 @@
 
 static BOOL update_read_bitmap_data(rdpUpdate* update, wStream* s, BITMAP_DATA* bitmapData)
 {
-	WINPR_UNUSED(update);
-
 	if (Stream_GetRemainingLength(s) < 18)
 		return FALSE;
 
@@ -141,19 +139,16 @@
 	if (!Stream_EnsureRemainingCapacity(s, 64 + bitmapData->bitmapLength))
 		return FALSE;
 
-	if (update->autoCalculateBitmapData)
-	{
-		bitmapData->flags = 0;
-		bitmapData->cbCompFirstRowSize = 0;
+	bitmapData->flags = 0;
+	bitmapData->cbCompFirstRowSize = 0;
 
-		if (bitmapData->compressed)
-			bitmapData->flags |= BITMAP_COMPRESSION;
+	if (bitmapData->compressed)
+		bitmapData->flags |= BITMAP_COMPRESSION;
 
-		if (update->context->settings->NoBitmapCompressionHeader)
-		{
-			bitmapData->flags |= NO_BITMAP_COMPRESSION_HDR;
-			bitmapData->cbCompMainBodySize = bitmapData->bitmapLength;
-		}
+	if (update->context->settings->NoBitmapCompressionHeader)
+	{
+		bitmapData->flags |= NO_BITMAP_COMPRESSION_HDR;
+		bitmapData->cbCompMainBodySize = bitmapData->bitmapLength;
 	}
 
 	Stream_Write_UINT16(s, bitmapData->destLeft);
@@ -290,7 +285,6 @@
 
 static void update_read_synchronize(rdpUpdate* update, wStream* s)
 {
-	WINPR_UNUSED(update);
 	Stream_Seek_UINT16(s); /* pad2Octets (2 bytes) */
 	                       /**
 	                        * The Synchronize Update is an artifact from the
@@ -632,8 +626,8 @@
 	Stream_Read_UINT16(s, updateType); /* updateType (2 bytes) */
 	WLog_Print(update->log, WLOG_TRACE, "%s Update Data PDU", UPDATE_TYPE_STRINGS[updateType]);
 
-	if (!update_begin_paint(update))
-		goto fail;
+	if (!IFCALLRESULT(TRUE, update->BeginPaint, context))
+		return FALSE;
 
 	switch (updateType)
 	{
@@ -648,7 +642,7 @@
 		if (!bitmap_update)
 		{
 			WLog_ERR(TAG, "UPDATE_TYPE_BITMAP - update_read_bitmap_update() failed");
-			goto fail;
+			return FALSE;
 		}
 
 		rc = IFCALLRESULT(FALSE, update->BitmapUpdate, context, bitmap_update);
@@ -663,7 +657,7 @@
 		if (!palette_update)
 		{
 			WLog_ERR(TAG, "UPDATE_TYPE_PALETTE - update_read_palette() failed");
-			goto fail;
+			return FALSE;
 		}
 
 		rc = IFCALLRESULT(FALSE, update->Palette, context, palette_update);
@@ -680,11 +674,6 @@
 		break;
 	}
 
-fail:
-
-	if (!update_end_paint(update))
-		rc = FALSE;
-
 	if (!rc)
 	{
 		WLog_ERR(TAG, "UPDATE_TYPE %s [%" PRIu16 "] failed", update_type_to_string(updateType),
@@ -692,6 +681,9 @@
 		return FALSE;
 	}
 
+	if (!IFCALLRESULT(FALSE, update->EndPaint, context))
+		return FALSE;
+
 	return TRUE;
 }
 
@@ -762,16 +754,13 @@
 	update->initialState = TRUE;
 }
 
-static BOOL _update_begin_paint(rdpContext* context)
+static BOOL update_begin_paint(rdpContext* context)
 {
 	wStream* s;
 	rdpUpdate* update = context->update;
 
 	if (update->us)
-	{
-		if (!update_end_paint(update))
-			return FALSE;
-	}
+		update->EndPaint(context);
 
 	s = fastpath_update_pdu_init_new(context->rdp->fastpath);
 
@@ -786,7 +775,7 @@
 	return TRUE;
 }
 
-static BOOL _update_end_paint(rdpContext* context)
+static BOOL update_end_paint(rdpContext* context)
 {
 	wStream* s;
 	int headerLength;
@@ -804,7 +793,7 @@
 
 	if (update->numberOrders > 0)
 	{
-		WLog_DBG(TAG, "sending %" PRIu16 " orders", update->numberOrders);
+		WLog_ERR(TAG, "sending %" PRIu16 " orders", update->numberOrders);
 		fastpath_send_update_pdu(context->rdp->fastpath, FASTPATH_UPDATETYPE_ORDERS, s, FALSE);
 	}
 
@@ -821,14 +810,20 @@
 
 	if (update->numberOrders > 0)
 	{
-		update_end_paint(update);
-		update_begin_paint(update);
+		update->EndPaint(context);
+		update->BeginPaint(context);
 	}
 }
 
 static void update_force_flush(rdpContext* context)
 {
-	update_flush(context);
+	rdpUpdate* update = context->update;
+
+	if (update->numberOrders > 0)
+	{
+		update->EndPaint(context);
+		update->BeginPaint(context);
+	}
 }
 
 static BOOL update_check_flush(rdpContext* context, int size)
@@ -839,7 +834,7 @@
 
 	if (!update->us)
 	{
-		update_begin_paint(update);
+		update->BeginPaint(context);
 		return FALSE;
 	}
 
@@ -947,10 +942,9 @@
 	return length;
 }
 
-int update_write_order_info(rdpContext* context, wStream* s, ORDER_INFO* orderInfo, size_t offset)
+int update_write_order_info(rdpContext* context, wStream* s, ORDER_INFO* orderInfo, int offset)
 {
 	size_t position;
-	WINPR_UNUSED(context);
 	position = Stream_GetPosition(s);
 	Stream_SetPosition(s, offset);
 	Stream_Write_UINT8(s, orderInfo->controlFlags); /* controlFlags (1 byte) */
@@ -1223,7 +1217,6 @@
 	Stream_Write_UINT32(s, play_sound->frequency);
 	return rdp_send_data_pdu(rdp, s, DATA_PDU_TYPE_PLAY_SOUND, rdp->mcs->userId);
 }
-
 /**
  * Primary Drawing Orders
  */
@@ -2018,8 +2011,8 @@
 
 void update_register_server_callbacks(rdpUpdate* update)
 {
-	update->BeginPaint = _update_begin_paint;
-	update->EndPaint = _update_end_paint;
+	update->BeginPaint = update_begin_paint;
+	update->EndPaint = update_end_paint;
 	update->SetBounds = update_set_bounds;
 	update->Synchronize = update_send_synchronize;
 	update->DesktopResize = update_send_desktop_resize;
@@ -2032,7 +2025,6 @@
 	update->SetKeyboardIndicators = update_send_set_keyboard_indicators;
 	update->SetKeyboardImeStatus = update_send_set_keyboard_ime_status;
 	update->SaveSessionInfo = rdp_send_save_session_info;
-	update->ServerStatusInfo = rdp_send_server_status_info;
 	update->primary->DstBlt = update_send_dstblt;
 	update->primary->PatBlt = update_send_patblt;
 	update->primary->ScrBlt = update_send_scrblt;
@@ -2074,16 +2066,17 @@
 	update_message_queue_free_message(msg);
 }
 
-void update_free_window_state(WINDOW_STATE_ORDER* window_state)
+static void update_free_window_state(WINDOW_STATE_ORDER* window_state)
 {
 	if (!window_state)
 		return;
 
-	free(window_state->OverlayDescription.string);
 	free(window_state->titleInfo.string);
+	window_state->titleInfo.string = NULL;
 	free(window_state->windowRects);
+	window_state->windowRects = NULL;
 	free(window_state->visibilityRects);
-	memset(window_state, 0, sizeof(WINDOW_STATE_ORDER));
+	window_state->visibilityRects = NULL;
 }
 
 rdpUpdate* update_new(rdpRdp* rdp)
@@ -2091,14 +2084,12 @@
 	const wObject cb = { NULL, NULL, NULL, update_free_queued_message, NULL };
 	rdpUpdate* update;
 	OFFSCREEN_DELETE_LIST* deleteList;
-	WINPR_UNUSED(rdp);
 	update = (rdpUpdate*)calloc(1, sizeof(rdpUpdate));
 
 	if (!update)
 		return NULL;
 
 	update->log = WLog_Get("com.freerdp.core.update");
-	InitializeCriticalSection(&(update->mux));
 	update->pointer = (rdpPointerUpdate*)calloc(1, sizeof(rdpPointerUpdate));
 
 	if (!update->pointer)
@@ -2134,7 +2125,6 @@
 	deleteList->cIndices = 0;
 	update->SuppressOutput = update_send_suppress_output;
 	update->initialState = TRUE;
-	update->autoCalculateBitmapData = TRUE;
 	update->queue = MessageQueue_New(&cb);
 
 	if (!update->queue)
@@ -2170,38 +2160,13 @@
 
 		if (update->window)
 		{
+			free(update->window->monitored_desktop.windowIds);
+			update_free_window_state(&update->window->window_state);
+			update_free_window_icon_info(update->window->window_icon.iconInfo);
 			free(update->window);
 		}
 
 		MessageQueue_Free(update->queue);
-		DeleteCriticalSection(&update->mux);
 		free(update);
 	}
 }
-
-BOOL update_begin_paint(rdpUpdate* update)
-{
-	if (!update)
-		return FALSE;
-
-	EnterCriticalSection(&update->mux);
-
-	if (!update->BeginPaint)
-		return TRUE;
-
-	return update->BeginPaint(update->context);
-}
-
-BOOL update_end_paint(rdpUpdate* update)
-{
-	BOOL rc = FALSE;
-
-	if (!update)
-		return FALSE;
-
-	if (update->EndPaint)
-		rc = update->EndPaint(update->context);
-
-	LeaveCriticalSection(&update->mux);
-	return rc;
-}
diff -urN libfreerdp/core/update.h ../../informatimago/FreeRDP/libfreerdp/core/update.h
--- libfreerdp/core/update.h	2019-07-25 19:51:04.229914122 +0300
+++ ../../informatimago/FreeRDP/libfreerdp/core/update.h	2019-07-25 20:11:28.195983812 +0300
@@ -64,7 +64,4 @@
 FREERDP_LOCAL void update_register_client_callbacks(rdpUpdate* update);
 FREERDP_LOCAL int update_process_messages(rdpUpdate* update);
 
-FREERDP_LOCAL BOOL update_begin_paint(rdpUpdate* update);
-FREERDP_LOCAL BOOL update_end_paint(rdpUpdate* update);
-
 #endif /* FREERDP_LIB_CORE_UPDATE_H */
diff -urN libfreerdp/core/window.c ../../informatimago/FreeRDP/libfreerdp/core/window.c
--- libfreerdp/core/window.c	2019-07-25 19:51:04.245914201 +0300
+++ ../../informatimago/FreeRDP/libfreerdp/core/window.c	2019-07-25 20:11:28.207983872 +0300
@@ -30,8 +30,6 @@
 
 #define TAG FREERDP_TAG("core.window")
 
-static void update_free_window_icon_info(ICON_INFO* iconInfo);
-
 BOOL rail_read_unicode_string(wStream* s, RAIL_UNICODE_STRING* unicode_string)
 {
 	UINT16 new_len;
@@ -201,8 +199,8 @@
 static BOOL update_read_window_state_order(wStream* s, WINDOW_ORDER_INFO* orderInfo,
                                            WINDOW_STATE_ORDER* windowState)
 {
-	UINT32 i;
-	size_t size;
+	int i;
+	int size;
 	RECTANGLE_16* newRect;
 
 	if (orderInfo->fieldFlags & WINDOW_ORDER_FIELD_OWNER)
@@ -238,40 +236,22 @@
 
 	if (orderInfo->fieldFlags & WINDOW_ORDER_FIELD_CLIENT_AREA_OFFSET)
 	{
-		if (Stream_GetRemainingLength(s) < 8)
+		if (Stream_GetRemainingLength(s) < 4)
 			return FALSE;
 
-		Stream_Read_INT32(s, windowState->clientOffsetX); /* clientOffsetX (4 bytes) */
-		Stream_Read_INT32(s, windowState->clientOffsetY); /* clientOffsetY (4 bytes) */
+		Stream_Read_UINT32(s, windowState->clientOffsetX); /* clientOffsetX (4 bytes) */
+		Stream_Read_UINT32(s, windowState->clientOffsetY); /* clientOffsetY (4 bytes) */
 	}
 
 	if (orderInfo->fieldFlags & WINDOW_ORDER_FIELD_CLIENT_AREA_SIZE)
 	{
-		if (Stream_GetRemainingLength(s) < 8)
+		if (Stream_GetRemainingLength(s) < 4)
 			return FALSE;
 
 		Stream_Read_UINT32(s, windowState->clientAreaWidth);  /* clientAreaWidth (4 bytes) */
 		Stream_Read_UINT32(s, windowState->clientAreaHeight); /* clientAreaHeight (4 bytes) */
 	}
 
-	if (orderInfo->fieldFlags & WINDOW_ORDER_FIELD_RESIZE_MARGIN_X)
-	{
-		if (Stream_GetRemainingLength(s) < 8)
-			return FALSE;
-
-		Stream_Read_UINT32(s, windowState->resizeMarginLeft);
-		Stream_Read_UINT32(s, windowState->resizeMarginRight);
-	}
-
-	if (orderInfo->fieldFlags & WINDOW_ORDER_FIELD_RESIZE_MARGIN_Y)
-	{
-		if (Stream_GetRemainingLength(s) < 8)
-			return FALSE;
-
-		Stream_Read_UINT32(s, windowState->resizeMarginTop);
-		Stream_Read_UINT32(s, windowState->resizeMarginBottom);
-	}
-
 	if (orderInfo->fieldFlags & WINDOW_ORDER_FIELD_RP_CONTENT)
 	{
 		if (Stream_GetRemainingLength(s) < 1)
@@ -293,8 +273,8 @@
 		if (Stream_GetRemainingLength(s) < 8)
 			return FALSE;
 
-		Stream_Read_INT32(s, windowState->windowOffsetX); /* windowOffsetX (4 bytes) */
-		Stream_Read_INT32(s, windowState->windowOffsetY); /* windowOffsetY (4 bytes) */
+		Stream_Read_UINT32(s, windowState->windowOffsetX); /* windowOffsetX (4 bytes) */
+		Stream_Read_UINT32(s, windowState->windowOffsetY); /* windowOffsetY (4 bytes) */
 	}
 
 	if (orderInfo->fieldFlags & WINDOW_ORDER_FIELD_WND_CLIENT_DELTA)
@@ -302,8 +282,8 @@
 		if (Stream_GetRemainingLength(s) < 8)
 			return FALSE;
 
-		Stream_Read_INT32(s, windowState->windowClientDeltaX); /* windowClientDeltaX (4 bytes) */
-		Stream_Read_INT32(s, windowState->windowClientDeltaY); /* windowClientDeltaY (4 bytes) */
+		Stream_Read_UINT32(s, windowState->windowClientDeltaX); /* windowClientDeltaX (4 bytes) */
+		Stream_Read_UINT32(s, windowState->windowClientDeltaY); /* windowClientDeltaY (4 bytes) */
 	}
 
 	if (orderInfo->fieldFlags & WINDOW_ORDER_FIELD_WND_SIZE)
@@ -343,7 +323,7 @@
 			return FALSE;
 
 		/* windowRects */
-		for (i = 0; i < windowState->numWindowRects; i++)
+		for (i = 0; i < (int)windowState->numWindowRects; i++)
 		{
 			Stream_Read_UINT16(s, windowState->windowRects[i].left);   /* left (2 bytes) */
 			Stream_Read_UINT16(s, windowState->windowRects[i].top);    /* top (2 bytes) */
@@ -354,7 +334,7 @@
 
 	if (orderInfo->fieldFlags & WINDOW_ORDER_FIELD_VIS_OFFSET)
 	{
-		if (Stream_GetRemainingLength(s) < 8)
+		if (Stream_GetRemainingLength(s) < 4)
 			return FALSE;
 
 		Stream_Read_UINT32(s, windowState->visibleOffsetX); /* visibleOffsetX (4 bytes) */
@@ -368,76 +348,34 @@
 
 		Stream_Read_UINT16(s, windowState->numVisibilityRects); /* numVisibilityRects (2 bytes) */
 
-		if (windowState->numVisibilityRects != 0)
+		if (windowState->numVisibilityRects == 0)
 		{
-			size = sizeof(RECTANGLE_16) * windowState->numVisibilityRects;
-			newRect = (RECTANGLE_16*)realloc(windowState->visibilityRects, size);
-
-			if (!newRect)
-			{
-				free(windowState->visibilityRects);
-				windowState->visibilityRects = NULL;
-				return FALSE;
-			}
-
-			windowState->visibilityRects = newRect;
-
-			if (Stream_GetRemainingLength(s) < windowState->numVisibilityRects * 8)
-				return FALSE;
-
-			/* visibilityRects */
-			for (i = 0; i < windowState->numVisibilityRects; i++)
-			{
-				Stream_Read_UINT16(s, windowState->visibilityRects[i].left);  /* left (2 bytes) */
-				Stream_Read_UINT16(s, windowState->visibilityRects[i].top);   /* top (2 bytes) */
-				Stream_Read_UINT16(s, windowState->visibilityRects[i].right); /* right (2 bytes) */
-				Stream_Read_UINT16(s,
-				                   windowState->visibilityRects[i].bottom); /* bottom (2 bytes) */
-			}
+			return TRUE;
 		}
-	}
-
-	if (orderInfo->fieldFlags & WINDOW_ORDER_FIELD_OVERLAY_DESCRIPTION)
-	{
-		if (!rail_read_unicode_string(s, &windowState->OverlayDescription))
-			return FALSE;
-	}
-
-	if (orderInfo->fieldFlags & WINDOW_ORDER_FIELD_ICON_OVERLAY_NULL)
-	{
-		/* no data to be read here */
-	}
 
-	if (orderInfo->fieldFlags & WINDOW_ORDER_FIELD_TASKBAR_BUTTON)
-	{
-		if (Stream_GetRemainingLength(s) < 1)
-			return FALSE;
-
-		Stream_Read_UINT8(s, windowState->TaskbarButton);
-	}
+		size = sizeof(RECTANGLE_16) * windowState->numVisibilityRects;
+		newRect = (RECTANGLE_16*)realloc(windowState->visibilityRects, size);
 
-	if (orderInfo->fieldFlags & WINDOW_ORDER_FIELD_ENFORCE_SERVER_ZORDER)
-	{
-		if (Stream_GetRemainingLength(s) < 1)
-			return FALSE;
-
-		Stream_Read_UINT8(s, windowState->EnforceServerZOrder);
-	}
-
-	if (orderInfo->fieldFlags & WINDOW_ORDER_FIELD_APPBAR_STATE)
-	{
-		if (Stream_GetRemainingLength(s) < 1)
+		if (!newRect)
+		{
+			free(windowState->visibilityRects);
+			windowState->visibilityRects = NULL;
 			return FALSE;
+		}
 
-		Stream_Read_UINT8(s, windowState->AppBarState);
-	}
+		windowState->visibilityRects = newRect;
 
-	if (orderInfo->fieldFlags & WINDOW_ORDER_FIELD_APPBAR_EDGE)
-	{
-		if (Stream_GetRemainingLength(s) < 1)
+		if (Stream_GetRemainingLength(s) < windowState->numVisibilityRects * 8)
 			return FALSE;
 
-		Stream_Read_UINT8(s, windowState->AppBarEdge);
+		/* visibilityRects */
+		for (i = 0; i < (int)windowState->numVisibilityRects; i++)
+		{
+			Stream_Read_UINT16(s, windowState->visibilityRects[i].left);   /* left (2 bytes) */
+			Stream_Read_UINT16(s, windowState->visibilityRects[i].top);    /* top (2 bytes) */
+			Stream_Read_UINT16(s, windowState->visibilityRects[i].right);  /* right (2 bytes) */
+			Stream_Read_UINT16(s, windowState->visibilityRects[i].bottom); /* bottom (2 bytes) */
+		}
 	}
 
 	return TRUE;
@@ -446,7 +384,7 @@
 static BOOL update_read_window_icon_order(wStream* s, WINDOW_ORDER_INFO* orderInfo,
                                           WINDOW_ICON_ORDER* window_icon)
 {
-	WINPR_UNUSED(orderInfo);
+	update_free_window_icon_info(window_icon->iconInfo);
 	window_icon->iconInfo = (ICON_INFO*)calloc(1, sizeof(ICON_INFO));
 
 	if (!window_icon->iconInfo)
@@ -458,7 +396,6 @@
 static BOOL update_read_window_cached_icon_order(wStream* s, WINDOW_ORDER_INFO* orderInfo,
                                                  WINDOW_CACHED_ICON_ORDER* window_cached_icon)
 {
-	WINPR_UNUSED(orderInfo);
 	return update_read_cached_icon_info(
 	    s, &window_cached_icon->cachedIcon); /* cachedIcon (CACHED_ICON_INFO) */
 }
@@ -496,210 +433,6 @@
 	}
 }
 
-#define DUMP_APPEND(buffer, size, ...)            \
-	do                                            \
-	{                                             \
-		char* b = (buffer);                       \
-		size_t s = (size);                        \
-		size_t pos = strnlen(b, s);               \
-		_snprintf(&b[pos], s - pos, __VA_ARGS__); \
-	} while (0)
-
-static void dump_window_state_order(wLog* log, const char* msg, const WINDOW_ORDER_INFO* order,
-                                    const WINDOW_STATE_ORDER* state)
-{
-	char buffer[3000] = { 0 };
-	const size_t bufferSize = sizeof(buffer) - 1;
-	_snprintf(buffer, bufferSize, "%s windowId=0x%" PRIu32 "", msg, order->windowId);
-
-	if (order->fieldFlags & WINDOW_ORDER_FIELD_OWNER)
-		DUMP_APPEND(buffer, bufferSize, " owner=0x%" PRIx32 "", state->ownerWindowId);
-
-	if (order->fieldFlags & WINDOW_ORDER_FIELD_STYLE)
-	{
-		DUMP_APPEND(buffer, bufferSize, " [ex]style=<0x%" PRIx32 ", 0x%" PRIx32 "", state->style,
-		            state->extendedStyle);
-
-		if (state->style & WS_POPUP)
-			DUMP_APPEND(buffer, bufferSize, " popup");
-
-		if (state->style & WS_VISIBLE)
-			DUMP_APPEND(buffer, bufferSize, " visible");
-
-		if (state->style & WS_THICKFRAME)
-			DUMP_APPEND(buffer, bufferSize, " thickframe");
-
-		if (state->style & WS_BORDER)
-			DUMP_APPEND(buffer, bufferSize, " border");
-
-		if (state->style & WS_CAPTION)
-			DUMP_APPEND(buffer, bufferSize, " caption");
-
-		if (state->extendedStyle & WS_EX_NOACTIVATE)
-			DUMP_APPEND(buffer, bufferSize, " noactivate");
-
-		if (state->extendedStyle & WS_EX_TOOLWINDOW)
-			DUMP_APPEND(buffer, bufferSize, " toolWindow");
-
-		if (state->extendedStyle & WS_EX_TOPMOST)
-			DUMP_APPEND(buffer, bufferSize, " topMost");
-
-		DUMP_APPEND(buffer, bufferSize, ">");
-	}
-
-	if (order->fieldFlags & WINDOW_ORDER_FIELD_SHOW)
-	{
-		const char* showStr;
-
-		switch (state->showState)
-		{
-		case 0:
-			showStr = "hidden";
-			break;
-
-		case 2:
-			showStr = "minimized";
-			break;
-
-		case 3:
-			showStr = "maximized";
-			break;
-
-		case 5:
-			showStr = "current";
-			break;
-
-		default:
-			showStr = "<unknown>";
-			break;
-		}
-
-		DUMP_APPEND(buffer, bufferSize, " show=%s", showStr);
-	}
-
-	if (order->fieldFlags & WINDOW_ORDER_FIELD_TITLE)
-		DUMP_APPEND(buffer, bufferSize, " title");
-
-	if (order->fieldFlags & WINDOW_ORDER_FIELD_CLIENT_AREA_OFFSET)
-		DUMP_APPEND(buffer, bufferSize, " clientOffsetX=%" PRId32 " clientOffsetY=%" PRId32 "",
-		            state->clientOffsetX, state->clientOffsetY);
-
-	if (order->fieldFlags & WINDOW_ORDER_FIELD_CLIENT_AREA_SIZE)
-		DUMP_APPEND(buffer, bufferSize, " clientAreaWidth=%" PRIu32 " clientAreaHeight=%" PRIu32 "",
-		            state->clientAreaWidth, state->clientAreaHeight);
-
-	if (order->fieldFlags & WINDOW_ORDER_FIELD_RESIZE_MARGIN_X)
-		DUMP_APPEND(buffer, bufferSize,
-		            " resizeMarginLeft=%" PRIu32 " resizeMarginRight=%" PRIu32 "",
-		            state->resizeMarginLeft, state->resizeMarginRight);
-
-	if (order->fieldFlags & WINDOW_ORDER_FIELD_RESIZE_MARGIN_Y)
-		DUMP_APPEND(buffer, bufferSize,
-		            " resizeMarginTop=%" PRIu32 " resizeMarginBottom=%" PRIu32 "",
-		            state->resizeMarginTop, state->resizeMarginBottom);
-
-	if (order->fieldFlags & WINDOW_ORDER_FIELD_RP_CONTENT)
-		DUMP_APPEND(buffer, bufferSize, " rpContent=0x%" PRIx32 "", state->RPContent);
-
-	if (order->fieldFlags & WINDOW_ORDER_FIELD_ROOT_PARENT)
-		DUMP_APPEND(buffer, bufferSize, " rootParent=0x%" PRIx32 "", state->rootParentHandle);
-
-	if (order->fieldFlags & WINDOW_ORDER_FIELD_WND_OFFSET)
-		DUMP_APPEND(buffer, bufferSize, " windowOffsetX=%" PRId32 " windowOffsetY=%" PRId32 "",
-		            state->windowOffsetX, state->windowOffsetY);
-
-	if (order->fieldFlags & WINDOW_ORDER_FIELD_WND_CLIENT_DELTA)
-		DUMP_APPEND(buffer, bufferSize,
-		            " windowClientDeltaX=%" PRId32 " windowClientDeltaY=%" PRId32 "",
-		            state->windowClientDeltaX, state->windowClientDeltaY);
-
-	if (order->fieldFlags & WINDOW_ORDER_FIELD_WND_SIZE)
-		DUMP_APPEND(buffer, bufferSize, " windowWidth=%" PRIu32 " windowHeight=%" PRIu32 "",
-		            state->windowWidth, state->windowHeight);
-
-	if (order->fieldFlags & WINDOW_ORDER_FIELD_WND_RECTS)
-	{
-		UINT32 i;
-		DUMP_APPEND(buffer, bufferSize, " windowRects=(");
-
-		for (i = 0; i < state->numWindowRects; i++)
-		{
-			DUMP_APPEND(buffer, bufferSize, "(%" PRIu16 ",%" PRIu16 ",%" PRIu16 ",%" PRIu16 ")",
-			            state->windowRects[i].left, state->windowRects[i].top,
-			            state->windowRects[i].right, state->windowRects[i].bottom);
-		}
-
-		DUMP_APPEND(buffer, bufferSize, ")");
-	}
-
-	if (order->fieldFlags & WINDOW_ORDER_FIELD_VIS_OFFSET)
-		DUMP_APPEND(buffer, bufferSize, " visibleOffsetX=%" PRId32 " visibleOffsetY=%" PRId32 "",
-		            state->visibleOffsetX, state->visibleOffsetY);
-
-	if (order->fieldFlags & WINDOW_ORDER_FIELD_VISIBILITY)
-	{
-		UINT32 i;
-		DUMP_APPEND(buffer, bufferSize, " visibilityRects=(");
-
-		for (i = 0; i < state->numVisibilityRects; i++)
-		{
-			DUMP_APPEND(buffer, bufferSize, "(%" PRIu16 ",%" PRIu16 ",%" PRIu16 ",%" PRIu16 ")",
-			            state->visibilityRects[i].left, state->visibilityRects[i].top,
-			            state->visibilityRects[i].right, state->visibilityRects[i].bottom);
-		}
-
-		DUMP_APPEND(buffer, bufferSize, ")");
-	}
-
-	if (order->fieldFlags & WINDOW_ORDER_FIELD_OVERLAY_DESCRIPTION)
-		DUMP_APPEND(buffer, bufferSize, " overlayDescr");
-
-	if (order->fieldFlags & WINDOW_ORDER_FIELD_ICON_OVERLAY_NULL)
-		DUMP_APPEND(buffer, bufferSize, " iconOverlayNull");
-
-	if (order->fieldFlags & WINDOW_ORDER_FIELD_TASKBAR_BUTTON)
-		DUMP_APPEND(buffer, bufferSize, " taskBarButton=0x%" PRIx8 "", state->TaskbarButton);
-
-	if (order->fieldFlags & WINDOW_ORDER_FIELD_ENFORCE_SERVER_ZORDER)
-		DUMP_APPEND(buffer, bufferSize, " enforceServerZOrder=0x%" PRIx8 "",
-		            state->EnforceServerZOrder);
-
-	if (order->fieldFlags & WINDOW_ORDER_FIELD_APPBAR_STATE)
-		DUMP_APPEND(buffer, bufferSize, " appBarState=0x%" PRIx8 "", state->AppBarState);
-
-	if (order->fieldFlags & WINDOW_ORDER_FIELD_APPBAR_EDGE)
-	{
-		const char* appBarEdgeStr;
-
-		switch (state->AppBarEdge)
-		{
-		case 0:
-			appBarEdgeStr = "left";
-			break;
-
-		case 1:
-			appBarEdgeStr = "top";
-			break;
-
-		case 2:
-			appBarEdgeStr = "right";
-			break;
-
-		case 3:
-			appBarEdgeStr = "bottom";
-			break;
-
-		default:
-			appBarEdgeStr = "<unknown>";
-			break;
-		}
-
-		DUMP_APPEND(buffer, bufferSize, " appBarEdge=%s", appBarEdgeStr);
-	}
-
-	WLog_Print(log, WLOG_DEBUG, buffer);
-}
-
 static BOOL update_recv_window_info_order(rdpUpdate* update, wStream* s,
                                           WINDOW_ORDER_INFO* orderInfo)
 {
@@ -714,72 +447,47 @@
 
 	if (orderInfo->fieldFlags & WINDOW_ORDER_ICON)
 	{
-		WINDOW_ICON_ORDER window_icon = { 0 };
-		result = update_read_window_icon_order(s, orderInfo, &window_icon);
-
-		if (result)
-		{
-			WLog_Print(update->log, WLOG_DEBUG, "WindowIcon windowId=0x%" PRIx32 "",
-			           orderInfo->windowId);
-			IFCALLRET(window->WindowIcon, result, context, orderInfo, &window_icon);
-		}
+		if (!update_read_window_icon_order(s, orderInfo, &window->window_icon))
+			return FALSE;
 
-		update_free_window_icon_info(window_icon.iconInfo);
-		free(window_icon.iconInfo);
+		WLog_Print(update->log, WLOG_DEBUG, "WindowIcon");
+		IFCALLRET(window->WindowIcon, result, context, orderInfo, &window->window_icon);
 	}
 	else if (orderInfo->fieldFlags & WINDOW_ORDER_CACHED_ICON)
 	{
-		WINDOW_CACHED_ICON_ORDER window_cached_icon = { 0 };
-		result = update_read_window_cached_icon_order(s, orderInfo, &window_cached_icon);
+		if (!update_read_window_cached_icon_order(s, orderInfo, &window->window_cached_icon))
+			return FALSE;
 
-		if (result)
-		{
-			WLog_Print(update->log, WLOG_DEBUG, "WindowCachedIcon windowId=0x%" PRIx32 "",
-			           orderInfo->windowId);
-			IFCALLRET(window->WindowCachedIcon, result, context, orderInfo, &window_cached_icon);
-		}
+		WLog_Print(update->log, WLOG_DEBUG, "WindowCachedIcon");
+		IFCALLRET(window->WindowCachedIcon, result, context, orderInfo,
+		          &window->window_cached_icon);
 	}
 	else if (orderInfo->fieldFlags & WINDOW_ORDER_STATE_DELETED)
 	{
 		update_read_window_delete_order(s, orderInfo);
-		WLog_Print(update->log, WLOG_DEBUG, "WindowDelete windowId=0x%" PRIx32 "",
-		           orderInfo->windowId);
+		WLog_Print(update->log, WLOG_DEBUG, "WindowDelete");
 		IFCALLRET(window->WindowDelete, result, context, orderInfo);
 	}
 	else
 	{
-		WINDOW_STATE_ORDER windowState = { 0 };
-		result = update_read_window_state_order(s, orderInfo, &windowState);
+		if (!update_read_window_state_order(s, orderInfo, &window->window_state))
+			return FALSE;
 
-		if (result)
+		if (orderInfo->fieldFlags & WINDOW_ORDER_STATE_NEW)
 		{
-			if (orderInfo->fieldFlags & WINDOW_ORDER_STATE_NEW)
-			{
-				dump_window_state_order(update->log, "WindowCreate", orderInfo, &windowState);
-				IFCALLRET(window->WindowCreate, result, context, orderInfo, &windowState);
-			}
-			else
-			{
-				dump_window_state_order(update->log, "WindowUpdate", orderInfo, &windowState);
-				IFCALLRET(window->WindowUpdate, result, context, orderInfo, &windowState);
-			}
-
-			update_free_window_state(&windowState);
+			WLog_Print(update->log, WLOG_DEBUG, "WindowCreate");
+			IFCALLRET(window->WindowCreate, result, context, orderInfo, &window->window_state);
+		}
+		else
+		{
+			WLog_Print(update->log, WLOG_DEBUG, "WindowUpdate");
+			IFCALLRET(window->WindowUpdate, result, context, orderInfo, &window->window_state);
 		}
 	}
 
 	return result;
 }
 
-static void update_notify_icon_state_order_free(NOTIFY_ICON_STATE_ORDER* notify)
-{
-	free(notify->toolTip.string);
-	free(notify->infoTip.text.string);
-	free(notify->infoTip.title.string);
-	update_free_window_icon_info(&notify->icon);
-	memset(notify, 0, sizeof(NOTIFY_ICON_STATE_ORDER));
-}
-
 static BOOL update_read_notification_icon_state_order(wStream* s, WINDOW_ORDER_INFO* orderInfo,
                                                       NOTIFY_ICON_STATE_ORDER* notify_icon_state)
 {
@@ -855,25 +563,21 @@
 	}
 	else
 	{
-		NOTIFY_ICON_STATE_ORDER notify_icon_state = { 0 };
-		result = update_read_notification_icon_state_order(s, orderInfo, &notify_icon_state);
-
-		if (!result)
-			goto fail;
+		if (!update_read_notification_icon_state_order(s, orderInfo, &window->notify_icon_state))
+			return FALSE;
 
 		if (orderInfo->fieldFlags & WINDOW_ORDER_STATE_NEW)
 		{
 			WLog_Print(update->log, WLOG_DEBUG, "NotifyIconCreate");
-			IFCALLRET(window->NotifyIconCreate, result, context, orderInfo, &notify_icon_state);
+			IFCALLRET(window->NotifyIconCreate, result, context, orderInfo,
+			          &window->notify_icon_state);
 		}
 		else
 		{
 			WLog_Print(update->log, WLOG_DEBUG, "NotifyIconUpdate");
-			IFCALLRET(window->NotifyIconUpdate, result, context, orderInfo, &notify_icon_state);
+			IFCALLRET(window->NotifyIconUpdate, result, context, orderInfo,
+			          &window->notify_icon_state);
 		}
-
-	fail:
-		update_notify_icon_state_order_free(&notify_icon_state);
 	}
 
 	return result;
@@ -935,32 +639,6 @@
 	/* non-monitored desktop notification event */
 }
 
-static void dump_monitored_desktop(wLog* log, const char* msg, const WINDOW_ORDER_INFO* orderInfo,
-                                   const MONITORED_DESKTOP_ORDER* monitored)
-{
-	char buffer[1000] = { 0 };
-	const size_t bufferSize = sizeof(buffer) - 1;
-	DUMP_APPEND(buffer, bufferSize, "%s", msg);
-
-	if (orderInfo->fieldFlags & WINDOW_ORDER_FIELD_DESKTOP_ACTIVE_WND)
-		DUMP_APPEND(buffer, bufferSize, " activeWindowId=0x%" PRIx32 "", monitored->activeWindowId);
-
-	if (orderInfo->fieldFlags & WINDOW_ORDER_FIELD_DESKTOP_ZORDER)
-	{
-		UINT32 i;
-		DUMP_APPEND(buffer, bufferSize, " windows=(");
-
-		for (i = 0; i < monitored->numWindowIds; i++)
-		{
-			DUMP_APPEND(buffer, bufferSize, "0x%" PRIx32 ",", monitored->windowIds[i]);
-		}
-
-		DUMP_APPEND(buffer, bufferSize, ")");
-	}
-
-	WLog_Print(log, WLOG_DEBUG, buffer);
-}
-
 static BOOL update_recv_desktop_info_order(rdpUpdate* update, wStream* s,
                                            WINDOW_ORDER_INFO* orderInfo)
 {
@@ -971,23 +649,16 @@
 	if (orderInfo->fieldFlags & WINDOW_ORDER_FIELD_DESKTOP_NONE)
 	{
 		update_read_desktop_non_monitored_order(s, orderInfo);
-		WLog_Print(update->log, WLOG_DEBUG, "NonMonitoredDesktop, windowId=0x%" PRIx32 "",
-		           orderInfo->windowId);
+		WLog_Print(update->log, WLOG_DEBUG, "NonMonitoredDesktop");
 		IFCALLRET(window->NonMonitoredDesktop, result, context, orderInfo);
 	}
 	else
 	{
-		MONITORED_DESKTOP_ORDER monitored_desktop = { 0 };
-		result = update_read_desktop_actively_monitored_order(s, orderInfo, &monitored_desktop);
-
-		if (result)
-		{
-			dump_monitored_desktop(update->log, "ActivelyMonitoredDesktop", orderInfo,
-			                       &monitored_desktop);
-			IFCALLRET(window->MonitoredDesktop, result, context, orderInfo, &monitored_desktop);
-		}
+		if (!update_read_desktop_actively_monitored_order(s, orderInfo, &window->monitored_desktop))
+			return FALSE;
 
-		free(monitored_desktop.windowIds);
+		WLog_Print(update->log, WLOG_DEBUG, "ActivelyMonitoredDesktop");
+		IFCALLRET(window->MonitoredDesktop, result, context, orderInfo, &window->monitored_desktop);
 	}
 
 	return result;
@@ -1004,44 +675,37 @@
 	iconInfo->bitsMask = NULL;
 	free(iconInfo->colorTable);
 	iconInfo->colorTable = NULL;
+	free(iconInfo);
 }
 
 BOOL update_recv_altsec_window_order(rdpUpdate* update, wStream* s)
 {
 	BOOL rc = TRUE;
-	size_t remaining;
 	UINT16 orderSize;
-	WINDOW_ORDER_INFO orderInfo = { 0 };
-	remaining = Stream_GetRemainingLength(s);
+	rdpWindowUpdate* window = update->window;
 
-	if (remaining < 6)
+	if (Stream_GetRemainingLength(s) < 6)
 	{
 		WLog_Print(update->log, WLOG_ERROR, "Stream short");
 		return FALSE;
 	}
 
-	Stream_Read_UINT16(s, orderSize);            /* orderSize (2 bytes) */
-	Stream_Read_UINT32(s, orderInfo.fieldFlags); /* FieldsPresentFlags (4 bytes) */
-
-	if (remaining + 1 < orderSize)
-	{
-		WLog_Print(update->log, WLOG_ERROR, "Stream short orderSize");
-		return FALSE;
-	}
+	Stream_Read_UINT16(s, orderSize);                    /* orderSize (2 bytes) */
+	Stream_Read_UINT32(s, window->orderInfo.fieldFlags); /* FieldsPresentFlags (4 bytes) */
 
-	if (!window_order_supported(update->context->settings, orderInfo.fieldFlags))
+	if (!window_order_supported(update->context->settings, window->orderInfo.fieldFlags))
 		return FALSE;
 
-	if (orderInfo.fieldFlags & WINDOW_ORDER_TYPE_WINDOW)
-		rc = update_recv_window_info_order(update, s, &orderInfo);
-	else if (orderInfo.fieldFlags & WINDOW_ORDER_TYPE_NOTIFY)
-		rc = update_recv_notification_icon_info_order(update, s, &orderInfo);
-	else if (orderInfo.fieldFlags & WINDOW_ORDER_TYPE_DESKTOP)
-		rc = update_recv_desktop_info_order(update, s, &orderInfo);
+	if (window->orderInfo.fieldFlags & WINDOW_ORDER_TYPE_WINDOW)
+		rc = update_recv_window_info_order(update, s, &window->orderInfo);
+	else if (window->orderInfo.fieldFlags & WINDOW_ORDER_TYPE_NOTIFY)
+		rc = update_recv_notification_icon_info_order(update, s, &window->orderInfo);
+	else if (window->orderInfo.fieldFlags & WINDOW_ORDER_TYPE_DESKTOP)
+		rc = update_recv_desktop_info_order(update, s, &window->orderInfo);
 
 	if (!rc)
 		WLog_Print(update->log, WLOG_ERROR, "windoworder flags %08" PRIx32 " failed",
-		           orderInfo.fieldFlags);
+		           window->orderInfo.fieldFlags);
 
 	return rc;
 }
diff -urN libfreerdp/core/window.h ../../informatimago/FreeRDP/libfreerdp/core/window.h
--- libfreerdp/core/window.h	2019-07-25 19:51:04.245914201 +0300
+++ ../../informatimago/FreeRDP/libfreerdp/core/window.h	2019-07-25 20:11:28.207983872 +0300
@@ -27,8 +27,8 @@
 #include <freerdp/log.h>
 #include <freerdp/api.h>
 
+FREERDP_LOCAL void update_free_window_icon_info(ICON_INFO* iconInfo);
 FREERDP_LOCAL BOOL update_recv_altsec_window_order(rdpUpdate* update, wStream* s);
-FREERDP_LOCAL void update_free_window_state(WINDOW_STATE_ORDER* window_state);
 
 #define WND_TAG FREERDP_TAG("core.wnd")
 #ifdef WITH_DEBUG_WND
diff -urN libfreerdp/crypto/certificate.c ../../informatimago/FreeRDP/libfreerdp/crypto/certificate.c
--- libfreerdp/crypto/certificate.c	2019-07-25 19:51:04.265914300 +0300
+++ ../../informatimago/FreeRDP/libfreerdp/crypto/certificate.c	2019-07-25 20:11:28.231983991 +0300
@@ -436,7 +436,7 @@
 
 	if (!data)
 	{
-		CloseHandle(fp);
+		fclose(fp);
 		return FALSE;
 	}
 
@@ -493,8 +493,6 @@
 				          pline);
 			else
 			{
-				int res;
-
 				/* If this is the replaced hostname, use the updated fingerprint. */
 				if ((strcmp(hostname, certificate_data->hostname) == 0) &&
 				    (port == certificate_data->port))
@@ -503,17 +501,8 @@
 					rc = TRUE;
 				}
 
-				res = _snprintf(NULL, 0, "%s %" PRIu16 " %s %s %s\n", hostname, port, fingerprint,
-				                subject, issuer);
-
-				if (res < 0)
-				{
-					free(data);
-					CloseHandle(fp);
-					return FALSE;
-				}
-
-				size = (size_t)res;
+				size = _snprintf(NULL, 0, "%s %" PRIu16 " %s %s %s\n", hostname, port, fingerprint,
+				                 subject, issuer);
 				tdata = malloc(size + 1);
 
 				if (!tdata)
@@ -525,18 +514,8 @@
 					return FALSE;
 				}
 
-				res = _snprintf(tdata, size + 1, "%s %" PRIu16 " %s %s %s\n", hostname, port,
-				                fingerprint, subject, issuer);
-
-				if (res < 0)
-				{
-					free(tdata);
-					free(data);
-					CloseHandle(fp);
-					return FALSE;
-				}
-
-				if ((size_t)res != size)
+				if (_snprintf(tdata, size + 1, "%s %" PRIu16 " %s %s %s\n", hostname, port,
+				              fingerprint, subject, issuer) != size)
 				{
 					WLog_ERR(TAG, "_snprintf(%s) returned %s [0x%08X]", certificate_store->file,
 					         strerror(errno), errno);
@@ -615,10 +594,9 @@
 BOOL certificate_data_print(rdpCertificateStore* certificate_store,
                             rdpCertificateData* certificate_data)
 {
-	int rc;
 	HANDLE fp;
 	char* tdata;
-	size_t size;
+	UINT64 size;
 	DWORD written;
 	/* reopen in append mode */
 	/* Assure POSIX style paths, CreateFile expects either '/' or '\\' */
@@ -637,14 +615,9 @@
 		return FALSE;
 	}
 
-	rc = _snprintf(NULL, 0, "%s %" PRIu16 " %s %s %s\n", certificate_data->hostname,
-	               certificate_data->port, certificate_data->fingerprint, certificate_data->subject,
-	               certificate_data->issuer);
-
-	if (rc < 0)
-		return FALSE;
-
-	size = (size_t)rc;
+	size = _snprintf(NULL, 0, "%s %" PRIu16 " %s %s %s\n", certificate_data->hostname,
+	                 certificate_data->port, certificate_data->fingerprint,
+	                 certificate_data->subject, certificate_data->issuer);
 	tdata = malloc(size + 1);
 
 	if (!tdata)
@@ -655,11 +628,9 @@
 		return FALSE;
 	}
 
-	rc = _snprintf(tdata, size + 1, "%s %" PRIu16 " %s %s %s\n", certificate_data->hostname,
-	               certificate_data->port, certificate_data->fingerprint, certificate_data->subject,
-	               certificate_data->issuer);
-
-	if ((rc < 0) || ((size_t)rc != size))
+	if (_snprintf(tdata, size + 1, "%s %" PRIu16 " %s %s %s\n", certificate_data->hostname,
+	              certificate_data->port, certificate_data->fingerprint, certificate_data->subject,
+	              certificate_data->issuer) != size)
 	{
 		WLog_ERR(TAG, "_snprintf(%s) returned %s [0x%08X]", certificate_store->file,
 		         strerror(errno), errno);
diff -urN libfreerdp/crypto/crypto.c ../../informatimago/FreeRDP/libfreerdp/crypto/crypto.c
--- libfreerdp/crypto/crypto.c	2019-07-25 19:51:04.281914379 +0300
+++ ../../informatimago/FreeRDP/libfreerdp/crypto/crypto.c	2019-07-25 20:11:28.243984050 +0300
@@ -309,8 +309,7 @@
 
 static const char* general_name_type_label(int general_name_type)
 {
-	if ((0 <= general_name_type) &&
-	    ((size_t)general_name_type < ARRAYSIZE(general_name_type_labels)))
+	if ((0 <= general_name_type) && (general_name_type < ARRAYSIZE(general_name_type_labels)))
 	{
 		return general_name_type_labels[general_name_type];
 	}
@@ -740,28 +739,13 @@
 	return crypto_print_name(X509_get_issuer_name(xcert));
 }
 
-static int verify_cb(int ok, X509_STORE_CTX* csc)
-{
-	if (ok != 1)
-	{
-		int err = X509_STORE_CTX_get_error(csc);
-		int derr = X509_STORE_CTX_get_error_depth(csc);
-		X509* where = X509_STORE_CTX_get_current_cert(csc);
-		const char* what = X509_verify_cert_error_string(err);
-		WLog_WARN(TAG, "Certificate verification failure '%s (%d)' at stack position %d", what, err,
-		          derr);
-		WLog_WARN(TAG, "%s", crypto_cert_subject(where));
-	}
-
-	return ok;
-}
-
 BOOL x509_verify_certificate(CryptoCert cert, const char* certificate_store_path)
 {
 	X509_STORE_CTX* csc;
 	BOOL status = FALSE;
 	X509_STORE* cert_ctx = NULL;
 	X509_LOOKUP* lookup = NULL;
+	X509* xcert = cert->px509;
 	cert_ctx = X509_STORE_new();
 
 	if (cert_ctx == NULL)
@@ -798,11 +782,10 @@
 
 	X509_STORE_set_flags(cert_ctx, 0);
 
-	if (!X509_STORE_CTX_init(csc, cert_ctx, cert->px509, cert->px509chain))
+	if (!X509_STORE_CTX_init(csc, cert_ctx, xcert, cert->px509chain))
 		goto end;
 
 	X509_STORE_CTX_set_purpose(csc, X509_PURPOSE_SSL_SERVER);
-	X509_STORE_CTX_set_verify_cb(csc, verify_cb);
 
 	if (X509_verify_cert(csc) == 1)
 		status = TRUE;
diff -urN libfreerdp/crypto/test/TestBase64.c ../../informatimago/FreeRDP/libfreerdp/crypto/test/TestBase64.c
--- libfreerdp/crypto/test/TestBase64.c	2019-07-25 19:51:04.301914479 +0300
+++ ../../informatimago/FreeRDP/libfreerdp/crypto/test/TestBase64.c	2019-07-25 20:11:28.263984150 +0300
@@ -43,8 +43,6 @@
 	int i, testNb = 0;
 	int outLen;
 	BYTE* decoded;
-	WINPR_UNUSED(argc);
-	WINPR_UNUSED(argv);
 	testNb++;
 	fprintf(stderr, "%d:encode base64...", testNb);
 
diff -urN libfreerdp/crypto/test/TestFreeRDPCrypto.c ../../informatimago/FreeRDP/libfreerdp/crypto/test/TestFreeRDPCrypto.c
--- libfreerdp/crypto/test/TestFreeRDPCrypto.c	2019-07-25 20:17:16.441710751 +0300
+++ ../../informatimago/FreeRDP/libfreerdp/crypto/test/TestFreeRDPCrypto.c	2019-07-25 20:11:28.267984169 +0300
@@ -4,149 +4,151 @@
 #include <string.h> /* NOLINT */
 
 #if defined(_MSC_VER)
-#pragma warning(disable : 4996) /* deprecation */
+#	pragma warning(disable : 4996) /* deprecation */
 #endif
 
-
-
 /* Forward declare test functions. */
 int TestKnownHosts(int, char*[]);
 int TestBase64(int, char*[]);
 int Test_x509_cert_info(int, char*[]);
 
-
 #ifdef __cplusplus
-#define CM_CAST(TYPE, EXPR) static_cast<TYPE>(EXPR)
+#	define CM_CAST(TYPE, EXPR) static_cast<TYPE>(EXPR)
 #else
-#define CM_CAST(TYPE, EXPR) (TYPE)(EXPR)
+#	define CM_CAST(TYPE, EXPR) (TYPE)(EXPR)
 #endif
 
 /* Create map.  */
 
-typedef int (*MainFuncPointer)(int, char* []); /* NOLINT */
-typedef struct /* NOLINT */
+typedef int (*MainFuncPointer)(int, char*[]); /* NOLINT */
+typedef struct                                /* NOLINT */
 {
-  const char* name;
-  MainFuncPointer func;
+	const char* name;
+	MainFuncPointer func;
 } functionMapEntry;
 
 static functionMapEntry cmakeGeneratedFunctionMapEntries[] = {
-    {
-    "TestKnownHosts",
-    TestKnownHosts
-  },
-  {
-    "TestBase64",
-    TestBase64
-  },
-  {
-    "Test_x509_cert_info",
-    Test_x509_cert_info
-  },
+	{ "TestKnownHosts", TestKnownHosts },
+	{ "TestBase64", TestBase64 },
+	{ "Test_x509_cert_info", Test_x509_cert_info },
 
-  { NULL, NULL } /* NOLINT */
+	{ NULL, NULL } /* NOLINT */
 };
 
-static const int NumTests = CM_CAST(int,
-  sizeof(cmakeGeneratedFunctionMapEntries) / sizeof(functionMapEntry)) - 1;
+static const int NumTests =
+    CM_CAST(int, sizeof(cmakeGeneratedFunctionMapEntries) / sizeof(functionMapEntry)) - 1;
 
 /* Allocate and create a lowercased copy of string
    (note that it has to be free'd manually) */
 static char* lowercase(const char* string)
 {
-  char *new_string, *p;
-  size_t stringSize;
+	char *new_string, *p;
+	size_t stringSize;
 
-  stringSize = CM_CAST(size_t, strlen(string) + 1);
-  new_string = CM_CAST(char*, malloc(sizeof(char) * stringSize));
+	stringSize = CM_CAST(size_t, strlen(string) + 1);
+	new_string = CM_CAST(char*, malloc(sizeof(char) * stringSize));
 
-  if (new_string == NULL) { /* NOLINT */
-    return NULL;            /* NOLINT */
-  }
-  strcpy(new_string, string);
-  for (p = new_string; *p != 0; ++p) {
-    *p = CM_CAST(char, tolower(*p));
-  }
-  return new_string;
+	if (new_string == NULL)
+	{                /* NOLINT */
+		return NULL; /* NOLINT */
+	}
+	strcpy(new_string, string);
+	for (p = new_string; *p != 0; ++p)
+	{
+		*p = CM_CAST(char, tolower(*p));
+	}
+	return new_string;
 }
 
 int main(int ac, char* av[])
 {
-  int i, testNum = 0, partial_match;
-  char *arg;
-  int testToRun = -1;
-
-  
-
-  /* If no test name was given */
-  /* process command line with user function.  */
-  if (ac < 2) {
-    /* Ask for a test.  */
-    printf("Available tests:\n");
-    for (i = 0; i < NumTests; ++i) {
-      printf("%3d. %s\n", i, cmakeGeneratedFunctionMapEntries[i].name);
-    }
-    printf("To run a test, enter the test number: ");
-    fflush(stdout);
-    if (scanf("%d", &testNum) != 1) {
-      printf("Couldn't parse that input as a number\n");
-      return -1;
-    }
-    if (testNum >= NumTests) {
-      printf("%3d is an invalid test number.\n", testNum);
-      return -1;
-    }
-    testToRun = testNum;
-    ac--;
-    av++;
-  }
-  partial_match = 0;
-  arg = NULL; /* NOLINT */
-  /* If partial match is requested.  */
-  if (testToRun == -1 && ac > 1) {
-    partial_match = (strcmp(av[1], "-R") == 0) ? 1 : 0;
-  }
-  if (partial_match != 0 && ac < 3) {
-    printf("-R needs an additional parameter.\n");
-    return -1;
-  }
-  if (testToRun == -1) {
-    arg = lowercase(av[1 + partial_match]);
-  }
-  for (i = 0; i < NumTests && testToRun == -1; ++i) {
-    char *test_name = lowercase(cmakeGeneratedFunctionMapEntries[i].name);
-    if (partial_match != 0 && strstr(test_name, arg) != NULL) { /* NOLINT */
-      testToRun = i;
-      ac -= 2;
-      av += 2;
-    } else if (partial_match == 0 && strcmp(test_name, arg) == 0) {
-      testToRun = i;
-      ac--;
-      av++;
-    }
-    free(test_name);
-  }
-  free(arg);
-  if (testToRun != -1) {
-    int result;
-
-    if (testToRun < 0 || testToRun >= NumTests) {
-      printf("testToRun was modified by TestDriver code to an invalid value: "
-             "%3d.\n",
-             testNum);
-      return -1;
-    }
-    result = (*cmakeGeneratedFunctionMapEntries[testToRun].func)(ac, av);
-
-    return result;
-  }
-
-  /* Nothing was run, display the test names.  */
-  printf("Available tests:\n");
-  for (i = 0; i < NumTests; ++i) {
-    printf("%3d. %s\n", i, cmakeGeneratedFunctionMapEntries[i].name);
-  }
-  printf("Failed: %s is an invalid test name.\n", av[1]);
+	int i, testNum = 0, partial_match;
+	char* arg;
+	int testToRun = -1;
+
+	/* If no test name was given */
+	/* process command line with user function.  */
+	if (ac < 2)
+	{
+		/* Ask for a test.  */
+		printf("Available tests:\n");
+		for (i = 0; i < NumTests; ++i)
+		{
+			printf("%3d. %s\n", i, cmakeGeneratedFunctionMapEntries[i].name);
+		}
+		printf("To run a test, enter the test number: ");
+		fflush(stdout);
+		if (scanf("%d", &testNum) != 1)
+		{
+			printf("Couldn't parse that input as a number\n");
+			return -1;
+		}
+		if (testNum >= NumTests)
+		{
+			printf("%3d is an invalid test number.\n", testNum);
+			return -1;
+		}
+		testToRun = testNum;
+		ac--;
+		av++;
+	}
+	partial_match = 0;
+	arg = NULL; /* NOLINT */
+	/* If partial match is requested.  */
+	if (testToRun == -1 && ac > 1)
+	{
+		partial_match = (strcmp(av[1], "-R") == 0) ? 1 : 0;
+	}
+	if (partial_match != 0 && ac < 3)
+	{
+		printf("-R needs an additional parameter.\n");
+		return -1;
+	}
+	if (testToRun == -1)
+	{
+		arg = lowercase(av[1 + partial_match]);
+	}
+	for (i = 0; i < NumTests && testToRun == -1; ++i)
+	{
+		char* test_name = lowercase(cmakeGeneratedFunctionMapEntries[i].name);
+		if (partial_match != 0 && strstr(test_name, arg) != NULL)
+		{ /* NOLINT */
+			testToRun = i;
+			ac -= 2;
+			av += 2;
+		}
+		else if (partial_match == 0 && strcmp(test_name, arg) == 0)
+		{
+			testToRun = i;
+			ac--;
+			av++;
+		}
+		free(test_name);
+	}
+	free(arg);
+	if (testToRun != -1)
+	{
+		int result;
+
+		if (testToRun < 0 || testToRun >= NumTests)
+		{
+			printf("testToRun was modified by TestDriver code to an invalid value: "
+			       "%3d.\n",
+			       testNum);
+			return -1;
+		}
+		result = (*cmakeGeneratedFunctionMapEntries[testToRun].func)(ac, av);
+
+		return result;
+	}
+
+	/* Nothing was run, display the test names.  */
+	printf("Available tests:\n");
+	for (i = 0; i < NumTests; ++i)
+	{
+		printf("%3d. %s\n", i, cmakeGeneratedFunctionMapEntries[i].name);
+	}
+	printf("Failed: %s is an invalid test name.\n", av[1]);
 
-  return -1;
+	return -1;
 }
diff -urN libfreerdp/crypto/test/TestKnownHosts.c ../../informatimago/FreeRDP/libfreerdp/crypto/test/TestKnownHosts.c
--- libfreerdp/crypto/test/TestKnownHosts.c	2019-07-25 19:51:04.309914518 +0300
+++ ../../informatimago/FreeRDP/libfreerdp/crypto/test/TestKnownHosts.c	2019-07-25 20:11:28.271984189 +0300
@@ -95,8 +95,6 @@
 	char sname[8192];
 	char dname[8192];
 	SYSTEMTIME systemTime;
-	WINPR_UNUSED(argc);
-	WINPR_UNUSED(argv);
 	GetSystemTime(&systemTime);
 	sprintf_s(sname, sizeof(sname),
 	          "TestKnownHostsCurrent-%04" PRIu16 "%02" PRIu16 "%02" PRIu16 "%02" PRIu16 "%02" PRIu16
diff -urN libfreerdp/crypto/test/Test_x509_cert_info.c ../../informatimago/FreeRDP/libfreerdp/crypto/test/Test_x509_cert_info.c
--- libfreerdp/crypto/test/Test_x509_cert_info.c	2019-07-25 19:51:04.313914538 +0300
+++ ../../informatimago/FreeRDP/libfreerdp/crypto/test/Test_x509_cert_info.c	2019-07-25 20:11:28.275984209 +0300
@@ -138,10 +138,7 @@
 int Test_x509_cert_info(int argc, char* argv[])
 {
 	char* cert_path = certificate_path();
-	int ret;
-	WINPR_UNUSED(argc);
-	WINPR_UNUSED(argv);
-	ret = TestCertificateFile(cert_path, certificate_tests, ARRAYSIZE(certificate_tests));
+	int ret = TestCertificateFile(cert_path, certificate_tests, ARRAYSIZE(certificate_tests));
 	free(cert_path);
 	return ret;
 }
diff -urN libfreerdp/crypto/tls.c ../../informatimago/FreeRDP/libfreerdp/crypto/tls.c
--- libfreerdp/crypto/tls.c	2019-07-25 19:51:04.353914737 +0300
+++ ../../informatimago/FreeRDP/libfreerdp/crypto/tls.c	2019-07-25 20:11:28.315984407 +0300
@@ -480,7 +480,7 @@
 
 static long bio_rdp_tls_callback_ctrl(BIO* bio, int cmd, bio_info_cb* fp)
 {
-	long status = 0;
+	int status = 0;
 	BIO_RDP_TLS* tls;
 
 	if (!bio)
@@ -494,16 +494,9 @@
 	switch (cmd)
 	{
 	case BIO_CTRL_SET_CALLBACK:
-	{
-		typedef void (*fkt_t)(const SSL*, int, int);
-		/* Documented since https://www.openssl.org/docs/man1.1.1/man3/BIO_set_callback.html
-		 * the argument is not really of type bio_info_cb* and must be cast
-		 * to the required type */
-		fkt_t fkt = (fkt_t)(void*)fp;
-		SSL_set_info_callback(tls->ssl, fkt);
+		SSL_set_info_callback(tls->ssl, (void (*)(const SSL*, int, int))fp);
 		status = 1;
-	}
-	break;
+		break;
 
 	default:
 		status = BIO_callback_ctrl(SSL_get_rbio(tls->ssl), cmd, fp);
@@ -809,6 +802,7 @@
 		{
 			WLog_ERR(TAG, "certificate not trusted, aborting.");
 			tls_send_alert(tls);
+			verify_status = 0;
 		}
 	}
 
@@ -1214,9 +1208,9 @@
 static BOOL tls_extract_pem(CryptoCert cert, BYTE** PublicKey, DWORD* PublicKeyLength)
 {
 	BIO* bio;
-	int status, count, x;
+	int status;
 	size_t offset;
-	size_t length = 0;
+	int length = 0;
 	BOOL rc = FALSE;
 	BYTE* pemCert = NULL;
 
@@ -1245,23 +1239,6 @@
 		goto fail;
 	}
 
-	if (cert->px509chain)
-	{
-		count = sk_BIO_num(cert->px509chain);
-
-		for (x = 0; x < count; x++)
-		{
-			X509* c = sk_BIO_value(cert->px509chain, x);
-			status = PEM_write_bio_X509(bio, c);
-
-			if (status < 0)
-			{
-				WLog_ERR(TAG, "PEM_write_bio_X509 failure: %d", status);
-				goto fail;
-			}
-		}
-	}
-
 	offset = 0;
 	length = 2048;
 	pemCert = (BYTE*)malloc(length + 1);
@@ -1280,7 +1257,7 @@
 		goto fail;
 	}
 
-	offset += (size_t)status;
+	offset += status;
 
 	while (offset >= length)
 	{
@@ -1326,17 +1303,17 @@
 {
 	int match;
 	int index;
-	DWORD length;
-	BOOL certificate_status;
 	char* common_name = NULL;
 	int common_name_length = 0;
 	char** dns_names = 0;
 	int dns_names_count = 0;
 	int* dns_names_lengths = NULL;
-	int verification_status = -1;
+	BOOL certificate_status;
 	BOOL hostname_match = FALSE;
+	BOOL verification_status = FALSE;
 	rdpCertificateData* certificate_data = NULL;
 	freerdp* instance = (freerdp*)tls->settings->instance;
+	DWORD length;
 	BYTE* pemCert = NULL;
 	DWORD flags = VERIFY_CERT_FLAG_NONE;
 
@@ -1346,7 +1323,7 @@
 	/* Check, if we already accepted this key. */
 	if (is_accepted(tls, pemCert, length))
 	{
-		verification_status = 1;
+		verification_status = TRUE;
 		goto end;
 	}
 
@@ -1362,26 +1339,30 @@
 	/* Certificate management is done by the application */
 	if (tls->settings->ExternalCertificateManagement)
 	{
+		int status = -1;
+
 		if (instance->VerifyX509Certificate)
-			verification_status =
+			status =
 			    instance->VerifyX509Certificate(instance, pemCert, length, hostname, port, flags);
 		else
 			WLog_ERR(TAG, "No VerifyX509Certificate callback registered!");
 
-		if (verification_status > 0)
+		if (status > 0)
 			accept_cert(tls, pemCert, length);
-		else if (verification_status < 0)
+		else if (status < 0)
 		{
 			WLog_ERR(TAG, "VerifyX509Certificate failed: (length = %d) status: [%d] %s", length,
-			         verification_status, pemCert);
+			         status, pemCert);
 			goto end;
 		}
+
+		verification_status = (status == 0) ? FALSE : TRUE;
 	}
 	/* ignore certificate verification if user explicitly required it (discouraged) */
 	else if (tls->settings->IgnoreCertificate)
-		verification_status = 1; /* success! */
+		verification_status = TRUE; /* success! */
 	else if (!tls->isGatewayTransport && (tls->settings->AuthenticationLevel == 0))
-		verification_status = 1; /* success! */
+		verification_status = TRUE; /* success! */
 	else
 	{
 		/* if user explicitly specified a certificate name, use it instead of the hostname */
@@ -1420,7 +1401,7 @@
 
 		/* if the certificate is valid and the certificate name matches, verification succeeds */
 		if (certificate_status && hostname_match)
-			verification_status = 1; /* success! */
+			verification_status = TRUE; /* success! */
 
 		if (!hostname_match)
 			flags |= VERIFY_CERT_FLAG_MISMATCH;
@@ -1452,11 +1433,6 @@
 					WLog_INFO(TAG, "No certificate stored, automatically accepting.");
 					accept_certificate = 1;
 				}
-				else if (tls->settings->AutoDenyCertificate)
-				{
-					WLog_INFO(TAG, "No certificate stored, automatically denying.");
-					accept_certificate = 0;
-				}
 				else if (instance->VerifyX509Certificate)
 				{
 					int rc = instance->VerifyX509Certificate(instance, pemCert, length, hostname,
@@ -1496,12 +1472,7 @@
 				                                 &old_subject, &old_issuer, &old_fingerprint))
 					WLog_WARN(TAG, "Failed to get certificate entry for %s:%d", hostname, port);
 
-				if (tls->settings->AutoDenyCertificate)
-				{
-					WLog_INFO(TAG, "No certificate stored, automatically denying.");
-					accept_certificate = 0;
-				}
-				else if (instance->VerifyX509Certificate)
+				if (instance->VerifyX509Certificate)
 				{
 					const int rc =
 					    instance->VerifyX509Certificate(instance, pemCert, length, hostname, port,
@@ -1544,21 +1515,21 @@
 				/* user accepted certificate, add entry in known_hosts file */
 				if (match < 0)
 					verification_status =
-					    certificate_data_replace(tls->certificate_store, certificate_data) ? 1 : -1;
+					    certificate_data_replace(tls->certificate_store, certificate_data);
 				else
 					verification_status =
-					    certificate_data_print(tls->certificate_store, certificate_data) ? 1 : -1;
+					    certificate_data_print(tls->certificate_store, certificate_data);
 
 				break;
 
 			case 2:
 				/* user did accept temporaty, do not add to known hosts file */
-				verification_status = 1;
+				verification_status = TRUE;
 				break;
 
 			default:
 				/* user did not accept, abort and do not add entry in known_hosts file */
-				verification_status = -1; /* failure! */
+				verification_status = FALSE; /* failure! */
 				break;
 			}
 
@@ -1567,7 +1538,7 @@
 			free(fingerprint);
 		}
 
-		if (verification_status > 0)
+		if (verification_status)
 			accept_cert(tls, pemCert, length);
 	}
 
@@ -1579,7 +1550,7 @@
 		crypto_cert_dns_names_free(dns_names_count, dns_names_lengths, dns_names);
 
 	free(pemCert);
-	return verification_status;
+	return (verification_status == 0) ? 0 : 1;
 }
 
 void tls_print_certificate_error(const char* hostname, UINT16 port, const char* fingerprint,
diff -urN libfreerdp/gdi/gdi.c ../../informatimago/FreeRDP/libfreerdp/gdi/gdi.c
--- libfreerdp/gdi/gdi.c	2019-07-25 19:51:04.421915073 +0300
+++ ../../informatimago/FreeRDP/libfreerdp/gdi/gdi.c	2019-07-25 20:11:28.383984744 +0300
@@ -1210,18 +1210,14 @@
 	if (!gdi || !gdi->primary)
 		return FALSE;
 
-	if ((width > INT32_MAX) || (height > INT32_MAX))
-		return FALSE;
-
-	if ((gdi->width == (INT32)width) && (gdi->height == (INT32)height) &&
-	    (!buffer || (gdi->primary_buffer == buffer)))
+	if (gdi->width == width && gdi->height == height && (!buffer || gdi->primary_buffer == buffer))
 		return TRUE;
 
 	if (gdi->drawing == gdi->primary)
 		gdi->drawing = NULL;
 
-	gdi->width = (INT32)width;
-	gdi->height = (INT32)height;
+	gdi->width = width;
+	gdi->height = height;
 	gdi_bitmap_free_ex(gdi->primary);
 	gdi->primary = NULL;
 	gdi->primary_buffer = NULL;
diff -urN libfreerdp/gdi/gfx.c ../../informatimago/FreeRDP/libfreerdp/gdi/gfx.c
--- libfreerdp/gdi/gfx.c	2019-07-25 19:51:04.457915253 +0300
+++ ../../informatimago/FreeRDP/libfreerdp/gdi/gfx.c	2019-07-25 20:11:28.411984883 +0300
@@ -23,8 +23,6 @@
 #	include "config.h"
 #endif
 
-#include "../core/update.h"
-
 #include <freerdp/log.h>
 #include <freerdp/gdi/gfx.h>
 #include <freerdp/gdi/region.h>
@@ -33,7 +31,7 @@
 
 static DWORD gfx_align_scanline(DWORD widthInBytes, DWORD alignment)
 {
-	const UINT32 align = alignment;
+	const UINT32 align = 16;
 	const UINT32 pad = align - (widthInBytes % alignment);
 	UINT32 scanline = widthInBytes;
 
@@ -102,11 +100,13 @@
 static UINT gdi_OutputUpdate(rdpGdi* gdi, gdiGfxSurface* surface)
 {
 	UINT rc = ERROR_INTERNAL_ERROR;
+	UINT32 nXDst, nYDst;
+	UINT32 nXSrc, nYSrc;
+	UINT16 width, height;
 	UINT32 surfaceX, surfaceY;
 	RECTANGLE_16 surfaceRect;
 	const RECTANGLE_16* rects;
 	UINT32 i, nbRects;
-	double sx, sy;
 	rdpUpdate* update = gdi->context->update;
 
 	if (gdi->suppressOutput)
@@ -116,44 +116,38 @@
 	surfaceY = surface->outputOriginY;
 	surfaceRect.left = 0;
 	surfaceRect.top = 0;
-	surfaceRect.right = surface->mappedWidth;
-	surfaceRect.bottom = surface->mappedHeight;
+	surfaceRect.right = surface->width;
+	surfaceRect.bottom = surface->height;
 	region16_intersect_rect(&(surface->invalidRegion), &(surface->invalidRegion), &surfaceRect);
-	sx = surface->outputTargetWidth / (double)surface->mappedWidth;
-	sy = surface->outputTargetHeight / (double)surface->mappedHeight;
 
 	if (!(rects = region16_rects(&surface->invalidRegion, &nbRects)) || !nbRects)
 		return CHANNEL_RC_OK;
 
-	if (!update_begin_paint(update))
+	if (!IFCALLRESULT(TRUE, update->BeginPaint, gdi->context))
 		goto fail;
 
 	for (i = 0; i < nbRects; i++)
 	{
-		const UINT32 nXSrc = rects[i].left;
-		const UINT32 nYSrc = rects[i].top;
-		const UINT32 nXDst = (UINT32)(surfaceX + nXSrc * sx);
-		const UINT32 nYDst = (UINT32)(surfaceY + nYSrc * sy);
-		const UINT32 swidth = rects[i].right - rects[i].left;
-		const UINT32 sheight = rects[i].bottom - rects[i].top;
-		const UINT32 dwidth = (UINT32)(swidth * sx);
-		const UINT32 dheight = (UINT32)(sheight * sy);
-
-		if (!freerdp_image_scale(gdi->primary_buffer, gdi->dstFormat, gdi->stride, nXDst, nYDst,
-		                         dwidth, dheight, surface->data, surface->format, surface->scanline,
-		                         nXSrc, nYSrc, swidth, sheight))
+		nXSrc = rects[i].left;
+		nYSrc = rects[i].top;
+		nXDst = surfaceX + nXSrc;
+		nYDst = surfaceY + nYSrc;
+		width = rects[i].right - rects[i].left;
+		height = rects[i].bottom - rects[i].top;
+
+		if (!freerdp_image_copy(gdi->primary_buffer, gdi->primary->hdc->format, gdi->stride, nXDst,
+		                        nYDst, width, height, surface->data, surface->format,
+		                        surface->scanline, nXSrc, nYSrc, NULL, FREERDP_FLIP_NONE))
 			return CHANNEL_RC_NULL_DATA;
 
-		gdi_InvalidateRegion(gdi->primary->hdc, (INT32)nXDst, (INT32)nYDst, (INT32)dwidth,
-		                     (INT32)dheight);
+		gdi_InvalidateRegion(gdi->primary->hdc, nXDst, nYDst, width, height);
 	}
 
+	if (!IFCALLRESULT(FALSE, update->EndPaint, gdi->context))
+		goto fail;
+
 	rc = CHANNEL_RC_OK;
 fail:
-
-	if (!update_end_paint(update))
-		rc = ERROR_INTERNAL_ERROR;
-
 	region16_clear(&(surface->invalidRegion));
 	return rc;
 }
@@ -178,17 +172,7 @@
 	{
 		surface = (gdiGfxSurface*)context->GetSurfaceData(context, pSurfaceIds[index]);
 
-		if (!surface)
-			continue;
-
-		/* Already handled in UpdateSurfaceArea callbacks */
-		if (context->UpdateSurfaceArea)
-		{
-			if (surface->windowId != 0)
-				continue;
-		}
-
-		if (!surface->outputMapped)
+		if (!surface || !surface->outputMapped)
 			continue;
 
 		status = gdi_OutputUpdate(gdi, surface);
@@ -579,9 +563,6 @@
 	status = IFCALLRESULT(CHANNEL_RC_OK, context->UpdateSurfaceArea, context, surface->surfaceId,
 	                      meta1->numRegionRects, meta1->regionRects);
 
-	if (status != CHANNEL_RC_OK)
-		goto fail;
-
 	for (i = 0; i < meta2->numRegionRects; i++)
 	{
 		region16_union_rect(&(surface->invalidRegion), &(surface->invalidRegion),
@@ -608,41 +589,6 @@
 #endif
 }
 
-static BOOL gdi_apply_alpha(BYTE* data, UINT32 format, UINT32 stride, RECTANGLE_16* rect,
-                            UINT32 startOffsetX, UINT32 count, BYTE a)
-{
-	UINT32 y;
-	UINT32 written = 0;
-	BOOL first = TRUE;
-	const UINT32 bpp = GetBytesPerPixel(format);
-
-	for (y = rect->top; y < rect->bottom; y++)
-	{
-		UINT32 x;
-		BYTE* line = &data[stride * y];
-
-		for (x = first ? rect->left + startOffsetX : rect->left; x < rect->right; x++)
-		{
-			UINT32 color;
-			BYTE r, g, b;
-			BYTE* src;
-
-			if (written == count)
-				return TRUE;
-
-			src = &line[x * bpp];
-			color = ReadColor(src, format);
-			SplitColor(color, format, &r, &g, &b, NULL, NULL);
-			color = FreeRDPGetColor(format, r, g, b, a);
-			WriteColor(src, format, color);
-			written++;
-		}
-
-		first = FALSE;
-	}
-
-	return TRUE;
-}
 /**
  * Function description
  *
@@ -652,15 +598,9 @@
                                      const RDPGFX_SURFACE_COMMAND* cmd)
 {
 	UINT status = CHANNEL_RC_OK;
-	UINT16 alphaSig, compressed;
+	UINT32 color;
 	gdiGfxSurface* surface;
 	RECTANGLE_16 invalidRect;
-	wStream s;
-	Stream_StaticInit(&s, cmd->data, cmd->length);
-
-	if (Stream_GetRemainingLength(&s) < 4)
-		return ERROR_INVALID_DATA;
-
 	surface = (gdiGfxSurface*)context->GetSurfaceData(context, cmd->surfaceId);
 
 	if (!surface)
@@ -670,85 +610,13 @@
 		return ERROR_NOT_FOUND;
 	}
 
-	Stream_Read_UINT16(&s, alphaSig);
-	Stream_Read_UINT16(&s, compressed);
-
-	if (alphaSig != 0x414C)
-		return ERROR_INVALID_DATA;
-
-	if (compressed == 0)
-	{
-		UINT32 x, y;
-
-		if (Stream_GetRemainingLength(&s) < cmd->height * cmd->width)
-			return ERROR_INVALID_DATA;
-
-		for (y = cmd->top; y < cmd->top + cmd->height; y++)
-		{
-			BYTE* line = &surface->data[surface->scanline * y];
-
-			for (x = cmd->left; x < cmd->left + cmd->width; x++)
-			{
-				UINT32 color;
-				BYTE r, g, b, a;
-				BYTE* src = &line[x * GetBytesPerPixel(surface->format)];
-				Stream_Read_UINT8(&s, a);
-				color = ReadColor(src, surface->format);
-				SplitColor(color, surface->format, &r, &g, &b, NULL, NULL);
-				color = FreeRDPGetColor(surface->format, r, g, b, a);
-				WriteColor(src, surface->format, color);
-			}
-		}
-	}
-	else
-	{
-		UINT32 startOffsetX = 0;
-		RECTANGLE_16 rect;
-		rect.left = cmd->left;
-		rect.top = cmd->top;
-		rect.right = cmd->left + cmd->width;
-		rect.bottom = cmd->top + cmd->height;
-
-		while (rect.top < rect.bottom)
-		{
-			UINT32 count;
-			BYTE a;
-
-			if (Stream_GetRemainingLength(&s) < 2)
-				return ERROR_INVALID_DATA;
-
-			Stream_Read_UINT8(&s, a);
-			Stream_Read_UINT8(&s, count);
+	WLog_WARN(TAG, "TODO gdi_SurfaceCommand_Alpha: status: %" PRIu32 "", status);
+	/* fill with green for now to distinguish from the rest */
+	color = FreeRDPGetColor(surface->format, 0x00, 0xFF, 0x00, 0xFF);
 
-			if (count >= 0xFF)
-			{
-				if (Stream_GetRemainingLength(&s) < 2)
-					return ERROR_INVALID_DATA;
-
-				Stream_Read_UINT16(&s, count);
-
-				if (count >= 0xFFFF)
-				{
-					if (Stream_GetRemainingLength(&s) < 4)
-						return ERROR_INVALID_DATA;
-
-					Stream_Read_UINT32(&s, count);
-				}
-			}
-
-			if (!gdi_apply_alpha(surface->data, surface->format, surface->scanline, &rect,
-			                     startOffsetX, count, a))
-				return ERROR_INTERNAL_ERROR;
-
-			startOffsetX += count;
-
-			while (startOffsetX >= cmd->width)
-			{
-				startOffsetX -= cmd->width;
-				rect.top++;
-			}
-		}
-	}
+	if (!freerdp_image_fill(surface->data, surface->format, surface->scanline, cmd->left, cmd->top,
+	                        cmd->width, cmd->height, color))
+		return ERROR_INTERNAL_ERROR;
 
 	invalidRect.left = cmd->left;
 	invalidRect.top = cmd->top;
@@ -951,12 +819,8 @@
 	}
 
 	surface->surfaceId = createSurface->surfaceId;
-	surface->width = gfx_align_scanline(createSurface->width, 16);
-	surface->height = gfx_align_scanline(createSurface->height, 16);
-	surface->mappedWidth = createSurface->width;
-	surface->mappedHeight = createSurface->height;
-	surface->outputTargetWidth = createSurface->width;
-	surface->outputTargetHeight = createSurface->height;
+	surface->width = (UINT32)createSurface->width;
+	surface->height = (UINT32)createSurface->height;
 
 	switch (createSurface->pixelFormat)
 	{
@@ -1006,10 +870,6 @@
 
 	if (surface)
 	{
-		if (surface->windowId != 0)
-			rc = IFCALLRESULT(CHANNEL_RC_OK, context->UnmapWindowForSurface, context,
-			                  surface->windowId);
-
 #ifdef WITH_GFX_H264
 		h264_context_free(surface->h264);
 #endif
@@ -1331,32 +1191,6 @@
 	surface->outputMapped = TRUE;
 	surface->outputOriginX = surfaceToOutput->outputOriginX;
 	surface->outputOriginY = surfaceToOutput->outputOriginY;
-	surface->outputTargetWidth = surface->mappedWidth;
-	surface->outputTargetHeight = surface->mappedHeight;
-	region16_clear(&surface->invalidRegion);
-	rc = CHANNEL_RC_OK;
-fail:
-	LeaveCriticalSection(&context->mux);
-	return rc;
-}
-
-static UINT
-gdi_MapSurfaceToScaledOutput(RdpgfxClientContext* context,
-                             const RDPGFX_MAP_SURFACE_TO_SCALED_OUTPUT_PDU* surfaceToOutput)
-{
-	UINT rc = ERROR_INTERNAL_ERROR;
-	gdiGfxSurface* surface;
-	EnterCriticalSection(&context->mux);
-	surface = (gdiGfxSurface*)context->GetSurfaceData(context, surfaceToOutput->surfaceId);
-
-	if (!surface)
-		goto fail;
-
-	surface->outputMapped = TRUE;
-	surface->outputOriginX = surfaceToOutput->outputOriginX;
-	surface->outputOriginY = surfaceToOutput->outputOriginY;
-	surface->outputTargetWidth = surfaceToOutput->targetWidth;
-	surface->outputTargetHeight = surfaceToOutput->targetHeight;
 	region16_clear(&surface->invalidRegion);
 	rc = CHANNEL_RC_OK;
 fail:
@@ -1372,72 +1206,11 @@
 static UINT gdi_MapSurfaceToWindow(RdpgfxClientContext* context,
                                    const RDPGFX_MAP_SURFACE_TO_WINDOW_PDU* surfaceToWindow)
 {
-	UINT rc = ERROR_INTERNAL_ERROR;
-	gdiGfxSurface* surface;
-	EnterCriticalSection(&context->mux);
-	surface = (gdiGfxSurface*)context->GetSurfaceData(context, surfaceToWindow->surfaceId);
-
-	if (!surface)
-		goto fail;
-
-	if (surface->windowId != 0)
-	{
-		if (surface->windowId != surfaceToWindow->windowId)
-			goto fail;
-	}
-
-	surface->windowId = surfaceToWindow->windowId;
-	surface->mappedWidth = surfaceToWindow->mappedWidth;
-	surface->mappedHeight = surfaceToWindow->mappedHeight;
-	surface->outputTargetWidth = surfaceToWindow->mappedWidth;
-	surface->outputTargetHeight = surfaceToWindow->mappedHeight;
-	rc = IFCALLRESULT(CHANNEL_RC_OK, context->MapWindowForSurface, context,
-	                  surfaceToWindow->surfaceId, surfaceToWindow->windowId);
-fail:
-	LeaveCriticalSection(&context->mux);
-	return rc;
-}
-
-static UINT
-gdi_MapSurfaceToScaledWindow(RdpgfxClientContext* context,
-                             const RDPGFX_MAP_SURFACE_TO_SCALED_WINDOW_PDU* surfaceToWindow)
-{
-	UINT rc = ERROR_INTERNAL_ERROR;
-	gdiGfxSurface* surface;
-	EnterCriticalSection(&context->mux);
-	surface = (gdiGfxSurface*)context->GetSurfaceData(context, surfaceToWindow->surfaceId);
-
-	if (!surface)
-		goto fail;
-
-	if (surface->windowId != 0)
-	{
-		if (surface->windowId != surfaceToWindow->windowId)
-			goto fail;
-	}
-
-	surface->windowId = surfaceToWindow->windowId;
-	surface->mappedWidth = surfaceToWindow->mappedWidth;
-	surface->mappedHeight = surfaceToWindow->mappedHeight;
-	surface->outputTargetWidth = surfaceToWindow->targetWidth;
-	surface->outputTargetHeight = surfaceToWindow->targetHeight;
-	rc = IFCALLRESULT(CHANNEL_RC_OK, context->MapWindowForSurface, context,
-	                  surfaceToWindow->surfaceId, surfaceToWindow->windowId);
-fail:
-	LeaveCriticalSection(&context->mux);
-	return rc;
+	return CHANNEL_RC_OK;
 }
 
 BOOL gdi_graphics_pipeline_init(rdpGdi* gdi, RdpgfxClientContext* gfx)
 {
-	return gdi_graphics_pipeline_init_ex(gdi, gfx, NULL, NULL, NULL);
-}
-
-BOOL gdi_graphics_pipeline_init_ex(rdpGdi* gdi, RdpgfxClientContext* gfx,
-                                   pcRdpgfxMapWindowForSurface map,
-                                   pcRdpgfxUnmapWindowForSurface unmap,
-                                   pcRdpgfxUpdateSurfaceArea update)
-{
 	if (!gdi || !gfx)
 		return FALSE;
 
@@ -1458,12 +1231,7 @@
 	gfx->EvictCacheEntry = gdi_EvictCacheEntry;
 	gfx->MapSurfaceToOutput = gdi_MapSurfaceToOutput;
 	gfx->MapSurfaceToWindow = gdi_MapSurfaceToWindow;
-	gfx->MapSurfaceToScaledOutput = gdi_MapSurfaceToScaledOutput;
-	gfx->MapSurfaceToScaledWindow = gdi_MapSurfaceToScaledWindow;
 	gfx->UpdateSurfaces = gdi_UpdateSurfaces;
-	gfx->MapWindowForSurface = map;
-	gfx->UnmapWindowForSurface = unmap;
-	gfx->UpdateSurfaceArea = update;
 	InitializeCriticalSection(&gfx->mux);
 	PROFILER_CREATE(gfx->SurfaceProfiler, "GFX-PROFILER");
 	return TRUE;
diff -urN libfreerdp/gdi/region.c ../../informatimago/FreeRDP/libfreerdp/gdi/region.c
--- libfreerdp/gdi/region.c	2019-07-25 19:51:04.477915352 +0300
+++ ../../informatimago/FreeRDP/libfreerdp/gdi/region.c	2019-07-25 20:11:28.431984983 +0300
@@ -427,7 +427,7 @@
 
 	cinvalid = hdc->hwnd->cinvalid;
 
-	if ((hdc->hwnd->ninvalid + 1) > (INT64)hdc->hwnd->count)
+	if ((hdc->hwnd->ninvalid + 1) > hdc->hwnd->count)
 	{
 		int new_cnt;
 		HGDI_RGN new_rgn;
diff -urN libfreerdp/gdi/test/TestGdiBitBlt.c ../../informatimago/FreeRDP/libfreerdp/gdi/test/TestGdiBitBlt.c
--- libfreerdp/gdi/test/TestGdiBitBlt.c	2019-07-25 19:51:04.505915491 +0300
+++ ../../informatimago/FreeRDP/libfreerdp/gdi/test/TestGdiBitBlt.c	2019-07-25 20:11:28.459985121 +0300
@@ -546,8 +546,6 @@
 		                          PIXEL_FORMAT_BGR24,  PIXEL_FORMAT_BGRA32, PIXEL_FORMAT_BGRX32,
 		                          PIXEL_FORMAT_ABGR32, PIXEL_FORMAT_XBGR32 };
 	const UINT32 listSize = sizeof(formatList) / sizeof(formatList[0]);
-	WINPR_UNUSED(argc);
-	WINPR_UNUSED(argv);
 
 	for (x = 0; x < listSize; x++)
 	{
diff -urN libfreerdp/gdi/test/TestGdi.c ../../informatimago/FreeRDP/libfreerdp/gdi/test/TestGdi.c
--- libfreerdp/gdi/test/TestGdi.c	2019-07-25 20:17:16.437710730 +0300
+++ ../../informatimago/FreeRDP/libfreerdp/gdi/test/TestGdi.c	2019-07-25 20:11:28.439985022 +0300
@@ -4,11 +4,9 @@
 #include <string.h> /* NOLINT */
 
 #if defined(_MSC_VER)
-#pragma warning(disable : 4996) /* deprecation */
+#	pragma warning(disable : 4996) /* deprecation */
 #endif
 
-
-
 /* Forward declare test functions. */
 int TestGdiRop3(int, char*[]);
 int TestGdiLine(int, char*[]);
@@ -18,155 +16,147 @@
 int TestGdiEllipse(int, char*[]);
 int TestGdiClip(int, char*[]);
 
-
 #ifdef __cplusplus
-#define CM_CAST(TYPE, EXPR) static_cast<TYPE>(EXPR)
+#	define CM_CAST(TYPE, EXPR) static_cast<TYPE>(EXPR)
 #else
-#define CM_CAST(TYPE, EXPR) (TYPE)(EXPR)
+#	define CM_CAST(TYPE, EXPR) (TYPE)(EXPR)
 #endif
 
 /* Create map.  */
 
-typedef int (*MainFuncPointer)(int, char* []); /* NOLINT */
-typedef struct /* NOLINT */
+typedef int (*MainFuncPointer)(int, char*[]); /* NOLINT */
+typedef struct                                /* NOLINT */
 {
-  const char* name;
-  MainFuncPointer func;
+	const char* name;
+	MainFuncPointer func;
 } functionMapEntry;
 
 static functionMapEntry cmakeGeneratedFunctionMapEntries[] = {
-    {
-    "TestGdiRop3",
-    TestGdiRop3
-  },
-  {
-    "TestGdiLine",
-    TestGdiLine
-  },
-  {
-    "TestGdiRect",
-    TestGdiRect
-  },
-  {
-    "TestGdiBitBlt",
-    TestGdiBitBlt
-  },
-  {
-    "TestGdiCreate",
-    TestGdiCreate
-  },
-  {
-    "TestGdiEllipse",
-    TestGdiEllipse
-  },
-  {
-    "TestGdiClip",
-    TestGdiClip
-  },
+	{ "TestGdiRop3", TestGdiRop3 },
+	{ "TestGdiLine", TestGdiLine },
+	{ "TestGdiRect", TestGdiRect },
+	{ "TestGdiBitBlt", TestGdiBitBlt },
+	{ "TestGdiCreate", TestGdiCreate },
+	{ "TestGdiEllipse", TestGdiEllipse },
+	{ "TestGdiClip", TestGdiClip },
 
-  { NULL, NULL } /* NOLINT */
+	{ NULL, NULL } /* NOLINT */
 };
 
-static const int NumTests = CM_CAST(int,
-  sizeof(cmakeGeneratedFunctionMapEntries) / sizeof(functionMapEntry)) - 1;
+static const int NumTests =
+    CM_CAST(int, sizeof(cmakeGeneratedFunctionMapEntries) / sizeof(functionMapEntry)) - 1;
 
 /* Allocate and create a lowercased copy of string
    (note that it has to be free'd manually) */
 static char* lowercase(const char* string)
 {
-  char *new_string, *p;
-  size_t stringSize;
+	char *new_string, *p;
+	size_t stringSize;
 
-  stringSize = CM_CAST(size_t, strlen(string) + 1);
-  new_string = CM_CAST(char*, malloc(sizeof(char) * stringSize));
+	stringSize = CM_CAST(size_t, strlen(string) + 1);
+	new_string = CM_CAST(char*, malloc(sizeof(char) * stringSize));
 
-  if (new_string == NULL) { /* NOLINT */
-    return NULL;            /* NOLINT */
-  }
-  strcpy(new_string, string);
-  for (p = new_string; *p != 0; ++p) {
-    *p = CM_CAST(char, tolower(*p));
-  }
-  return new_string;
+	if (new_string == NULL)
+	{                /* NOLINT */
+		return NULL; /* NOLINT */
+	}
+	strcpy(new_string, string);
+	for (p = new_string; *p != 0; ++p)
+	{
+		*p = CM_CAST(char, tolower(*p));
+	}
+	return new_string;
 }
 
 int main(int ac, char* av[])
 {
-  int i, testNum = 0, partial_match;
-  char *arg;
-  int testToRun = -1;
-
-  
-
-  /* If no test name was given */
-  /* process command line with user function.  */
-  if (ac < 2) {
-    /* Ask for a test.  */
-    printf("Available tests:\n");
-    for (i = 0; i < NumTests; ++i) {
-      printf("%3d. %s\n", i, cmakeGeneratedFunctionMapEntries[i].name);
-    }
-    printf("To run a test, enter the test number: ");
-    fflush(stdout);
-    if (scanf("%d", &testNum) != 1) {
-      printf("Couldn't parse that input as a number\n");
-      return -1;
-    }
-    if (testNum >= NumTests) {
-      printf("%3d is an invalid test number.\n", testNum);
-      return -1;
-    }
-    testToRun = testNum;
-    ac--;
-    av++;
-  }
-  partial_match = 0;
-  arg = NULL; /* NOLINT */
-  /* If partial match is requested.  */
-  if (testToRun == -1 && ac > 1) {
-    partial_match = (strcmp(av[1], "-R") == 0) ? 1 : 0;
-  }
-  if (partial_match != 0 && ac < 3) {
-    printf("-R needs an additional parameter.\n");
-    return -1;
-  }
-  if (testToRun == -1) {
-    arg = lowercase(av[1 + partial_match]);
-  }
-  for (i = 0; i < NumTests && testToRun == -1; ++i) {
-    char *test_name = lowercase(cmakeGeneratedFunctionMapEntries[i].name);
-    if (partial_match != 0 && strstr(test_name, arg) != NULL) { /* NOLINT */
-      testToRun = i;
-      ac -= 2;
-      av += 2;
-    } else if (partial_match == 0 && strcmp(test_name, arg) == 0) {
-      testToRun = i;
-      ac--;
-      av++;
-    }
-    free(test_name);
-  }
-  free(arg);
-  if (testToRun != -1) {
-    int result;
-
-    if (testToRun < 0 || testToRun >= NumTests) {
-      printf("testToRun was modified by TestDriver code to an invalid value: "
-             "%3d.\n",
-             testNum);
-      return -1;
-    }
-    result = (*cmakeGeneratedFunctionMapEntries[testToRun].func)(ac, av);
-
-    return result;
-  }
-
-  /* Nothing was run, display the test names.  */
-  printf("Available tests:\n");
-  for (i = 0; i < NumTests; ++i) {
-    printf("%3d. %s\n", i, cmakeGeneratedFunctionMapEntries[i].name);
-  }
-  printf("Failed: %s is an invalid test name.\n", av[1]);
+	int i, testNum = 0, partial_match;
+	char* arg;
+	int testToRun = -1;
+
+	/* If no test name was given */
+	/* process command line with user function.  */
+	if (ac < 2)
+	{
+		/* Ask for a test.  */
+		printf("Available tests:\n");
+		for (i = 0; i < NumTests; ++i)
+		{
+			printf("%3d. %s\n", i, cmakeGeneratedFunctionMapEntries[i].name);
+		}
+		printf("To run a test, enter the test number: ");
+		fflush(stdout);
+		if (scanf("%d", &testNum) != 1)
+		{
+			printf("Couldn't parse that input as a number\n");
+			return -1;
+		}
+		if (testNum >= NumTests)
+		{
+			printf("%3d is an invalid test number.\n", testNum);
+			return -1;
+		}
+		testToRun = testNum;
+		ac--;
+		av++;
+	}
+	partial_match = 0;
+	arg = NULL; /* NOLINT */
+	/* If partial match is requested.  */
+	if (testToRun == -1 && ac > 1)
+	{
+		partial_match = (strcmp(av[1], "-R") == 0) ? 1 : 0;
+	}
+	if (partial_match != 0 && ac < 3)
+	{
+		printf("-R needs an additional parameter.\n");
+		return -1;
+	}
+	if (testToRun == -1)
+	{
+		arg = lowercase(av[1 + partial_match]);
+	}
+	for (i = 0; i < NumTests && testToRun == -1; ++i)
+	{
+		char* test_name = lowercase(cmakeGeneratedFunctionMapEntries[i].name);
+		if (partial_match != 0 && strstr(test_name, arg) != NULL)
+		{ /* NOLINT */
+			testToRun = i;
+			ac -= 2;
+			av += 2;
+		}
+		else if (partial_match == 0 && strcmp(test_name, arg) == 0)
+		{
+			testToRun = i;
+			ac--;
+			av++;
+		}
+		free(test_name);
+	}
+	free(arg);
+	if (testToRun != -1)
+	{
+		int result;
+
+		if (testToRun < 0 || testToRun >= NumTests)
+		{
+			printf("testToRun was modified by TestDriver code to an invalid value: "
+			       "%3d.\n",
+			       testNum);
+			return -1;
+		}
+		result = (*cmakeGeneratedFunctionMapEntries[testToRun].func)(ac, av);
+
+		return result;
+	}
+
+	/* Nothing was run, display the test names.  */
+	printf("Available tests:\n");
+	for (i = 0; i < NumTests; ++i)
+	{
+		printf("%3d. %s\n", i, cmakeGeneratedFunctionMapEntries[i].name);
+	}
+	printf("Failed: %s is an invalid test name.\n", av[1]);
 
-  return -1;
+	return -1;
 }
diff -urN libfreerdp/gdi/test/TestGdiClip.c ../../informatimago/FreeRDP/libfreerdp/gdi/test/TestGdiClip.c
--- libfreerdp/gdi/test/TestGdiClip.c	2019-07-25 19:51:04.513915529 +0300
+++ ../../informatimago/FreeRDP/libfreerdp/gdi/test/TestGdiClip.c	2019-07-25 20:11:28.467985161 +0300
@@ -329,8 +329,6 @@
 
 int TestGdiClip(int argc, char* argv[])
 {
-	WINPR_UNUSED(argc);
-	WINPR_UNUSED(argv);
 	fprintf(stderr, "test_gdi_ClipCoords()\n");
 
 	if (test_gdi_ClipCoords() < 0)
diff -urN libfreerdp/gdi/test/TestGdiCreate.c ../../informatimago/FreeRDP/libfreerdp/gdi/test/TestGdiCreate.c
--- libfreerdp/gdi/test/TestGdiCreate.c	2019-07-25 19:51:04.517915550 +0300
+++ ../../informatimago/FreeRDP/libfreerdp/gdi/test/TestGdiCreate.c	2019-07-25 20:11:28.475985200 +0300
@@ -85,8 +85,8 @@
 {
 	int rc = -1;
 	UINT32 format = PIXEL_FORMAT_ARGB32;
-	INT32 width;
-	INT32 height;
+	UINT32 width;
+	UINT32 height;
 	BYTE* data;
 	HGDI_BITMAP hBitmap = NULL;
 	width = 32;
@@ -134,8 +134,8 @@
 {
 	int rc = -1;
 	HGDI_DC hdc;
-	INT32 width;
-	INT32 height;
+	UINT32 width;
+	UINT32 height;
 	HGDI_BITMAP hBitmap = NULL;
 
 	if (!(hdc = gdi_GetDC()))
@@ -256,10 +256,10 @@
 static int test_gdi_CreateRectRgn(void)
 {
 	int rc = -1;
-	INT32 x1 = 32;
-	INT32 y1 = 64;
-	INT32 x2 = 128;
-	INT32 y2 = 256;
+	UINT32 x1 = 32;
+	UINT32 y1 = 64;
+	UINT32 x2 = 128;
+	UINT32 y2 = 256;
 	HGDI_RGN hRegion = gdi_CreateRectRgn(x1, y1, x2, y2);
 
 	if (!hRegion)
@@ -293,10 +293,10 @@
 {
 	int rc = -1;
 	HGDI_RECT hRect;
-	INT32 x1 = 32;
-	INT32 y1 = 64;
-	INT32 x2 = 128;
-	INT32 y2 = 256;
+	UINT32 x1 = 32;
+	UINT32 y1 = 64;
+	UINT32 x2 = 128;
+	UINT32 y2 = 256;
 
 	if (!(hRect = gdi_CreateRect(x1, y1, x2, y2)))
 	{
@@ -518,8 +518,6 @@
 
 int TestGdiCreate(int argc, char* argv[])
 {
-	WINPR_UNUSED(argc);
-	WINPR_UNUSED(argv);
 	fprintf(stderr, "test_gdi_GetDC()\n");
 
 	if (test_gdi_GetDC() < 0)
diff -urN libfreerdp/gdi/test/TestGdiEllipse.c ../../informatimago/FreeRDP/libfreerdp/gdi/test/TestGdiEllipse.c
--- libfreerdp/gdi/test/TestGdiEllipse.c	2019-07-25 19:51:04.521915570 +0300
+++ ../../informatimago/FreeRDP/libfreerdp/gdi/test/TestGdiEllipse.c	2019-07-25 20:11:28.479985221 +0300
@@ -87,8 +87,6 @@
 		                            PIXEL_FORMAT_BGRX32 };
 	const UINT32 number_formats = sizeof(colorFormats) / sizeof(colorFormats[0]);
 	gdiPalette g;
-	WINPR_UNUSED(argc);
-	WINPR_UNUSED(argv);
 
 	for (i = 0; i < number_formats; i++)
 	{
diff -urN libfreerdp/gdi/test/TestGdiLine.c ../../informatimago/FreeRDP/libfreerdp/gdi/test/TestGdiLine.c
--- libfreerdp/gdi/test/TestGdiLine.c	2019-07-25 19:51:04.541915669 +0300
+++ ../../informatimago/FreeRDP/libfreerdp/gdi/test/TestGdiLine.c	2019-07-25 20:11:28.499985320 +0300
@@ -575,8 +575,6 @@
 		                            PIXEL_FORMAT_ABGR32, PIXEL_FORMAT_XBGR32, PIXEL_FORMAT_BGRA32,
 		                            PIXEL_FORMAT_BGRX32 };
 	const UINT32 number_formats = sizeof(colorFormats) / sizeof(colorFormats[0]);
-	WINPR_UNUSED(argc);
-	WINPR_UNUSED(argv);
 
 	for (i = 0; i < number_formats; i++)
 	{
diff -urN libfreerdp/gdi/test/TestGdiRect.c ../../informatimago/FreeRDP/libfreerdp/gdi/test/TestGdiRect.c
--- libfreerdp/gdi/test/TestGdiRect.c	2019-07-25 19:51:04.545915688 +0300
+++ ../../informatimago/FreeRDP/libfreerdp/gdi/test/TestGdiRect.c	2019-07-25 20:11:28.499985320 +0300
@@ -156,9 +156,6 @@
 
 int TestGdiRect(int argc, char* argv[])
 {
-	WINPR_UNUSED(argc);
-	WINPR_UNUSED(argv);
-
 	if (test_gdi_PtInRect() < 0)
 		return -1;
 
diff -urN libfreerdp/gdi/test/TestGdiRop3.c ../../informatimago/FreeRDP/libfreerdp/gdi/test/TestGdiRop3.c
--- libfreerdp/gdi/test/TestGdiRop3.c	2019-07-25 19:51:04.545915688 +0300
+++ ../../informatimago/FreeRDP/libfreerdp/gdi/test/TestGdiRop3.c	2019-07-25 20:11:28.503985339 +0300
@@ -184,9 +184,7 @@
 
 int TestGdiRop3(int argc, char* argv[])
 {
-	size_t index;
-	WINPR_UNUSED(argc);
-	WINPR_UNUSED(argv);
+	int index;
 
 	for (index = 0; index < sizeof(test_ROP3) / sizeof(test_ROP3[0]); index++)
 	{
diff -urN libfreerdp/gdi/video.c ../../informatimago/FreeRDP/libfreerdp/gdi/video.c
--- libfreerdp/gdi/video.c	2019-07-25 19:51:04.553915728 +0300
+++ ../../informatimago/FreeRDP/libfreerdp/gdi/video.c	2019-07-25 20:11:28.511985379 +0300
@@ -17,8 +17,6 @@
  * limitations under the License.
  */
 
-#include "../core/update.h"
-
 #include <freerdp/client/geometry.h>
 #include <freerdp/client/video.h>
 #include <freerdp/gdi/gdi.h>
@@ -80,7 +78,6 @@
 
 static BOOL gdiVideoShowSurface(VideoClientContext* video, VideoSurface* surface)
 {
-	BOOL rc = FALSE;
 	rdpGdi* gdi = (rdpGdi*)video->custom;
 	gdiVideoSurface* gdiSurface = (gdiVideoSurface*)surface;
 	RECTANGLE_16 surfaceRect;
@@ -89,45 +86,26 @@
 	surfaceRect.top = surface->y;
 	surfaceRect.right = surface->x + surface->w;
 	surfaceRect.bottom = surface->y + surface->h;
-
-	if (!update_begin_paint(update))
-		goto fail;
-
-	if ((gdi->width < 0) || (gdi->height < 0))
-		goto fail;
-	else
+	update->BeginPaint(gdi->context);
 	{
 		const UINT32 nXSrc = surface->x;
 		const UINT32 nYSrc = surface->y;
 		const UINT32 nXDst = nXSrc;
 		const UINT32 nYDst = nYSrc;
-		const UINT32 width = (surface->w + surface->x < (UINT32)gdi->width)
-		                         ? surface->w
-		                         : (UINT32)gdi->width - surface->x;
-		const UINT32 height = (surface->h + surface->y < (UINT32)gdi->height)
-		                          ? surface->h
-		                          : (UINT32)gdi->height - surface->y;
+		const UINT32 width =
+		    (surface->w + surface->x < gdi->width) ? surface->w : gdi->width - surface->x;
+		const UINT32 height =
+		    (surface->h + surface->y < gdi->height) ? surface->h : gdi->height - surface->y;
 
 		if (!freerdp_image_copy(gdi->primary_buffer, gdi->primary->hdc->format, gdi->stride, nXDst,
 		                        nYDst, width, height, surface->data, gdi->primary->hdc->format,
 		                        gdiSurface->scanline, 0, 0, NULL, FREERDP_FLIP_NONE))
-			goto fail;
-
-		if ((nXDst > INT32_MAX) || (nYDst > INT32_MAX) || (width > INT32_MAX) ||
-		    (height > INT32_MAX))
-			goto fail;
+			return CHANNEL_RC_NULL_DATA;
 
-		gdi_InvalidateRegion(gdi->primary->hdc, (INT32)nXDst, (INT32)nYDst, (INT32)width,
-		                     (INT32)height);
+		gdi_InvalidateRegion(gdi->primary->hdc, nXDst, nYDst, width, height);
 	}
-
-	rc = TRUE;
-fail:
-
-	if (!update_end_paint(update))
-		return FALSE;
-
-	return rc;
+	update->EndPaint(gdi->context);
+	return TRUE;
 }
 
 static BOOL gdiVideoDeleteSurface(VideoClientContext* video, VideoSurface* surface)
diff -urN libfreerdp/locale/xkb_layout_ids.c ../../informatimago/FreeRDP/libfreerdp/locale/xkb_layout_ids.c
--- libfreerdp/locale/xkb_layout_ids.c	2019-07-25 19:51:04.765916780 +0300
+++ ../../informatimago/FreeRDP/libfreerdp/locale/xkb_layout_ids.c	2019-07-25 20:11:28.719986411 +0300
@@ -832,7 +832,7 @@
 
 UINT32 find_keyboard_layout_in_xorg_rules(char* layout, char* variant)
 {
-	size_t i, j;
+	int i, j;
 
 	if ((layout == NULL) || (variant == NULL))
 		return 0;
diff -urN libfreerdp/mit-krb5-pkinit/CMakeLists.txt ../../informatimago/FreeRDP/libfreerdp/mit-krb5-pkinit/CMakeLists.txt
--- libfreerdp/mit-krb5-pkinit/CMakeLists.txt	1970-01-01 03:00:00.000000000 +0300
+++ ../../informatimago/FreeRDP/libfreerdp/mit-krb5-pkinit/CMakeLists.txt	2019-07-19 20:00:34.133156354 +0300
@@ -0,0 +1,12 @@
+set(MODULE_NAME "freerdp-mit-krb5-pkinit")
+set(MODULE_PREFIX "FREERDP_MIT_KRB5_PKINIT")
+set(${MODULE_PREFIX}_SRCS
+  kinit.c
+  kinit_kdb.c
+  )
+set(${MODULE_PREFIX}_LIBRARIES
+  kdb5
+  kadm5clnt
+  )
+freerdp_module_add(${${MODULE_PREFIX}_SRCS})
+freerdp_library_add(${${MODULE_PREFIX}_LIBRARIES})
diff -urN libfreerdp/mit-krb5-pkinit/extern.h ../../informatimago/FreeRDP/libfreerdp/mit-krb5-pkinit/extern.h
--- libfreerdp/mit-krb5-pkinit/extern.h	1970-01-01 03:00:00.000000000 +0300
+++ ../../informatimago/FreeRDP/libfreerdp/mit-krb5-pkinit/extern.h	2019-07-19 20:00:34.133156354 +0300
@@ -0,0 +1,33 @@
+/* -*- mode: c; c-basic-offset: 4; indent-tabs-mode: nil -*- */
+/* clients/kinit/extern.h - Global declarations for kinit */
+/*
+ * Copyright (C) 2010 by the Massachusetts Institute of Technology.
+ * All rights reserved.
+ *
+ * Export of this software from the United States of America may
+ *   require a specific license from the United States Government.
+ *   It is the responsibility of any person or organization contemplating
+ *   export to obtain such a license before exporting.
+ *
+ * WITHIN THAT CONSTRAINT, permission to use, copy, modify, and
+ * distribute this software and its documentation for any purpose and
+ * without fee is hereby granted, provided that the above copyright
+ * notice appear in all copies and that both that copyright notice and
+ * this permission notice appear in supporting documentation, and that
+ * the name of M.I.T. not be used in advertising or publicity pertaining
+ * to distribution of the software without specific, written prior
+ * permission.  Furthermore if you modify this software you must label
+ * your software as modified software and not distribute it in such a
+ * fashion that it might be confused with the original M.I.T. software.
+ * M.I.T. makes no representations about the suitability of
+ * this software for any purpose.  It is provided "as is" without express
+ * or implied warranty.
+ */
+
+#ifndef KINIT_EXTERN_H
+#define KINIT_EXTERN_H
+
+krb5_error_code kinit_kdb_init(krb5_context* pcontext, char* realm);
+void kinit_kdb_fini(void);
+
+#endif /* KINIT_EXTERN_H */
diff -urN libfreerdp/mit-krb5-pkinit/kinit.c ../../informatimago/FreeRDP/libfreerdp/mit-krb5-pkinit/kinit.c
--- libfreerdp/mit-krb5-pkinit/kinit.c	1970-01-01 03:00:00.000000000 +0300
+++ ../../informatimago/FreeRDP/libfreerdp/mit-krb5-pkinit/kinit.c	2019-07-25 20:11:28.751986569 +0300
@@ -0,0 +1,976 @@
+/* -*- mode: c; c-basic-offset: 4; indent-tabs-mode: nil -*- */
+/* clients/kinit/kinit.c - Initialize a credential cache */
+/*
+ * Copyright 1990, 2008 by the Massachusetts Institute of Technology.
+ * All Rights Reserved.
+ *
+ * Export of this software from the United States of America may
+ *   require a specific license from the United States Government.
+ *   It is the responsibility of any person or organization contemplating
+ *   export to obtain such a license before exporting.
+ *
+ * WITHIN THAT CONSTRAINT, permission to use, copy, modify, and
+ * distribute this software and its documentation for any purpose and
+ * without fee is hereby granted, provided that the above copyright
+ * notice appear in all copies and that both that copyright notice and
+ * this permission notice appear in supporting documentation, and that
+ * the name of M.I.T. not be used in advertising or publicity pertaining
+ * to distribution of the software without specific, written prior
+ * permission.  Furthermore if you modify this software you must label
+ * your software as modified software and not distribute it in such a
+ * fashion that it might be confused with the original M.I.T. software.
+ * M.I.T. makes no representations about the suitability of
+ * this software for any purpose.  It is provided "as is" without express
+ * or implied warranty.
+ */
+
+// #include "autoconf.h"
+// #include <k5-int.h>
+// #include "k5-platform.h"        /* For asprintf and getopt */
+#include <locale.h>
+#include <ctype.h>
+#include <string.h>
+#include <stdio.h>
+#include <time.h>
+#include <errno.h>
+
+#include <krb5.h>
+#include <com_err.h>
+
+#include <freerdp/log.h>
+#include <freerdp/settings.h>
+#include <winpr/strlst.h>
+
+#include "extern.h"
+#include "kinit.h"
+
+#define TAG CLIENT_TAG("kinit")
+
+#define _(s) s
+
+krb5_error_code k5_kt_get_principal(krb5_context context, krb5_keytab keytab,
+                                    krb5_principal* princ_out);
+
+krb5_error_code krb5int_copy_data_contents_add0(krb5_context, const krb5_data*, krb5_data*);
+
+/* Return the delta between two timestamps (a - b) as a signed 32-bit value,
+ * without relying on undefined behavior. */
+static inline krb5_deltat ts_delta(krb5_timestamp a, krb5_timestamp b)
+{
+	return (krb5_deltat)((uint32_t)a - (uint32_t)b);
+}
+
+/* Copy a data structure, with fresh allocation. */
+krb5_error_code KRB5_CALLCONV krb5_copy_data_add0(krb5_context context, const krb5_data* indata,
+                                                  krb5_data** outdata)
+{
+	krb5_data* tempdata;
+	krb5_error_code retval;
+
+	if (!indata)
+	{
+		*outdata = 0;
+		return 0;
+	}
+
+	if (!(tempdata = (krb5_data*)malloc(sizeof(*tempdata))))
+		return ENOMEM;
+
+	retval = krb5int_copy_data_contents_add0(context, indata, tempdata);
+
+	if (retval)
+	{
+		krb5_free_data_contents(context, tempdata);
+		return retval;
+	}
+
+	*outdata = tempdata;
+	return 0;
+}
+
+#ifdef HAVE_PWD_H
+#	include <pwd.h>
+static char* get_name_from_os()
+{
+	struct passwd* pw;
+	pw = getpwuid(getuid());
+	return (pw != NULL) ? pw->pw_name : NULL;
+}
+#else /* HAVE_PWD_H */
+#	ifdef _WIN32
+static char* get_name_from_os()
+{
+	static char name[1024];
+	DWORD name_size = sizeof(name);
+
+	if (GetUserName(name, &name_size))
+	{
+		name[sizeof(name) - 1] = '\0'; /* Just to be extra safe */
+		return name;
+	}
+	else
+	{
+		return NULL;
+	}
+}
+#	else  /* _WIN32 */
+static char* get_name_from_os()
+{
+	return NULL;
+}
+#	endif /* _WIN32 */
+#endif     /* HAVE_PWD_H */
+
+typedef enum
+{
+	INIT_PW,
+	INIT_KT,
+	RENEW,
+	VALIDATE
+} action_type;
+
+struct k_opts
+{
+	/* In seconds */
+	krb5_deltat starttime;
+	krb5_deltat lifetime;
+	krb5_deltat rlife;
+
+	int forwardable;
+	int proxiable;
+	int request_pac;
+	int anonymous;
+	int addresses;
+
+	int not_forwardable;
+	int not_proxiable;
+	int not_request_pac;
+	int no_addresses;
+
+	int verbose;
+
+	char* principal_name;
+	char* service_name;
+	char* keytab_name;
+	char* k5_in_cache_name;
+	char* k5_out_cache_name;
+	char* armor_ccache;
+
+	action_type action;
+	int use_client_keytab;
+
+	int num_pa_opts;
+	krb5_gic_opt_pa_data* pa_opts;
+
+	int canonicalize;
+	int enterprise;
+
+	/* output */
+	krb5_data* outdata;
+};
+
+void pa_opts_free(int num_pa_opts, krb5_gic_opt_pa_data* pa_opts)
+{
+	if (pa_opts != NULL)
+	{
+		int i;
+
+		for (i = 0; i < num_pa_opts; i++)
+		{
+			free(pa_opts[i].attr);
+			free(pa_opts[i].value);
+		}
+
+		free(pa_opts);
+	}
+}
+
+void k_opts_free_fields(struct k_opts* opts)
+{
+	free(opts->principal_name);
+	free(opts->service_name);
+	free(opts->keytab_name);
+	free(opts->k5_in_cache_name);
+	free(opts->k5_out_cache_name);
+	free(opts->armor_ccache);
+	pa_opts_free(opts->num_pa_opts, opts->pa_opts);
+	memset(opts, 0, sizeof(*opts));
+}
+
+struct k5_data
+{
+	krb5_context ctx;
+	krb5_ccache in_cc, out_cc;
+	krb5_principal me;
+	char* name;
+	krb5_boolean switch_to_cache;
+};
+
+#define CHECK_MEMORY(pointer, error_action)                                \
+	do                                                                     \
+	{                                                                      \
+		if (!(pointer))                                                    \
+		{                                                                  \
+			WLog_ERR(TAG, "%s:%d: out of memory", __FUNCTION__, __LINE__); \
+			error_action;                                                  \
+		}                                                                  \
+	} while (0)
+
+#define CHECK_STRING_PRESENT(string, name, error_action) \
+	do                                                   \
+	{                                                    \
+		if ((string) == NULL)                            \
+		{                                                \
+			WLog_ERR(TAG, "Missing %s", name);           \
+			error_action;                                \
+		}                                                \
+	} while (0)
+
+static krb5_context errctx;
+static void extended_com_err_fn(const char* myprog, errcode_t code, const char* fmt, va_list args)
+{
+	const char* emsg;
+	char* buffer = NULL;
+	int size = 0;
+	va_list dry;
+	va_copy(dry, args);
+	emsg = krb5_get_error_message(errctx, code);
+	WLog_ERR(myprog, "%s", emsg);
+	krb5_free_error_message(errctx, emsg);
+	size = vsnprintf(NULL, 0, fmt, dry);
+	CHECK_MEMORY(buffer = malloc(1 + size), return );
+	size = vsnprintf(buffer, 1 + size, fmt, args);
+	WLog_ERR(myprog, "%s", buffer);
+	free(buffer);
+}
+
+static int add_preauth_opt(struct k_opts* opts, char* attribute, char* value)
+{
+	size_t newsize = (opts->num_pa_opts + 1) * sizeof(*opts->pa_opts);
+	krb5_gic_opt_pa_data* p;
+	krb5_gic_opt_pa_data* x = realloc(opts->pa_opts, newsize);
+
+	if (x == NULL)
+	{
+		return ENOMEM;
+	}
+
+	opts->pa_opts = x;
+	p = &opts->pa_opts[opts->num_pa_opts];
+	p->attr = attribute;
+	p->value = value;
+	opts->num_pa_opts++;
+	return 0;
+}
+
+static int k5_begin(struct k_opts* opts, struct k5_data* k5)
+{
+	krb5_error_code ret;
+	int success = 0;
+	int flags = opts->enterprise ? KRB5_PRINCIPAL_PARSE_ENTERPRISE : 0;
+	krb5_ccache defcache = NULL;
+	krb5_principal defcache_princ = NULL, princ;
+	krb5_keytab keytab;
+	const char* deftype = NULL;
+	char *defrealm, *name;
+	ret = krb5_init_context(&k5->ctx);
+
+	if (ret)
+	{
+		com_err(TAG, ret, _("while initializing Kerberos 5 library"));
+		return 0;
+	}
+
+	errctx = k5->ctx;
+
+	if (opts->k5_out_cache_name)
+	{
+		ret = krb5_cc_resolve(k5->ctx, opts->k5_out_cache_name, &k5->out_cc);
+
+		if (ret)
+		{
+			com_err(TAG, ret, _("resolving ccache %s"), opts->k5_out_cache_name);
+			goto cleanup;
+		}
+
+		if (opts->verbose)
+		{
+			WLog_INFO(TAG, _("Using specified cache: %s"), opts->k5_out_cache_name);
+		}
+	}
+	else
+	{
+		/* Resolve the default ccache and get its type and default principal
+		 * (if it is initialized). */
+		ret = krb5_cc_default(k5->ctx, &defcache);
+
+		if (ret)
+		{
+			com_err(TAG, ret, _("while getting default ccache"));
+			goto cleanup;
+		}
+
+		deftype = krb5_cc_get_type(k5->ctx, defcache);
+
+		if (krb5_cc_get_principal(k5->ctx, defcache, &defcache_princ) != 0)
+			defcache_princ = NULL;
+	}
+
+	/* Choose a client principal name. */
+	if (opts->principal_name != NULL)
+	{
+		/* Use the specified principal name. */
+		ret = krb5_parse_name_flags(k5->ctx, opts->principal_name, flags, &k5->me);
+
+		if (ret)
+		{
+			com_err(TAG, ret, _("when parsing name %s"), opts->principal_name);
+			goto cleanup;
+		}
+	}
+	else if (opts->anonymous)
+	{
+		/* Use the anonymous principal for the local realm. */
+		ret = krb5_get_default_realm(k5->ctx, &defrealm);
+
+		if (ret)
+		{
+			com_err(TAG, ret, _("while getting default realm"));
+			goto cleanup;
+		}
+
+		ret = krb5_build_principal_ext(k5->ctx, &k5->me, strlen(defrealm), defrealm,
+		                               strlen(KRB5_WELLKNOWN_NAMESTR), KRB5_WELLKNOWN_NAMESTR,
+		                               strlen(KRB5_ANONYMOUS_PRINCSTR), KRB5_ANONYMOUS_PRINCSTR, 0);
+		krb5_free_default_realm(k5->ctx, defrealm);
+
+		if (ret)
+		{
+			com_err(TAG, ret, _("while building principal"));
+			goto cleanup;
+		}
+	}
+	else if (opts->action == INIT_KT && opts->use_client_keytab)
+	{
+		/* Use the first entry from the client keytab. */
+		ret = krb5_kt_client_default(k5->ctx, &keytab);
+
+		if (ret)
+		{
+			com_err(TAG, ret, _("When resolving the default client keytab"));
+			goto cleanup;
+		}
+
+		ret = k5_kt_get_principal(k5->ctx, keytab, &k5->me);
+		krb5_kt_close(k5->ctx, keytab);
+
+		if (ret)
+		{
+			com_err(TAG, ret, _("When determining client principal name from keytab"));
+			goto cleanup;
+		}
+	}
+	else if (opts->action == INIT_KT)
+	{
+		/* Use the default host/service name. */
+		ret = krb5_sname_to_principal(k5->ctx, NULL, NULL, KRB5_NT_SRV_HST, &k5->me);
+
+		if (ret)
+		{
+			com_err(TAG, ret, _("when creating default server principal name"));
+			goto cleanup;
+		}
+
+		if (k5->me->realm.data[0] == 0)
+		{
+			ret = krb5_unparse_name(k5->ctx, k5->me, &k5->name);
+
+			if (ret == 0)
+			{
+				com_err(TAG, KRB5_ERR_HOST_REALM_UNKNOWN, _("(principal %s)"), k5->name);
+			}
+			else
+			{
+				com_err(TAG, KRB5_ERR_HOST_REALM_UNKNOWN, _("for local services"));
+			}
+
+			goto cleanup;
+		}
+	}
+	else if (k5->out_cc != NULL)
+	{
+		/* If the output ccache is initialized, use its principal. */
+		if (krb5_cc_get_principal(k5->ctx, k5->out_cc, &princ) == 0)
+			k5->me = princ;
+	}
+	else if (defcache_princ != NULL)
+	{
+		/* Use the default cache's principal, and use the default cache as the
+		 * output cache. */
+		k5->out_cc = defcache;
+		defcache = NULL;
+		k5->me = defcache_princ;
+		defcache_princ = NULL;
+	}
+
+	/* If we still haven't chosen, use the local username. */
+	if (k5->me == NULL)
+	{
+		name = get_name_from_os();
+
+		if (name == NULL)
+		{
+			fprintf(stderr, _("Unable to identify user"));
+			goto cleanup;
+		}
+
+		ret = krb5_parse_name_flags(k5->ctx, name, flags, &k5->me);
+
+		if (ret)
+		{
+			com_err(TAG, ret, _("when parsing name %s"), name);
+			goto cleanup;
+		}
+	}
+
+	if (k5->out_cc == NULL && krb5_cc_support_switch(k5->ctx, deftype))
+	{
+		/* Use an existing cache for the client principal if we can. */
+		ret = krb5_cc_cache_match(k5->ctx, k5->me, &k5->out_cc);
+
+		if (ret && ret != KRB5_CC_NOTFOUND)
+		{
+			com_err(TAG, ret, _("while searching for ccache for %s"), opts->principal_name);
+			goto cleanup;
+		}
+
+		if (!ret)
+		{
+			if (opts->verbose)
+			{
+				WLog_INFO(TAG, _("Using existing cache: %s"),
+				          krb5_cc_get_name(k5->ctx, k5->out_cc));
+			}
+
+			k5->switch_to_cache = 1;
+		}
+		else if (defcache_princ != NULL)
+		{
+			/* Create a new cache to avoid overwriting the initialized default
+			 * cache. */
+			ret = krb5_cc_new_unique(k5->ctx, deftype, NULL, &k5->out_cc);
+
+			if (ret)
+			{
+				com_err(TAG, ret, _("while generating new ccache"));
+				goto cleanup;
+			}
+
+			if (opts->verbose)
+			{
+				WLog_INFO(TAG, _("Using new cache: %s"), krb5_cc_get_name(k5->ctx, k5->out_cc));
+			}
+
+			k5->switch_to_cache = 1;
+		}
+	}
+
+	/* Use the default cache if we haven't picked one yet. */
+	if (k5->out_cc == NULL)
+	{
+		k5->out_cc = defcache;
+		defcache = NULL;
+
+		if (opts->verbose)
+		{
+			WLog_INFO(TAG, _("Using default cache: %s"), krb5_cc_get_name(k5->ctx, k5->out_cc));
+		}
+	}
+
+	if (opts->k5_in_cache_name)
+	{
+		ret = krb5_cc_resolve(k5->ctx, opts->k5_in_cache_name, &k5->in_cc);
+
+		if (ret)
+		{
+			com_err(TAG, ret, _("resolving ccache %s"), opts->k5_in_cache_name);
+			goto cleanup;
+		}
+
+		if (opts->verbose)
+		{
+			WLog_INFO(TAG, _("Using specified input cache: %s"), opts->k5_in_cache_name);
+		}
+	}
+
+	ret = krb5_unparse_name(k5->ctx, k5->me, &k5->name);
+
+	if (ret)
+	{
+		com_err(TAG, ret, _("when unparsing name"));
+		goto cleanup;
+	}
+
+	if (opts->verbose)
+		WLog_INFO(TAG, _("Using principal: %s"), k5->name);
+
+	free(opts->principal_name);
+	CHECK_MEMORY(opts->principal_name = strdup(k5->name), goto cleanup);
+	success = 1;
+cleanup:
+
+	if (defcache != NULL)
+		krb5_cc_close(k5->ctx, defcache);
+
+	krb5_free_principal(k5->ctx, defcache_princ);
+	return success;
+}
+
+static void k5_end(struct k5_data* k5)
+{
+	krb5_free_unparsed_name(k5->ctx, k5->name);
+	krb5_free_principal(k5->ctx, k5->me);
+
+	if (k5->in_cc != NULL)
+		krb5_cc_close(k5->ctx, k5->in_cc);
+
+	if (k5->out_cc != NULL)
+		krb5_cc_close(k5->ctx, k5->out_cc);
+
+	krb5_free_context(k5->ctx);
+	errctx = NULL;
+	memset(k5, 0, sizeof(*k5));
+}
+
+static krb5_error_code KRB5_CALLCONV kinit_prompter(krb5_context ctx, void* data, const char* name,
+                                                    const char* banner, int num_prompts,
+                                                    krb5_prompt prompts[])
+{
+	krb5_boolean* pwprompt = data;
+	krb5_prompt_type* ptypes;
+	int i;
+	/* Make a note if we receive a password prompt. */
+	ptypes = krb5_get_prompt_types(ctx);
+
+	for (i = 0; i < num_prompts; i++)
+	{
+		if (ptypes != NULL && ptypes[i] == KRB5_PROMPT_TYPE_PASSWORD)
+			*pwprompt = TRUE;
+	}
+
+	return krb5_prompter_posix(ctx, data, name, banner, num_prompts, prompts);
+}
+
+static int k5_kinit(struct k_opts* opts, struct k5_data* k5)
+{
+	int notix = 1;
+	krb5_keytab keytab = 0;
+	krb5_creds my_creds;
+	krb5_error_code ret;
+	krb5_get_init_creds_opt* options = NULL;
+	krb5_boolean pwprompt = FALSE;
+	krb5_address** addresses = NULL;
+	int i;
+	memset(&my_creds, 0, sizeof(my_creds));
+	ret = krb5_get_init_creds_opt_alloc(k5->ctx, &options);
+
+	if (ret)
+		goto cleanup;
+
+	if (opts->lifetime)
+		krb5_get_init_creds_opt_set_tkt_life(options, opts->lifetime);
+
+	if (opts->rlife)
+		krb5_get_init_creds_opt_set_renew_life(options, opts->rlife);
+
+	if (opts->forwardable)
+		krb5_get_init_creds_opt_set_forwardable(options, 1);
+
+	if (opts->not_forwardable)
+		krb5_get_init_creds_opt_set_forwardable(options, 0);
+
+	if (opts->proxiable)
+		krb5_get_init_creds_opt_set_proxiable(options, 1);
+
+	if (opts->not_proxiable)
+		krb5_get_init_creds_opt_set_proxiable(options, 0);
+
+	if (opts->canonicalize)
+		krb5_get_init_creds_opt_set_canonicalize(options, 1);
+
+	if (opts->anonymous)
+		krb5_get_init_creds_opt_set_anonymous(options, 1);
+
+	if (opts->addresses)
+	{
+		ret = krb5_os_localaddr(k5->ctx, &addresses);
+
+		if (ret)
+		{
+			com_err(TAG, ret, _("getting local addresses"));
+			goto cleanup;
+		}
+
+		krb5_get_init_creds_opt_set_address_list(options, addresses);
+	}
+
+	if (opts->no_addresses)
+		krb5_get_init_creds_opt_set_address_list(options, NULL);
+
+	if (opts->armor_ccache != NULL)
+	{
+		krb5_get_init_creds_opt_set_fast_ccache_name(k5->ctx, options, opts->armor_ccache);
+	}
+
+	if (opts->request_pac)
+		krb5_get_init_creds_opt_set_pac_request(k5->ctx, options, TRUE);
+
+	if (opts->not_request_pac)
+		krb5_get_init_creds_opt_set_pac_request(k5->ctx, options, FALSE);
+
+	if (opts->action == INIT_KT && opts->keytab_name != NULL)
+	{
+#ifndef _WIN32
+
+		if (strncmp(opts->keytab_name, "KDB:", 4) == 0)
+		{
+			ret = kinit_kdb_init(&k5->ctx, k5->me->realm.data);
+
+			if (ret)
+			{
+				com_err(TAG, ret, _("while setting up KDB keytab for realm %s"),
+				        k5->me->realm.data);
+				goto cleanup;
+			}
+		}
+
+#endif
+		ret = krb5_kt_resolve(k5->ctx, opts->keytab_name, &keytab);
+
+		if (ret)
+		{
+			com_err(TAG, ret, _("resolving keytab %s"), opts->keytab_name);
+			goto cleanup;
+		}
+
+		if (opts->verbose)
+			WLog_INFO(TAG, _("Using keytab: %s"), opts->keytab_name);
+	}
+	else if (opts->action == INIT_KT && opts->use_client_keytab)
+	{
+		ret = krb5_kt_client_default(k5->ctx, &keytab);
+
+		if (ret)
+		{
+			com_err(TAG, ret, _("resolving default client keytab"));
+			goto cleanup;
+		}
+	}
+
+	for (i = 0; i < opts->num_pa_opts; i++)
+	{
+		ret = krb5_get_init_creds_opt_set_pa(k5->ctx, options, opts->pa_opts[i].attr,
+		                                     opts->pa_opts[i].value);
+
+		if (ret)
+		{
+			com_err(TAG, ret, _("while setting '%s'='%s'"), opts->pa_opts[i].attr,
+			        opts->pa_opts[i].value);
+			goto cleanup;
+		}
+
+		if (opts->verbose)
+		{
+			WLog_INFO(TAG, _("PA Option %s = %s"), opts->pa_opts[i].attr, opts->pa_opts[i].value);
+		}
+	}
+
+	if (k5->in_cc)
+	{
+		ret = krb5_get_init_creds_opt_set_in_ccache(k5->ctx, options, k5->in_cc);
+
+		if (ret)
+		{
+			com_err(TAG, ret, _("Cannot set the In Credential Cache"));
+			goto cleanup;
+		}
+	}
+
+	ret = krb5_get_init_creds_opt_set_out_ccache(k5->ctx, options, k5->out_cc);
+
+	if (ret)
+	{
+		com_err(TAG, ret, _("Cannot set the Out Credential Cache"));
+		goto cleanup;
+	}
+
+	switch (opts->action)
+	{
+	case INIT_PW:
+		ret = krb5_get_init_creds_password(k5->ctx, &my_creds, k5->me, 0, kinit_prompter, &pwprompt,
+		                                   opts->starttime, opts->service_name, options);
+		break;
+
+	case INIT_KT:
+		ret = krb5_get_init_creds_keytab(k5->ctx, &my_creds, k5->me, keytab, opts->starttime,
+		                                 opts->service_name, options);
+		break;
+
+	case VALIDATE:
+		ret = krb5_get_validated_creds(k5->ctx, &my_creds, k5->me, k5->out_cc, opts->service_name);
+		break;
+
+	case RENEW:
+		ret = krb5_get_renewed_creds(k5->ctx, &my_creds, k5->me, k5->out_cc, opts->service_name);
+		break;
+	}
+
+	if (ret)
+	{
+		char* doing = NULL;
+
+		switch (opts->action)
+		{
+		case INIT_PW:
+		case INIT_KT:
+			doing = _("getting initial credentials");
+			break;
+
+		case VALIDATE:
+			doing = _("validating credentials");
+			break;
+
+		case RENEW:
+			doing = _("renewing credentials");
+			break;
+		}
+
+		/* If reply decryption failed, or if pre-authentication failed and we
+		 * were prompted for a password, assume the password was wrong. */
+		if (ret == KRB5KRB_AP_ERR_BAD_INTEGRITY || (pwprompt && ret == KRB5KDC_ERR_PREAUTH_FAILED))
+		{
+			com_err(TAG, ret, _("Password incorrect while %s with %s"), doing, opts->service_name);
+		}
+		else
+		{
+			com_err(TAG, ret, _("while %s with %s"), doing, opts->service_name);
+		}
+
+		goto cleanup;
+	}
+
+	if (opts->action != INIT_PW && opts->action != INIT_KT)
+	{
+		ret =
+		    krb5_cc_initialize(k5->ctx, k5->out_cc, opts->canonicalize ? my_creds.client : k5->me);
+
+		if (ret)
+		{
+			com_err(TAG, ret, _("when initializing cache %s"),
+			        opts->k5_out_cache_name ? opts->k5_out_cache_name : "");
+			goto cleanup;
+		}
+
+		if (opts->verbose)
+			WLog_INFO(TAG, _("Initialized cache"));
+
+		ret = krb5_cc_store_cred(k5->ctx, k5->out_cc, &my_creds);
+
+		if (ret)
+		{
+			com_err(TAG, ret, _("while storing credentials"));
+			goto cleanup;
+		}
+
+		if (opts->verbose)
+			WLog_INFO(TAG, _("Stored credentials"));
+	}
+
+	/* Get canonicalized principal name for credentials delegation (CredSSP) */
+	krb5_copy_data_add0(k5->ctx, my_creds.client->data, &(opts->outdata));
+	notix = 0;
+
+	if (k5->switch_to_cache)
+	{
+		ret = krb5_cc_switch(k5->ctx, k5->out_cc);
+
+		if (ret)
+		{
+			com_err(TAG, ret, _("while switching to new ccache"));
+			goto cleanup;
+		}
+	}
+
+cleanup:
+#ifndef _WIN32
+	kinit_kdb_fini();
+#endif
+
+	if (options)
+		krb5_get_init_creds_opt_free(k5->ctx, options);
+
+	if (my_creds.client == k5->me)
+		my_creds.client = 0;
+
+	krb5_free_cred_contents(k5->ctx, &my_creds);
+
+	if (keytab != NULL)
+		krb5_kt_close(k5->ctx, keytab);
+
+	return notix ? 0 : 1;
+}
+
+static int kinit(struct k_opts* opts, char** canonicalized_user)
+{
+	int authed_k5 = 0;
+	struct k5_data k5;
+	set_com_err_hook(extended_com_err_fn);
+	memset(&k5, 0, sizeof(k5));
+
+	if (k5_begin(opts, &k5))
+	{
+		authed_k5 = k5_kinit(opts, &k5);
+	}
+
+	if (authed_k5)
+	{
+		WLog_INFO(TAG, "Authenticated to Kerberos v5");
+
+		if (opts->outdata)
+		{
+			if (opts->outdata->data)
+			{
+				CHECK_MEMORY((*canonicalized_user) = strdup(opts->outdata->data),
+				             authed_k5 = FALSE);
+			}
+			else
+			{
+				WLog_WARN(TAG, "kinit couldn't canonicalize the UPN %s.", opts->principal_name);
+			}
+
+			krb5_free_data(k5.ctx, opts->outdata);
+		}
+		else
+		{
+			WLog_ERR(TAG, "kinit produced no output data.");
+		}
+	}
+	else
+	{
+		WLog_ERR(TAG, "Not authenticated to Kerberos v5.");
+	}
+
+	k5_end(&k5);
+	return authed_k5 ? 0 : 1;
+}
+
+static int convert_deltat(char* timestring, krb5_deltat* deltat, int try_absolute, const char* what)
+{
+	/* See: http://web.mit.edu/kerberos/krb5-latest/doc/basic/date_format.html */
+	if (timestring == NULL)
+	{
+		return 0;
+	}
+
+	if (krb5_string_to_deltat(timestring, deltat) != 0)
+	{
+		krb5_timestamp abs_starttime;
+
+		if (!try_absolute)
+		{
+			goto bad;
+		}
+
+		/* Parse as an absolute time; intentionally undocumented
+		 * but left for backwards compatibility. */
+		if ((krb5_string_to_timestamp(timestring, &abs_starttime) != 0) || (abs_starttime == 0))
+		{
+			goto bad;
+		}
+
+		(*deltat) = ts_delta(abs_starttime, time(NULL));
+	}
+
+	return 0;
+bad:
+	WLog_ERR(TAG, "Bad %s option %s", what, timestring);
+	return 1;
+}
+
+static int fill_opts_with_settings(rdpSettings* settings, struct k_opts* opts)
+{
+	char* attribute = NULL;
+	char* value = NULL;
+	char** anchors = NULL;
+	memset(opts, 0, sizeof(*opts));
+	opts->verbose = settings->Krb5Trace;
+	opts->canonicalize = 1;
+	opts->enterprise = 1;
+	opts->action = INIT_PW;
+
+	if ((0 != convert_deltat(settings->KerberosStartTime, &opts->starttime, 1, "start time")) ||
+	    (0 != convert_deltat(settings->KerberosLifeTime, &opts->lifetime, 0, "life time")) ||
+	    (0 !=
+	     convert_deltat(settings->KerberosRenewableLifeTime, &opts->rlife, 0, "renewable time")))
+	{
+		goto error;
+	}
+
+	CHECK_STRING_PRESENT(settings->UserPrincipalName, "user principal name setting", goto error);
+	CHECK_STRING_PRESENT(settings->PkinitIdentity, "pkinit Identity setting", goto error);
+	CHECK_MEMORY(opts->principal_name = strdup(settings->UserPrincipalName), goto error);
+	CHECK_MEMORY(value = strdup(settings->PkinitIdentity), goto error);
+	CHECK_MEMORY(attribute = strdup("X509_user_identity"), goto error);
+
+	if (0 != add_preauth_opt(opts, attribute, value))
+	{
+		WLog_ERR(TAG, "Could not add preauth option %s = %s", attribute, value);
+		goto error;
+	}
+
+	if (settings->PkinitAnchors != NULL)
+	{
+		int i;
+		anchors = string_list_split_string(settings->PkinitAnchors, ",",
+		                                   /* remove_empty_substring = */ 1);
+
+		for (i = 0; anchors[i] != NULL; i++)
+		{
+			CHECK_MEMORY(attribute = strdup("X509_anchors"), goto error);
+			CHECK_MEMORY(value = string_concatenate("FILE:", anchors[i], NULL), goto error);
+
+			if (0 != add_preauth_opt(opts, attribute, value))
+			{
+				WLog_ERR(TAG, "Could not add preauth option %s = %s", attribute, value);
+				goto error;
+			}
+		}
+
+		string_list_free(anchors);
+	}
+
+	return 0;
+error:
+	free(attribute);
+	free(value);
+	string_list_free(anchors);
+	k_opts_free_fields(opts);
+	return 1;
+}
+
+int kerberos_get_tgt(rdpSettings* settings)
+{
+	int ret = 0;
+	struct k_opts opts;
+
+	if (fill_opts_with_settings(settings, &opts) != 0)
+	{
+		return 1;
+	}
+
+	ret = kinit(&opts, &settings->CanonicalizedUserHint);
+	k_opts_free_fields(&opts);
+	return ret;
+}
+
+/**** THE END ****/
diff -urN libfreerdp/mit-krb5-pkinit/kinit.h ../../informatimago/FreeRDP/libfreerdp/mit-krb5-pkinit/kinit.h
--- libfreerdp/mit-krb5-pkinit/kinit.h	1970-01-01 03:00:00.000000000 +0300
+++ ../../informatimago/FreeRDP/libfreerdp/mit-krb5-pkinit/kinit.h	2019-07-25 20:11:28.751986569 +0300
@@ -0,0 +1,20 @@
+#ifndef LIBFREERDP_MIT_KRB5_PKINIT_H
+#define LIBFREERDP_MIT_KRB5_PKINIT_H
+#include <freerdp/settings.h>
+
+/**
+ * @brief Gets a kerberos Ticket Granting Ticket.
+ * @param settings->Krb5Trace [input] boolean to set the verbose flag.
+ * @param settings->KerberosStartTime [input] string
+ * @param settings->KerberosLifeTime [input] string
+ * @param settings->KerberosRenewableLifeTime [input] string
+ * @param settings->UserPrincipalName [input] string user principal name setting", goto error);
+ * @param settings->PkinitIdentity [input] string The PKInit identity string.
+ * @param settings->PkinitAnchors [input] string The list of certifciate anchor files, separated
+ * with commas.
+ * @param settings->CanonicalizedUserHint [output] string Stores the canonicalized UserHint.
+ * @return 0 in case of success,  non 0 in case of failure.
+ */
+int kerberos_get_tgt(rdpSettings* settings);
+
+#endif
diff -urN libfreerdp/mit-krb5-pkinit/kinit_kdb.c ../../informatimago/FreeRDP/libfreerdp/mit-krb5-pkinit/kinit_kdb.c
--- libfreerdp/mit-krb5-pkinit/kinit_kdb.c	1970-01-01 03:00:00.000000000 +0300
+++ ../../informatimago/FreeRDP/libfreerdp/mit-krb5-pkinit/kinit_kdb.c	2019-07-25 20:11:28.755986589 +0300
@@ -0,0 +1,75 @@
+/* -*- mode: c; c-basic-offset: 4; indent-tabs-mode: nil -*- */
+/* clients/kinit/kinit_kdb.c */
+/*
+ * Copyright (C) 2010 by the Massachusetts Institute of Technology.
+ * All rights reserved.
+ *
+ * Export of this software from the United States of America may
+ *   require a specific license from the United States Government.
+ *   It is the responsibility of any person or organization contemplating
+ *   export to obtain such a license before exporting.
+ *
+ * WITHIN THAT CONSTRAINT, permission to use, copy, modify, and
+ * distribute this software and its documentation for any purpose and
+ * without fee is hereby granted, provided that the above copyright
+ * notice appear in all copies and that both that copyright notice and
+ * this permission notice appear in supporting documentation, and that
+ * the name of M.I.T. not be used in advertising or publicity pertaining
+ * to distribution of the software without specific, written prior
+ * permission.  Furthermore if you modify this software you must label
+ * your software as modified software and not distribute it in such a
+ * fashion that it might be confused with the original M.I.T. software.
+ * M.I.T. makes no representations about the suitability of
+ * this software for any purpose.  It is provided "as is" without express
+ * or implied warranty.
+ */
+
+/**
+ *    @file kinit_kdb.c
+ *    Operations to open the KDB and make the KDB key table available
+ *    for kinit.
+ */
+
+#include <string.h>
+
+#include <kadm5/admin.h>
+#include <kdb.h>
+#include "extern.h"
+
+/* Server handle */
+static void* server_handle;
+
+/* Free and reinitialize *pcontext with the KDB opened to the given realm, so
+ * that it can be used with the KDB keytab type. */
+krb5_error_code kinit_kdb_init(krb5_context* pcontext, char* realm)
+{
+	kadm5_config_params config;
+	krb5_error_code ret;
+
+	if (*pcontext)
+	{
+		krb5_free_context(*pcontext);
+		*pcontext = NULL;
+	}
+
+	memset(&config, 0, sizeof config);
+	ret = kadm5_init_krb5_context(pcontext);
+
+	if (ret)
+		return ret;
+
+	config.mask = KADM5_CONFIG_REALM;
+	config.realm = realm;
+	ret = kadm5_init(*pcontext, "kinit", NULL, "kinit", &config, KADM5_STRUCT_VERSION,
+	                 KADM5_API_VERSION_4, NULL, &server_handle);
+
+	if (ret)
+		return ret;
+
+	return krb5_db_register_keytab(*pcontext);
+}
+
+void kinit_kdb_fini()
+{
+	kadm5_destroy(server_handle);
+}
diff -urN libfreerdp/primitives/prim_alphaComp_opt.c ../../informatimago/FreeRDP/libfreerdp/primitives/prim_alphaComp_opt.c
--- libfreerdp/primitives/prim_alphaComp_opt.c	2019-07-25 19:51:04.909917494 +0300
+++ ../../informatimago/FreeRDP/libfreerdp/primitives/prim_alphaComp_opt.c	2019-07-25 20:11:28.895987283 +0300
@@ -52,8 +52,7 @@
 	const UINT32* sptr1 = (const UINT32*)pSrc1;
 	const UINT32* sptr2 = (const UINT32*)pSrc2;
 	UINT32* dptr;
-	int linebytes, src1Jump, src2Jump, dstJump;
-	UINT32 y;
+	int linebytes, src1Jump, src2Jump, dstJump, y;
 	__m128i xmm0, xmm1;
 
 	if ((width <= 0) || (height <= 0))
diff -urN libfreerdp/primitives/prim_colors.c ../../informatimago/FreeRDP/libfreerdp/primitives/prim_colors.c
--- libfreerdp/primitives/prim_colors.c	2019-07-25 19:51:04.925917573 +0300
+++ ../../informatimago/FreeRDP/libfreerdp/primitives/prim_colors.c	2019-07-25 20:11:28.907987343 +0300
@@ -292,8 +292,6 @@
                                     const INT16* g, const INT16* b, DWORD width)
 {
 	DWORD x;
-	WINPR_UNUSED(formatSize);
-	WINPR_UNUSED(DstFormat);
 
 	for (x = 0; x < width; x++)
 	{
@@ -310,8 +308,6 @@
                                     const INT16* g, const INT16* b, DWORD width)
 {
 	DWORD x;
-	WINPR_UNUSED(formatSize);
-	WINPR_UNUSED(DstFormat);
 
 	for (x = 0; x < width; x++)
 	{
@@ -328,8 +324,6 @@
                                      const INT16* g, const INT16* b, DWORD width)
 {
 	DWORD x;
-	WINPR_UNUSED(formatSize);
-	WINPR_UNUSED(DstFormat);
 
 	for (x = 0; x < width; x++)
 	{
@@ -347,8 +341,6 @@
                                      const INT16* g, const INT16* b, DWORD width)
 {
 	DWORD x;
-	WINPR_UNUSED(formatSize);
-	WINPR_UNUSED(DstFormat);
 
 	for (x = 0; x < width; x++)
 	{
@@ -366,8 +358,6 @@
                                      const INT16* g, const INT16* b, DWORD width)
 {
 	DWORD x;
-	WINPR_UNUSED(formatSize);
-	WINPR_UNUSED(DstFormat);
 
 	for (x = 0; x < width; x++)
 	{
@@ -385,8 +375,6 @@
                                      const INT16* g, const INT16* b, DWORD width)
 {
 	DWORD x;
-	WINPR_UNUSED(formatSize);
-	WINPR_UNUSED(DstFormat);
 
 	for (x = 0; x < width; x++)
 	{
diff -urN libfreerdp/primitives/prim_colors_opt.c ../../informatimago/FreeRDP/libfreerdp/primitives/prim_colors_opt.c
--- libfreerdp/primitives/prim_colors_opt.c	2019-07-25 19:51:04.969917791 +0300
+++ ../../informatimago/FreeRDP/libfreerdp/primitives/prim_colors_opt.c	2019-07-25 20:11:28.955987580 +0300
@@ -73,8 +73,7 @@
 {
 	__m128i zero, max, r_cr, g_cb, g_cr, b_cb, c4096;
 	__m128i *y_buf, *cb_buf, *cr_buf, *r_buf, *g_buf, *b_buf;
-	UINT32 yp;
-	int srcbump, dstbump, imax;
+	int srcbump, dstbump, yp, imax;
 
 	if (((ULONG_PTR)(pSrc[0]) & 0x0f) || ((ULONG_PTR)(pSrc[1]) & 0x0f) ||
 	    ((ULONG_PTR)(pSrc[2]) & 0x0f) || ((ULONG_PTR)(pDst[0]) & 0x0f) ||
@@ -211,7 +210,7 @@
 	const UINT32 step = sizeof(__m128i) / sizeof(INT16);
 	const UINT32 imax = (roi->width - pad) * sizeof(INT16) / sizeof(__m128i);
 	BYTE* d_buf = pDst;
-	UINT32 yp;
+	int yp;
 	const size_t dstPad = (dstStep - roi->width * 4);
 #	ifdef DO_PREFETCH
 
@@ -398,7 +397,7 @@
 	const UINT32 step = sizeof(__m128i) / sizeof(INT16);
 	const UINT32 imax = (roi->width - pad) * sizeof(INT16) / sizeof(__m128i);
 	BYTE* d_buf = pDst;
-	UINT32 yp;
+	int yp;
 	const size_t dstPad = (dstStep - roi->width * 4);
 #	ifdef DO_PREFETCH
 
@@ -601,8 +600,7 @@
 {
 	__m128i min, max, y_r, y_g, y_b, cb_r, cb_g, cb_b, cr_r, cr_g, cr_b;
 	__m128i *r_buf, *g_buf, *b_buf, *y_buf, *cb_buf, *cr_buf;
-	UINT32 yp;
-	int srcbump, dstbump, imax;
+	int srcbump, dstbump, yp, imax;
 
 	if (((ULONG_PTR)(pSrc[0]) & 0x0f) || ((ULONG_PTR)(pSrc[1]) & 0x0f) ||
 	    ((ULONG_PTR)(pSrc[2]) & 0x0f) || ((ULONG_PTR)(pDst[0]) & 0x0f) ||
diff -urN libfreerdp/primitives/prim_internal.h ../../informatimago/FreeRDP/libfreerdp/primitives/prim_internal.h
--- libfreerdp/primitives/prim_internal.h	2019-07-25 19:51:04.981917850 +0300
+++ ../../informatimago/FreeRDP/libfreerdp/primitives/prim_internal.h	2019-07-25 20:11:28.963987621 +0300
@@ -46,8 +46,6 @@
 static INLINE BYTE* writePixelBGRX(BYTE* dst, DWORD formatSize, UINT32 format, BYTE R, BYTE G,
                                    BYTE B, BYTE A)
 {
-	WINPR_UNUSED(formatSize);
-	WINPR_UNUSED(format);
 	*dst++ = B;
 	*dst++ = G;
 	*dst++ = R;
@@ -58,8 +56,6 @@
 static INLINE BYTE* writePixelRGBX(BYTE* dst, DWORD formatSize, UINT32 format, BYTE R, BYTE G,
                                    BYTE B, BYTE A)
 {
-	WINPR_UNUSED(formatSize);
-	WINPR_UNUSED(format);
 	*dst++ = R;
 	*dst++ = G;
 	*dst++ = B;
@@ -70,8 +66,6 @@
 static INLINE BYTE* writePixelXBGR(BYTE* dst, DWORD formatSize, UINT32 format, BYTE R, BYTE G,
                                    BYTE B, BYTE A)
 {
-	WINPR_UNUSED(formatSize);
-	WINPR_UNUSED(format);
 	*dst++ = A;
 	*dst++ = B;
 	*dst++ = G;
@@ -82,8 +76,6 @@
 static INLINE BYTE* writePixelXRGB(BYTE* dst, DWORD formatSize, UINT32 format, BYTE R, BYTE G,
                                    BYTE B, BYTE A)
 {
-	WINPR_UNUSED(formatSize);
-	WINPR_UNUSED(format);
 	*dst++ = A;
 	*dst++ = R;
 	*dst++ = G;
diff -urN libfreerdp/primitives/primitives.c ../../informatimago/FreeRDP/libfreerdp/primitives/primitives.c
--- libfreerdp/primitives/primitives.c	2019-07-25 19:51:05.009917989 +0300
+++ ../../informatimago/FreeRDP/libfreerdp/primitives/primitives.c	2019-07-25 20:11:28.991987760 +0300
@@ -38,9 +38,6 @@
 /* ------------------------------------------------------------------------- */
 static BOOL CALLBACK primitives_init_generic(PINIT_ONCE once, PVOID param, PVOID* context)
 {
-	WINPR_UNUSED(once);
-	WINPR_UNUSED(param);
-	WINPR_UNUSED(context);
 	primitives_init_add(&pPrimitivesGeneric);
 	primitives_init_andor(&pPrimitivesGeneric);
 	primitives_init_alphaComp(&pPrimitivesGeneric);
@@ -57,9 +54,6 @@
 #if defined(HAVE_OPTIMIZED_PRIMITIVES)
 static BOOL CALLBACK primitives_init(PINIT_ONCE once, PVOID param, PVOID* context)
 {
-	WINPR_UNUSED(once);
-	WINPR_UNUSED(param);
-	WINPR_UNUSED(context);
 	/* Now call each section's initialization routine. */
 	primitives_init_add_opt(&pPrimitives);
 	primitives_init_andor_opt(&pPrimitives);
diff -urN libfreerdp/primitives/prim_YUV.c ../../informatimago/FreeRDP/libfreerdp/primitives/prim_YUV.c
--- libfreerdp/primitives/prim_YUV.c	2019-07-25 19:51:04.813917018 +0300
+++ ../../informatimago/FreeRDP/libfreerdp/primitives/prim_YUV.c	2019-07-25 20:11:28.799986807 +0300
@@ -1316,21 +1316,6 @@
                                                BYTE* pDst2[3], const UINT32 dst2Step[3],
                                                const prim_size_t* roi)
 {
-	if (!pSrc || !pDst1 || !dst1Step || !pDst2 || !dst2Step)
-		return -1;
-
-	if (!pDst1[0] || !pDst1[1] || !pDst1[2])
-		return -1;
-
-	if (!dst1Step[0] || !dst1Step[1] || !dst1Step[2])
-		return -1;
-
-	if (!pDst2[0] || !pDst2[1] || !pDst2[2])
-		return -1;
-
-	if (!dst2Step[0] || !dst2Step[1] || !dst2Step[2])
-		return -1;
-
 	switch (srcFormat)
 	{
 	case PIXEL_FORMAT_BGRA32:
diff -urN libfreerdp/primitives/test/TestPrimitives.c ../../informatimago/FreeRDP/libfreerdp/primitives/test/TestPrimitives.c
--- libfreerdp/primitives/test/TestPrimitives.c	2019-07-25 20:17:16.457710830 +0300
+++ ../../informatimago/FreeRDP/libfreerdp/primitives/test/TestPrimitives.c	2019-07-25 20:11:28.999987799 +0300
@@ -4,11 +4,9 @@
 #include <string.h> /* NOLINT */
 
 #if defined(_MSC_VER)
-#pragma warning(disable : 4996) /* deprecation */
+#	pragma warning(disable : 4996) /* deprecation */
 #endif
 
-
-
 /* Forward declare test functions. */
 int TestPrimitivesAdd(int, char*[]);
 int TestPrimitivesAlphaComp(int, char*[]);
@@ -22,171 +20,151 @@
 int TestPrimitivesYCbCr(int, char*[]);
 int TestPrimitivesYCoCg(int, char*[]);
 
-
 #ifdef __cplusplus
-#define CM_CAST(TYPE, EXPR) static_cast<TYPE>(EXPR)
+#	define CM_CAST(TYPE, EXPR) static_cast<TYPE>(EXPR)
 #else
-#define CM_CAST(TYPE, EXPR) (TYPE)(EXPR)
+#	define CM_CAST(TYPE, EXPR) (TYPE)(EXPR)
 #endif
 
 /* Create map.  */
 
-typedef int (*MainFuncPointer)(int, char* []); /* NOLINT */
-typedef struct /* NOLINT */
+typedef int (*MainFuncPointer)(int, char*[]); /* NOLINT */
+typedef struct                                /* NOLINT */
 {
-  const char* name;
-  MainFuncPointer func;
+	const char* name;
+	MainFuncPointer func;
 } functionMapEntry;
 
 static functionMapEntry cmakeGeneratedFunctionMapEntries[] = {
-    {
-    "TestPrimitivesAdd",
-    TestPrimitivesAdd
-  },
-  {
-    "TestPrimitivesAlphaComp",
-    TestPrimitivesAlphaComp
-  },
-  {
-    "TestPrimitivesAndOr",
-    TestPrimitivesAndOr
-  },
-  {
-    "TestPrimitivesColors",
-    TestPrimitivesColors
-  },
-  {
-    "TestPrimitivesCopy",
-    TestPrimitivesCopy
-  },
-  {
-    "TestPrimitivesSet",
-    TestPrimitivesSet
-  },
-  {
-    "TestPrimitivesShift",
-    TestPrimitivesShift
-  },
-  {
-    "TestPrimitivesSign",
-    TestPrimitivesSign
-  },
-  {
-    "TestPrimitivesYUV",
-    TestPrimitivesYUV
-  },
-  {
-    "TestPrimitivesYCbCr",
-    TestPrimitivesYCbCr
-  },
-  {
-    "TestPrimitivesYCoCg",
-    TestPrimitivesYCoCg
-  },
+	{ "TestPrimitivesAdd", TestPrimitivesAdd },
+	{ "TestPrimitivesAlphaComp", TestPrimitivesAlphaComp },
+	{ "TestPrimitivesAndOr", TestPrimitivesAndOr },
+	{ "TestPrimitivesColors", TestPrimitivesColors },
+	{ "TestPrimitivesCopy", TestPrimitivesCopy },
+	{ "TestPrimitivesSet", TestPrimitivesSet },
+	{ "TestPrimitivesShift", TestPrimitivesShift },
+	{ "TestPrimitivesSign", TestPrimitivesSign },
+	{ "TestPrimitivesYUV", TestPrimitivesYUV },
+	{ "TestPrimitivesYCbCr", TestPrimitivesYCbCr },
+	{ "TestPrimitivesYCoCg", TestPrimitivesYCoCg },
 
-  { NULL, NULL } /* NOLINT */
+	{ NULL, NULL } /* NOLINT */
 };
 
-static const int NumTests = CM_CAST(int,
-  sizeof(cmakeGeneratedFunctionMapEntries) / sizeof(functionMapEntry)) - 1;
+static const int NumTests =
+    CM_CAST(int, sizeof(cmakeGeneratedFunctionMapEntries) / sizeof(functionMapEntry)) - 1;
 
 /* Allocate and create a lowercased copy of string
    (note that it has to be free'd manually) */
 static char* lowercase(const char* string)
 {
-  char *new_string, *p;
-  size_t stringSize;
+	char *new_string, *p;
+	size_t stringSize;
 
-  stringSize = CM_CAST(size_t, strlen(string) + 1);
-  new_string = CM_CAST(char*, malloc(sizeof(char) * stringSize));
+	stringSize = CM_CAST(size_t, strlen(string) + 1);
+	new_string = CM_CAST(char*, malloc(sizeof(char) * stringSize));
 
-  if (new_string == NULL) { /* NOLINT */
-    return NULL;            /* NOLINT */
-  }
-  strcpy(new_string, string);
-  for (p = new_string; *p != 0; ++p) {
-    *p = CM_CAST(char, tolower(*p));
-  }
-  return new_string;
+	if (new_string == NULL)
+	{                /* NOLINT */
+		return NULL; /* NOLINT */
+	}
+	strcpy(new_string, string);
+	for (p = new_string; *p != 0; ++p)
+	{
+		*p = CM_CAST(char, tolower(*p));
+	}
+	return new_string;
 }
 
 int main(int ac, char* av[])
 {
-  int i, testNum = 0, partial_match;
-  char *arg;
-  int testToRun = -1;
-
-  
-
-  /* If no test name was given */
-  /* process command line with user function.  */
-  if (ac < 2) {
-    /* Ask for a test.  */
-    printf("Available tests:\n");
-    for (i = 0; i < NumTests; ++i) {
-      printf("%3d. %s\n", i, cmakeGeneratedFunctionMapEntries[i].name);
-    }
-    printf("To run a test, enter the test number: ");
-    fflush(stdout);
-    if (scanf("%d", &testNum) != 1) {
-      printf("Couldn't parse that input as a number\n");
-      return -1;
-    }
-    if (testNum >= NumTests) {
-      printf("%3d is an invalid test number.\n", testNum);
-      return -1;
-    }
-    testToRun = testNum;
-    ac--;
-    av++;
-  }
-  partial_match = 0;
-  arg = NULL; /* NOLINT */
-  /* If partial match is requested.  */
-  if (testToRun == -1 && ac > 1) {
-    partial_match = (strcmp(av[1], "-R") == 0) ? 1 : 0;
-  }
-  if (partial_match != 0 && ac < 3) {
-    printf("-R needs an additional parameter.\n");
-    return -1;
-  }
-  if (testToRun == -1) {
-    arg = lowercase(av[1 + partial_match]);
-  }
-  for (i = 0; i < NumTests && testToRun == -1; ++i) {
-    char *test_name = lowercase(cmakeGeneratedFunctionMapEntries[i].name);
-    if (partial_match != 0 && strstr(test_name, arg) != NULL) { /* NOLINT */
-      testToRun = i;
-      ac -= 2;
-      av += 2;
-    } else if (partial_match == 0 && strcmp(test_name, arg) == 0) {
-      testToRun = i;
-      ac--;
-      av++;
-    }
-    free(test_name);
-  }
-  free(arg);
-  if (testToRun != -1) {
-    int result;
-
-    if (testToRun < 0 || testToRun >= NumTests) {
-      printf("testToRun was modified by TestDriver code to an invalid value: "
-             "%3d.\n",
-             testNum);
-      return -1;
-    }
-    result = (*cmakeGeneratedFunctionMapEntries[testToRun].func)(ac, av);
-
-    return result;
-  }
-
-  /* Nothing was run, display the test names.  */
-  printf("Available tests:\n");
-  for (i = 0; i < NumTests; ++i) {
-    printf("%3d. %s\n", i, cmakeGeneratedFunctionMapEntries[i].name);
-  }
-  printf("Failed: %s is an invalid test name.\n", av[1]);
+	int i, testNum = 0, partial_match;
+	char* arg;
+	int testToRun = -1;
+
+	/* If no test name was given */
+	/* process command line with user function.  */
+	if (ac < 2)
+	{
+		/* Ask for a test.  */
+		printf("Available tests:\n");
+		for (i = 0; i < NumTests; ++i)
+		{
+			printf("%3d. %s\n", i, cmakeGeneratedFunctionMapEntries[i].name);
+		}
+		printf("To run a test, enter the test number: ");
+		fflush(stdout);
+		if (scanf("%d", &testNum) != 1)
+		{
+			printf("Couldn't parse that input as a number\n");
+			return -1;
+		}
+		if (testNum >= NumTests)
+		{
+			printf("%3d is an invalid test number.\n", testNum);
+			return -1;
+		}
+		testToRun = testNum;
+		ac--;
+		av++;
+	}
+	partial_match = 0;
+	arg = NULL; /* NOLINT */
+	/* If partial match is requested.  */
+	if (testToRun == -1 && ac > 1)
+	{
+		partial_match = (strcmp(av[1], "-R") == 0) ? 1 : 0;
+	}
+	if (partial_match != 0 && ac < 3)
+	{
+		printf("-R needs an additional parameter.\n");
+		return -1;
+	}
+	if (testToRun == -1)
+	{
+		arg = lowercase(av[1 + partial_match]);
+	}
+	for (i = 0; i < NumTests && testToRun == -1; ++i)
+	{
+		char* test_name = lowercase(cmakeGeneratedFunctionMapEntries[i].name);
+		if (partial_match != 0 && strstr(test_name, arg) != NULL)
+		{ /* NOLINT */
+			testToRun = i;
+			ac -= 2;
+			av += 2;
+		}
+		else if (partial_match == 0 && strcmp(test_name, arg) == 0)
+		{
+			testToRun = i;
+			ac--;
+			av++;
+		}
+		free(test_name);
+	}
+	free(arg);
+	if (testToRun != -1)
+	{
+		int result;
+
+		if (testToRun < 0 || testToRun >= NumTests)
+		{
+			printf("testToRun was modified by TestDriver code to an invalid value: "
+			       "%3d.\n",
+			       testNum);
+			return -1;
+		}
+		result = (*cmakeGeneratedFunctionMapEntries[testToRun].func)(ac, av);
+
+		return result;
+	}
+
+	/* Nothing was run, display the test names.  */
+	printf("Available tests:\n");
+	for (i = 0; i < NumTests; ++i)
+	{
+		printf("%3d. %s\n", i, cmakeGeneratedFunctionMapEntries[i].name);
+	}
+	printf("Failed: %s is an invalid test name.\n", av[1]);
 
-  return -1;
+	return -1;
 }
diff -urN libfreerdp/primitives/test/TestPrimitivesColors.c ../../informatimago/FreeRDP/libfreerdp/primitives/test/TestPrimitivesColors.c
--- libfreerdp/primitives/test/TestPrimitivesColors.c	2019-07-25 19:51:05.033918109 +0300
+++ ../../informatimago/FreeRDP/libfreerdp/primitives/test/TestPrimitivesColors.c	2019-07-25 20:11:29.015987878 +0300
@@ -29,7 +29,7 @@
 	INT16* b;
 	BYTE* out1;
 	BYTE* out2;
-	UINT64 i;
+	int i;
 	BOOL failed = FALSE;
 	const INT16* ptrs[3];
 	const UINT32 rgbStride = roi.width * 2;
@@ -264,8 +264,6 @@
 		                      PIXEL_FORMAT_BGRA32, PIXEL_FORMAT_BGRX32 };
 	DWORD x;
 	prim_size_t roi = { 1920, 1080 };
-	WINPR_UNUSED(argc);
-	WINPR_UNUSED(argv);
 	prim_test_setup(FALSE);
 
 	for (x = 0; x < sizeof(formats) / sizeof(formats[0]); x++)
diff -urN libfreerdp/primitives/test/TestPrimitivesCopy.c ../../informatimago/FreeRDP/libfreerdp/primitives/test/TestPrimitivesCopy.c
--- libfreerdp/primitives/test/TestPrimitivesCopy.c	2019-07-25 19:51:05.033918109 +0300
+++ ../../informatimago/FreeRDP/libfreerdp/primitives/test/TestPrimitivesCopy.c	2019-07-25 20:11:29.019987898 +0300
@@ -81,8 +81,6 @@
 
 int TestPrimitivesCopy(int argc, char* argv[])
 {
-	WINPR_UNUSED(argc);
-	WINPR_UNUSED(argv);
 	prim_test_setup(FALSE);
 
 	if (!test_copy8u_func())
diff -urN libfreerdp/primitives/test/TestPrimitivesSet.c ../../informatimago/FreeRDP/libfreerdp/primitives/test/TestPrimitivesSet.c
--- libfreerdp/primitives/test/TestPrimitivesSet.c	2019-07-25 19:51:05.037918128 +0300
+++ ../../informatimago/FreeRDP/libfreerdp/primitives/test/TestPrimitivesSet.c	2019-07-25 20:11:29.023987918 +0300
@@ -266,8 +266,6 @@
 
 int TestPrimitivesSet(int argc, char* argv[])
 {
-	WINPR_UNUSED(argc);
-	WINPR_UNUSED(argv);
 	prim_test_setup(FALSE);
 
 	if (!test_set8u_func())
diff -urN libfreerdp/primitives/test/TestPrimitivesShift.c ../../informatimago/FreeRDP/libfreerdp/primitives/test/TestPrimitivesShift.c
--- libfreerdp/primitives/test/TestPrimitivesShift.c	2019-07-25 19:51:05.045918168 +0300
+++ ../../informatimago/FreeRDP/libfreerdp/primitives/test/TestPrimitivesShift.c	2019-07-25 20:11:29.027987938 +0300
@@ -345,8 +345,6 @@
 
 int TestPrimitivesShift(int argc, char* argv[])
 {
-	WINPR_UNUSED(argc);
-	WINPR_UNUSED(argv);
 	prim_test_setup(FALSE);
 
 	if (!test_lShift_16s_func())
diff -urN libfreerdp/scquery/buffer.c ../../informatimago/FreeRDP/libfreerdp/scquery/buffer.c
--- libfreerdp/scquery/buffer.c	1970-01-01 03:00:00.000000000 +0300
+++ ../../informatimago/FreeRDP/libfreerdp/scquery/buffer.c	2019-07-25 20:11:29.283989207 +0300
@@ -0,0 +1,87 @@
+#include <stdlib.h>
+#include <string.h>
+#include "buffer.h"
+#include "scquery_error.h"
+
+enum
+{
+	buffer_flag_allocated = (1 << 0)
+};
+
+typedef struct
+{
+	CK_ULONG flags;
+	CK_ULONG size;
+	CK_BYTE* data;
+} buffer_t;
+
+CK_ULONG buffer_size(buffer buf)
+{
+	buffer_t* buffer = buf;
+	return buffer->size;
+}
+
+CK_BYTE* buffer_data(buffer buf)
+{
+	buffer_t* buffer = buf;
+	return buffer->data;
+}
+
+buffer buffer_new_copy(CK_ULONG size, CK_BYTE* data)
+{
+	buffer_t* buffer = checked_malloc(sizeof(*buffer));
+
+	if (buffer == NULL)
+	{
+		return NULL;
+	}
+
+	buffer->flags = buffer_flag_allocated;
+	buffer->size = size;
+	buffer->data = checked_malloc(buffer->size);
+
+	if (buffer->data == NULL)
+	{
+		free(buffer);
+		return NULL;
+	}
+
+	memcpy(buffer->data, data, buffer->size);
+	return buffer;
+}
+
+buffer buffer_new(CK_ULONG size, CK_BYTE* data)
+{
+	buffer_t* buffer = checked_malloc(sizeof(*buffer));
+
+	if (buffer == NULL)
+	{
+		return NULL;
+	}
+
+	buffer->flags = 0;
+	buffer->size = size;
+	buffer->data = data;
+	return buffer;
+}
+
+void buffer_free(buffer buf)
+{
+	buffer_t* buffer = buf;
+
+	if (buffer == NULL)
+	{
+		return;
+	}
+
+	if (buffer->flags & buffer_flag_allocated)
+	{
+		memset(buffer->data, 0, buffer->size);
+		free(buffer->data);
+	}
+
+	memset(buffer, 0, sizeof(*buffer));
+	free(buffer);
+}
+
+/**** THE END ****/
diff -urN libfreerdp/scquery/buffer.h ../../informatimago/FreeRDP/libfreerdp/scquery/buffer.h
--- libfreerdp/scquery/buffer.h	1970-01-01 03:00:00.000000000 +0300
+++ ../../informatimago/FreeRDP/libfreerdp/scquery/buffer.h	2019-07-25 20:11:29.287989227 +0300
@@ -0,0 +1,13 @@
+#ifndef LIBFREERDP_SCQUERY_BUFFER_H
+#define LIBFREERDP_SCQUERY_BUFFER_H
+#include <pkcs11-helper-1.0/pkcs11.h>
+
+typedef void* buffer;
+CK_ULONG buffer_size(buffer buf);
+CK_BYTE* buffer_data(buffer buf);
+
+buffer buffer_new_copy(CK_ULONG size, CK_BYTE* data);
+buffer buffer_new(CK_ULONG size, CK_BYTE* data);
+void buffer_free(buffer buf);
+
+#endif
diff -urN libfreerdp/scquery/certificate.c ../../informatimago/FreeRDP/libfreerdp/scquery/certificate.c
--- libfreerdp/scquery/certificate.c	1970-01-01 03:00:00.000000000 +0300
+++ ../../informatimago/FreeRDP/libfreerdp/scquery/certificate.c	2019-07-25 20:11:29.287989227 +0300
@@ -0,0 +1,79 @@
+#include <stdlib.h>
+#include "certificate.h"
+#include "scquery_error.h"
+
+/* ========================================================================== */
+/* smartcard_certificate */
+
+smartcard_certificate scquery_certificate_allocate()
+{
+	smartcard_certificate certificate = checked_malloc(sizeof(*certificate));
+
+	if (certificate)
+	{
+		certificate->slot_id = 0;
+		certificate->slot_description = NULL;
+		certificate->token_label = NULL;
+		certificate->token_serial = NULL;
+		certificate->id = NULL;
+		certificate->label = NULL;
+		certificate->type = 0;
+		certificate->issuer = NULL;
+		certificate->subject = NULL;
+		certificate->value = NULL;
+		certificate->key_type = 0;
+		certificate->protected_authentication_path = 0;
+	}
+
+	return certificate;
+}
+
+smartcard_certificate scquery_certificate_new(CK_SLOT_ID slot_id, char* slot_description,
+                                              char* token_label, char* token_serial, char* id,
+                                              char* label, CK_CERTIFICATE_TYPE type, buffer issuer,
+                                              buffer subject, buffer value, CK_KEY_TYPE key_type,
+                                              int protected_authentication_path)
+{
+	smartcard_certificate certificate = scquery_certificate_allocate();
+
+	if (certificate)
+	{
+		certificate->slot_id = slot_id;
+		certificate->slot_description = slot_description;
+		certificate->token_label = token_label;
+		certificate->token_serial = token_serial;
+		certificate->id = id;
+		certificate->label = label;
+		certificate->type = type;
+		certificate->issuer = issuer;
+		certificate->subject = subject;
+		certificate->value = value;
+		certificate->key_type = key_type;
+		certificate->protected_authentication_path = protected_authentication_path;
+	}
+
+	return certificate;
+}
+
+void scquery_certificate_deepfree(smartcard_certificate certificate)
+{
+	if (certificate)
+	{
+		free(certificate->slot_description);
+		free(certificate->token_label);
+		free(certificate->token_serial);
+		free(certificate->id);
+		free(certificate->label);
+		buffer_free(certificate->issuer);
+		buffer_free(certificate->subject);
+		buffer_free(certificate->value);
+		scquery_certificate_free(certificate);
+	}
+}
+
+void scquery_certificate_free(smartcard_certificate certificate)
+{
+	free(certificate);
+}
+
+/**** THE END ****/
diff -urN libfreerdp/scquery/certificate.h ../../informatimago/FreeRDP/libfreerdp/scquery/certificate.h
--- libfreerdp/scquery/certificate.h	1970-01-01 03:00:00.000000000 +0300
+++ ../../informatimago/FreeRDP/libfreerdp/scquery/certificate.h	2019-07-25 20:11:29.291989247 +0300
@@ -0,0 +1,41 @@
+#ifndef LIBFREERDP_SCQUERY_CERTIFICATE_H
+#define LIBFREERDP_SCQUERY_CERTIFICATE_H
+#include <stddef.h>
+#include "buffer.h"
+
+typedef struct
+{
+	CK_SLOT_ID slot_id;
+	char* slot_description; /* ReaderName */
+	char* token_label;      /* CardName */
+	char* token_serial;
+	char* id;
+	char* label;
+	CK_CERTIFICATE_TYPE type;
+	buffer issuer;
+	buffer subject;
+	buffer value;
+	CK_KEY_TYPE key_type;
+	int protected_authentication_path;
+} smartcard_certificate_t, *smartcard_certificate;
+
+/* scquery_certificate_new
+allocates and initialize a new smartcard_certificate */
+smartcard_certificate scquery_certificate_new(CK_SLOT_ID slot_id, char* slot_description,
+                                              char* token_label, char* token_serial, char* id,
+                                              char* label, CK_CERTIFICATE_TYPE type, buffer issuer,
+                                              buffer subject, buffer value, CK_KEY_TYPE key_type,
+                                              int protected_authentication_path);
+
+/* scquery_certificate_free
+frees only the smartcard_certificate structure (not the fields). */
+void scquery_certificate_free(smartcard_certificate certificate);
+/* scquery_certificate_deepfree
+deepfrees smartcard_certificate structure and all its fields. */
+void scquery_certificate_deepfree(smartcard_certificate certificate);
+
+/* scquery_certificate_allocate
+allocates an empty smartcard_certificate structure. */
+smartcard_certificate scquery_certificate_allocate();
+
+#endif
diff -urN libfreerdp/scquery/certificate_list.c ../../informatimago/FreeRDP/libfreerdp/scquery/certificate_list.c
--- libfreerdp/scquery/certificate_list.c	1970-01-01 03:00:00.000000000 +0300
+++ ../../informatimago/FreeRDP/libfreerdp/scquery/certificate_list.c	2019-07-25 20:11:29.291989247 +0300
@@ -0,0 +1,70 @@
+#include <stdlib.h>
+#include "certificate_list.h"
+#include "scquery_error.h"
+
+certificate_list certificate_list_cons(smartcard_certificate certificate, certificate_list rest)
+{
+	certificate_list list = checked_malloc(sizeof(*list));
+
+	if (list)
+	{
+		list->certificate = certificate;
+		list->rest = rest;
+	}
+
+	return list;
+}
+
+void certificate_list_deepfree(certificate_list list)
+{
+	if (list)
+	{
+		scquery_certificate_deepfree(list->certificate);
+		certificate_list_deepfree(list->rest);
+		certificate_list_free(list);
+	}
+}
+
+smartcard_certificate certificate_list_first(certificate_list list)
+{
+	return ((list == NULL) ? NULL : list->certificate);
+}
+certificate_list certificate_list_rest(certificate_list list)
+{
+	return ((list == NULL) ? NULL : list->rest);
+}
+void certificate_list_free(certificate_list list)
+{
+	free(list);
+}
+
+certificate_list certificate_list_delete(smartcard_certificate certificate, certificate_list list)
+{
+	if (certificate_list_first(list) == certificate)
+	{
+		certificate_list result = certificate_list_rest(list);
+		certificate_list_free(list);
+		return result;
+	}
+	else
+	{
+		certificate_list previous = list;
+
+		while ((certificate_list_rest(previous) != NULL) &&
+		       (certificate_list_first(certificate_list_rest(previous)) != certificate))
+		{
+			previous = certificate_list_rest(previous);
+		}
+
+		if (certificate_list_rest(previous) != NULL)
+		{
+			certificate_list old = certificate_list_rest(previous);
+			previous->rest = certificate_list_rest(old);
+			certificate_list_free(old);
+		}
+
+		return list;
+	}
+}
+
+/**** THE END ****/
diff -urN libfreerdp/scquery/certificate_list.h ../../informatimago/FreeRDP/libfreerdp/scquery/certificate_list.h
--- libfreerdp/scquery/certificate_list.h	1970-01-01 03:00:00.000000000 +0300
+++ ../../informatimago/FreeRDP/libfreerdp/scquery/certificate_list.h	2019-07-25 20:11:29.291989247 +0300
@@ -0,0 +1,41 @@
+
+#ifndef LIBFREERDP_SCQUERY_CERTIFICATE_LIST_H
+#define LIBFREERDP_SCQUERY_CERTIFICATE_LIST_H
+#include "certificate.h"
+
+typedef struct certificate_list
+{
+	smartcard_certificate certificate;
+	struct certificate_list* rest;
+} certificate_list_t, *certificate_list;
+
+smartcard_certificate certificate_list_first(certificate_list list);
+certificate_list certificate_list_rest(certificate_list list);
+
+#define DO_CERTIFICATE_LIST(certificate, current, list)                                           \
+	for ((current = list,                                                                         \
+	    certificate = ((current != NULL) ? certificate_list_first(current) : CK_INVALID_HANDLE)); \
+	     (current != NULL);                                                                       \
+	     (current = certificate_list_rest(current),                                               \
+	     certificate = ((current != NULL) ? certificate_list_first(current) : CK_INVALID_HANDLE)))
+
+/* certificate_list_cons
+allocates a new list node containing the certificate and the next list. */
+certificate_list certificate_list_cons(smartcard_certificate certificate, certificate_list rest);
+
+/* certificate_list_delete
+removes the certificate from the certificate list.
+returns the list (or the rest of the list when the certificate was the first element).
+The node that held the certificate is freed, but not the certificate!
+*/
+certificate_list certificate_list_delete(smartcard_certificate certificate, certificate_list list);
+
+/* certificate_list_deepfree
+deepfrees the certificates and the list nodes */
+void certificate_list_deepfree(certificate_list list);
+
+/* certificate_list_free
+frees only the current list nodes (not the next ones). */
+void certificate_list_free(certificate_list list);
+
+#endif
diff -urN libfreerdp/scquery/CMakeLists.txt ../../informatimago/FreeRDP/libfreerdp/scquery/CMakeLists.txt
--- libfreerdp/scquery/CMakeLists.txt	1970-01-01 03:00:00.000000000 +0300
+++ ../../informatimago/FreeRDP/libfreerdp/scquery/CMakeLists.txt	2019-07-19 20:00:34.133156354 +0300
@@ -0,0 +1,41 @@
+# FreeRDP: A Remote Desktop Protocol Implementation
+# libfreerdp-scquery cmake build script
+#
+# Copyright 2018 Pascal Bourguignon <pjb@informatimago.com>
+#
+# Licensed under the Apache License, Version 2.0 (the "License");
+# you may not use this file except in compliance with the License.
+# You may obtain a copy of the License at
+#
+#     http://www.apache.org/licenses/LICENSE-2.0
+#
+# Unless required by applicable law or agreed to in writing, software
+# distributed under the License is distributed on an "AS IS" BASIS,
+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+# See the License for the specific language governing permissions and
+# limitations under the License.
+
+set(MODULE_NAME "freerdp-scquery")
+set(MODULE_PREFIX "FREERDP_SCQUERY")
+
+set(${MODULE_PREFIX}_SRCS
+    buffer.c
+    certificate.c
+    certificate_list.c
+    pkcs11errors.c
+    pkcs11module.c
+    scquery.c
+    scquery_error.c
+    scquery_string.c
+    smartcard_certificate.c
+    x509_alt_names.c
+)
+
+freerdp_module_add(${${MODULE_PREFIX}_SRCS})
+
+# freerdp_include_directory_add(${OPENSSL_INCLUDE_DIR})
+# freerdp_library_add(${OPENSSL_LIBRARIES})
+
+# if(BUILD_TESTING)
+# 	add_subdirectory(test)
+# endif()
diff -urN libfreerdp/scquery/pkcs11errors.c ../../informatimago/FreeRDP/libfreerdp/scquery/pkcs11errors.c
--- libfreerdp/scquery/pkcs11errors.c	1970-01-01 03:00:00.000000000 +0300
+++ ../../informatimago/FreeRDP/libfreerdp/scquery/pkcs11errors.c	2019-07-25 20:11:29.299989286 +0300
@@ -0,0 +1,113 @@
+#include <stdio.h>
+#include <string.h>
+
+#include "pkcs11errors.h"
+
+const char* pkcs11_return_value_label(CK_RV rv)
+{
+	static struct
+	{
+		CK_RV rv;
+		const char* label;
+	} labels[] = { { CKR_OK, "CKR_OK" },
+		           { CKR_CANCEL, "CKR_CANCEL" },
+		           { CKR_HOST_MEMORY, "CKR_HOST_MEMORY" },
+		           { CKR_SLOT_ID_INVALID, "CKR_SLOT_ID_INVALID" },
+		           { CKR_GENERAL_ERROR, "CKR_GENERAL_ERROR" },
+		           { CKR_FUNCTION_FAILED, "CKR_FUNCTION_FAILED" },
+		           { CKR_ARGUMENTS_BAD, "CKR_ARGUMENTS_BAD" },
+		           { CKR_NO_EVENT, "CKR_NO_EVENT" },
+		           { CKR_NEED_TO_CREATE_THREADS, "CKR_NEED_TO_CREATE_THREADS" },
+		           { CKR_CANT_LOCK, "CKR_CANT_LOCK" },
+		           { CKR_ATTRIBUTE_READ_ONLY, "CKR_ATTRIBUTE_READ_ONLY" },
+		           { CKR_ATTRIBUTE_SENSITIVE, "CKR_ATTRIBUTE_SENSITIVE" },
+		           { CKR_ATTRIBUTE_TYPE_INVALID, "CKR_ATTRIBUTE_TYPE_INVALID" },
+		           { CKR_ATTRIBUTE_VALUE_INVALID, "CKR_ATTRIBUTE_VALUE_INVALID" },
+		           { CKR_DATA_INVALID, "CKR_DATA_INVALID" },
+		           { CKR_DATA_LEN_RANGE, "CKR_DATA_LEN_RANGE" },
+		           { CKR_DEVICE_ERROR, "CKR_DEVICE_ERROR" },
+		           { CKR_DEVICE_MEMORY, "CKR_DEVICE_MEMORY" },
+		           { CKR_DEVICE_REMOVED, "CKR_DEVICE_REMOVED" },
+		           { CKR_ENCRYPTED_DATA_INVALID, "CKR_ENCRYPTED_DATA_INVALID" },
+		           { CKR_ENCRYPTED_DATA_LEN_RANGE, "CKR_ENCRYPTED_DATA_LEN_RANGE" },
+		           { CKR_FUNCTION_CANCELED, "CKR_FUNCTION_CANCELED" },
+		           { CKR_FUNCTION_NOT_PARALLEL, "CKR_FUNCTION_NOT_PARALLEL" },
+		           { CKR_FUNCTION_NOT_SUPPORTED, "CKR_FUNCTION_NOT_SUPPORTED" },
+		           { CKR_KEY_HANDLE_INVALID, "CKR_KEY_HANDLE_INVALID" },
+		           { CKR_KEY_SIZE_RANGE, "CKR_KEY_SIZE_RANGE" },
+		           { CKR_KEY_TYPE_INCONSISTENT, "CKR_KEY_TYPE_INCONSISTENT" },
+		           { CKR_KEY_NOT_NEEDED, "CKR_KEY_NOT_NEEDED" },
+		           { CKR_KEY_CHANGED, "CKR_KEY_CHANGED" },
+		           { CKR_KEY_NEEDED, "CKR_KEY_NEEDED" },
+		           { CKR_KEY_INDIGESTIBLE, "CKR_KEY_INDIGESTIBLE" },
+		           { CKR_KEY_FUNCTION_NOT_PERMITTED, "CKR_KEY_FUNCTION_NOT_PERMITTED" },
+		           { CKR_KEY_NOT_WRAPPABLE, "CKR_KEY_NOT_WRAPPABLE" },
+		           { CKR_KEY_UNEXTRACTABLE, "CKR_KEY_UNEXTRACTABLE" },
+		           { CKR_MECHANISM_INVALID, "CKR_MECHANISM_INVALID" },
+		           { CKR_MECHANISM_PARAM_INVALID, "CKR_MECHANISM_PARAM_INVALID" },
+		           { CKR_OBJECT_HANDLE_INVALID, "CKR_OBJECT_HANDLE_INVALID" },
+		           { CKR_OPERATION_ACTIVE, "CKR_OPERATION_ACTIVE" },
+		           { CKR_OPERATION_NOT_INITIALIZED, "CKR_OPERATION_NOT_INITIALIZED" },
+		           { CKR_PIN_INCORRECT, "CKR_PIN_INCORRECT" },
+		           { CKR_PIN_INVALID, "CKR_PIN_INVALID" },
+		           { CKR_PIN_LEN_RANGE, "CKR_PIN_LEN_RANGE" },
+		           { CKR_PIN_EXPIRED, "CKR_PIN_EXPIRED" },
+		           { CKR_PIN_LOCKED, "CKR_PIN_LOCKED" },
+		           { CKR_SESSION_CLOSED, "CKR_SESSION_CLOSED" },
+		           { CKR_SESSION_COUNT, "CKR_SESSION_COUNT" },
+		           { CKR_SESSION_HANDLE_INVALID, "CKR_SESSION_HANDLE_INVALID" },
+		           { CKR_SESSION_PARALLEL_NOT_SUPPORTED, "CKR_SESSION_PARALLEL_NOT_SUPPORTED" },
+		           { CKR_SESSION_READ_ONLY, "CKR_SESSION_READ_ONLY" },
+		           { CKR_SESSION_EXISTS, "CKR_SESSION_EXISTS" },
+		           { CKR_SESSION_READ_ONLY_EXISTS, "CKR_SESSION_READ_ONLY_EXISTS" },
+		           { CKR_SESSION_READ_WRITE_SO_EXISTS, "CKR_SESSION_READ_WRITE_SO_EXISTS" },
+		           { CKR_SIGNATURE_INVALID, "CKR_SIGNATURE_INVALID" },
+		           { CKR_SIGNATURE_LEN_RANGE, "CKR_SIGNATURE_LEN_RANGE" },
+		           { CKR_TEMPLATE_INCOMPLETE, "CKR_TEMPLATE_INCOMPLETE" },
+		           { CKR_TEMPLATE_INCONSISTENT, "CKR_TEMPLATE_INCONSISTENT" },
+		           { CKR_TOKEN_NOT_PRESENT, "CKR_TOKEN_NOT_PRESENT" },
+		           { CKR_TOKEN_NOT_RECOGNIZED, "CKR_TOKEN_NOT_RECOGNIZED" },
+		           { CKR_TOKEN_WRITE_PROTECTED, "CKR_TOKEN_WRITE_PROTECTED" },
+		           { CKR_UNWRAPPING_KEY_HANDLE_INVALID, "CKR_UNWRAPPING_KEY_HANDLE_INVALID" },
+		           { CKR_UNWRAPPING_KEY_SIZE_RANGE, "CKR_UNWRAPPING_KEY_SIZE_RANGE" },
+		           { CKR_UNWRAPPING_KEY_TYPE_INCONSISTENT, "CKR_UNWRAPPING_KEY_TYPE_INCONSISTENT" },
+		           { CKR_USER_ALREADY_LOGGED_IN, "CKR_USER_ALREADY_LOGGED_IN" },
+		           { CKR_USER_NOT_LOGGED_IN, "CKR_USER_NOT_LOGGED_IN" },
+		           { CKR_USER_PIN_NOT_INITIALIZED, "CKR_USER_PIN_NOT_INITIALIZED" },
+		           { CKR_USER_TYPE_INVALID, "CKR_USER_TYPE_INVALID" },
+		           { CKR_USER_ANOTHER_ALREADY_LOGGED_IN, "CKR_USER_ANOTHER_ALREADY_LOGGED_IN" },
+		           { CKR_USER_TOO_MANY_TYPES, "CKR_USER_TOO_MANY_TYPES" },
+		           { CKR_WRAPPED_KEY_INVALID, "CKR_WRAPPED_KEY_INVALID" },
+		           { CKR_WRAPPED_KEY_LEN_RANGE, "CKR_WRAPPED_KEY_LEN_RANGE" },
+		           { CKR_WRAPPING_KEY_HANDLE_INVALID, "CKR_WRAPPING_KEY_HANDLE_INVALID" },
+		           { CKR_WRAPPING_KEY_SIZE_RANGE, "CKR_WRAPPING_KEY_SIZE_RANGE" },
+		           { CKR_WRAPPING_KEY_TYPE_INCONSISTENT, "CKR_WRAPPING_KEY_TYPE_INCONSISTENT" },
+		           { CKR_RANDOM_SEED_NOT_SUPPORTED, "CKR_RANDOM_SEED_NOT_SUPPORTED" },
+		           { CKR_RANDOM_NO_RNG, "CKR_RANDOM_NO_RNG" },
+		           { CKR_DOMAIN_PARAMS_INVALID, "CKR_DOMAIN_PARAMS_INVALID" },
+		           { CKR_BUFFER_TOO_SMALL, "CKR_BUFFER_TOO_SMALL" },
+		           { CKR_SAVED_STATE_INVALID, "CKR_SAVED_STATE_INVALID" },
+		           { CKR_INFORMATION_SENSITIVE, "CKR_INFORMATION_SENSITIVE" },
+		           { CKR_STATE_UNSAVEABLE, "CKR_STATE_UNSAVEABLE" },
+		           { CKR_CRYPTOKI_NOT_INITIALIZED, "CKR_CRYPTOKI_NOT_INITIALIZED" },
+		           { CKR_CRYPTOKI_ALREADY_INITIALIZED, "CKR_CRYPTOKI_ALREADY_INITIALIZED" },
+		           { CKR_MUTEX_BAD, "CKR_MUTEX_BAD" },
+		           { CKR_MUTEX_NOT_LOCKED, "CKR_MUTEX_NOT_LOCKED" },
+		           { CKR_FUNCTION_REJECTED, "CKR_FUNCTION_REJECTED" },
+		           { 0, 0 } };
+	int i = 0;
+
+	while (labels[i].label)
+	{
+		if (rv == labels[i].rv)
+		{
+			return labels[i].label;
+		}
+
+		i++;
+	}
+
+	static char buffer[80];
+	sprintf(buffer, "Unknown CR_RV value: %lu (0x%lx)", rv, rv);
+	return buffer;
+}
diff -urN libfreerdp/scquery/pkcs11errors.h ../../informatimago/FreeRDP/libfreerdp/scquery/pkcs11errors.h
--- libfreerdp/scquery/pkcs11errors.h	1970-01-01 03:00:00.000000000 +0300
+++ ../../informatimago/FreeRDP/libfreerdp/scquery/pkcs11errors.h	2019-07-25 20:11:29.299989286 +0300
@@ -0,0 +1,8 @@
+#ifndef LIBFREERDP_SCQUERY_PKCS11ERRORS_H
+#define LIBFREERDP_SCQUERY_PKCS11ERRORS_H
+
+#include <pkcs11-helper-1.0/pkcs11.h>
+
+const char* pkcs11_return_value_label(CK_RV rv);
+
+#endif
diff -urN libfreerdp/scquery/pkcs11module.c ../../informatimago/FreeRDP/libfreerdp/scquery/pkcs11module.c
--- libfreerdp/scquery/pkcs11module.c	1970-01-01 03:00:00.000000000 +0300
+++ ../../informatimago/FreeRDP/libfreerdp/scquery/pkcs11module.c	2019-07-25 20:11:29.303989306 +0300
@@ -0,0 +1,366 @@
+#include <dlfcn.h>
+#include <stdlib.h>
+#include <string.h>
+#include <stdio.h>
+
+#include "pkcs11module.h"
+#include "pkcs11errors.h"
+#include "scquery_error.h"
+
+/*
+C_LoadModule
+Allocate the pkcs11_module and load the library.
+*/
+pkcs11_module* C_LoadModule(const char* library_path)
+{
+	pkcs11_module* module;
+	CK_RV rv, (*c_get_function_list)(CK_FUNCTION_LIST_PTR_PTR);
+
+	if (library_path == NULL)
+	{
+		ERROR(ENODATA, "dlopen failed: %s", dlerror());
+		goto failed;
+	}
+
+	if (!(module = checked_calloc(1, sizeof(*module))))
+	{
+		goto failed;
+	}
+
+	if (!(module->library = dlopen(library_path, RTLD_LAZY)))
+	{
+		ERROR(-1, "dlopen failed: %s", dlerror());
+		free(module);
+		goto failed;
+	}
+
+	/* Get the list of function pointers */
+	c_get_function_list =
+	    (CK_RV(*)(CK_FUNCTION_LIST_PTR_PTR))dlsym(module->library, "C_GetFunctionList");
+
+	if (!c_get_function_list)
+	{
+		goto unload_and_failed;
+	}
+
+	rv = c_get_function_list(&module->p11);
+
+	if (rv == CKR_OK)
+	{
+		return (void*)module;
+	}
+
+	ERROR(rv, "C_GetFunctionList() failed with %s.", pkcs11_return_value_label(rv));
+unload_and_failed:
+	C_UnloadModule(module);
+failed:
+	ERROR(-1, "Failed to load PKCS#11 module %s", library_path ? library_path : "NULL");
+	return NULL;
+}
+
+/*
+C_UnloadModule
+Unload the library and free the pkcs11_module
+*/
+CK_RV C_UnloadModule(pkcs11_module* module)
+{
+	if (!module)
+	{
+		return CKR_ARGUMENTS_BAD;
+	}
+
+	if (module->library != NULL && dlclose(module->library) < 0)
+	{
+		return CKR_FUNCTION_FAILED;
+	}
+
+	memset(module, 0, sizeof(*module));
+	free(module);
+	return CKR_OK;
+}
+
+CK_BBOOL check_rv(CK_RV rv, const char* file, unsigned long line, const char* caller,
+                  const char* function)
+{
+	if (rv == CKR_OK)
+	{
+		return CK_TRUE;
+	}
+
+	handle_error(file, line, caller, EX_OSERR, "PKCS#11 function %s returned error: %s", function,
+	             pkcs11_return_value_label(rv));
+	return CK_FALSE;
+}
+
+CK_SESSION_HANDLE pkcs11module_open_session(pkcs11_module* module, CK_ULONG slot_id, CK_FLAGS flags,
+                                            void* application_reference, CK_NOTIFY notify_function)
+{
+	CK_SESSION_HANDLE session = CK_INVALID_HANDLE;
+
+	if (CHECK_RV(module->p11->C_OpenSession(slot_id, flags, application_reference, notify_function,
+	                                        &session),
+	             "C_OpenSession"))
+	{
+		return session;
+	}
+	else
+	{
+		return CK_INVALID_HANDLE;
+	}
+}
+
+void get_list_of_slots_with_token(pkcs11_module* module, slot_id_list* list)
+{
+	list->count = sizeof(list->slot_id) / sizeof(list->slot_id[0]);
+
+	if (!CHECK_RV(module->p11->C_GetSlotList(CK_TRUE, &(list->slot_id[0]), &(list->count)),
+	              "C_GetSlotList"))
+	{
+		list->count = 0;
+	}
+}
+
+void attribute_free_buffer(CK_ATTRIBUTE* attribute)
+{
+	if (attribute)
+	{
+		if (attribute->pValue != NULL)
+		{
+			free(attribute->pValue);
+		}
+
+		attribute->pValue = NULL;
+		attribute->ulValueLen = 0;
+	}
+}
+
+void attribute_copy(CK_ATTRIBUTE* destination, CK_ATTRIBUTE* source)
+{
+	destination->type = source->type;
+	destination->pValue = source->pValue;
+	destination->ulValueLen = source->ulValueLen;
+}
+
+void attribute_allocate_attribute_array(CK_ATTRIBUTE* attribute)
+{
+	attribute->pValue = checked_calloc(attribute->ulValueLen, sizeof(void*));
+}
+void attribute_allocate_ulong_array(CK_ATTRIBUTE* attribute)
+{
+	attribute->pValue = checked_calloc(attribute->ulValueLen, sizeof(CK_ULONG));
+}
+void attribute_allocate_buffer(CK_ATTRIBUTE* attribute)
+{
+	attribute->pValue = checked_calloc(attribute->ulValueLen, 1);
+}
+
+void template_free_buffers(template* template)
+{
+	CK_ULONG i;
+
+	for (i = 0; i < template->count; i++)
+	{
+		attribute_free_buffer(&template->attributes[i]);
+	}
+}
+
+void template_allocate_buffers(template* template)
+{
+	CK_ULONG i;
+
+	for (i = 0; i < template->count; i++)
+	{
+		CK_ATTRIBUTE* attribute = &template->attributes[i];
+
+		if ((attribute->pValue == NULL) && (attribute->ulValueLen != CK_UNAVAILABLE_INFORMATION))
+		{
+			switch (attribute->type)
+			{
+			case CKA_WRAP_TEMPLATE:
+			case CKA_UNWRAP_TEMPLATE:
+				attribute_allocate_attribute_array(attribute);
+				break;
+
+			case CKA_ALLOWED_MECHANISMS:
+				attribute_allocate_ulong_array(attribute);
+				break;
+
+			default:
+				attribute_allocate_buffer(attribute);
+				break;
+			}
+		}
+	}
+}
+
+CK_BBOOL template_has_unallocated_buffers(template* template)
+{
+	CK_ULONG i;
+
+	for (i = 0; i < template->count; i++)
+	{
+		CK_ATTRIBUTE* attribute = &template->attributes[i];
+
+		if ((attribute->pValue == NULL) && (attribute->ulValueLen != CK_UNAVAILABLE_INFORMATION))
+		{
+			return CK_TRUE;
+		}
+	}
+
+	return CK_FALSE;
+}
+
+void template_pack(template* template)
+{
+	CK_ULONG i;
+	CK_ULONG j = 0;
+
+	for (i = 0; i < template->count; i++)
+	{
+		if (!((template->attributes[i].type == CK_UNAVAILABLE_INFORMATION) ||
+		      (template->attributes[i].ulValueLen == CK_UNAVAILABLE_INFORMATION)))
+		{
+			if (j < i)
+			{
+				attribute_copy(&template->attributes[j], &template->attributes[i]);
+			}
+
+			j++;
+		}
+	}
+
+	template->count = j;
+}
+
+CK_OBJECT_HANDLE object_handle_first(object_handle_list list)
+{
+	return list->object_handle;
+}
+object_handle_list object_handle_rest(object_handle_list list)
+{
+	return list->rest;
+}
+object_handle_list object_handle_cons(CK_OBJECT_HANDLE object_handle, object_handle_list rest)
+{
+	object_handle_list list = checked_malloc(sizeof(*list));
+
+	if (list)
+	{
+		list->object_handle = object_handle;
+		list->rest = rest;
+	}
+
+	return list;
+}
+void object_handle_list_free(object_handle_list list)
+{
+	while (list != NULL)
+	{
+		object_handle_list current = list;
+		list = object_handle_rest(list);
+		free(current);
+	}
+}
+
+CK_ULONG object_handle_list_length(object_handle_list list)
+{
+	CK_ULONG length = 0;
+
+	while (list)
+	{
+		length++;
+		list = object_handle_rest(list);
+	}
+
+	return length;
+}
+
+object_handle_list find_all_object(pkcs11_module* module, CK_SESSION_HANDLE session,
+                                   template* template)
+{
+	if (CHECK_RV(module->p11->C_FindObjectsInit(session, &template->attributes[0], template->count),
+	             "C_FindObjectsInit"))
+	{
+		object_handle_list list = NULL;
+		CK_BBOOL got_some_objects = CK_FALSE;
+		object_handle_buffer buffer;
+		const CK_ULONG max_count = sizeof(buffer.object_handles) / sizeof(buffer.object_handles[0]);
+
+		do
+		{
+			got_some_objects = CK_FALSE;
+			buffer.count = 0;
+
+			if (CHECK_RV(module->p11->C_FindObjects(session, &buffer.object_handles[0], max_count,
+			                                        &buffer.count),
+			             "C_FindObjets"))
+			{
+				if (buffer.count > 0)
+				{
+					CK_ULONG i;
+					got_some_objects = CK_TRUE;
+
+					for (i = 0; i < buffer.count; i++)
+					{
+						list = object_handle_cons(buffer.object_handles[i], list);
+					}
+				}
+			}
+		} while (got_some_objects);
+
+		CHECK_RV(module->p11->C_FindObjectsFinal(session), "C_FindObjectsFinal");
+		return list;
+	}
+	else
+	{
+		return NULL;
+	}
+}
+
+CK_RV object_get_attributes(pkcs11_module* module, CK_SESSION_HANDLE session,
+                            CK_OBJECT_HANDLE object, template* template)
+{
+	CK_RV rv = module->p11->C_GetAttributeValue(session, object, &template->attributes[0],
+	                                            template->count);
+	VERBOSE(module->verbose, "C_GetAttributeValue returned %s for %lu attributes",
+	        pkcs11_return_value_label(rv), template->count);
+
+	switch (rv)
+	{
+	case CKR_OK:
+		if (!template_has_unallocated_buffers(template))
+		{
+			return rv;
+		}
+
+	case CKR_ATTRIBUTE_SENSITIVE:
+	case CKR_ATTRIBUTE_TYPE_INVALID:
+	case CKR_BUFFER_TOO_SMALL:
+		template_pack(template);
+		template_allocate_buffers(template);
+		rv = module->p11->C_GetAttributeValue(session, object, &template->attributes[0],
+		                                      template->count);
+		VERBOSE(module->verbose,
+		        "C_GetAttributeValue returned %s after buffer allocation for %lu attributes",
+		        pkcs11_return_value_label(rv), template->count);
+
+		switch (rv)
+		{
+		case CKR_OK:
+		case CKR_ATTRIBUTE_SENSITIVE:
+		case CKR_ATTRIBUTE_TYPE_INVALID:
+		case CKR_BUFFER_TOO_SMALL:
+			return rv;
+
+		default:
+			CHECK_RV(rv, "C_GetAttributeValue");
+			return rv;
+		}
+
+		break;
+
+	default:
+		CHECK_RV(rv, "C_GetAttributeValue");
+		return rv;
+	}
+}
diff -urN libfreerdp/scquery/pkcs11module.h ../../informatimago/FreeRDP/libfreerdp/scquery/pkcs11module.h
--- libfreerdp/scquery/pkcs11module.h	1970-01-01 03:00:00.000000000 +0300
+++ ../../informatimago/FreeRDP/libfreerdp/scquery/pkcs11module.h	2019-07-25 20:11:29.307989326 +0300
@@ -0,0 +1,104 @@
+#ifndef LIBFREERDP_SCQUERY_PKCS11MODULE_H
+#define LIBFREERDP_SCQUERY_PKCS11MODULE_H
+
+#include <pkcs11-helper-1.0/pkcs11.h>
+
+CK_BBOOL check_rv(CK_RV rv, const char* file, unsigned long line, const char* caller,
+                  const char* function);
+#define CHECK_RV(rv, function) (check_rv((rv), __FILE__, __LINE__, __FUNCTION__, (function)))
+
+typedef struct
+{
+	void* library;
+	CK_FUNCTION_LIST_PTR p11;
+	CK_RV rv;
+	CK_BBOOL verbose;
+} pkcs11_module;
+
+pkcs11_module* C_LoadModule(const char* mspec);
+CK_RV C_UnloadModule(pkcs11_module* module);
+
+#define WITH_PKCS11_MODULE(module, name)                                                       \
+	for (((module = C_LoadModule(name)) ? (module->rv = module->p11->C_Initialize(NULL)) : 0); \
+	     ((module != NULL) &&                                                                  \
+	      ((module->rv == CKR_OK) || (module->rv == CKR_CRYPTOKI_ALREADY_INITIALIZED)));       \
+	     (((module != NULL) ? (module->p11->C_Finalize(NULL), C_UnloadModule(module)) : 0),    \
+	      module = NULL))
+
+CK_SESSION_HANDLE pkcs11module_open_session(pkcs11_module* module, CK_ULONG slot_id, CK_FLAGS flags,
+                                            void* application_reference, CK_NOTIFY notify_function);
+
+#define WITH_PKCS11_OPEN_SESSION(session, module, slot_id, flags, application_reference,    \
+                                 notify_function)                                           \
+	for (session = pkcs11module_open_session(module, slot_id, flags, application_reference, \
+	                                         notify_function);                              \
+	     session != CK_INVALID_HANDLE;                                                      \
+	     session = ((session != CK_INVALID_HANDLE)                                          \
+	                    ? (module->p11->C_CloseSession(session), CK_INVALID_HANDLE)         \
+	                    : CK_INVALID_HANDLE))
+
+#define MAX_SLOT_ID_LIST_SIZE (64)
+typedef struct
+{
+	CK_ULONG count;
+	CK_ULONG slot_id[MAX_SLOT_ID_LIST_SIZE];
+} slot_id_list;
+
+void get_list_of_slots_with_token(pkcs11_module* module, slot_id_list* list);
+
+#define MAX_ATTRIBUTE_TYPE_LIST_SIZE (64)
+typedef struct
+{
+	CK_ULONG count;
+	CK_ATTRIBUTE_TYPE attribute_types[MAX_ATTRIBUTE_TYPE_LIST_SIZE];
+} attribute_type_list;
+
+#define MAX_TEMPLATE_SIZE (64)
+typedef struct
+{
+	CK_ULONG count;
+	CK_ATTRIBUTE attributes[MAX_TEMPLATE_SIZE];
+} template;
+
+void attribute_free_buffer(CK_ATTRIBUTE* attribute);
+void attribute_copy(CK_ATTRIBUTE* destination, CK_ATTRIBUTE* source);
+void attribute_allocate_attribute_array(CK_ATTRIBUTE* attribute);
+void attribute_allocate_ulong_array(CK_ATTRIBUTE* attribute);
+void attribute_allocate_buffer(CK_ATTRIBUTE* attribute);
+
+void template_free_buffers(template* template);
+void template_pack(template* template);
+void template_allocate_buffers(template* template);
+
+#define MAX_OBJECT_HANDLE_BUFFER_SIZE (128)
+typedef struct
+{
+	CK_ULONG count;
+	CK_OBJECT_HANDLE object_handles[MAX_OBJECT_HANDLE_BUFFER_SIZE];
+} object_handle_buffer;
+
+typedef struct object_handle_list
+{
+	CK_OBJECT_HANDLE object_handle;
+	struct object_handle_list* rest;
+} object_handle_list_t, *object_handle_list;
+
+CK_OBJECT_HANDLE object_handle_first(object_handle_list list);
+object_handle_list object_handle_rest(object_handle_list list);
+object_handle_list object_handle_cons(CK_OBJECT_HANDLE object_handle, object_handle_list rest);
+void object_handle_list_free(object_handle_list list);
+CK_ULONG object_handle_list_length(object_handle_list list);
+
+#define DO_OBJECT_HANDLE_LIST(object_handle, current, list)                                      \
+	for ((current = list,                                                                        \
+	    object_handle = ((current != NULL) ? object_handle_first(current) : CK_INVALID_HANDLE)); \
+	     (current != NULL);                                                                      \
+	     (current = object_handle_rest(current),                                                 \
+	     object_handle = ((current != NULL) ? object_handle_first(current) : CK_INVALID_HANDLE)))
+
+object_handle_list find_all_object(pkcs11_module* module, CK_SESSION_HANDLE session,
+                                   template* template);
+CK_RV object_get_attributes(pkcs11_module* module, CK_SESSION_HANDLE session,
+                            CK_OBJECT_HANDLE object, template* template);
+
+#endif
diff -urN libfreerdp/scquery/scquery.c ../../informatimago/FreeRDP/libfreerdp/scquery/scquery.c
--- libfreerdp/scquery/scquery.c	1970-01-01 03:00:00.000000000 +0300
+++ ../../informatimago/FreeRDP/libfreerdp/scquery/scquery.c	2019-07-25 20:11:29.311989346 +0300
@@ -0,0 +1,180 @@
+#include <ctype.h>
+#include <dlfcn.h>
+#include <errno.h>
+#include <stdarg.h>
+#include <stdio.h>
+#include <stddef.h>
+#include <stdlib.h>
+#include <string.h>
+#include <sysexits.h>
+#include <unistd.h>
+
+#include <freerdp/log.h>
+
+#include "scquery.h"
+#include "certificate.h"
+#include "smartcard_certificate.h"
+#include "scquery_error.h"
+#include "scquery_string.h"
+#include "x509_alt_names.h"
+
+static const char* scquery_upn_oid = "1.3.6.1.4.1.311.20.2.3";
+/* static const char* scquery_kpn_oid = "1.3.6.1.5.2.2"; */
+
+#define TAG CLIENT_TAG("scquery")
+
+void* error_out_of_memory(size_t size)
+{
+	ERROR(EX_OSERR, "Out of memory, could not allocate %u bytes", size);
+	return NULL;
+}
+
+static void report_level(DWORD level, const char* file, unsigned long line, const char* function,
+                         int status, const char* format, va_list ap)
+{
+	wLog* log = WLog_Get(TAG);
+
+	if ((log != NULL) && (level >= WLog_GetLogLevel(log)))
+	{
+		WLog_PrintMessageVA(log, WLOG_MESSAGE_TEXT, level, line, file, function, format, ap);
+	}
+}
+
+void report_error(const char* file, unsigned long line, const char* function, int status,
+                  const char* format, ...)
+{
+	va_list ap;
+	va_start(ap, format);
+	report_level(WLOG_ERROR, file, line, function, status, format, ap);
+	va_end(ap);
+}
+
+void report_warning(const char* file, unsigned long line, const char* function, int status,
+                    const char* format, ...)
+{
+	va_list ap;
+	va_start(ap, format);
+	report_level(WLOG_WARN, file, line, function, status, format, ap);
+	va_end(ap);
+}
+
+const char* next_arg(va_list ap)
+{
+	return va_arg(ap, const char*);
+}
+
+void report_verbose(const char* file, unsigned long line, const char* function, const char* format,
+                    ...)
+{
+	va_list ap;
+	va_start(ap, format);
+	report_level(WLOG_INFO, file, line, function, 0, format, ap);
+	va_end(ap);
+}
+
+void initialize_error_handling(void)
+{
+	handle_out_of_memory = error_out_of_memory;
+	handle_error = report_error;
+	handle_warning = report_warning;
+	handle_verbose = report_verbose;
+}
+
+scquery_result query_X509_user_identities(const char* module, const char* reader_name,
+                                          const char* card_name, int verbose)
+{
+	scquery_result result = NULL;
+	certificate_list current;
+	certificate_list clist = find_x509_certificates_with_signing_rsa_private_key(
+	    module, reader_name, card_name, verbose);
+	smartcard_certificate entry = NULL;
+	char* X509_user_identity = NULL;
+	char* upn = NULL;
+	DO_CERTIFICATE_LIST(entry, current, clist)
+	{
+		alt_name name;
+		alt_name_list current;
+		alt_name_list alist = certificate_extract_subject_alt_names(entry->value);
+		DO_ALT_NAME_LIST(name, current, alist)
+		{
+			if ((0 != strcasecmp("OTHERNAME", name->type)) || (name->count < 2) ||
+			    (0 != strcmp(scquery_upn_oid, name->components[0])))
+			{
+				continue;
+			}
+
+			upn = check_memory(strdup(name->components[1]), 1 + strlen(name->components[1]));
+			break;
+		}
+		alt_name_list_deepfree(alist);
+
+		if (upn != NULL)
+		{
+			break;
+		}
+	}
+
+	if ((entry != NULL) && (upn != NULL))
+	{
+		X509_user_identity = string_format("PKCS11:module_name=%s:slotid=%lu:token=%s:certid=%s",
+		                                   module, entry->slot_id, entry->token_label, entry->id);
+
+		if (X509_user_identity != NULL)
+		{
+			result = scquery_result_new(entry, X509_user_identity, upn);
+			/* Remove entry from clist,  since we keep entry in the result,  and we'll free clist.
+			 */
+			clist = certificate_list_delete(entry, clist);
+		}
+	}
+	else
+	{
+		entry = NULL;
+	}
+
+	certificate_list_deepfree(clist);
+
+	if (result == NULL)
+	{
+		scquery_certificate_deepfree(entry);
+		free(X509_user_identity);
+		free(upn);
+	}
+
+	return result;
+}
+
+scquery_result scquery_X509_user_identities(const char* module, const char* reader_name,
+                                            const char* card_name, int verbose)
+{
+	initialize_error_handling();
+	return query_X509_user_identities(module, reader_name, card_name, verbose);
+}
+
+scquery_result scquery_result_new(smartcard_certificate certificate, char* X509_user_identity,
+                                  char* upn)
+{
+	scquery_result result = checked_malloc(sizeof(*result));
+
+	if (result)
+	{
+		result->certificate = certificate;
+		result->X509_user_identity = X509_user_identity;
+		result->upn = upn;
+	}
+
+	return result;
+}
+
+void scquery_result_free(scquery_result that)
+{
+	if (that)
+	{
+		scquery_certificate_deepfree(that->certificate);
+		free(that->X509_user_identity);
+		free(that->upn);
+		free(that);
+	}
+}
+
+/**** THE END ****/
diff -urN libfreerdp/scquery/scquery_error.c ../../informatimago/FreeRDP/libfreerdp/scquery/scquery_error.c
--- libfreerdp/scquery/scquery_error.c	1970-01-01 03:00:00.000000000 +0300
+++ ../../informatimago/FreeRDP/libfreerdp/scquery/scquery_error.c	2019-07-25 20:11:29.315989365 +0300
@@ -0,0 +1,21 @@
+#include <stdlib.h>
+
+#include "scquery_error.h"
+
+/* ========================================================================== */
+/* Error Handling */
+
+void* check_memory(void* memory, size_t size)
+{
+	return memory ? memory : handle_out_of_memory(size);
+}
+
+void* checked_malloc(size_t size)
+{
+	return check_memory(malloc(size), size);
+}
+
+void* checked_calloc(size_t nmemb, size_t size)
+{
+	return check_memory(calloc(nmemb, size), nmemb * size);
+}
diff -urN libfreerdp/scquery/scquery_error.h ../../informatimago/FreeRDP/libfreerdp/scquery/scquery_error.h
--- libfreerdp/scquery/scquery_error.h	1970-01-01 03:00:00.000000000 +0300
+++ ../../informatimago/FreeRDP/libfreerdp/scquery/scquery_error.h	2019-07-25 20:11:29.315989365 +0300
@@ -0,0 +1,69 @@
+#ifndef LIBFREERDP_SCQUERY_ERROR_H
+#define LIBFREERDP_SCQUERY_ERROR_H
+#include <stddef.h>
+#include <errno.h>
+#include <sysexits.h>
+
+/* out_of_memory
+handles the out of memory error (when malloc returns NULL).
+It may not return, or it should return a pointer returned
+untouched by the caller.
+*/
+typedef void* (*out_of_memory_handler)(size_t size);
+out_of_memory_handler handle_out_of_memory;
+
+/* check_memory
+checks the memory pointer is not null, and returns it.
+If it's null, then call out_of_memory and return its results.
+*/
+void* check_memory(void* memory, size_t size);
+
+/* checked_malloc
+allocates size bytes of memory, or if it can't, calls out_of_memory and return its results.
+*/
+void* checked_malloc(size_t size);
+
+/* checked_calloc
+allocates nmemb * size bytes of memory and clears it,
+or if it can't, calls out_of_memory and return its results.
+*/
+void* checked_calloc(size_t nmemb, size_t size);
+
+/* error
+handles other errors, displaying the formated error message.
+It may return or not.
+*/
+typedef void (*error_handler)(const char* file, unsigned long line, const char* function,
+                              int status, const char* format, ...);
+error_handler handle_error;
+#define ERROR(status, format, ...) \
+	(handle_error(__FILE__, __LINE__, __FUNCTION__, status, format, ##__VA_ARGS__))
+
+/* warn
+handles the warning, displaying the formated error message, and returning.
+*/
+typedef void (*warning_handler)(const char* file, unsigned long line, const char* function,
+                                int status, const char* format, ...);
+warning_handler handle_warning;
+#define WARN(status, format, ...) \
+	(handle_warning(__FILE__, __LINE__, __FUNCTION__, status, format, ##__VA_ARGS__))
+
+typedef void (*verbose_handler)(const char* file, unsigned long line, const char* function,
+                                const char* format, ...);
+verbose_handler handle_verbose;
+#define VERBOSE(verbose, format, ...) \
+	((verbose) ? handle_verbose(__FILE__, __LINE__, __FUNCTION__, format, ##__VA_ARGS__) : (void)0)
+
+#ifdef assert
+#	undef assert
+#endif
+#define assert(condition)                                           \
+	do                                                              \
+	{                                                               \
+		if (!(condition))                                           \
+		{                                                           \
+			ERROR(EX_SOFTWARE, "Assertion failed: %s", #condition); \
+		}                                                           \
+	} while (0)
+
+#endif
diff -urN libfreerdp/scquery/scquery.h ../../informatimago/FreeRDP/libfreerdp/scquery/scquery.h
--- libfreerdp/scquery/scquery.h	1970-01-01 03:00:00.000000000 +0300
+++ ../../informatimago/FreeRDP/libfreerdp/scquery/scquery.h	2019-07-25 20:11:29.315989365 +0300
@@ -0,0 +1,32 @@
+#ifndef LIBFREERDP_SCQUERY_H
+#define LIBFREERDP_SCQUERY_H
+
+#include "certificate.h"
+
+typedef struct
+{
+	smartcard_certificate certificate;
+	char* X509_user_identity; /* kinit -X X509_user_identity value */
+	char* upn;
+} scquery_result_t, *scquery_result;
+
+/**
+ * Find a user identity and UPN on a smartcard.
+ *
+ * @param module path to a pkcs11 shared library (eg. "/usr/lib/opensc-pkcs11.so" or
+ * "/usr/lib/libiaspkcs11.so")
+ * @param reader_name NULL or a smartcard reader name.
+ * @param card_name NULL or a smartcard name.
+ * @param verbose non-0 to add some logs.
+ * @return A structure containign the X509_user_identity parameter for kinit, and the upn from the
+ * selected certificate from the smartcard. The result shall be freed with  scquery_result_free().
+ */
+scquery_result scquery_X509_user_identities(const char* module, const char* reader_name,
+                                            const char* card_name, int verbose);
+
+scquery_result scquery_result_new(smartcard_certificate certificate, char* X509_user_identity,
+                                  char* upn);
+
+void scquery_result_free(scquery_result that);
+
+#endif
diff -urN libfreerdp/scquery/scquery_string.c ../../informatimago/FreeRDP/libfreerdp/scquery/scquery_string.c
--- libfreerdp/scquery/scquery_string.c	1970-01-01 03:00:00.000000000 +0300
+++ ../../informatimago/FreeRDP/libfreerdp/scquery/scquery_string.c	2019-07-25 20:11:29.319989386 +0300
@@ -0,0 +1,186 @@
+#include <stdarg.h>
+#include <stdio.h>
+
+#include "scquery_string.h"
+#include "scquery_error.h"
+
+#if _POSIX_C_SOURCE >= 200809L || defined(_GNU_SOURCE)
+/* strndup and strnlen are defined in string.h */
+void string_dummy(void)
+{
+} /* some compilers complain on empty sources. */
+#else
+
+size_t strnlen(const char* string, size_t length)
+{
+	size_t i = 0;
+
+	if (string == NULL)
+	{
+		return i;
+	}
+
+	while ((i < length) && (string[i] != '\0'))
+	{
+		i++;
+	}
+
+	return i;
+}
+
+char* strndup(const char* string, size_t length)
+{
+	if (string == NULL)
+	{
+		return NULL;
+	}
+	else
+	{
+		size_t i;
+		size_t size = 1 + strnlen(string, length);
+		char* result = checked_malloc(size);
+
+		if (result == NULL)
+		{
+			errno = ENOMEM;
+			return NULL;
+		}
+
+		for (i = 0; i < size - 1; i++)
+		{
+			result[i] = string[i];
+		}
+
+		result[size - 1] = '\0';
+		return result;
+	}
+}
+
+#endif
+
+#if (_XOPEN_SOURCE >= 500) || (_POSIX_C_SOURCE >= 200809L) || _BSD_SOURCE || _SVID_SOURCE
+/* strdup is defined in string.h */
+#else
+
+char* strdup(const char* string)
+{
+	if (string == NULL)
+	{
+		return NULL;
+	}
+	else
+	{
+		char* result = checked_malloc(1 + strlen(string));
+
+		if (result == NULL)
+		{
+			errno = ENOMEM;
+			return NULL;
+		}
+
+		strcpy(result, string);
+		return result;
+	}
+}
+
+#endif
+
+/* typedef char* (* string_preprocess_pr)(const char *); */
+/* typedef void (* string_postprocess_pr)(char *); */
+
+char* string_mapconcat(string_preprocess_pr preprocess, string_postprocess_pr postprocess,
+                       unsigned count, const char** strings, const char* separator)
+{
+	if ((count == 0) || (strings == 0))
+	{
+		goto failure;
+	}
+
+	char* item;
+	char* current;
+	size_t seplen = strlen(separator);
+	size_t size = 1 + seplen * (count - 1);
+	unsigned i;
+
+	for (i = 0; i < count; i++)
+	{
+		size += strlen(strings[i]);
+	}
+
+	char* result = checked_malloc(size);
+
+	if (result == NULL)
+	{
+		goto failure;
+	}
+
+	current = result;
+	item = preprocess(strings[0]);
+	strcpy(current, item);
+	current = strchr(current, '\0');
+	postprocess(item);
+
+	for (i = 1; i < count; i++)
+	{
+		item = preprocess(strings[i]);
+		strcat(current, separator);
+		current = strchr(current, '\0');
+		strcat(current, item);
+		current = strchr(current, '\0');
+		postprocess(item);
+	}
+
+	return result;
+failure:
+	return check_memory(strdup(""), 1);
+}
+
+size_t string_count(const char* string, char character)
+{
+	size_t count = 0;
+
+	while ((string = strchr(string, character)) != NULL)
+	{
+		count++;
+	}
+
+	return count;
+}
+
+size_t padded_string_length(const char* padded_string, size_t max_size, char pad)
+{
+	size_t len = strnlen(padded_string, max_size);
+
+	while ((len > 0) && (padded_string[len - 1] == pad))
+	{
+		len--;
+	}
+
+	return len;
+}
+
+char* string_from_padded_string(const char* padded_string, size_t max_size, char pad)
+{
+	size_t length = padded_string_length(padded_string, max_size, pad);
+	return check_memory(strndup(padded_string, length), length);
+}
+
+char* string_format(const char* format_string, ...)
+{
+	char* result = NULL;
+	va_list args;
+	int length;
+	va_start(args, format_string);
+	length = vsnprintf(NULL, 0, format_string, args);
+	va_end(args);
+	result = checked_malloc(1 + length);
+
+	if (result != NULL)
+	{
+		va_start(args, format_string);
+		vsnprintf(result, 1 + length, format_string, args);
+		va_end(args);
+	}
+
+	return result;
+}
diff -urN libfreerdp/scquery/scquery_string.h ../../informatimago/FreeRDP/libfreerdp/scquery/scquery_string.h
--- libfreerdp/scquery/scquery_string.h	1970-01-01 03:00:00.000000000 +0300
+++ ../../informatimago/FreeRDP/libfreerdp/scquery/scquery_string.h	2019-07-25 20:11:29.323989405 +0300
@@ -0,0 +1,41 @@
+#ifndef LIBFREERDP_SCQUERY_STRING_H
+#define LIBFREERDP_SCQUERY_STRING_H
+
+#include <string.h>
+
+#if (_POSIX_C_SOURCE >= 200809L) || defined(_GNU_SOURCE)
+/* strndup and strnlen are defined in string.h */
+#else
+
+size_t strnlen(const char* string, size_t length);
+char* strndup(const char* string, size_t length);
+
+#endif
+
+#if (_XOPEN_SOURCE >= 500) || (_POSIX_C_SOURCE >= 200809L) || _BSD_SOURCE || _SVID_SOURCE
+/* strdup is defined in string.h */
+#else
+
+char* strdup(const char* string);
+
+#endif
+
+typedef char* (*string_preprocess_pr)(const char*);
+typedef void (*string_postprocess_pr)(char*);
+char* string_mapconcat(string_preprocess_pr preprocess, string_postprocess_pr postprocess,
+                       unsigned count, const char** strings, const char* separator);
+
+size_t string_count(const char* string, char character);
+
+size_t padded_string_length(const char* padded_string, size_t max_size, char pad);
+char* string_from_padded_string(const char* padded_string, size_t max_size, char pad);
+
+/*
+string_format
+format a string as with sprintf,  but first computing the output size
+and allocating buffer of that size (plus terminating nul).
+@result returns the new string,  or NULL if it couldn't be allocated.
+ */
+char* string_format(const char* format_string, ...);
+
+#endif
diff -urN libfreerdp/scquery/smartcard_certificate.c ../../informatimago/FreeRDP/libfreerdp/scquery/smartcard_certificate.c
--- libfreerdp/scquery/smartcard_certificate.c	1970-01-01 03:00:00.000000000 +0300
+++ ../../informatimago/FreeRDP/libfreerdp/scquery/smartcard_certificate.c	2019-07-25 20:11:29.331989445 +0300
@@ -0,0 +1,345 @@
+#include <stdlib.h>
+#include <stdio.h>
+#include <string.h>
+#include <stdbool.h>
+#include <pkcs11-helper-1.0/pkcs11.h>
+#include "smartcard_certificate.h"
+#include "pkcs11module.h"
+#include "pkcs11errors.h"
+#include "scquery_error.h"
+#include "scquery_string.h"
+
+/* ========================================================================== */
+/* Searching certificates on a IAS-ECC smartcard. */
+
+static char* bytes_to_hexadecimal(CK_BYTE* bytes, CK_ULONG count)
+{
+	char* buffer = checked_malloc(2 * count + 1);
+	char* current = buffer;
+
+	if (buffer == NULL)
+	{
+		return buffer;
+	}
+
+	while (count > 0)
+	{
+		sprintf(current, "%02x", *bytes);
+		bytes++;
+		current += 2;
+		count--;
+	}
+
+	*current = '\0';
+	return buffer;
+}
+
+CK_OBJECT_HANDLE object_handle_ensure_one(object_handle_list list, char* what)
+{
+	if ((list == NULL) || (object_handle_rest(list) != NULL))
+	{
+		WARN(0, "Something strange: there is %s %s when exactly one was expected.",
+		     (list == NULL) ? "zero" : "more than one", what);
+	}
+
+	CK_OBJECT_HANDLE result = ((list == NULL) ? CK_INVALID_HANDLE : object_handle_first(list));
+	object_handle_list_free(list);
+	return result;
+}
+
+CK_ULONG position_of_attribute(CK_ULONG attribute_type, template* template)
+{
+	CK_ULONG i;
+
+	for (i = 0; i < template->count; i++)
+	{
+		if (template->attributes[i].type == attribute_type)
+		{
+			return i;
+		}
+	}
+
+	return CK_UNAVAILABLE_INFORMATION;
+}
+
+char* string_attribute(CK_ULONG attribute, template* template)
+{
+	CK_ULONG index = position_of_attribute(attribute, template);
+
+	if (index == CK_UNAVAILABLE_INFORMATION)
+	{
+		const char* text = "unavailable";
+		return check_memory(strdup(text), 1 + strlen(text));
+	}
+	else
+	{
+		return check_memory(
+		    strndup(template->attributes[index].pValue, template->attributes[index].ulValueLen),
+		    template->attributes[index].ulValueLen + 1);
+	}
+}
+
+buffer buffer_attribute(CK_ULONG attribute, template* template)
+{
+	CK_ULONG index = position_of_attribute(attribute, template);
+
+	if (index == CK_UNAVAILABLE_INFORMATION)
+	{
+		return NULL;
+	}
+	else
+	{
+		return buffer_new_copy(template->attributes[index].ulValueLen,
+		                       template->attributes[index].pValue);
+	}
+}
+
+certificate_list find_x509_certificates_with_signing_rsa_private_key_in_slot(
+    pkcs11_module* module, CK_ULONG slot_id, const char* slot_description, const char* token_label,
+    const char* token_serial, int protected_authentication_path, CK_SESSION_HANDLE session,
+    certificate_list result)
+{
+	CK_OBJECT_CLASS oclass = CKO_PRIVATE_KEY;
+	CK_BBOOL sign = CK_TRUE;
+	CK_KEY_TYPE ktype = CKK_RSA;
+	template privkey_template = { 3,
+		                          { { CKA_CLASS, &oclass, sizeof(oclass) },
+		                            { CKA_SIGN, &sign, sizeof(sign) },
+		                            { CKA_KEY_TYPE, &ktype, sizeof(ktype) } } };
+	object_handle_list privkey_list = find_all_object(module, session, &privkey_template);
+	object_handle_list current;
+	CK_OBJECT_HANDLE privkey_handle;
+	VERBOSE(module->verbose, "Found %lu private keys", object_handle_list_length(privkey_list));
+	DO_OBJECT_HANDLE_LIST(privkey_handle, current, privkey_list)
+	{
+		template privkey_attributes = { 2, { { CKA_CLASS, NULL, 0 }, { CKA_ID, NULL, 0 } } };
+		CK_BYTE* id;
+		CK_ULONG id_size;
+		object_get_attributes(module, session, privkey_handle, &privkey_attributes);
+		id = privkey_attributes.attributes[1].pValue;
+		id_size = privkey_attributes.attributes[1].ulValueLen;
+
+		if (id && (id_size != CK_UNAVAILABLE_INFORMATION))
+		{
+			CK_OBJECT_CLASS oclass = CKO_CERTIFICATE;
+			CK_CERTIFICATE_TYPE ctype = CKC_X_509;
+			template certificate_template = { 3,
+				                              { { CKA_CLASS, &oclass, sizeof(oclass) },
+				                                { CKA_CERTIFICATE_TYPE, &ctype, sizeof(ctype) },
+				                                { CKA_ID, id, id_size } } };
+			CK_OBJECT_HANDLE certificate_handle;
+			char* idstring = bytes_to_hexadecimal(id, id_size);
+			VERBOSE(module->verbose, "Private key ID %s", idstring);
+			certificate_handle = object_handle_ensure_one(
+			    find_all_object(module, session, &certificate_template), "certificate handle");
+
+			if (certificate_handle == CK_INVALID_HANDLE)
+			{
+				VERBOSE(module->verbose, "Found no certificate for private key ID %s", idstring);
+				free(idstring);
+				continue;
+			}
+
+			free(idstring);
+			template certificate_attributes = { 10,
+				                                { { CKA_CLASS, NULL, 0 },
+				                                  { CKA_ID, NULL, 0 },
+				                                  { CKA_OBJECT_ID, NULL, 0 },
+				                                  { CKA_LABEL, NULL, 0 },
+				                                  { CKA_CERTIFICATE_TYPE, NULL, 0 },
+				                                  { CKA_CERTIFICATE_CATEGORY, NULL, 0 },
+				                                  { CKA_ISSUER, NULL, 0 },
+				                                  { CKA_SUBJECT, NULL, 0 },
+				                                  { CKA_VALUE, NULL, 0 },
+				                                  { CKA_KEY_TYPE, NULL, 0 } } };
+			object_get_attributes(module, session, certificate_handle, &certificate_attributes);
+			smartcard_certificate certificate;
+			CK_ULONG id_index = position_of_attribute(CKA_ID, &certificate_attributes);
+			CK_ULONG certype_index =
+			    position_of_attribute(CKA_CERTIFICATE_TYPE, &certificate_attributes);
+			CK_ULONG keytype_index = position_of_attribute(CKA_KEY_TYPE, &certificate_attributes);
+			certificate = scquery_certificate_new(
+			    slot_id, check_memory(strdup(slot_description), strlen(slot_description)),
+			    check_memory(strdup(token_label), strlen(token_label)),
+			    check_memory(strdup(token_serial), strlen(token_serial)),
+			    ((id_index != CK_UNAVAILABLE_INFORMATION)
+			         ? (bytes_to_hexadecimal(
+			               certificate_attributes.attributes[id_index].pValue,
+			               certificate_attributes.attributes[id_index].ulValueLen))
+			         : string_attribute(CKA_ID, &certificate_attributes)),
+			    string_attribute(CKA_LABEL, &certificate_attributes),
+			    ((certype_index != CK_UNAVAILABLE_INFORMATION)
+			         ? (*(CK_CERTIFICATE_TYPE*)certificate_attributes.attributes[certype_index]
+			                 .pValue)
+			         : 0),
+			    buffer_attribute(CKA_ISSUER, &certificate_attributes),
+			    buffer_attribute(CKA_SUBJECT, &certificate_attributes),
+			    buffer_attribute(CKA_VALUE, &certificate_attributes),
+			    ((keytype_index != CK_UNAVAILABLE_INFORMATION)
+			         ? (*(CK_KEY_TYPE*)certificate_attributes.attributes[keytype_index].pValue)
+			         : 0),
+			    protected_authentication_path);
+			VERBOSE(
+			    module->verbose,
+			    "Certificate slot_id=%lu token_label=%s id=%s label=%s type=%lu issuer=(%d bytes) "
+			    "subject=(%d bytes) value=(%d bytes) key_type=%lu",
+			    certificate->slot_id, certificate->token_label, certificate->id, certificate->label,
+			    certificate->type, (certificate->issuer ? buffer_size(certificate->issuer) : 0),
+			    (certificate->subject ? buffer_size(certificate->subject) : 0),
+			    (certificate->value ? buffer_size(certificate->value) : 0), certificate->key_type);
+			result = certificate_list_cons(certificate, result);
+			template_free_buffers(&certificate_attributes);
+			template_free_buffers(&privkey_attributes);
+		}
+		else
+		{
+			VERBOSE(module->verbose, "Private key has no ID!");
+		}
+	}
+	object_handle_list_free(privkey_list);
+	return result;
+}
+
+char* get_slot_description(pkcs11_module* module, CK_ULONG slot_id)
+{
+	CK_SLOT_INFO info;
+	char* result = NULL;
+
+	if (CHECK_RV(module->p11->C_GetSlotInfo(slot_id, &info), "C_GetSlotInfo"))
+	{
+		result = check_memory(string_from_padded_string((const char*)info.slotDescription,
+		                                                sizeof(info.slotDescription), ' '),
+		                      sizeof(info.slotDescription) + 1);
+	}
+
+	return result;
+}
+
+char* get_token_label(pkcs11_module* module, CK_ULONG slot_id, char** token_serial,
+                      int* protected_authentication_path)
+{
+	CK_TOKEN_INFO info;
+
+	if (CHECK_RV(module->p11->C_GetTokenInfo(slot_id, &info), "C_GetTokenInfo"))
+	{
+		char* label = check_memory(
+		    string_from_padded_string((const char*)info.label, sizeof(info.label), ' '),
+		    sizeof(info.label) + 1);
+		char* serial = check_memory(string_from_padded_string((const char*)info.serialNumber,
+		                                                      sizeof(info.serialNumber), ' '),
+		                            sizeof(info.serialNumber) + 1);
+		(*token_serial) = serial;
+		(*protected_authentication_path) = ((info.flags & CKF_PROTECTED_AUTHENTICATION_PATH) != 0);
+		return label;
+	}
+
+	(*token_serial) = NULL;
+	return NULL;
+}
+
+CK_BBOOL selected_slot(pkcs11_module* module, CK_ULONG slot_id, const char* slot_description,
+                       const char* reader_name)
+{
+	CK_BBOOL selected = TRUE;
+
+	if (reader_name != NULL)
+	{
+		selected = ((slot_description != NULL) && (0 == strcmp(slot_description, reader_name)));
+	}
+
+	if (selected)
+	{
+		VERBOSE(module->verbose, "Processing slot id %lu", slot_id);
+	}
+	else
+	{
+		VERBOSE(module->verbose, "Rejected slot id %lu (reader named \"%s\",  not \"%s\")", slot_id,
+		        reader_name);
+	}
+
+	return selected;
+}
+
+CK_BBOOL selected_token(pkcs11_module* module, CK_ULONG slot_id, const char* label,
+                        const char* serial, const char* card_name)
+{
+	CK_BBOOL selected = TRUE;
+
+	if (card_name != NULL)
+	{
+		selected = ((label != NULL) && (0 == strcmp(label, card_name))) ||
+		           ((serial != NULL) && (0 == strcmp(serial, card_name)));
+	}
+
+	if (selected)
+	{
+		VERBOSE(module->verbose, "Processing token label %s (serial %s)", label, serial);
+	}
+	else
+	{
+		VERBOSE(module->verbose, "Rejected token label %s (serial %s), not named %s", label, serial,
+		        card_name);
+	}
+
+	return selected;
+}
+
+certificate_list find_x509_certificates_with_signing_rsa_private_key(
+    const char* pkcs11_library_path, const char* reader_name, const char* card_name, int verbose)
+{
+	/* Find PRIVATE-KEYs of KEY-TYPE = RSA, that can SIGN, and that have a X-509 certificate with
+	 * same ID. */
+	certificate_list result = NULL;
+	pkcs11_module* module = NULL;
+	slot_id_list slots;
+	WITH_PKCS11_MODULE(module, pkcs11_library_path)
+	{
+		module->verbose = verbose;
+		get_list_of_slots_with_token(module, &slots);
+		VERBOSE(module->verbose, "Found %d slots", slots.count);
+
+		if (slots.count == 0)
+		{
+			ERROR(1, "No smartcard!");
+		}
+		else
+		{
+			CK_ULONG i;
+
+			for (i = 0; i < slots.count; i++)
+			{
+				CK_ULONG slot_id = slots.slot_id[i];
+				char* slot_description = get_slot_description(module, slot_id);
+
+				if (selected_slot(module, slot_id, slot_description, reader_name))
+				{
+					int protected_authentication_path = 0;
+					char* serial = NULL;
+					char* label =
+					    get_token_label(module, slot_id, &serial, &protected_authentication_path);
+
+					if (selected_token(module, slot_id, label, serial, card_name))
+					{
+						CK_SESSION_HANDLE session;
+						WITH_PKCS11_OPEN_SESSION(session, module, slot_id, CKF_SERIAL_SESSION, NULL,
+						                         NULL)
+						{
+							VERBOSE(module->verbose, "Opened PKCS#11 session %lu", session);
+							result = find_x509_certificates_with_signing_rsa_private_key_in_slot(
+							    module, slot_id, slot_description, label, serial,
+							    protected_authentication_path, session, result);
+						}
+					}
+
+					free(label);
+					free(serial);
+				}
+
+				free(slot_description);
+			}
+		}
+	}
+	return result;
+}
+
+/**** THE END ****/
diff -urN libfreerdp/scquery/smartcard_certificate.h ../../informatimago/FreeRDP/libfreerdp/scquery/smartcard_certificate.h
--- libfreerdp/scquery/smartcard_certificate.h	1970-01-01 03:00:00.000000000 +0300
+++ ../../informatimago/FreeRDP/libfreerdp/scquery/smartcard_certificate.h	2019-07-25 20:11:29.335989465 +0300
@@ -0,0 +1,20 @@
+#ifndef LIBFREERDP_SCQUERY_SMARTCARD_CERTIFICATE_H
+#define LIBFREERDP_SCQUERY_SMARTCARD_CERTIFICATE_H
+#include "certificate_list.h"
+
+/* find_x509_certificates_with_signing_rsa_private_key
+
+When given, reader_name and / or card_name select secific slots (reader) or token (card).
+
+@result a list of certificates that can be used with PKINIT.
+This list shall be freed with  certificate_list_deepfree
+@param verbose when non-0 will print logs on stderr.
+@param reader_name NULL, or a nul-terminated string matching the slot_info.slot_description (with
+the padding removed).
+@param card_name NULL, or a nul-terminated string matching the token_info.label or
+token_info.serial_number (with the padding removed).
+*/
+certificate_list find_x509_certificates_with_signing_rsa_private_key(
+    const char* pkcs11_library_path, const char* reader_name, const char* card_name, int verbose);
+
+#endif
diff -urN libfreerdp/scquery/x509_alt_names.c ../../informatimago/FreeRDP/libfreerdp/scquery/x509_alt_names.c
--- libfreerdp/scquery/x509_alt_names.c	1970-01-01 03:00:00.000000000 +0300
+++ ../../informatimago/FreeRDP/libfreerdp/scquery/x509_alt_names.c	2019-07-25 20:11:29.343989504 +0300
@@ -0,0 +1,631 @@
+#include <string.h>
+#include <openssl/bn.h>
+#include <openssl/err.h>
+#include <openssl/safestack.h>
+#include <openssl/ssl.h>
+#include <openssl/stack.h>
+#include <openssl/x509v3.h>
+#include "x509_alt_names.h"
+#include "scquery_error.h"
+#include "scquery_string.h"
+
+static void string_list_free(unsigned count, char** components)
+{
+	unsigned i;
+
+	for (i = 0; i < count; i++)
+	{
+		free(components[i]);
+	}
+
+	free(components);
+}
+
+alt_name alt_name_new_with_components(char* type, unsigned count, char** components)
+{
+	alt_name name = alt_name_new(type, count);
+
+	if (name == NULL)
+	{
+		return NULL;
+	}
+
+	name->count = count;
+	name->allocated = count;
+	name->components = components;
+	return name;
+}
+
+alt_name alt_name_new(char* type, unsigned allocated)
+{
+	alt_name result = checked_malloc(sizeof(*result));
+
+	if (result == NULL)
+	{
+		return NULL;
+	}
+
+	result->type = check_memory(strdup(type), 1 + strlen(type));
+	result->count = 0;
+	result->allocated = allocated;
+	result->components =
+	    ((allocated == 0) ? NULL
+	                      : checked_calloc(result->allocated, sizeof(result->components[0])));
+
+	if ((result->type == NULL) || ((result->allocated > 0) && (result->components == NULL)))
+	{
+		free(result->type);
+		string_list_free(result->allocated, result->components);
+		free(result);
+		return NULL;
+	}
+
+	return result;
+}
+
+void alt_name_add_component(alt_name name, char* component)
+{
+	if ((name == NULL) || (component == NULL))
+	{
+		return;
+	}
+
+	if (name->count >= name->allocated)
+	{
+		unsigned new_allocated = ((name->allocated == 0) ? 8 : 2 * name->allocated);
+		char** new_components =
+		    realloc(name->components, new_allocated * sizeof(name->components[0]));
+
+		if (new_components == NULL)
+		{
+			ERROR(EX_OSERR, "Cannot add component '%s'", component);
+			return;
+		}
+
+		name->components = new_components;
+		name->allocated = new_allocated;
+	}
+
+	unsigned index = name->count++;
+	name->components[index] = check_memory(strdup(component), 1 + strlen(component));
+	return;
+}
+
+void alt_name_free(alt_name name)
+{
+	if (name == NULL)
+	{
+		return;
+	}
+
+	free(name->type);
+	string_list_free(name->count, name->components);
+	free(name);
+}
+
+alt_name_list alt_name_list_cons(alt_name name, alt_name_list rest)
+{
+	alt_name_list list = checked_malloc(sizeof(*list));
+
+	if (list == NULL)
+	{
+		return NULL;
+	}
+
+	list->name = name;
+	list->rest = rest;
+	return list;
+}
+
+alt_name alt_name_list_first(alt_name_list list)
+{
+	return ((list == NULL) ? NULL : list->name);
+}
+
+alt_name_list alt_name_list_rest(alt_name_list list)
+{
+	return ((list == NULL) ? NULL : list->rest);
+}
+
+void alt_name_list_free(alt_name_list list)
+{
+	free(list);
+}
+
+void alt_name_list_deepfree(alt_name_list list)
+{
+	while (list != NULL)
+	{
+		alt_name_list rest = list->rest;
+		alt_name_free(list->name);
+		alt_name_list_free(list);
+		list = rest;
+	}
+}
+
+char* general_name_type_label(int general_name_type)
+{
+	static const char* labels[] = { "OTHERNAME", "EMAIL", "DNS",   "X400", "DIRNAME",
+		                            "EDIPARTY",  "URI",   "IPADD", "RID" };
+
+	if ((general_name_type < 0) || (general_name_type >= (int)(sizeof(labels) / sizeof(labels[0]))))
+	{
+		char* result = checked_malloc(64);
+
+		if (result == NULL)
+		{
+			return NULL;
+		}
+
+		sprintf(result, "Unknown GENERAL_NAME type %d", general_name_type);
+		return result;
+	}
+
+	return strdup(labels[general_name_type]);
+}
+
+void extract_asn1_string(GENERAL_NAME* name, alt_name alt_name)
+{
+	unsigned char* string = NULL;
+
+	switch (name->type)
+	{
+	case GEN_URI:
+	case GEN_DNS:
+	case GEN_EMAIL:
+		if (ASN1_STRING_to_UTF8(&string, name->d.ia5) < 0)
+		{
+			char* type = general_name_type_label(name->type);
+			ERROR(EX_OSERR, "Error converting with ASN1_STRING_to_UTF8 a %s general name", type);
+			free(type);
+			return;
+		}
+
+		/* alt_name_add_component makes a copy of the component: */
+		alt_name_add_component(alt_name, (char*)string);
+		OPENSSL_free(string);
+	}
+}
+
+char* type_id_to_oid_string(ASN1_OBJECT* type_id)
+{
+	char small_buffer[1];
+	int buffer_size = 1 + OBJ_obj2txt(small_buffer, 1, type_id, /*no_name=*/1);
+	char* buffer = checked_malloc(buffer_size);
+
+	if (buffer == NULL)
+	{
+		return NULL;
+	}
+
+	OBJ_obj2txt(buffer, buffer_size, type_id, /*no_name=*/1);
+	return buffer;
+}
+
+char* asn1_string_to_string(ASN1_TYPE* value)
+{
+	unsigned char* utf8string = NULL;
+	int result = ASN1_STRING_to_UTF8(&utf8string, value->value.asn1_string);
+
+	if (result < 0)
+	{
+		return check_memory(strdup(""), 1);
+	}
+
+	char* string = check_memory(strdup((char*)utf8string), 1 + result);
+	OPENSSL_free(utf8string);
+	return string;
+}
+
+char* asn1_boolean_to_string(ASN1_TYPE* value)
+{
+	return check_memory(strdup(value->value.boolean ? "true" : "false"), 6);
+}
+
+typedef void (*collector_pr)(unsigned class, unsigned primitive, unsigned tag, unsigned char* data,
+                             unsigned length, void* collect_data);
+
+void collect_alt_name_component(unsigned class, unsigned primitive, unsigned tag,
+                                unsigned char* data, unsigned length, void* collect_data)
+{
+	(void)class;
+	(void)primitive;
+	(void)tag;
+	alt_name name = collect_data;
+	/* Use an auto buffer if length is small enough, or else a dynamic buffer. */
+	char buffer[4096];
+
+	if (1 + length <= sizeof(buffer))
+	{
+		strncpy(buffer, (char*)data, length);
+		buffer[length] = '\0';
+		alt_name_add_component(name, buffer);
+	}
+	else
+	{
+		char* buffer = checked_malloc(1 + length);
+
+		if (!buffer)
+		{
+			return;
+		}
+
+		strncpy(buffer, (char*)data, length);
+		buffer[length] = '\0';
+		alt_name_add_component(name, buffer);
+		free(buffer);
+	}
+}
+
+enum
+{
+	asn1_eoc = 0,
+	asn1_boolean = 1,
+	asn1_integer = 2,
+	asn1_bit_string = 3,
+	asn1_octet_string = 4,
+	asn1_null = 5,
+	asn1_object = 6,
+	asn1_object_descriptor = 7,
+	asn1_external = 8,
+	asn1_real = 9,
+	asn1_enumerated = 10,
+	asn1_utf8string = 12,
+	asn1_sequence = 16,
+	asn1_set = 17,
+	asn1_numericstring = 18,
+	asn1_printablestring = 19,
+	asn1_t61string = 20,
+	asn1_teletexstring = asn1_t61string,
+	asn1_videotexstring = 21,
+	asn1_ia5string = 22,
+	asn1_utctime = 23,
+	asn1_generalizedtime = 24,
+	asn1_graphicstring = 25,
+	asn1_iso64string = 26,
+	asn1_visiblestring = asn1_iso64string,
+	asn1_generalstring = 27,
+	asn1_universalstring = 28,
+	asn1_bmpstring = 30,
+};
+
+unsigned decode_der_length(unsigned char* data, unsigned i, unsigned* length)
+{
+	unsigned len = 0;
+	unsigned char b = data[i++];
+
+	if (b < 128)
+	{
+		len = b;
+	}
+	else
+	{
+		unsigned char c = b & 0x7f;
+
+		while (0 < c--)
+		{
+			len = (len << 8) | data[i++];
+		}
+	}
+
+	(*length) = len;
+	return i;
+}
+
+char* decode_integer(unsigned char* data, unsigned i, unsigned length)
+{
+	unsigned long long value = 0;
+
+	if (length <= sizeof(value))
+	{
+		unsigned j;
+
+		for (j = 0; 0 < length--; j += 8)
+		{
+			value |= (data[i++] << j);
+		}
+	}
+	else
+	{
+		value = (~0);
+	}
+
+	char* buffer = checked_malloc(64);
+
+	if (buffer)
+	{
+		snprintf(buffer, sizeof(buffer) - 1, "%llu", value);
+	}
+
+	return buffer;
+}
+
+unsigned decode_der_item_collect(unsigned char* data, unsigned i, unsigned length,
+                                 collector_pr collect, void* collect_data)
+{
+	/* We decode a sequence item.
+	   It can be a context-specific indexed element, or a plain element.
+	   When given a context-specific index, we just collect it, and then go on collecting the
+	   element itself. */
+	/* decode tag */
+	unsigned char tag = data[i] & 31;
+	unsigned char class = (data[i] >> 6) & 0b11;
+	unsigned char primitive = ((data[i] & 32) == 0);
+	i++;
+	/* decode length */
+	unsigned len = 0;
+	i = decode_der_length(data, i, &len);
+	assert(1 + len <= length);
+
+	/* decode elements */
+	switch (class)
+	{
+	case 2: /*context specific*/
+	{
+		char index[3];
+		sprintf(index, "%d", tag);
+		collect(class, primitive, tag, (unsigned char*)index, strlen(index), collect_data);
+		i = decode_der_item_collect(data, i, len, collect, collect_data);
+		break;
+	}
+
+	default:
+		switch (tag)
+		{
+		case asn1_eoc:
+		{
+			/* not processed yet */
+			collect(class, primitive, tag, (unsigned char*)&"", 0, collect_data);
+			i += len;
+			break;
+		}
+
+		case asn1_boolean:
+		{
+			char buffer[8];
+			strcpy(buffer, (data[i] ? "true" : "false"));
+			collect(class, primitive, tag, (unsigned char*)buffer, strlen(buffer), collect_data);
+			i += len;
+			break;
+		}
+
+		case asn1_integer:
+		{
+			char* value = decode_integer(data, i, len);
+			collect(class, primitive, tag, (unsigned char*)value, strlen(value), collect_data);
+			free(value);
+			i += len;
+			break;
+		}
+
+		case asn1_bit_string:
+		case asn1_octet_string:
+		{
+			/* not processed yet */
+			collect(class, primitive, tag, (unsigned char*)&"", 0, collect_data);
+			i += len;
+			break;
+		}
+
+		case asn1_null:
+		{
+			char buffer[8];
+			strcpy(buffer, "null");
+			collect(class, primitive, tag, (unsigned char*)buffer, strlen(buffer), collect_data);
+			i += len;
+			break;
+		}
+
+		case asn1_set:
+		case asn1_sequence:
+		{
+			unsigned e = i + len;
+
+			while (i < e)
+			{
+				i = decode_der_item_collect(data, i, len, collect, collect_data);
+			}
+
+			break;
+		}
+
+		case asn1_utf8string:
+		case asn1_numericstring:
+		case asn1_printablestring:
+		case asn1_t61string:
+		case asn1_videotexstring:
+		case asn1_ia5string:
+		case asn1_graphicstring:
+		case asn1_iso64string:
+		case asn1_generalstring:
+		case asn1_universalstring:
+		case asn1_bmpstring:
+		{
+			collect(class, primitive, tag, data + i, len, collect_data);
+			i += len;
+			break;
+		}
+
+		case asn1_object:
+		case asn1_object_descriptor:
+		case asn1_external:
+		case asn1_real:
+		case asn1_enumerated:
+		case asn1_utctime:
+		case asn1_generalizedtime:
+		{
+			/* not processed yet */
+			collect(class, primitive, tag, (unsigned char*)&"", 0, collect_data);
+			i += len;
+			break;
+		}
+		}
+	}
+
+	return i;
+}
+
+void extract_othername_object(GENERAL_NAME* name, alt_name alt_name)
+{
+	switch (name->type)
+	{
+		char* type;
+
+	case GEN_OTHERNAME:
+		alt_name_add_component(alt_name, type = type_id_to_oid_string(name->d.otherName->type_id));
+		unsigned char* der = NULL;
+		int length = i2d_ASN1_TYPE(name->d.otherName->value, &der);
+		decode_der_item_collect(der, 0, (unsigned)length, collect_alt_name_component, alt_name);
+		free(der);
+		free(type);
+	}
+}
+
+typedef alt_name (*extract_alt_name_pr)(GENERAL_NAME* name, unsigned i);
+
+alt_name extract_alt_name(GENERAL_NAME* name, unsigned i)
+{
+	(void)i;
+	alt_name alt_name;
+	char* type;
+
+	switch (name->type)
+	{
+	case GEN_URI:
+	case GEN_DNS:
+	case GEN_EMAIL:
+		alt_name = alt_name_new(type = general_name_type_label(name->type), 1);
+		extract_asn1_string(name, alt_name);
+		free(type);
+		return alt_name;
+
+	case GEN_OTHERNAME:
+		alt_name = alt_name_new(type = general_name_type_label(name->type), 1);
+		extract_othername_object(name, alt_name);
+		free(type);
+		return alt_name;
+
+	default:
+		return NULL;
+	}
+}
+
+void cert_info_kpn(X509* x509, alt_name alt_name)
+{
+	int i;
+	int j = 0;
+	STACK_OF(GENERAL_NAME) * gens;
+	GENERAL_NAME* name;
+	ASN1_OBJECT* krb5PrincipalName;
+	gens = X509_get_ext_d2i(x509, NID_subject_alt_name, NULL, NULL);
+	krb5PrincipalName = OBJ_txt2obj("1.3.6.1.5.2.2", 1);
+
+	if (!gens)
+	{
+		return; /* no alternate names */
+	}
+
+	if (!krb5PrincipalName)
+	{
+		ERROR(0, "Cannot map KPN object");
+		return;
+	}
+
+	for (i = 0; (i < sk_GENERAL_NAME_num(gens)); i++)
+	{
+		name = sk_GENERAL_NAME_value(gens, i);
+
+		if (name && name->type == GEN_OTHERNAME)
+		{
+			if (OBJ_cmp(name->d.otherName->type_id, krb5PrincipalName))
+			{
+				continue; /* object is not a UPN */
+			}
+			else
+			{
+				/* NOTE:
+				from PKINIT RFC, I deduce that stored format for kerberos
+				Principal Name is ASN1_STRING, but not sure at 100%
+				Any help will be granted
+				*/
+				unsigned char* txt;
+				ASN1_TYPE* val = name->d.otherName->value;
+				ASN1_STRING* str = val->value.asn1_string;
+
+				if ((ASN1_STRING_to_UTF8(&txt, str)) < 0)
+				{
+					ERROR(0, "ASN1_STRING_to_UTF8() failed: %s",
+					      ERR_error_string(ERR_get_error(), NULL));
+				}
+				else
+				{
+					alt_name_add_component(alt_name, check_memory(strdup((const char*)txt),
+					                                              1 + strlen((const char*)txt)));
+					j++;
+				}
+			}
+		}
+	}
+
+	sk_GENERAL_NAME_pop_free(gens, GENERAL_NAME_free);
+	ASN1_OBJECT_free(krb5PrincipalName);
+
+	if (j == 0)
+	{
+		ERROR(0, "Certificate does not contain a KPN entry");
+	}
+}
+
+alt_name_list map_subject_alt_names(X509* certificate, extract_alt_name_pr extract_alt_name)
+{
+	STACK_OF(GENERAL_NAME)* gens = X509_get_ext_d2i(certificate, NID_subject_alt_name, NULL, NULL);
+	alt_name_list results = NULL;
+
+	if (gens == NULL)
+	{
+		return NULL;
+	}
+
+	int count = sk_GENERAL_NAME_num(gens);
+	int i;
+
+	for (i = 0; i < count; i++)
+	{
+		GENERAL_NAME* name = sk_GENERAL_NAME_value(gens, i);
+		alt_name alt_name = extract_alt_name(name, i);
+
+		if (alt_name != NULL)
+		{
+			results = alt_name_list_cons(alt_name, results);
+		}
+	}
+
+	/* It looks like it's not possible to free the general_name themselves
+	   (they may be taken directly from the certificate data?).
+	   sk_GENERAL_NAME_pop_free(gens, GENERAL_NAME_free) crashes. */
+	sk_GENERAL_NAME_pop_free(gens, GENERAL_NAME_free);
+	/* sk_GENERAL_NAME_free(gens); */
+	return results;
+}
+
+alt_name_list certificate_extract_subject_alt_names(buffer certificate_data)
+{
+	if (certificate_data == NULL)
+	{
+		return NULL;
+	}
+	else
+	{
+		/* d2i_X509 increments the input point by the length read */
+		const unsigned char* next = buffer_data(certificate_data);
+		X509* certificate = d2i_X509(NULL, &next, buffer_size(certificate_data));
+		alt_name_list result = map_subject_alt_names(certificate, extract_alt_name);
+		/* alt_name alt_name = alt_name_new("1.3.6.1.5.2.2",1); */
+		/* cert_info_kpn(certificate, alt_name); */
+		/* result = alt_name_list_cons(alt_name, result); */
+		X509_free(certificate);
+		return result;
+	}
+}
+
+/**** THE END ****/
diff -urN libfreerdp/scquery/x509_alt_names.h ../../informatimago/FreeRDP/libfreerdp/scquery/x509_alt_names.h
--- libfreerdp/scquery/x509_alt_names.h	1970-01-01 03:00:00.000000000 +0300
+++ ../../informatimago/FreeRDP/libfreerdp/scquery/x509_alt_names.h	2019-07-25 20:11:29.343989504 +0300
@@ -0,0 +1,36 @@
+#ifndef LIBFREERDP_SCQUERY_X509_ALT_NAMES_H
+#define LIBFREERDP_SCQUERY_X509_ALT_NAMES_H
+#include "buffer.h"
+
+typedef struct
+{
+	char* type;
+	unsigned count;
+	unsigned allocated;
+	char** components;
+} alt_name_t, *alt_name;
+
+alt_name alt_name_new_with_components(char* type, unsigned count, char** components);
+alt_name alt_name_new(char* type, unsigned allocated);
+void alt_name_add_component(alt_name name, char* component);
+void alt_name_free(alt_name name);
+
+typedef struct alt_name_node
+{
+	alt_name name;
+	struct alt_name_node* rest;
+} alt_name_list_t, *alt_name_list;
+
+alt_name_list alt_name_list_cons(alt_name name, alt_name_list rest);
+alt_name alt_name_list_first(alt_name_list list);
+alt_name_list alt_name_list_rest(alt_name_list list);
+void alt_name_list_free(alt_name_list list);
+void alt_name_list_deepfree(alt_name_list list);
+
+#define DO_ALT_NAME_LIST(alt_name, current, list)                                      \
+	for ((current = list, alt_name = alt_name_list_first(current)); (current != NULL); \
+	     (current = alt_name_list_rest(current), alt_name = alt_name_list_first(current)))
+
+alt_name_list certificate_extract_subject_alt_names(buffer certificate_data);
+
+#endif
diff -urN libfreerdp/utils/msusb.c ../../informatimago/FreeRDP/libfreerdp/utils/msusb.c
--- libfreerdp/utils/msusb.c	2019-07-25 19:51:05.309919477 +0300
+++ ../../informatimago/FreeRDP/libfreerdp/utils/msusb.c	2019-07-25 20:11:29.355989564 +0300
@@ -43,7 +43,7 @@
 
 static void msusb_mspipes_free(MSUSB_PIPE_DESCRIPTOR** MsPipes, UINT32 NumberOfPipes)
 {
-	UINT32 pnum = 0;
+	int pnum = 0;
 
 	if (MsPipes)
 	{
@@ -69,7 +69,7 @@
 static MSUSB_PIPE_DESCRIPTOR** msusb_mspipes_read(BYTE* data, UINT32 data_size,
                                                   UINT32 NumberOfPipes, int* offset)
 {
-	UINT32 pnum, move = 0;
+	int pnum, move = 0;
 	MSUSB_PIPE_DESCRIPTOR** MsPipes;
 	MsPipes = (MSUSB_PIPE_DESCRIPTOR**)calloc(NumberOfPipes, sizeof(MSUSB_PIPE_DESCRIPTOR*));
 
@@ -128,7 +128,7 @@
 static void msusb_msinterface_free_list(MSUSB_INTERFACE_DESCRIPTOR** MsInterfaces,
                                         UINT32 NumInterfaces)
 {
-	UINT32 inum = 0;
+	int inum = 0;
 
 	if (MsInterfaces)
 	{
@@ -188,7 +188,7 @@
 {
 	MSUSB_PIPE_DESCRIPTOR** MsPipes;
 	MSUSB_PIPE_DESCRIPTOR* MsPipe;
-	UINT32 pnum = 0, move = 0;
+	int pnum = 0, move = 0;
 	/* Length */
 	data_write_UINT16(data, MsInterface->Length);
 	/* InterfaceNumber */
@@ -238,8 +238,7 @@
 static MSUSB_INTERFACE_DESCRIPTOR** msusb_msinterface_read_list(BYTE* data, UINT32 data_size,
                                                                 UINT32 NumInterfaces)
 {
-	UINT32 inum;
-	int offset = 0;
+	int inum, offset = 0;
 	MSUSB_INTERFACE_DESCRIPTOR** MsInterfaces;
 	MsInterfaces =
 	    (MSUSB_INTERFACE_DESCRIPTOR**)calloc(NumInterfaces, sizeof(MSUSB_INTERFACE_DESCRIPTOR*));
@@ -257,7 +256,7 @@
 
 int msusb_msconfig_write(MSUSB_CONFIG_DESCRIPTOR* MsConfg, BYTE* data, int* offset)
 {
-	UINT32 inum = 0;
+	int inum = 0;
 	MSUSB_INTERFACE_DESCRIPTOR** MsInterfaces;
 	MSUSB_INTERFACE_DESCRIPTOR* MsInterface;
 	/* ConfigurationHandle*/
@@ -294,7 +293,7 @@
 
 MSUSB_CONFIG_DESCRIPTOR* msusb_msconfig_read(BYTE* data, UINT32 data_size, UINT32 NumInterfaces)
 {
-	UINT32 i, offset = 0;
+	int i, offset = 0;
 	UINT16 lenInterface;
 	MSUSB_CONFIG_DESCRIPTOR* MsConfig;
 	BYTE lenConfiguration, typeConfiguration;
@@ -339,7 +338,7 @@
 	MSUSB_INTERFACE_DESCRIPTOR* MsInterface;
 	MSUSB_PIPE_DESCRIPTOR** MsPipes;
 	MSUSB_PIPE_DESCRIPTOR* MsPipe;
-	UINT32 inum = 0, pnum = 0;
+	int inum = 0, pnum = 0;
 	WLog_INFO(TAG, "=================MsConfig:========================");
 	WLog_INFO(TAG, "wTotalLength:%" PRIu16 "", MsConfig->wTotalLength);
 	WLog_INFO(TAG, "bConfigurationValue:%" PRIu8 "", MsConfig->bConfigurationValue);
diff -urN libfreerdp/utils/test/TestFreeRDPUtils.c ../../informatimago/FreeRDP/libfreerdp/utils/test/TestFreeRDPUtils.c
--- libfreerdp/utils/test/TestFreeRDPUtils.c	2019-07-25 20:17:16.433710711 +0300
+++ ../../informatimago/FreeRDP/libfreerdp/utils/test/TestFreeRDPUtils.c	2019-07-25 20:11:29.379989683 +0300
@@ -4,139 +4,147 @@
 #include <string.h> /* NOLINT */
 
 #if defined(_MSC_VER)
-#pragma warning(disable : 4996) /* deprecation */
+#	pragma warning(disable : 4996) /* deprecation */
 #endif
 
-
-
 /* Forward declare test functions. */
 int TestRingBuffer(int, char*[]);
 
-
 #ifdef __cplusplus
-#define CM_CAST(TYPE, EXPR) static_cast<TYPE>(EXPR)
+#	define CM_CAST(TYPE, EXPR) static_cast<TYPE>(EXPR)
 #else
-#define CM_CAST(TYPE, EXPR) (TYPE)(EXPR)
+#	define CM_CAST(TYPE, EXPR) (TYPE)(EXPR)
 #endif
 
 /* Create map.  */
 
-typedef int (*MainFuncPointer)(int, char* []); /* NOLINT */
-typedef struct /* NOLINT */
+typedef int (*MainFuncPointer)(int, char*[]); /* NOLINT */
+typedef struct                                /* NOLINT */
 {
-  const char* name;
-  MainFuncPointer func;
+	const char* name;
+	MainFuncPointer func;
 } functionMapEntry;
 
 static functionMapEntry cmakeGeneratedFunctionMapEntries[] = {
-    {
-    "TestRingBuffer",
-    TestRingBuffer
-  },
+	{ "TestRingBuffer", TestRingBuffer },
 
-  { NULL, NULL } /* NOLINT */
+	{ NULL, NULL } /* NOLINT */
 };
 
-static const int NumTests = CM_CAST(int,
-  sizeof(cmakeGeneratedFunctionMapEntries) / sizeof(functionMapEntry)) - 1;
+static const int NumTests =
+    CM_CAST(int, sizeof(cmakeGeneratedFunctionMapEntries) / sizeof(functionMapEntry)) - 1;
 
 /* Allocate and create a lowercased copy of string
    (note that it has to be free'd manually) */
 static char* lowercase(const char* string)
 {
-  char *new_string, *p;
-  size_t stringSize;
+	char *new_string, *p;
+	size_t stringSize;
 
-  stringSize = CM_CAST(size_t, strlen(string) + 1);
-  new_string = CM_CAST(char*, malloc(sizeof(char) * stringSize));
+	stringSize = CM_CAST(size_t, strlen(string) + 1);
+	new_string = CM_CAST(char*, malloc(sizeof(char) * stringSize));
 
-  if (new_string == NULL) { /* NOLINT */
-    return NULL;            /* NOLINT */
-  }
-  strcpy(new_string, string);
-  for (p = new_string; *p != 0; ++p) {
-    *p = CM_CAST(char, tolower(*p));
-  }
-  return new_string;
+	if (new_string == NULL)
+	{                /* NOLINT */
+		return NULL; /* NOLINT */
+	}
+	strcpy(new_string, string);
+	for (p = new_string; *p != 0; ++p)
+	{
+		*p = CM_CAST(char, tolower(*p));
+	}
+	return new_string;
 }
 
 int main(int ac, char* av[])
 {
-  int i, testNum = 0, partial_match;
-  char *arg;
-  int testToRun = -1;
-
-  
-
-  /* If no test name was given */
-  /* process command line with user function.  */
-  if (ac < 2) {
-    /* Ask for a test.  */
-    printf("Available tests:\n");
-    for (i = 0; i < NumTests; ++i) {
-      printf("%3d. %s\n", i, cmakeGeneratedFunctionMapEntries[i].name);
-    }
-    printf("To run a test, enter the test number: ");
-    fflush(stdout);
-    if (scanf("%d", &testNum) != 1) {
-      printf("Couldn't parse that input as a number\n");
-      return -1;
-    }
-    if (testNum >= NumTests) {
-      printf("%3d is an invalid test number.\n", testNum);
-      return -1;
-    }
-    testToRun = testNum;
-    ac--;
-    av++;
-  }
-  partial_match = 0;
-  arg = NULL; /* NOLINT */
-  /* If partial match is requested.  */
-  if (testToRun == -1 && ac > 1) {
-    partial_match = (strcmp(av[1], "-R") == 0) ? 1 : 0;
-  }
-  if (partial_match != 0 && ac < 3) {
-    printf("-R needs an additional parameter.\n");
-    return -1;
-  }
-  if (testToRun == -1) {
-    arg = lowercase(av[1 + partial_match]);
-  }
-  for (i = 0; i < NumTests && testToRun == -1; ++i) {
-    char *test_name = lowercase(cmakeGeneratedFunctionMapEntries[i].name);
-    if (partial_match != 0 && strstr(test_name, arg) != NULL) { /* NOLINT */
-      testToRun = i;
-      ac -= 2;
-      av += 2;
-    } else if (partial_match == 0 && strcmp(test_name, arg) == 0) {
-      testToRun = i;
-      ac--;
-      av++;
-    }
-    free(test_name);
-  }
-  free(arg);
-  if (testToRun != -1) {
-    int result;
-
-    if (testToRun < 0 || testToRun >= NumTests) {
-      printf("testToRun was modified by TestDriver code to an invalid value: "
-             "%3d.\n",
-             testNum);
-      return -1;
-    }
-    result = (*cmakeGeneratedFunctionMapEntries[testToRun].func)(ac, av);
-
-    return result;
-  }
-
-  /* Nothing was run, display the test names.  */
-  printf("Available tests:\n");
-  for (i = 0; i < NumTests; ++i) {
-    printf("%3d. %s\n", i, cmakeGeneratedFunctionMapEntries[i].name);
-  }
-  printf("Failed: %s is an invalid test name.\n", av[1]);
+	int i, testNum = 0, partial_match;
+	char* arg;
+	int testToRun = -1;
+
+	/* If no test name was given */
+	/* process command line with user function.  */
+	if (ac < 2)
+	{
+		/* Ask for a test.  */
+		printf("Available tests:\n");
+		for (i = 0; i < NumTests; ++i)
+		{
+			printf("%3d. %s\n", i, cmakeGeneratedFunctionMapEntries[i].name);
+		}
+		printf("To run a test, enter the test number: ");
+		fflush(stdout);
+		if (scanf("%d", &testNum) != 1)
+		{
+			printf("Couldn't parse that input as a number\n");
+			return -1;
+		}
+		if (testNum >= NumTests)
+		{
+			printf("%3d is an invalid test number.\n", testNum);
+			return -1;
+		}
+		testToRun = testNum;
+		ac--;
+		av++;
+	}
+	partial_match = 0;
+	arg = NULL; /* NOLINT */
+	/* If partial match is requested.  */
+	if (testToRun == -1 && ac > 1)
+	{
+		partial_match = (strcmp(av[1], "-R") == 0) ? 1 : 0;
+	}
+	if (partial_match != 0 && ac < 3)
+	{
+		printf("-R needs an additional parameter.\n");
+		return -1;
+	}
+	if (testToRun == -1)
+	{
+		arg = lowercase(av[1 + partial_match]);
+	}
+	for (i = 0; i < NumTests && testToRun == -1; ++i)
+	{
+		char* test_name = lowercase(cmakeGeneratedFunctionMapEntries[i].name);
+		if (partial_match != 0 && strstr(test_name, arg) != NULL)
+		{ /* NOLINT */
+			testToRun = i;
+			ac -= 2;
+			av += 2;
+		}
+		else if (partial_match == 0 && strcmp(test_name, arg) == 0)
+		{
+			testToRun = i;
+			ac--;
+			av++;
+		}
+		free(test_name);
+	}
+	free(arg);
+	if (testToRun != -1)
+	{
+		int result;
+
+		if (testToRun < 0 || testToRun >= NumTests)
+		{
+			printf("testToRun was modified by TestDriver code to an invalid value: "
+			       "%3d.\n",
+			       testNum);
+			return -1;
+		}
+		result = (*cmakeGeneratedFunctionMapEntries[testToRun].func)(ac, av);
+
+		return result;
+	}
+
+	/* Nothing was run, display the test names.  */
+	printf("Available tests:\n");
+	for (i = 0; i < NumTests; ++i)
+	{
+		printf("%3d. %s\n", i, cmakeGeneratedFunctionMapEntries[i].name);
+	}
+	printf("Failed: %s is an invalid test name.\n", av[1]);
 
-  return -1;
+	return -1;
 }
diff -urN libfreerdp/utils/test/TestRingBuffer.c ../../informatimago/FreeRDP/libfreerdp/utils/test/TestRingBuffer.c
--- libfreerdp/utils/test/TestRingBuffer.c	2019-07-25 19:51:05.337919615 +0300
+++ ../../informatimago/FreeRDP/libfreerdp/utils/test/TestRingBuffer.c	2019-07-25 20:11:29.383989703 +0300
@@ -27,10 +27,7 @@
 	RingBuffer rb;
 	DataChunk chunks[2];
 	BYTE bytes[200];
-	size_t i;
-	size_t k;
-	int x;
-	int nchunks, j, counter = 0;
+	int nchunks, i, j, k, counter = 0;
 
 	for (i = 0; i < sizeof(bytes); i++)
 		bytes[i] = (BYTE)i;
@@ -52,11 +49,11 @@
 	if (nchunks != 2 || chunks[0].size != 3 || chunks[1].size != 1)
 		goto error;
 
-	for (x = 0, j = 2; x < nchunks; x++)
+	for (i = 0, j = 2; i < nchunks; i++)
 	{
-		for (k = 0; k < chunks[x].size; k++, j++)
+		for (k = 0; k < (int)chunks[i].size; k++, j++)
 		{
-			if (chunks[x].data[k] != (BYTE)j)
+			if (chunks[i].data[k] != (BYTE)j)
 				goto error;
 		}
 	}

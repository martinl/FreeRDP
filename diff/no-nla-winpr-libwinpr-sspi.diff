diff --git a/winpr/libwinpr/sspi/CredSSP/credssp.c b/winpr/libwinpr/sspi/CredSSP/credssp.c
index e98f4942d..a2fb23413 100644
--- a/winpr/libwinpr/sspi/CredSSP/credssp.c
+++ b/winpr/libwinpr/sspi/CredSSP/credssp.c
@@ -97,7 +97,7 @@ static SECURITY_STATUS SEC_ENTRY credssp_QueryContextAttributes(PCtxtHandle phCo
 	return SEC_E_UNSUPPORTED_FUNCTION;
 }
 
-static SECURITY_STATUS SEC_ENTRY credssp_AcquireCredentialsHandleW(
+SECURITY_STATUS SEC_ENTRY credssp_AcquireCredentialsHandleW(
     SEC_WCHAR* pszPrincipal, SEC_WCHAR* pszPackage, ULONG fCredentialUse, void* pvLogonID,
     void* pAuthData, SEC_GET_KEY_FN pGetKeyFn, void* pvGetKeyArgument, PCredHandle phCredential,
     PTimeStamp ptsExpiry)
diff --git a/winpr/libwinpr/sspi/NTLM/ntlm.c b/winpr/libwinpr/sspi/NTLM/ntlm.c
index 66f571758..65a5f692f 100644
--- a/winpr/libwinpr/sspi/NTLM/ntlm.c
+++ b/winpr/libwinpr/sspi/NTLM/ntlm.c
@@ -109,6 +109,20 @@ static int ntlm_SetContextServicePrincipalNameW(NTLM_CONTEXT* context, LPWSTR Se
 	return 1;
 }
 
+static int ntlm_SetContextServicePrincipalNameA(NTLM_CONTEXT* context, char* ServicePrincipalName)
+{
+	int status;
+	context->ServicePrincipalName.Buffer = NULL;
+	status = ConvertToUnicode(CP_UTF8, 0, ServicePrincipalName, -1,
+	                          &context->ServicePrincipalName.Buffer, 0);
+
+	if (status <= 0)
+		return -1;
+
+	context->ServicePrincipalName.Length = (USHORT)((status - 1) * 2);
+	return 1;
+}
+
 static int ntlm_SetContextTargetName(NTLM_CONTEXT* context, char* TargetName)
 {
 	int status;
@@ -961,7 +975,7 @@ static SECURITY_STATUS SEC_ENTRY ntlm_RevertSecurityContext(PCtxtHandle phContex
 static SECURITY_STATUS SEC_ENTRY ntlm_EncryptMessage(PCtxtHandle phContext, ULONG fQOP,
                                                      PSecBufferDesc pMessage, ULONG MessageSeqNo)
 {
-	ULONG index;
+	int index;
 	int length;
 	void* data;
 	UINT32 SeqNo;
@@ -977,14 +991,12 @@ static SECURITY_STATUS SEC_ENTRY ntlm_EncryptMessage(PCtxtHandle phContext, ULON
 	SeqNo = MessageSeqNo;
 	context = (NTLM_CONTEXT*)sspi_SecureHandleGetLowerPointer(phContext);
 
-	for (index = 0; index < pMessage->cBuffers; index++)
+	for (index = 0; index < (int)pMessage->cBuffers; index++)
 	{
-		SecBuffer* cur = &pMessage->pBuffers[index];
-
-		if (cur->BufferType & SECBUFFER_DATA)
-			data_buffer = cur;
-		else if (cur->BufferType & SECBUFFER_TOKEN)
-			signature_buffer = cur;
+		if (pMessage->pBuffers[index].BufferType == SECBUFFER_DATA)
+			data_buffer = &pMessage->pBuffers[index];
+		else if (pMessage->pBuffers[index].BufferType == SECBUFFER_TOKEN)
+			signature_buffer = &pMessage->pBuffers[index];
 	}
 
 	if (!data_buffer)
@@ -1021,14 +1033,11 @@ static SECURITY_STATUS SEC_ENTRY ntlm_EncryptMessage(PCtxtHandle phContext, ULON
 	}
 
 	/* Encrypt message using with RC4, result overwrites original buffer */
-	if ((data_buffer->BufferType & SECBUFFER_READONLY) == 0)
-	{
-		if (context->confidentiality)
-			winpr_RC4_Update(context->SendRc4Seal, length, (BYTE*)data,
-			                 (BYTE*)data_buffer->pvBuffer);
-		else
-			CopyMemory(data_buffer->pvBuffer, data, length);
-	}
+
+	if (context->confidentiality)
+		winpr_RC4_Update(context->SendRc4Seal, length, (BYTE*)data, (BYTE*)data_buffer->pvBuffer);
+	else
+		CopyMemory(data_buffer->pvBuffer, data, length);
 
 #ifdef WITH_DEBUG_NTLM
 	WLog_DBG(TAG, "Data Buffer (length = %d)", length);
@@ -1039,14 +1048,11 @@ static SECURITY_STATUS SEC_ENTRY ntlm_EncryptMessage(PCtxtHandle phContext, ULON
 	free(data);
 	/* RC4-encrypt first 8 bytes of digest */
 	winpr_RC4_Update(context->SendRc4Seal, 8, digest, checksum);
-	if ((signature_buffer->BufferType & SECBUFFER_READONLY) == 0)
-	{
-		signature = (BYTE*)signature_buffer->pvBuffer;
-		/* Concatenate version, ciphertext and sequence number to build signature */
-		Data_Write_UINT32(signature, version);
-		CopyMemory(&signature[4], (void*)checksum, 8);
-		Data_Write_UINT32(&signature[12], SeqNo);
-	}
+	signature = (BYTE*)signature_buffer->pvBuffer;
+	/* Concatenate version, ciphertext and sequence number to build signature */
+	Data_Write_UINT32(signature, version);
+	CopyMemory(&signature[4], (void*)checksum, 8);
+	Data_Write_UINT32(&signature[12], SeqNo);
 	context->SendSeqNum++;
 #ifdef WITH_DEBUG_NTLM
 	WLog_DBG(TAG, "Signature (length = %" PRIu32 ")", signature_buffer->cbBuffer);
diff --git a/winpr/libwinpr/sspi/NTLM/ntlm.h b/winpr/libwinpr/sspi/NTLM/ntlm.h
index c6216ea41..48bd33cc9 100644
--- a/winpr/libwinpr/sspi/NTLM/ntlm.h
+++ b/winpr/libwinpr/sspi/NTLM/ntlm.h
@@ -261,7 +261,6 @@ struct _NTLM_CONTEXT
 	SecBuffer NtChallengeResponse;
 	SecBuffer LmChallengeResponse;
 	NTLMv2_RESPONSE NTLMv2Response;
-	BYTE NtProofString[16];
 	BYTE Timestamp[8];
 	BYTE ChallengeTimestamp[8];
 	BYTE ServerChallenge[8];
diff --git a/winpr/libwinpr/sspi/NTLM/ntlm_av_pairs.c b/winpr/libwinpr/sspi/NTLM/ntlm_av_pairs.c
index 47669bb2e..56a19cbbb 100644
--- a/winpr/libwinpr/sspi/NTLM/ntlm_av_pairs.c
+++ b/winpr/libwinpr/sspi/NTLM/ntlm_av_pairs.c
@@ -39,50 +39,13 @@
 #include "../../log.h"
 #define TAG WINPR_TAG("sspi.NTLM")
 
-static BOOL ntlm_av_pair_get_next_offset(const NTLM_AV_PAIR* pAvPair, size_t size, size_t* pOffset);
+static const char* const AV_PAIR_STRINGS[] = {
+	"MsvAvEOL",           "MsvAvNbComputerName", "MsvAvNbDomainName", "MsvAvDnsComputerName",
+	"MsvAvDnsDomainName", "MsvAvDnsTreeName",    "MsvAvFlags",        "MsvAvTimestamp",
+	"MsvAvRestrictions",  "MsvAvTargetName",     "MsvChannelBindings"
+};
 
-static BOOL ntlm_av_pair_check_data(const NTLM_AV_PAIR* pAvPair, size_t cbAvPair, size_t size)
-{
-	size_t offset;
-	if (!pAvPair || cbAvPair < sizeof(NTLM_AV_PAIR) + size)
-		return FALSE;
-	if (!ntlm_av_pair_get_next_offset(pAvPair, cbAvPair, &offset))
-		return FALSE;
-	return cbAvPair >= offset;
-}
-
-static const char* get_av_pair_string(UINT16 pair)
-{
-	switch (pair)
-	{
-		case MsvAvEOL:
-			return "MsvAvEOL";
-		case MsvAvNbComputerName:
-			return "MsvAvNbComputerName";
-		case MsvAvNbDomainName:
-			return "MsvAvNbDomainName";
-		case MsvAvDnsComputerName:
-			return "MsvAvDnsComputerName";
-		case MsvAvDnsDomainName:
-			return "MsvAvDnsDomainName";
-		case MsvAvDnsTreeName:
-			return "MsvAvDnsTreeName";
-		case MsvAvFlags:
-			return "MsvAvFlags";
-		case MsvAvTimestamp:
-			return "MsvAvTimestamp";
-		case MsvAvSingleHost:
-			return "MsvAvSingleHost";
-		case MsvAvTargetName:
-			return "MsvAvTargetName";
-		case MsvChannelBindings:
-			return "MsvChannelBindings";
-		default:
-			return "UNKNOWN";
-	}
-}
-
-static BOOL ntlm_av_pair_check(const NTLM_AV_PAIR* pAvPair, size_t cbAvPair);
+static BOOL ntlm_av_pair_check(NTLM_AV_PAIR* pAvPair, size_t cbAvPair);
 static NTLM_AV_PAIR* ntlm_av_pair_next(NTLM_AV_PAIR* pAvPairList, size_t* pcbAvPairList);
 
 static INLINE void ntlm_av_pair_set_id(NTLM_AV_PAIR* pAvPair, UINT16 id)
@@ -107,51 +70,34 @@ static BOOL ntlm_av_pair_list_init(NTLM_AV_PAIR* pAvPairList, size_t cbAvPairLis
 	return TRUE;
 }
 
-static INLINE BOOL ntlm_av_pair_get_id(const NTLM_AV_PAIR* pAvPair, size_t size, UINT16* pair)
+static INLINE UINT16 ntlm_av_pair_get_id(const NTLM_AV_PAIR* pAvPair)
 {
 	UINT16 AvId;
-	if (!pAvPair || !pair)
-		return FALSE;
-
-	if (size < sizeof(NTLM_AV_PAIR))
-		return FALSE;
-
 	Data_Read_UINT16(&pAvPair->AvId, AvId);
-
-	*pair = AvId;
-	return TRUE;
+	return AvId;
 }
 
 ULONG ntlm_av_pair_list_length(NTLM_AV_PAIR* pAvPairList, size_t cbAvPairList)
 {
 	size_t cbAvPair;
 	NTLM_AV_PAIR* pAvPair;
-
 	pAvPair = ntlm_av_pair_get(pAvPairList, cbAvPairList, MsvAvEOL, &cbAvPair);
+
 	if (!pAvPair)
 		return 0;
 
 	return ((PBYTE)pAvPair - (PBYTE)pAvPairList) + sizeof(NTLM_AV_PAIR);
 }
 
-static INLINE BOOL ntlm_av_pair_get_len(const NTLM_AV_PAIR* pAvPair, size_t size, size_t* pAvLen)
+static INLINE SIZE_T ntlm_av_pair_get_len(const NTLM_AV_PAIR* pAvPair)
 {
 	UINT16 AvLen;
-	if (!pAvPair)
-		return FALSE;
-
-	if (size < sizeof(NTLM_AV_PAIR))
-		return FALSE;
-
 	Data_Read_UINT16(&pAvPair->AvLen, AvLen);
-
-	*pAvLen = AvLen;
-	return TRUE;
+	return AvLen;
 }
 
 void ntlm_print_av_pair_list(NTLM_AV_PAIR* pAvPairList, size_t cbAvPairList)
 {
-	UINT16 pair;
 	size_t cbAvPair = cbAvPairList;
 	NTLM_AV_PAIR* pAvPair = pAvPairList;
 
@@ -160,14 +106,13 @@ void ntlm_print_av_pair_list(NTLM_AV_PAIR* pAvPairList, size_t cbAvPairList)
 
 	WLog_INFO(TAG, "AV_PAIRs =");
 
-	while (pAvPair && ntlm_av_pair_get_id(pAvPair, cbAvPair, &pair) && (pair != MsvAvEOL))
+	while (pAvPair && ntlm_av_pair_get_id(pAvPair) != MsvAvEOL)
 	{
-		size_t cbLen = 0;
-		ntlm_av_pair_get_len(pAvPair, cbAvPair, &cbLen);
-
-		WLog_INFO(TAG, "\t%s AvId: %" PRIu16 " AvLen: %" PRIu16 "", get_av_pair_string(pair), pair);
-		winpr_HexDump(TAG, WLOG_INFO, ntlm_av_pair_get_value_pointer(pAvPair), cbLen);
-
+		WLog_INFO(TAG, "\t%s AvId: %" PRIu16 " AvLen: %" PRIu16 "",
+		          AV_PAIR_STRINGS[ntlm_av_pair_get_id(pAvPair)], ntlm_av_pair_get_id(pAvPair),
+		          ntlm_av_pair_get_len(pAvPair));
+		winpr_HexDump(TAG, WLOG_INFO, ntlm_av_pair_get_value_pointer(pAvPair),
+		              ntlm_av_pair_get_len(pAvPair));
 		pAvPair = ntlm_av_pair_next(pAvPair, &cbAvPair);
 	}
 }
@@ -183,21 +128,17 @@ PBYTE ntlm_av_pair_get_value_pointer(NTLM_AV_PAIR* pAvPair)
 	return (PBYTE)pAvPair + sizeof(NTLM_AV_PAIR);
 }
 
-static BOOL ntlm_av_pair_get_next_offset(const NTLM_AV_PAIR* pAvPair, size_t size, size_t* pOffset)
+static size_t ntlm_av_pair_get_next_offset(NTLM_AV_PAIR* pAvPair)
 {
-	size_t avLen;
-	if (!pOffset)
-		return FALSE;
-
-	if (!ntlm_av_pair_get_len(pAvPair, size, &avLen))
-		return FALSE;
-	*pOffset = avLen + sizeof(NTLM_AV_PAIR);
-	return TRUE;
+	return ntlm_av_pair_get_len(pAvPair) + sizeof(NTLM_AV_PAIR);
 }
 
-static BOOL ntlm_av_pair_check(const NTLM_AV_PAIR* pAvPair, size_t cbAvPair)
+static BOOL ntlm_av_pair_check(NTLM_AV_PAIR* pAvPair, size_t cbAvPair)
 {
-	return ntlm_av_pair_check_data(pAvPair, cbAvPair, 0);
+	if (!pAvPair || cbAvPair < sizeof(NTLM_AV_PAIR))
+		return FALSE;
+
+	return cbAvPair >= ntlm_av_pair_get_next_offset(pAvPair);
 }
 
 static NTLM_AV_PAIR* ntlm_av_pair_next(NTLM_AV_PAIR* pAvPair, size_t* pcbAvPair)
@@ -206,12 +147,11 @@ static NTLM_AV_PAIR* ntlm_av_pair_next(NTLM_AV_PAIR* pAvPair, size_t* pcbAvPair)
 
 	if (!pcbAvPair)
 		return NULL;
-	if (!ntlm_av_pair_check(pAvPair, *pcbAvPair))
-		return NULL;
 
-	if (!ntlm_av_pair_get_next_offset(pAvPair, *pcbAvPair, &offset))
+	if (!ntlm_av_pair_check(pAvPair, *pcbAvPair))
 		return NULL;
 
+	offset = ntlm_av_pair_get_next_offset(pAvPair);
 	*pcbAvPair -= offset;
 	return (NTLM_AV_PAIR*)((PBYTE)pAvPair + offset);
 }
@@ -219,17 +159,19 @@ static NTLM_AV_PAIR* ntlm_av_pair_next(NTLM_AV_PAIR* pAvPair, size_t* pcbAvPair)
 NTLM_AV_PAIR* ntlm_av_pair_get(NTLM_AV_PAIR* pAvPairList, size_t cbAvPairList, NTLM_AV_ID AvId,
                                size_t* pcbAvPairListRemaining)
 {
-	UINT16 id;
 	size_t cbAvPair = cbAvPairList;
 	NTLM_AV_PAIR* pAvPair = pAvPairList;
 
 	if (!ntlm_av_pair_check(pAvPair, cbAvPair))
 		pAvPair = NULL;
 
-	while (pAvPair && ntlm_av_pair_get_id(pAvPair, cbAvPair, &id))
+	while (pAvPair)
 	{
+		UINT16 id = ntlm_av_pair_get_id(pAvPair);
+
 		if (id == AvId)
 			break;
+
 		if (id == MsvAvEOL)
 		{
 			pAvPair = NULL;
@@ -241,6 +183,7 @@ NTLM_AV_PAIR* ntlm_av_pair_get(NTLM_AV_PAIR* pAvPairList, size_t cbAvPairList, N
 
 	if (!pAvPair)
 		cbAvPair = 0;
+
 	if (pcbAvPairListRemaining)
 		*pcbAvPairListRemaining = cbAvPair;
 
@@ -252,7 +195,6 @@ static BOOL ntlm_av_pair_add(NTLM_AV_PAIR* pAvPairList, size_t cbAvPairList, NTL
 {
 	size_t cbAvPair;
 	NTLM_AV_PAIR* pAvPair;
-
 	pAvPair = ntlm_av_pair_get(pAvPairList, cbAvPairList, MsvAvEOL, &cbAvPair);
 
 	/* size of header + value length + terminating MsvAvEOL AV_PAIR */
@@ -261,6 +203,7 @@ static BOOL ntlm_av_pair_add(NTLM_AV_PAIR* pAvPairList, size_t cbAvPairList, NTL
 
 	ntlm_av_pair_set_id(pAvPair, AvId);
 	ntlm_av_pair_set_len(pAvPair, AvLen);
+
 	if (AvLen)
 	{
 		assert(Value != NULL);
@@ -274,20 +217,11 @@ static BOOL ntlm_av_pair_add(NTLM_AV_PAIR* pAvPairList, size_t cbAvPairList, NTL
 static BOOL ntlm_av_pair_add_copy(NTLM_AV_PAIR* pAvPairList, size_t cbAvPairList,
                                   NTLM_AV_PAIR* pAvPair, size_t cbAvPair)
 {
-	UINT16 pair;
-	size_t avLen;
-
 	if (!ntlm_av_pair_check(pAvPair, cbAvPair))
 		return FALSE;
 
-	if (!ntlm_av_pair_get_id(pAvPair, cbAvPair, &pair))
-		return FALSE;
-
-	if (!ntlm_av_pair_get_len(pAvPair, cbAvPair, &avLen))
-		return FALSE;
-
-	return ntlm_av_pair_add(pAvPairList, cbAvPairList, pair,
-	                        ntlm_av_pair_get_value_pointer(pAvPair), avLen);
+	return ntlm_av_pair_add(pAvPairList, cbAvPairList, ntlm_av_pair_get_id(pAvPair),
+	                        ntlm_av_pair_get_value_pointer(pAvPair), ntlm_av_pair_get_len(pAvPair));
 }
 
 static int ntlm_get_target_computer_name(PUNICODE_STRING pName, COMPUTER_NAME_FORMAT type)
@@ -565,47 +499,32 @@ int ntlm_construct_authenticate_target_info(NTLM_CONTEXT* context)
 
 	if (AvNbDomainName)
 	{
-		size_t avLen;
-		if (!ntlm_av_pair_get_len(AvNbDomainName, cbAvNbDomainName, &avLen))
-			goto fail;
 		AvPairsCount++; /* MsvAvNbDomainName */
-		AvPairsValueLength += avLen;
+		AvPairsValueLength += ntlm_av_pair_get_len(AvNbDomainName);
 	}
 
 	if (AvNbComputerName)
 	{
-		size_t avLen;
-		if (!ntlm_av_pair_get_len(AvNbComputerName, cbAvNbComputerName, &avLen))
-			goto fail;
 		AvPairsCount++; /* MsvAvNbComputerName */
-		AvPairsValueLength += avLen;
+		AvPairsValueLength += ntlm_av_pair_get_len(AvNbComputerName);
 	}
 
 	if (AvDnsDomainName)
 	{
-		size_t avLen;
-		if (!ntlm_av_pair_get_len(AvDnsDomainName, cbAvDnsDomainName, &avLen))
-			goto fail;
 		AvPairsCount++; /* MsvAvDnsDomainName */
-		AvPairsValueLength += avLen;
+		AvPairsValueLength += ntlm_av_pair_get_len(AvDnsDomainName);
 	}
 
 	if (AvDnsComputerName)
 	{
-		size_t avLen;
-		if (!ntlm_av_pair_get_len(AvDnsComputerName, cbAvDnsComputerName, &avLen))
-			goto fail;
 		AvPairsCount++; /* MsvAvDnsComputerName */
-		AvPairsValueLength += avLen;
+		AvPairsValueLength += ntlm_av_pair_get_len(AvDnsComputerName);
 	}
 
 	if (AvDnsTreeName)
 	{
-		size_t avLen;
-		if (!ntlm_av_pair_get_len(AvDnsTreeName, cbAvDnsTreeName, &avLen))
-			goto fail;
 		AvPairsCount++; /* MsvAvDnsTreeName */
-		AvPairsValueLength += avLen;
+		AvPairsValueLength += ntlm_av_pair_get_len(AvDnsTreeName);
 	}
 
 	AvPairsCount++; /* MsvAvTimestamp */
@@ -652,54 +571,54 @@ int ntlm_construct_authenticate_target_info(NTLM_CONTEXT* context)
 		size += 8; /* unknown 8-byte padding */
 
 	if (!sspi_SecBufferAlloc(&context->AuthenticateTargetInfo, size))
-		goto fail;
+		return -1;
 
 	AuthenticateTargetInfo = (NTLM_AV_PAIR*)context->AuthenticateTargetInfo.pvBuffer;
 	cbAuthenticateTargetInfo = context->AuthenticateTargetInfo.cbBuffer;
 
 	if (!ntlm_av_pair_list_init(AuthenticateTargetInfo, cbAuthenticateTargetInfo))
-		goto fail;
+		return -1;
 
 	if (AvNbDomainName)
 	{
 		if (!ntlm_av_pair_add_copy(AuthenticateTargetInfo, cbAuthenticateTargetInfo, AvNbDomainName,
 		                           cbAvNbDomainName))
-			goto fail;
+			return -1;
 	}
 
 	if (AvNbComputerName)
 	{
 		if (!ntlm_av_pair_add_copy(AuthenticateTargetInfo, cbAuthenticateTargetInfo,
 		                           AvNbComputerName, cbAvNbComputerName))
-			goto fail;
+			return -1;
 	}
 
 	if (AvDnsDomainName)
 	{
 		if (!ntlm_av_pair_add_copy(AuthenticateTargetInfo, cbAuthenticateTargetInfo,
 		                           AvDnsDomainName, cbAvDnsDomainName))
-			goto fail;
+			return -1;
 	}
 
 	if (AvDnsComputerName)
 	{
 		if (!ntlm_av_pair_add_copy(AuthenticateTargetInfo, cbAuthenticateTargetInfo,
 		                           AvDnsComputerName, cbAvDnsComputerName))
-			goto fail;
+			return -1;
 	}
 
 	if (AvDnsTreeName)
 	{
 		if (!ntlm_av_pair_add_copy(AuthenticateTargetInfo, cbAuthenticateTargetInfo, AvDnsTreeName,
 		                           cbAvDnsTreeName))
-			goto fail;
+			return -1;
 	}
 
 	if (AvTimestamp)
 	{
 		if (!ntlm_av_pair_add_copy(AuthenticateTargetInfo, cbAuthenticateTargetInfo, AvTimestamp,
 		                           cbAvTimestamp))
-			goto fail;
+			return -1;
 	}
 
 	if (context->UseMIC)
@@ -709,28 +628,28 @@ int ntlm_construct_authenticate_target_info(NTLM_CONTEXT* context)
 
 		if (!ntlm_av_pair_add(AuthenticateTargetInfo, cbAuthenticateTargetInfo, MsvAvFlags,
 		                      (PBYTE)&flags, 4))
-			goto fail;
+			return -1;
 	}
 
 	if (context->SendSingleHostData)
 	{
 		if (!ntlm_av_pair_add(AuthenticateTargetInfo, cbAuthenticateTargetInfo, MsvAvSingleHost,
 		                      (PBYTE)&context->SingleHostData, context->SingleHostData.Size))
-			goto fail;
+			return -1;
 	}
 
 	if (!context->SuppressExtendedProtection)
 	{
 		if (!ntlm_av_pair_add(AuthenticateTargetInfo, cbAuthenticateTargetInfo, MsvChannelBindings,
 		                      context->ChannelBindingsHash, 16))
-			goto fail;
+			return -1;
 
 		if (context->ServicePrincipalName.Length > 0)
 		{
 			if (!ntlm_av_pair_add(AuthenticateTargetInfo, cbAuthenticateTargetInfo, MsvAvTargetName,
 			                      (PBYTE)context->ServicePrincipalName.Buffer,
 			                      context->ServicePrincipalName.Length))
-				goto fail;
+				return -1;
 		}
 	}
 
@@ -740,13 +659,10 @@ int ntlm_construct_authenticate_target_info(NTLM_CONTEXT* context)
 		AvEOL = ntlm_av_pair_get(ChallengeTargetInfo, cbChallengeTargetInfo, MsvAvEOL, NULL);
 
 		if (!AvEOL)
-			goto fail;
+			return -1;
 
 		ZeroMemory(AvEOL, sizeof(NTLM_AV_PAIR));
 	}
 
 	return 1;
-fail:
-	sspi_SecBufferFree(&context->AuthenticateTargetInfo);
-	return -1;
 }
diff --git a/winpr/libwinpr/sspi/NTLM/ntlm_compute.c b/winpr/libwinpr/sspi/NTLM/ntlm_compute.c
index dbd7f7fb0..60526467f 100644
--- a/winpr/libwinpr/sspi/NTLM/ntlm_compute.c
+++ b/winpr/libwinpr/sspi/NTLM/ntlm_compute.c
@@ -121,12 +121,9 @@ void ntlm_print_version_info(NTLM_VERSION_INFO* versionInfo)
 	WLog_INFO(TAG, "\tNTLMRevisionCurrent: 0x%02" PRIX8 "", versionInfo->NTLMRevisionCurrent);
 }
 
-static int ntlm_read_ntlm_v2_client_challenge(wStream* s, NTLMv2_CLIENT_CHALLENGE* challenge)
+int ntlm_read_ntlm_v2_client_challenge(wStream* s, NTLMv2_CLIENT_CHALLENGE* challenge)
 {
 	size_t size;
-	if (Stream_GetRemainingLength(s) < 28)
-		return -1;
-
 	Stream_Read_UINT8(s, challenge->RespType);
 	Stream_Read_UINT8(s, challenge->HiRespType);
 	Stream_Read_UINT16(s, challenge->Reserved1);
@@ -149,7 +146,7 @@ static int ntlm_read_ntlm_v2_client_challenge(wStream* s, NTLMv2_CLIENT_CHALLENG
 	return 1;
 }
 
-static int ntlm_write_ntlm_v2_client_challenge(wStream* s, NTLMv2_CLIENT_CHALLENGE* challenge)
+int ntlm_write_ntlm_v2_client_challenge(wStream* s, NTLMv2_CLIENT_CHALLENGE* challenge)
 {
 	ULONG length;
 	Stream_Write_UINT8(s, challenge->RespType);
@@ -166,8 +163,6 @@ static int ntlm_write_ntlm_v2_client_challenge(wStream* s, NTLMv2_CLIENT_CHALLEN
 
 int ntlm_read_ntlm_v2_response(wStream* s, NTLMv2_RESPONSE* response)
 {
-	if (Stream_GetRemainingLength(s) < 16)
-		return -1;
 	Stream_Read(s, response->Response, 16);
 	return ntlm_read_ntlm_v2_client_challenge(s, &(response->Challenge));
 }
@@ -188,8 +183,8 @@ void ntlm_current_time(BYTE* timestamp)
 	FILETIME filetime;
 	ULARGE_INTEGER time64;
 	GetSystemTimeAsFileTime(&filetime);
-	time64.u.LowPart = filetime.dwLowDateTime;
-	time64.u.HighPart = filetime.dwHighDateTime;
+	time64.LowPart = filetime.dwLowDateTime;
+	time64.HighPart = filetime.dwHighDateTime;
 	CopyMemory(timestamp, &(time64.QuadPart), 8);
 }
 
@@ -206,7 +201,7 @@ void ntlm_generate_timestamp(NTLM_CONTEXT* context)
 		ntlm_current_time(context->Timestamp);
 }
 
-static int ntlm_fetch_ntlm_v2_hash(NTLM_CONTEXT* context, BYTE* hash)
+int ntlm_fetch_ntlm_v2_hash(NTLM_CONTEXT* context, BYTE* hash)
 {
 	WINPR_SAM* sam;
 	WINPR_SAM_ENTRY* entry;
@@ -261,7 +256,7 @@ static int ntlm_fetch_ntlm_v2_hash(NTLM_CONTEXT* context, BYTE* hash)
 	return 1;
 }
 
-static int ntlm_convert_password_hash(NTLM_CONTEXT* context, BYTE* hash)
+int ntlm_convert_password_hash(NTLM_CONTEXT* context, BYTE* hash)
 {
 	int status;
 	int i, hn, ln;
@@ -319,9 +314,7 @@ static int ntlm_compute_ntlm_v2_hash(NTLM_CONTEXT* context, BYTE* hash)
 	if (memcmp(context->NtlmV2Hash, NTLM_NULL_BUFFER, 16) != 0)
 		return 1;
 
-	if (!credentials)
-		return -1;
-	else if (memcmp(context->NtlmHash, NTLM_NULL_BUFFER, 16) != 0)
+	if (memcmp(context->NtlmHash, NTLM_NULL_BUFFER, 16) != 0)
 	{
 		NTOWFv2FromHashW(context->NtlmHash, (LPWSTR)credentials->identity.User,
 		                 credentials->identity.UserLength * 2, (LPWSTR)credentials->identity.Domain,
@@ -420,20 +413,21 @@ int ntlm_compute_lm_v2_response(NTLM_CONTEXT* context)
 int ntlm_compute_ntlm_v2_response(NTLM_CONTEXT* context)
 {
 	BYTE* blob;
-	SecBuffer ntlm_v2_temp = { 0 };
-	SecBuffer ntlm_v2_temp_chal = { 0 };
-	PSecBuffer TargetInfo = &context->ChallengeTargetInfo;
-	int ret = -1;
+	BYTE nt_proof_str[WINPR_MD5_DIGEST_LENGTH];
+	SecBuffer ntlm_v2_temp;
+	SecBuffer ntlm_v2_temp_chal;
+	PSecBuffer TargetInfo;
+	TargetInfo = &context->ChallengeTargetInfo;
 
 	if (!sspi_SecBufferAlloc(&ntlm_v2_temp, TargetInfo->cbBuffer + 28))
-		goto exit;
+		return -1;
 
 	ZeroMemory(ntlm_v2_temp.pvBuffer, ntlm_v2_temp.cbBuffer);
 	blob = (BYTE*)ntlm_v2_temp.pvBuffer;
 
 	/* Compute the NTLMv2 hash */
 	if (ntlm_compute_ntlm_v2_hash(context, (BYTE*)context->NtlmV2Hash) < 0)
-		goto exit;
+		return -1;
 
 	/* Construct temp */
 	blob[0] = 1; /* RespType (1 byte) */
@@ -452,32 +446,30 @@ int ntlm_compute_ntlm_v2_response(NTLM_CONTEXT* context)
 	/* Concatenate server challenge with temp */
 
 	if (!sspi_SecBufferAlloc(&ntlm_v2_temp_chal, ntlm_v2_temp.cbBuffer + 8))
-		goto exit;
+		return -1;
 
 	blob = (BYTE*)ntlm_v2_temp_chal.pvBuffer;
 	CopyMemory(blob, context->ServerChallenge, 8);
 	CopyMemory(&blob[8], ntlm_v2_temp.pvBuffer, ntlm_v2_temp.cbBuffer);
 	winpr_HMAC(WINPR_MD_MD5, (BYTE*)context->NtlmV2Hash, WINPR_MD5_DIGEST_LENGTH,
-	           (BYTE*)ntlm_v2_temp_chal.pvBuffer, ntlm_v2_temp_chal.cbBuffer,
-	           context->NtProofString, WINPR_MD5_DIGEST_LENGTH);
+	           (BYTE*)ntlm_v2_temp_chal.pvBuffer, ntlm_v2_temp_chal.cbBuffer, (BYTE*)nt_proof_str,
+	           WINPR_MD5_DIGEST_LENGTH);
 
 	/* NtChallengeResponse, Concatenate NTProofStr with temp */
 
 	if (!sspi_SecBufferAlloc(&context->NtChallengeResponse, ntlm_v2_temp.cbBuffer + 16))
-		goto exit;
+		return -1;
 
 	blob = (BYTE*)context->NtChallengeResponse.pvBuffer;
-	CopyMemory(blob, context->NtProofString, WINPR_MD5_DIGEST_LENGTH);
+	CopyMemory(blob, nt_proof_str, 16);
 	CopyMemory(&blob[16], ntlm_v2_temp.pvBuffer, ntlm_v2_temp.cbBuffer);
 	/* Compute SessionBaseKey, the HMAC-MD5 hash of NTProofStr using the NTLMv2 hash as the key */
 	winpr_HMAC(WINPR_MD_MD5, (BYTE*)context->NtlmV2Hash, WINPR_MD5_DIGEST_LENGTH,
-	           context->NtProofString, WINPR_MD5_DIGEST_LENGTH, context->SessionBaseKey,
+	           (BYTE*)nt_proof_str, WINPR_MD5_DIGEST_LENGTH, (BYTE*)context->SessionBaseKey,
 	           WINPR_MD5_DIGEST_LENGTH);
-	ret = 1;
-exit:
 	sspi_SecBufferFree(&ntlm_v2_temp);
 	sspi_SecBufferFree(&ntlm_v2_temp_chal);
-	return ret;
+	return 1;
 }
 
 /**
@@ -597,8 +589,7 @@ void ntlm_decrypt_random_session_key(NTLM_CONTEXT* context)
  * @param signing_key Destination signing key
  */
 
-static int ntlm_generate_signing_key(BYTE* exported_session_key, PSecBuffer sign_magic,
-                                     BYTE* signing_key)
+int ntlm_generate_signing_key(BYTE* exported_session_key, PSecBuffer sign_magic, BYTE* signing_key)
 {
 	int length;
 	BYTE* value;
@@ -658,8 +649,7 @@ void ntlm_generate_server_signing_key(NTLM_CONTEXT* context)
  * @param sealing_key Destination sealing key
  */
 
-static int ntlm_generate_sealing_key(BYTE* exported_session_key, PSecBuffer seal_magic,
-                                     BYTE* sealing_key)
+int ntlm_generate_sealing_key(BYTE* exported_session_key, PSecBuffer seal_magic, BYTE* sealing_key)
 {
 	BYTE* p;
 	SecBuffer buffer;
diff --git a/winpr/libwinpr/sspi/NTLM/ntlm_message.c b/winpr/libwinpr/sspi/NTLM/ntlm_message.c
index 34813a414..4ed6f33e1 100644
--- a/winpr/libwinpr/sspi/NTLM/ntlm_message.c
+++ b/winpr/libwinpr/sspi/NTLM/ntlm_message.c
@@ -38,7 +38,6 @@
 
 static const char NTLM_SIGNATURE[8] = { 'N', 'T', 'L', 'M', 'S', 'S', 'P', '\0' };
 
-#ifdef WITH_DEBUG_NTLM
 static const char* const NTLM_NEGOTIATE_STRINGS[] = { "NTLMSSP_NEGOTIATE_56",
 	                                                  "NTLMSSP_NEGOTIATE_KEY_EXCH",
 	                                                  "NTLMSSP_NEGOTIATE_128",
@@ -87,7 +86,6 @@ static void ntlm_print_negotiate_flags(UINT32 flags)
 		}
 	}
 }
-#endif
 
 static int ntlm_read_message_header(wStream* s, NTLM_MESSAGE_HEADER* header)
 {
@@ -219,11 +217,6 @@ SECURITY_STATUS ntlm_read_NegotiateMessage(NTLM_CONTEXT* context, PSecBuffer buf
 		return SEC_E_INVALID_TOKEN;
 	}
 
-	if (Stream_GetRemainingLength(s) < 4)
-	{
-		Stream_Free(s, FALSE);
-		return SEC_E_INVALID_TOKEN;
-	}
 	Stream_Read_UINT32(s, message->NegotiateFlags); /* NegotiateFlags (4 bytes) */
 
 	if (!((message->NegotiateFlags & NTLMSSP_REQUEST_TARGET) &&
@@ -367,16 +360,12 @@ SECURITY_STATUS ntlm_write_NegotiateMessage(NTLM_CONTEXT* context, PSecBuffer bu
 
 SECURITY_STATUS ntlm_read_ChallengeMessage(NTLM_CONTEXT* context, PSecBuffer buffer)
 {
-	SECURITY_STATUS status = SEC_E_INVALID_TOKEN;
 	wStream* s;
-	size_t length;
-	size_t StartOffset;
-	size_t PayloadOffset;
+	int length;
+	PBYTE StartOffset;
+	PBYTE PayloadOffset;
 	NTLM_AV_PAIR* AvTimestamp;
 	NTLM_CHALLENGE_MESSAGE* message;
-	if (!context || !buffer)
-		return SEC_E_INTERNAL_ERROR;
-
 	ntlm_generate_client_challenge(context);
 	message = &context->CHALLENGE_MESSAGE;
 	ZeroMemory(message, sizeof(NTLM_CHALLENGE_MESSAGE));
@@ -385,51 +374,77 @@ SECURITY_STATUS ntlm_read_ChallengeMessage(NTLM_CONTEXT* context, PSecBuffer buf
 	if (!s)
 		return SEC_E_INTERNAL_ERROR;
 
-	StartOffset = Stream_GetPosition(s);
+	StartOffset = Stream_Pointer(s);
 
 	if (ntlm_read_message_header(s, (NTLM_MESSAGE_HEADER*)message) < 0)
-		goto fail;
+	{
+		Stream_Free(s, FALSE);
+		return SEC_E_INVALID_TOKEN;
+	}
 
 	if (message->MessageType != MESSAGE_TYPE_CHALLENGE)
-		goto fail;
+	{
+		Stream_Free(s, FALSE);
+		return SEC_E_INVALID_TOKEN;
+	}
 
 	if (ntlm_read_message_fields(s, &(message->TargetName)) < 0) /* TargetNameFields (8 bytes) */
-		goto fail;
+	{
+		Stream_Free(s, FALSE);
+		return SEC_E_INVALID_TOKEN;
+	}
 
 	if (Stream_GetRemainingLength(s) < 4)
-		goto fail;
+	{
+		Stream_Free(s, FALSE);
+		return SEC_E_INVALID_TOKEN;
+	}
 
 	Stream_Read_UINT32(s, message->NegotiateFlags); /* NegotiateFlags (4 bytes) */
 	context->NegotiateFlags = message->NegotiateFlags;
 
 	if (Stream_GetRemainingLength(s) < 8)
-		goto fail;
+	{
+		Stream_Free(s, FALSE);
+		return SEC_E_INVALID_TOKEN;
+	}
 
 	Stream_Read(s, message->ServerChallenge, 8); /* ServerChallenge (8 bytes) */
 	CopyMemory(context->ServerChallenge, message->ServerChallenge, 8);
 
 	if (Stream_GetRemainingLength(s) < 8)
-		goto fail;
+	{
+		Stream_Free(s, FALSE);
+		return SEC_E_INVALID_TOKEN;
+	}
 
 	Stream_Read(s, message->Reserved, 8); /* Reserved (8 bytes), should be ignored */
 
 	if (ntlm_read_message_fields(s, &(message->TargetInfo)) < 0) /* TargetInfoFields (8 bytes) */
-		goto fail;
+	{
+		Stream_Free(s, FALSE);
+		return SEC_E_INVALID_TOKEN;
+	}
 
 	if (context->NegotiateFlags & NTLMSSP_NEGOTIATE_VERSION)
 	{
 		if (ntlm_read_version_info(s, &(message->Version)) < 0) /* Version (8 bytes) */
-			goto fail;
+		{
+			Stream_Free(s, FALSE);
+			return SEC_E_INVALID_TOKEN;
+		}
 	}
 
 	/* Payload (variable) */
-	PayloadOffset = Stream_GetPosition(s);
+	PayloadOffset = Stream_Pointer(s);
 
-	status = SEC_E_INTERNAL_ERROR;
 	if (message->TargetName.Len > 0)
 	{
 		if (ntlm_read_message_fields_buffer(s, &(message->TargetName)) < 0)
-			goto fail;
+		{
+			Stream_Free(s, FALSE);
+			return SEC_E_INTERNAL_ERROR;
+		}
 	}
 
 	if (message->TargetInfo.Len > 0)
@@ -437,7 +452,10 @@ SECURITY_STATUS ntlm_read_ChallengeMessage(NTLM_CONTEXT* context, PSecBuffer buf
 		size_t cbAvTimestamp;
 
 		if (ntlm_read_message_fields_buffer(s, &(message->TargetInfo)) < 0)
-			goto fail;
+		{
+			Stream_Free(s, FALSE);
+			return SEC_E_INTERNAL_ERROR;
+		}
 
 		context->ChallengeTargetInfo.pvBuffer = message->TargetInfo.Buffer;
 		context->ChallengeTargetInfo.cbBuffer = message->TargetInfo.Len;
@@ -449,7 +467,7 @@ SECURITY_STATUS ntlm_read_ChallengeMessage(NTLM_CONTEXT* context, PSecBuffer buf
 			PBYTE ptr = ntlm_av_pair_get_value_pointer(AvTimestamp);
 
 			if (!ptr)
-				goto fail;
+				return SEC_E_INTERNAL_ERROR;
 
 			if (context->NTLMv2)
 				context->UseMIC = TRUE;
@@ -459,14 +477,14 @@ SECURITY_STATUS ntlm_read_ChallengeMessage(NTLM_CONTEXT* context, PSecBuffer buf
 	}
 
 	length = (PayloadOffset - StartOffset) + message->TargetName.Len + message->TargetInfo.Len;
-	if (length > buffer->cbBuffer)
-		goto fail;
 
 	if (!sspi_SecBufferAlloc(&context->ChallengeMessage, length))
-		goto fail;
+	{
+		Stream_Free(s, FALSE);
+		return SEC_E_INTERNAL_ERROR;
+	}
 
-	if (context->ChallengeMessage.pvBuffer)
-		CopyMemory(context->ChallengeMessage.pvBuffer, Stream_Buffer(s) + StartOffset, length);
+	CopyMemory(context->ChallengeMessage.pvBuffer, StartOffset, length);
 #ifdef WITH_DEBUG_NTLM
 	WLog_DBG(TAG, "CHALLENGE_MESSAGE (length = %d)", length);
 	winpr_HexDump(TAG, WLOG_DEBUG, context->ChallengeMessage.pvBuffer,
@@ -492,7 +510,10 @@ SECURITY_STATUS ntlm_read_ChallengeMessage(NTLM_CONTEXT* context, PSecBuffer buf
 	if (context->NTLMv2)
 	{
 		if (ntlm_construct_authenticate_target_info(context) < 0)
-			goto fail;
+		{
+			Stream_Free(s, FALSE);
+			return SEC_E_INTERNAL_ERROR;
+		}
 
 		sspi_SecBufferFree(&context->ChallengeTargetInfo);
 		context->ChallengeTargetInfo.pvBuffer = context->AuthenticateTargetInfo.pvBuffer;
@@ -502,10 +523,16 @@ SECURITY_STATUS ntlm_read_ChallengeMessage(NTLM_CONTEXT* context, PSecBuffer buf
 	ntlm_generate_timestamp(context); /* Timestamp */
 
 	if (ntlm_compute_lm_v2_response(context) < 0) /* LmChallengeResponse */
-		goto fail;
+	{
+		Stream_Free(s, FALSE);
+		return SEC_E_INTERNAL_ERROR;
+	}
 
 	if (ntlm_compute_ntlm_v2_response(context) < 0) /* NtChallengeResponse */
-		goto fail;
+	{
+		Stream_Free(s, FALSE);
+		return SEC_E_INTERNAL_ERROR;
+	}
 
 	ntlm_generate_key_exchange_key(context);     /* KeyExchangeKey */
 	ntlm_generate_random_session_key(context);   /* RandomSessionKey */
@@ -544,11 +571,9 @@ SECURITY_STATUS ntlm_read_ChallengeMessage(NTLM_CONTEXT* context, PSecBuffer buf
 	winpr_HexDump(TAG, WLOG_DEBUG, context->Timestamp, 8);
 #endif
 	context->state = NTLM_STATE_AUTHENTICATE;
-	status = SEC_I_CONTINUE_NEEDED;
-fail:
 	ntlm_free_message_fields_buffer(&(message->TargetName));
 	Stream_Free(s, FALSE);
-	return status;
+	return SEC_I_CONTINUE_NEEDED;
 }
 
 SECURITY_STATUS ntlm_write_ChallengeMessage(NTLM_CONTEXT* context, PSecBuffer buffer)
@@ -649,15 +674,15 @@ SECURITY_STATUS ntlm_write_ChallengeMessage(NTLM_CONTEXT* context, PSecBuffer bu
 
 SECURITY_STATUS ntlm_read_AuthenticateMessage(NTLM_CONTEXT* context, PSecBuffer buffer)
 {
-	SECURITY_STATUS status = SEC_E_INVALID_TOKEN;
 	wStream* s;
 	size_t length;
-	UINT32 flags = 0;
-	NTLM_AV_PAIR* AvFlags = NULL;
+	UINT32 flags;
+	NTLM_AV_PAIR* AvFlags;
 	UINT32 PayloadBufferOffset;
 	NTLM_AUTHENTICATE_MESSAGE* message;
 	SSPI_CREDENTIALS* credentials = context->credentials;
-
+	flags = 0;
+	AvFlags = NULL;
 	message = &context->AUTHENTICATE_MESSAGE;
 	ZeroMemory(message, sizeof(NTLM_AUTHENTICATE_MESSAGE));
 	s = Stream_New((BYTE*)buffer->pvBuffer, buffer->cbBuffer);
@@ -666,85 +691,130 @@ SECURITY_STATUS ntlm_read_AuthenticateMessage(NTLM_CONTEXT* context, PSecBuffer
 		return SEC_E_INTERNAL_ERROR;
 
 	if (ntlm_read_message_header(s, (NTLM_MESSAGE_HEADER*)message) < 0)
-		goto fail;
+	{
+		Stream_Free(s, FALSE);
+		return SEC_E_INVALID_TOKEN;
+	}
 
 	if (message->MessageType != MESSAGE_TYPE_AUTHENTICATE)
-		goto fail;
+	{
+		Stream_Free(s, FALSE);
+		return SEC_E_INVALID_TOKEN;
+	}
 
 	if (ntlm_read_message_fields(s, &(message->LmChallengeResponse)) <
 	    0) /* LmChallengeResponseFields (8 bytes) */
-		goto fail;
+	{
+		Stream_Free(s, FALSE);
+		return SEC_E_INVALID_TOKEN;
+	}
 
 	if (ntlm_read_message_fields(s, &(message->NtChallengeResponse)) <
 	    0) /* NtChallengeResponseFields (8 bytes) */
-		goto fail;
+	{
+		Stream_Free(s, FALSE);
+		return SEC_E_INVALID_TOKEN;
+	}
 
 	if (ntlm_read_message_fields(s, &(message->DomainName)) < 0) /* DomainNameFields (8 bytes) */
-		goto fail;
+	{
+		Stream_Free(s, FALSE);
+		return SEC_E_INVALID_TOKEN;
+	}
 
 	if (ntlm_read_message_fields(s, &(message->UserName)) < 0) /* UserNameFields (8 bytes) */
-		goto fail;
+	{
+		Stream_Free(s, FALSE);
+		return SEC_E_INVALID_TOKEN;
+	}
 
 	if (ntlm_read_message_fields(s, &(message->Workstation)) < 0) /* WorkstationFields (8 bytes) */
-		goto fail;
+	{
+		Stream_Free(s, FALSE);
+		return SEC_E_INVALID_TOKEN;
+	}
 
 	if (ntlm_read_message_fields(s, &(message->EncryptedRandomSessionKey)) <
 	    0) /* EncryptedRandomSessionKeyFields (8 bytes) */
-		goto fail;
+	{
+		Stream_Free(s, FALSE);
+		return SEC_E_INVALID_TOKEN;
+	}
 
-	if (Stream_GetRemainingLength(s) < 4)
-		goto fail;
 	Stream_Read_UINT32(s, message->NegotiateFlags); /* NegotiateFlags (4 bytes) */
 	context->NegotiateKeyExchange =
 	    (message->NegotiateFlags & NTLMSSP_NEGOTIATE_KEY_EXCH) ? TRUE : FALSE;
 
 	if ((context->NegotiateKeyExchange && !message->EncryptedRandomSessionKey.Len) ||
 	    (!context->NegotiateKeyExchange && message->EncryptedRandomSessionKey.Len))
-		goto fail;
+	{
+		Stream_Free(s, FALSE);
+		return SEC_E_INVALID_TOKEN;
+	}
 
 	if (message->NegotiateFlags & NTLMSSP_NEGOTIATE_VERSION)
 	{
 		if (ntlm_read_version_info(s, &(message->Version)) < 0) /* Version (8 bytes) */
-			goto fail;
+		{
+			Stream_Free(s, FALSE);
+			return SEC_E_INVALID_TOKEN;
+		}
 	}
 
 	PayloadBufferOffset = Stream_GetPosition(s);
 
-	status = SEC_E_INTERNAL_ERROR;
 	if (ntlm_read_message_fields_buffer(s, &(message->DomainName)) < 0) /* DomainName */
-		goto fail;
+	{
+		Stream_Free(s, FALSE);
+		return SEC_E_INTERNAL_ERROR;
+	}
 
 	if (ntlm_read_message_fields_buffer(s, &(message->UserName)) < 0) /* UserName */
-		goto fail;
+	{
+		Stream_Free(s, FALSE);
+		return SEC_E_INTERNAL_ERROR;
+	}
 
 	if (ntlm_read_message_fields_buffer(s, &(message->Workstation)) < 0) /* Workstation */
-		goto fail;
+	{
+		Stream_Free(s, FALSE);
+		return SEC_E_INTERNAL_ERROR;
+	}
 
 	if (ntlm_read_message_fields_buffer(s, &(message->LmChallengeResponse)) <
 	    0) /* LmChallengeResponse */
-		goto fail;
+	{
+		Stream_Free(s, FALSE);
+		return SEC_E_INTERNAL_ERROR;
+	}
 
 	if (ntlm_read_message_fields_buffer(s, &(message->NtChallengeResponse)) <
 	    0) /* NtChallengeResponse */
-		goto fail;
+	{
+		Stream_Free(s, FALSE);
+		return SEC_E_INTERNAL_ERROR;
+	}
 
 	if (message->NtChallengeResponse.Len > 0)
 	{
-		int rc;
 		size_t cbAvFlags;
 		wStream* snt =
 		    Stream_New(message->NtChallengeResponse.Buffer, message->NtChallengeResponse.Len);
 
 		if (!snt)
-			goto fail;
+		{
+			Stream_Free(s, FALSE);
+			return SEC_E_INTERNAL_ERROR;
+		}
 
-		status = SEC_E_INVALID_TOKEN;
-		rc = ntlm_read_ntlm_v2_response(snt, &(context->NTLMv2Response));
-		Stream_Free(snt, FALSE);
-		if (rc < 0)
-			goto fail;
-		status = SEC_E_INTERNAL_ERROR;
+		if (ntlm_read_ntlm_v2_response(snt, &(context->NTLMv2Response)) < 0)
+		{
+			Stream_Free(s, FALSE);
+			Stream_Free(snt, FALSE);
+			return SEC_E_INVALID_TOKEN;
+		}
 
+		Stream_Free(snt, FALSE);
 		context->NtChallengeResponse.pvBuffer = message->NtChallengeResponse.Buffer;
 		context->NtChallengeResponse.cbBuffer = message->NtChallengeResponse.Len;
 		sspi_SecBufferFree(&(context->ChallengeTargetInfo));
@@ -761,12 +831,18 @@ SECURITY_STATUS ntlm_read_AuthenticateMessage(NTLM_CONTEXT* context, PSecBuffer
 
 	if (ntlm_read_message_fields_buffer(s, &(message->EncryptedRandomSessionKey)) <
 	    0) /* EncryptedRandomSessionKey */
-		goto fail;
+	{
+		Stream_Free(s, FALSE);
+		return SEC_E_INTERNAL_ERROR;
+	}
 
 	if (message->EncryptedRandomSessionKey.Len > 0)
 	{
 		if (message->EncryptedRandomSessionKey.Len != 16)
-			goto fail;
+		{
+			Stream_Free(s, FALSE);
+			return SEC_E_INVALID_TOKEN;
+		}
 
 		CopyMemory(context->EncryptedRandomSessionKey, message->EncryptedRandomSessionKey.Buffer,
 		           16);
@@ -775,7 +851,10 @@ SECURITY_STATUS ntlm_read_AuthenticateMessage(NTLM_CONTEXT* context, PSecBuffer
 	length = Stream_GetPosition(s);
 
 	if (!sspi_SecBufferAlloc(&context->AuthenticateMessage, length))
-		goto fail;
+	{
+		Stream_Free(s, FALSE);
+		return SEC_E_INTERNAL_ERROR;
+	}
 
 	CopyMemory(context->AuthenticateMessage.pvBuffer, Stream_Buffer(s), length);
 	buffer->cbBuffer = length;
@@ -785,15 +864,15 @@ SECURITY_STATUS ntlm_read_AuthenticateMessage(NTLM_CONTEXT* context, PSecBuffer
 	{
 		context->MessageIntegrityCheckOffset = (UINT32)Stream_GetPosition(s);
 
-		status = SEC_E_INVALID_TOKEN;
 		if (Stream_GetRemainingLength(s) < 16)
-			goto fail;
+		{
+			Stream_Free(s, FALSE);
+			return SEC_E_INVALID_TOKEN;
+		}
 
 		Stream_Read(s, message->MessageIntegrityCheck, 16);
 	}
 
-	status = SEC_E_INTERNAL_ERROR;
-
 #ifdef WITH_DEBUG_NTLM
 	WLog_DBG(TAG, "AUTHENTICATE_MESSAGE (length = %" PRIu32 ")",
 	         context->AuthenticateMessage.cbBuffer);
@@ -825,7 +904,10 @@ SECURITY_STATUS ntlm_read_AuthenticateMessage(NTLM_CONTEXT* context, PSecBuffer
 		credentials->identity.User = (UINT16*)malloc(message->UserName.Len);
 
 		if (!credentials->identity.User)
-			goto fail;
+		{
+			Stream_Free(s, FALSE);
+			return SEC_E_INTERNAL_ERROR;
+		}
 
 		CopyMemory(credentials->identity.User, message->UserName.Buffer, message->UserName.Len);
 		credentials->identity.UserLength = message->UserName.Len / 2;
@@ -836,7 +918,10 @@ SECURITY_STATUS ntlm_read_AuthenticateMessage(NTLM_CONTEXT* context, PSecBuffer
 		credentials->identity.Domain = (UINT16*)malloc(message->DomainName.Len);
 
 		if (!credentials->identity.Domain)
-			goto fail;
+		{
+			Stream_Free(s, FALSE);
+			return SEC_E_INTERNAL_ERROR;
+		}
 
 		CopyMemory(credentials->identity.Domain, message->DomainName.Buffer,
 		           message->DomainName.Len);
@@ -847,10 +932,6 @@ SECURITY_STATUS ntlm_read_AuthenticateMessage(NTLM_CONTEXT* context, PSecBuffer
 	/* Computations beyond this point require the NTLM hash of the password */
 	context->state = NTLM_STATE_COMPLETION;
 	return SEC_I_COMPLETE_NEEDED;
-
-fail:
-	Stream_Free(s, FALSE);
-	return status;
 }
 
 /**
@@ -1090,43 +1171,13 @@ SECURITY_STATUS ntlm_server_AuthenticateComplete(NTLM_CONTEXT* context)
 			WLog_ERR(TAG, "Message Integrity Check (MIC) verification failed!");
 #ifdef WITH_DEBUG_NTLM
 			WLog_ERR(TAG, "Expected MIC:");
-			winpr_HexDump(TAG, WLOG_ERROR, messageIntegrityCheck, sizeof(messageIntegrityCheck));
+			winpr_HexDump(TAG, WLOG_ERROR, messageIntegrityCheck, 16);
 			WLog_ERR(TAG, "Actual MIC:");
-			winpr_HexDump(TAG, WLOG_ERROR, message->MessageIntegrityCheck,
-			              sizeof(message->MessageIntegrityCheck));
+			winpr_HexDump(TAG, WLOG_ERROR, message->MessageIntegrityCheck, 16);
 #endif
 			return SEC_E_MESSAGE_ALTERED;
 		}
 	}
-	else
-	{
-		/* no mic message was present
-
-		   https://docs.microsoft.com/en-us/openspecs/windows_protocols/ms-nlmp/f9e6fbc4-a953-4f24-b229-ccdcc213b9ec
-		   the mic is optional, as not supported in Windows NT, Windows 2000, Windows XP, and
-		   Windows Server 2003 and, as it seems, in the NTLMv2 implementation of Qt5.
-
-		   now check the NtProofString, to detect if the entered client password matches the
-		   expected password.
-		   */
-
-#ifdef WITH_DEBUG_NTLM
-		WLog_DBG(TAG, "No MIC present, using NtProofString for verification.");
-#endif
-
-		if (memcmp(context->NTLMv2Response.Response, context->NtProofString, 16) != 0)
-		{
-			WLog_ERR(TAG, "NtProofString verification failed!");
-#ifdef WITH_DEBUG_NTLM
-			WLog_ERR(TAG, "Expected NtProofString:");
-			winpr_HexDump(TAG, WLOG_ERROR, context->NtProofString, sizeof(context->NtProofString));
-			WLog_ERR(TAG, "Actual NtProofString:");
-			winpr_HexDump(TAG, WLOG_ERROR, context->NTLMv2Response.Response,
-			              sizeof(context->NTLMv2Response));
-#endif
-			return SEC_E_LOGON_DENIED;
-		}
-	}
 
 	/* Generate signing keys */
 	ntlm_generate_client_signing_key(context);
diff --git a/winpr/libwinpr/sspi/Schannel/schannel.c b/winpr/libwinpr/sspi/Schannel/schannel.c
index 81b6f945a..a00841874 100644
--- a/winpr/libwinpr/sspi/Schannel/schannel.c
+++ b/winpr/libwinpr/sspi/Schannel/schannel.c
@@ -28,9 +28,9 @@
 
 #include "../sspi.h"
 
-static char* SCHANNEL_PACKAGE_NAME = "Schannel";
+char* SCHANNEL_PACKAGE_NAME = "Schannel";
 
-SCHANNEL_CONTEXT* schannel_ContextNew(void)
+SCHANNEL_CONTEXT* schannel_ContextNew()
 {
 	SCHANNEL_CONTEXT* context;
 	context = (SCHANNEL_CONTEXT*)calloc(1, sizeof(SCHANNEL_CONTEXT));
@@ -58,14 +58,14 @@ void schannel_ContextFree(SCHANNEL_CONTEXT* context)
 	free(context);
 }
 
-static SCHANNEL_CREDENTIALS* schannel_CredentialsNew(void)
+SCHANNEL_CREDENTIALS* schannel_CredentialsNew()
 {
 	SCHANNEL_CREDENTIALS* credentials;
 	credentials = (SCHANNEL_CREDENTIALS*)calloc(1, sizeof(SCHANNEL_CREDENTIALS));
 	return credentials;
 }
 
-static void schannel_CredentialsFree(SCHANNEL_CREDENTIALS* credentials)
+void schannel_CredentialsFree(SCHANNEL_CREDENTIALS* credentials)
 {
 	free(credentials);
 }
@@ -87,9 +87,8 @@ static ALG_ID schannel_SupportedAlgs[] = { CALG_AES_128,
 	                                       CALG_DSS_SIGN,
 	                                       CALG_ECDSA };
 
-static SECURITY_STATUS SEC_ENTRY schannel_QueryCredentialsAttributesW(PCredHandle phCredential,
-                                                                      ULONG ulAttribute,
-                                                                      void* pBuffer)
+SECURITY_STATUS SEC_ENTRY schannel_QueryCredentialsAttributesW(PCredHandle phCredential,
+                                                               ULONG ulAttribute, void* pBuffer)
 {
 	if (ulAttribute == SECPKG_ATTR_SUPPORTED_ALGS)
 	{
@@ -116,14 +115,13 @@ static SECURITY_STATUS SEC_ENTRY schannel_QueryCredentialsAttributesW(PCredHandl
 	return SEC_E_UNSUPPORTED_FUNCTION;
 }
 
-static SECURITY_STATUS SEC_ENTRY schannel_QueryCredentialsAttributesA(PCredHandle phCredential,
-                                                                      ULONG ulAttribute,
-                                                                      void* pBuffer)
+SECURITY_STATUS SEC_ENTRY schannel_QueryCredentialsAttributesA(PCredHandle phCredential,
+                                                               ULONG ulAttribute, void* pBuffer)
 {
 	return schannel_QueryCredentialsAttributesW(phCredential, ulAttribute, pBuffer);
 }
 
-static SECURITY_STATUS SEC_ENTRY schannel_AcquireCredentialsHandleW(
+SECURITY_STATUS SEC_ENTRY schannel_AcquireCredentialsHandleW(
     SEC_WCHAR* pszPrincipal, SEC_WCHAR* pszPackage, ULONG fCredentialUse, void* pvLogonID,
     void* pAuthData, SEC_GET_KEY_FN pGetKeyFn, void* pvGetKeyArgument, PCredHandle phCredential,
     PTimeStamp ptsExpiry)
@@ -158,7 +156,7 @@ static SECURITY_STATUS SEC_ENTRY schannel_AcquireCredentialsHandleW(
 	return SEC_E_OK;
 }
 
-static SECURITY_STATUS SEC_ENTRY schannel_AcquireCredentialsHandleA(
+SECURITY_STATUS SEC_ENTRY schannel_AcquireCredentialsHandleA(
     SEC_CHAR* pszPrincipal, SEC_CHAR* pszPackage, ULONG fCredentialUse, void* pvLogonID,
     void* pAuthData, SEC_GET_KEY_FN pGetKeyFn, void* pvGetKeyArgument, PCredHandle phCredential,
     PTimeStamp ptsExpiry)
@@ -176,7 +174,7 @@ static SECURITY_STATUS SEC_ENTRY schannel_AcquireCredentialsHandleA(
 	return status;
 }
 
-static SECURITY_STATUS SEC_ENTRY schannel_FreeCredentialsHandle(PCredHandle phCredential)
+SECURITY_STATUS SEC_ENTRY schannel_FreeCredentialsHandle(PCredHandle phCredential)
 {
 	SCHANNEL_CREDENTIALS* credentials;
 
@@ -192,7 +190,7 @@ static SECURITY_STATUS SEC_ENTRY schannel_FreeCredentialsHandle(PCredHandle phCr
 	return SEC_E_OK;
 }
 
-static SECURITY_STATUS SEC_ENTRY schannel_InitializeSecurityContextW(
+SECURITY_STATUS SEC_ENTRY schannel_InitializeSecurityContextW(
     PCredHandle phCredential, PCtxtHandle phContext, SEC_WCHAR* pszTargetName, ULONG fContextReq,
     ULONG Reserved1, ULONG TargetDataRep, PSecBufferDesc pInput, ULONG Reserved2,
     PCtxtHandle phNewContext, PSecBufferDesc pOutput, PULONG pfContextAttr, PTimeStamp ptsExpiry)
@@ -221,7 +219,7 @@ static SECURITY_STATUS SEC_ENTRY schannel_InitializeSecurityContextW(
 	return status;
 }
 
-static SECURITY_STATUS SEC_ENTRY schannel_InitializeSecurityContextA(
+SECURITY_STATUS SEC_ENTRY schannel_InitializeSecurityContextA(
     PCredHandle phCredential, PCtxtHandle phContext, SEC_CHAR* pszTargetName, ULONG fContextReq,
     ULONG Reserved1, ULONG TargetDataRep, PSecBufferDesc pInput, ULONG Reserved2,
     PCtxtHandle phNewContext, PSecBufferDesc pOutput, PULONG pfContextAttr, PTimeStamp ptsExpiry)
@@ -241,7 +239,7 @@ static SECURITY_STATUS SEC_ENTRY schannel_InitializeSecurityContextA(
 	return status;
 }
 
-static SECURITY_STATUS SEC_ENTRY schannel_AcceptSecurityContext(
+SECURITY_STATUS SEC_ENTRY schannel_AcceptSecurityContext(
     PCredHandle phCredential, PCtxtHandle phContext, PSecBufferDesc pInput, ULONG fContextReq,
     ULONG TargetDataRep, PCtxtHandle phNewContext, PSecBufferDesc pOutput, PULONG pfContextAttr,
     PTimeStamp ptsTimeStamp)
@@ -267,7 +265,7 @@ static SECURITY_STATUS SEC_ENTRY schannel_AcceptSecurityContext(
 	return status;
 }
 
-static SECURITY_STATUS SEC_ENTRY schannel_DeleteSecurityContext(PCtxtHandle phContext)
+SECURITY_STATUS SEC_ENTRY schannel_DeleteSecurityContext(PCtxtHandle phContext)
 {
 	SCHANNEL_CONTEXT* context;
 	context = (SCHANNEL_CONTEXT*)sspi_SecureHandleGetLowerPointer(phContext);
@@ -279,8 +277,8 @@ static SECURITY_STATUS SEC_ENTRY schannel_DeleteSecurityContext(PCtxtHandle phCo
 	return SEC_E_OK;
 }
 
-static SECURITY_STATUS SEC_ENTRY schannel_QueryContextAttributes(PCtxtHandle phContext,
-                                                                 ULONG ulAttribute, void* pBuffer)
+SECURITY_STATUS SEC_ENTRY schannel_QueryContextAttributes(PCtxtHandle phContext, ULONG ulAttribute,
+                                                          void* pBuffer)
 {
 	if (!phContext)
 		return SEC_E_INVALID_HANDLE;
@@ -311,22 +309,20 @@ static SECURITY_STATUS SEC_ENTRY schannel_QueryContextAttributes(PCtxtHandle phC
 	return SEC_E_UNSUPPORTED_FUNCTION;
 }
 
-static SECURITY_STATUS SEC_ENTRY schannel_MakeSignature(PCtxtHandle phContext, ULONG fQOP,
-                                                        PSecBufferDesc pMessage, ULONG MessageSeqNo)
+SECURITY_STATUS SEC_ENTRY schannel_MakeSignature(PCtxtHandle phContext, ULONG fQOP,
+                                                 PSecBufferDesc pMessage, ULONG MessageSeqNo)
 {
 	return SEC_E_OK;
 }
 
-static SECURITY_STATUS SEC_ENTRY schannel_VerifySignature(PCtxtHandle phContext,
-                                                          PSecBufferDesc pMessage,
-                                                          ULONG MessageSeqNo, ULONG* pfQOP)
+SECURITY_STATUS SEC_ENTRY schannel_VerifySignature(PCtxtHandle phContext, PSecBufferDesc pMessage,
+                                                   ULONG MessageSeqNo, ULONG* pfQOP)
 {
 	return SEC_E_OK;
 }
 
-static SECURITY_STATUS SEC_ENTRY schannel_EncryptMessage(PCtxtHandle phContext, ULONG fQOP,
-                                                         PSecBufferDesc pMessage,
-                                                         ULONG MessageSeqNo)
+SECURITY_STATUS SEC_ENTRY schannel_EncryptMessage(PCtxtHandle phContext, ULONG fQOP,
+                                                  PSecBufferDesc pMessage, ULONG MessageSeqNo)
 {
 	SECURITY_STATUS status;
 	SCHANNEL_CONTEXT* context;
@@ -339,9 +335,8 @@ static SECURITY_STATUS SEC_ENTRY schannel_EncryptMessage(PCtxtHandle phContext,
 	return status;
 }
 
-static SECURITY_STATUS SEC_ENTRY schannel_DecryptMessage(PCtxtHandle phContext,
-                                                         PSecBufferDesc pMessage,
-                                                         ULONG MessageSeqNo, ULONG* pfQOP)
+SECURITY_STATUS SEC_ENTRY schannel_DecryptMessage(PCtxtHandle phContext, PSecBufferDesc pMessage,
+                                                  ULONG MessageSeqNo, ULONG* pfQOP)
 {
 	SECURITY_STATUS status;
 	SCHANNEL_CONTEXT* context;
diff --git a/winpr/libwinpr/sspi/Schannel/schannel_openssl.c b/winpr/libwinpr/sspi/Schannel/schannel_openssl.c
index 7b8b00d97..6ca65d5e0 100644
--- a/winpr/libwinpr/sspi/Schannel/schannel_openssl.c
+++ b/winpr/libwinpr/sspi/Schannel/schannel_openssl.c
@@ -49,7 +49,7 @@ struct _SCHANNEL_OPENSSL
 #include "../../log.h"
 #define TAG WINPR_TAG("sspi.schannel")
 
-static char* openssl_get_ssl_error_string(int ssl_error)
+char* openssl_get_ssl_error_string(int ssl_error)
 {
 	switch (ssl_error)
 	{
@@ -487,7 +487,6 @@ SECURITY_STATUS schannel_openssl_encrypt_message(SCHANNEL_OPENSSL* context, PSec
 		size_t ustatus = (size_t)status;
 		size_t length;
 		size_t offset = 0;
-
 		length =
 		    (pStreamHeaderBuffer->cbBuffer > ustatus) ? ustatus : pStreamHeaderBuffer->cbBuffer;
 		CopyMemory(pStreamHeaderBuffer->pvBuffer, &context->ReadBuffer[offset], length);
diff --git a/winpr/libwinpr/sspi/sspi_winpr.c b/winpr/libwinpr/sspi/sspi_winpr.c
index 7db9b0e00..5bd897d02 100644
--- a/winpr/libwinpr/sspi/sspi_winpr.c
+++ b/winpr/libwinpr/sspi/sspi_winpr.c
@@ -241,12 +241,9 @@ void sspi_CredentialsFree(SSPI_CREDENTIALS* credentials)
 		passwordLength *= 2;
 	}
 
-	if (credentials->identity.User)
-		memset(credentials->identity.User, 0, userLength);
-	if (credentials->identity.Domain)
-		memset(credentials->identity.Domain, 0, domainLength);
-	if (credentials->identity.Password)
-		memset(credentials->identity.Password, 0, passwordLength);
+	memset(credentials->identity.User, 0, userLength);
+	memset(credentials->identity.Domain, 0, domainLength);
+	memset(credentials->identity.Password, 0, passwordLength);
 	free(credentials->identity.User);
 	free(credentials->identity.Domain);
 	free(credentials->identity.Password);
diff --git a/winpr/libwinpr/sspi/test/TestEnumerateSecurityPackages.c b/winpr/libwinpr/sspi/test/TestEnumerateSecurityPackages.c
index e4ef1813b..4e566ef86 100644
--- a/winpr/libwinpr/sspi/test/TestEnumerateSecurityPackages.c
+++ b/winpr/libwinpr/sspi/test/TestEnumerateSecurityPackages.c
@@ -11,9 +11,7 @@ int TestEnumerateSecurityPackages(int argc, char* argv[])
 	ULONG cPackages;
 	SECURITY_STATUS status;
 	SecPkgInfo* pPackageInfo;
-
 	sspi_GlobalInit();
-
 	status = EnumerateSecurityPackages(&cPackages, &pPackageInfo);
 
 	if (status != SEC_E_OK)
@@ -31,6 +29,5 @@ int TestEnumerateSecurityPackages(int argc, char* argv[])
 
 	FreeContextBuffer(pPackageInfo);
 	sspi_GlobalFinish();
-
 	return 0;
 }
diff --git a/winpr/libwinpr/sspi/test/TestNTLM.c b/winpr/libwinpr/sspi/test/TestNTLM.c
index 82d266fe6..83abe70db 100644
--- a/winpr/libwinpr/sspi/test/TestNTLM.c
+++ b/winpr/libwinpr/sspi/test/TestNTLM.c
@@ -470,15 +470,10 @@ void test_ntlm_server_free(TEST_NTLM_SERVER* ntlm)
 int TestNTLM(int argc, char* argv[])
 {
 	int status;
-	int rc = -1;
 	PSecBuffer pSecBuffer;
-	TEST_NTLM_CLIENT* client = NULL;
-	TEST_NTLM_SERVER* server = NULL;
+	TEST_NTLM_CLIENT* client;
+	TEST_NTLM_SERVER* server;
 	BOOL DynamicTest = TRUE;
-
-	WINPR_UNUSED(argc);
-	WINPR_UNUSED(argv);
-
 	/**
 	 * Client Initialization
 	 */
@@ -487,7 +482,7 @@ int TestNTLM(int argc, char* argv[])
 	if (!client)
 	{
 		printf("Memory allocation failed");
-		goto fail;
+		return -1;
 	}
 
 	status = test_ntlm_client_init(client, TEST_NTLM_USER, TEST_NTLM_DOMAIN, TEST_NTLM_PASSWORD);
@@ -495,7 +490,7 @@ int TestNTLM(int argc, char* argv[])
 	if (status < 0)
 	{
 		printf("test_ntlm_client_init failure\n");
-		goto fail;
+		return -1;
 	}
 
 	/**
@@ -506,7 +501,7 @@ int TestNTLM(int argc, char* argv[])
 	if (!server)
 	{
 		printf("Memory allocation failed\n");
-		goto fail;
+		return -1;
 	}
 
 	status = test_ntlm_server_init(server);
@@ -514,7 +509,7 @@ int TestNTLM(int argc, char* argv[])
 	if (status < 0)
 	{
 		printf("test_ntlm_server_init failure\n");
-		goto fail;
+		return -1;
 	}
 
 	/**
@@ -525,7 +520,7 @@ int TestNTLM(int argc, char* argv[])
 	if (status < 0)
 	{
 		printf("test_ntlm_client_authenticate failure\n");
-		goto fail;
+		return -1;
 	}
 
 	if (!DynamicTest)
@@ -562,7 +557,7 @@ int TestNTLM(int argc, char* argv[])
 		if (!pSecBuffer->pvBuffer)
 		{
 			printf("Memory allocation failed\n");
-			goto fail;
+			return -1;
 		}
 
 		CopyMemory(pSecBuffer->pvBuffer, TEST_NTLM_NEGOTIATE, pSecBuffer->cbBuffer);
@@ -583,7 +578,7 @@ int TestNTLM(int argc, char* argv[])
 	if (status < 0)
 	{
 		printf("test_ntlm_server_authenticate failure\n");
-		goto fail;
+		return -1;
 	}
 
 	if (!DynamicTest)
@@ -621,7 +616,7 @@ int TestNTLM(int argc, char* argv[])
 		if (!pSecBuffer->pvBuffer)
 		{
 			printf("Memory allocation failed\n");
-			goto fail;
+			return -1;
 		}
 
 		CopyMemory(pSecBuffer->pvBuffer, TEST_NTLM_CHALLENGE, pSecBuffer->cbBuffer);
@@ -648,7 +643,7 @@ int TestNTLM(int argc, char* argv[])
 	if (status < 0)
 	{
 		printf("test_ntlm_client_authenticate failure\n");
-		goto fail;
+		return -1;
 	}
 
 	pSecBuffer = &(client->outputBuffer[0]);
@@ -661,7 +656,7 @@ int TestNTLM(int argc, char* argv[])
 		if (!pSecBuffer->pvBuffer)
 		{
 			printf("Memory allocation failed\n");
-			goto fail;
+			return -1;
 		}
 
 		CopyMemory(pSecBuffer->pvBuffer, TEST_NTLM_AUTHENTICATE, pSecBuffer->cbBuffer);
@@ -681,16 +676,13 @@ int TestNTLM(int argc, char* argv[])
 	if (status < 0)
 	{
 		printf("test_ntlm_server_authenticate failure\n");
-		goto fail;
+		return -1;
 	}
 
-	rc = 0;
-
-fail:
 	/**
 	 * Cleanup & Termination
 	 */
 	test_ntlm_client_free(client);
 	test_ntlm_server_free(server);
-	return rc;
+	return 0;
 }
diff --git a/winpr/libwinpr/sspi/test/TestSchannel.c b/winpr/libwinpr/sspi/test/TestSchannel.c
index b7ead9c2a..8e9cc1219 100644
--- a/winpr/libwinpr/sspi/test/TestSchannel.c
+++ b/winpr/libwinpr/sspi/test/TestSchannel.c
@@ -227,8 +227,10 @@ static int schannel_send(PSecurityFunctionTable table, HANDLE hPipe, PCtxtHandle
 	status = table->QueryContextAttributes(phContext, SECPKG_ATTR_STREAM_SIZES, &StreamSizes);
 	ioBufferLength = StreamSizes.cbHeader + StreamSizes.cbMaximumMessage + StreamSizes.cbTrailer;
 	ioBuffer = (BYTE*)calloc(1, ioBufferLength);
+
 	if (!ioBuffer)
 		return -1;
+
 	pMessageBuffer = ioBuffer + StreamSizes.cbHeader;
 	CopyMemory(pMessageBuffer, buffer, length);
 	Buffers[0].pvBuffer = ioBuffer;
@@ -287,6 +289,7 @@ static int schannel_recv(PSecurityFunctionTable table, HANDLE hPipe, PCtxtHandle
 	status = table->QueryContextAttributes(phContext, SECPKG_ATTR_STREAM_SIZES, &StreamSizes);
 	ioBufferLength = StreamSizes.cbHeader + StreamSizes.cbMaximumMessage + StreamSizes.cbTrailer;
 	ioBuffer = (BYTE*)calloc(1, ioBufferLength);
+
 	if (!ioBuffer)
 		return -1;
 
@@ -399,11 +402,13 @@ static DWORD WINAPI schannel_test_server_thread(LPVOID arg)
 	cchNameString =
 	    CertGetNameString(pCertContext, CERT_NAME_SIMPLE_DISPLAY_TYPE, 0, NULL, NULL, 0);
 	pszNameString = (LPTSTR)malloc(cchNameString * sizeof(TCHAR));
+
 	if (!pszNameString)
 	{
 		printf("Memory allocation failed\n");
 		return 0;
 	}
+
 	cchNameString = CertGetNameString(pCertContext, CERT_NAME_SIMPLE_DISPLAY_TYPE, 0, NULL,
 	                                  pszNameString, cchNameString);
 	_tprintf(_T("Certificate Name: %s\n"), pszNameString);
@@ -426,17 +431,20 @@ static DWORD WINAPI schannel_test_server_thread(LPVOID arg)
 
 	extraData = FALSE;
 	g_ServerWait = TRUE;
+
 	if (!(lpTokenIn = (BYTE*)malloc(cbMaxToken)))
 	{
 		printf("Memory allocation failed\n");
 		return 0;
 	}
+
 	if (!(lpTokenOut = (BYTE*)malloc(cbMaxToken)))
 	{
 		printf("Memory allocation failed\n");
 		free(lpTokenIn);
 		return 0;
 	}
+
 	fContextReq = ASC_REQ_STREAM | ASC_REQ_SEQUENCE_DETECT | ASC_REQ_REPLAY_DETECT |
 	              ASC_REQ_CONFIDENTIALITY | ASC_REQ_EXTENDED_ERROR;
 
@@ -554,39 +562,46 @@ static int dump_test_certificate_files(void)
 	FILE* fp;
 	char* fullpath = NULL;
 	int ret = -1;
-
 	/*
 	 * Output Certificate File
 	 */
 	fullpath = GetCombinedPath("/tmp", "localhost.crt");
+
 	if (!fullpath)
 		return -1;
 
 	fp = fopen(fullpath, "w+");
+
 	if (fp)
 	{
 		if (fwrite((void*)test_localhost_crt, sizeof(test_localhost_crt), 1, fp) != 1)
 			goto out_fail;
+
 		fclose(fp);
 		fp = NULL;
 	}
-	free(fullpath);
 
+	free(fullpath);
 	/*
 	 * Output Private Key File
 	 */
 	fullpath = GetCombinedPath("/tmp", "localhost.key");
+
 	if (!fullpath)
 		return -1;
+
 	fp = fopen(fullpath, "w+");
+
 	if (fp && fwrite((void*)test_localhost_key, sizeof(test_localhost_key), 1, fp) != 1)
 		goto out_fail;
 
 	ret = 1;
 out_fail:
 	free(fullpath);
+
 	if (fp)
 		fclose(fp);
+
 	return ret;
 }
 
@@ -728,16 +743,19 @@ int TestSchannel(int argc, char* argv[])
 	fContextReq = ISC_REQ_STREAM | ISC_REQ_SEQUENCE_DETECT | ISC_REQ_REPLAY_DETECT |
 	              ISC_REQ_CONFIDENTIALITY | ISC_RET_EXTENDED_ERROR |
 	              ISC_REQ_MANUAL_CRED_VALIDATION | ISC_REQ_INTEGRITY;
+
 	if (!(lpTokenIn = (BYTE*)malloc(cbMaxToken)))
 	{
 		printf("Memory allocation failed\n");
 		return -1;
 	}
+
 	if (!(lpTokenOut = (BYTE*)malloc(cbMaxToken)))
 	{
 		printf("Memory allocation failed\n");
 		return -1;
 	}
+
 	ZeroMemory(&SecBuffer_in, sizeof(SecBuffer_in));
 	ZeroMemory(&SecBuffer_out, sizeof(SecBuffer_out));
 	ZeroMemory(&SecBufferDesc_in, sizeof(SecBufferDesc));
diff --git a/winpr/libwinpr/sspicli/sspicli.c b/winpr/libwinpr/sspicli/sspicli.c
index 039416994..e88b53d48 100644
--- a/winpr/libwinpr/sspicli/sspicli.c
+++ b/winpr/libwinpr/sspicli/sspicli.c
@@ -201,23 +201,18 @@ BOOL LogonUserExW(LPCWSTR lpszUsername, LPCWSTR lpszDomain, LPCWSTR lpszPassword
 BOOL GetUserNameExA(EXTENDED_NAME_FORMAT NameFormat, LPSTR lpNameBuffer, PULONG nSize)
 {
 	size_t length;
-	char login[MAX_PATH];
+	char* login;
 
 	switch (NameFormat)
 	{
 		case NameSamCompatible:
-#ifndef HAVE_GETLOGIN_R
-			strncpy(login, getlogin(), sizeof(login));
-#else
-			if (getlogin_r(login, sizeof(login)) != 0)
-				return FALSE;
-#endif
+			login = getlogin();
 			length = strlen(login);
 
 			if (*nSize >= length)
 			{
 				CopyMemory(lpNameBuffer, login, length + 1);
-				return TRUE;
+				return 1;
 			}
 			else
 			{
@@ -240,7 +235,7 @@ BOOL GetUserNameExA(EXTENDED_NAME_FORMAT NameFormat, LPSTR lpNameBuffer, PULONG
 			break;
 	}
 
-	return FALSE;
+	return 0;
 }
 
 BOOL GetUserNameExW(EXTENDED_NAME_FORMAT NameFormat, LPWSTR lpNameBuffer, PULONG nSize)

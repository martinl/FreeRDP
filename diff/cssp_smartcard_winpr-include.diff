--- winpr/include/winpr/smartcard.h	2019-07-25 19:51:07.417929929 +0300
+++ ../../informatimago/FreeRDP/winpr/include/winpr/smartcard.h	2019-07-25 20:11:31.367999541 +0300
@@ -34,73 +34,73 @@
 
 #	define SCARD_S_SUCCESS NO_ERROR
 
-#	define SCARD_F_INTERNAL_ERROR (HRESULT)(0x80100001L)
-#	define SCARD_E_CANCELLED (HRESULT)(0x80100002L)
-#	define SCARD_E_INVALID_HANDLE (HRESULT)(0x80100003L)
-#	define SCARD_E_INVALID_PARAMETER (HRESULT)(0x80100004L)
-#	define SCARD_E_INVALID_TARGET (HRESULT)(0x80100005L)
-#	define SCARD_E_NO_MEMORY (HRESULT)(0x80100006L)
-#	define SCARD_F_WAITED_TOO_LONG (HRESULT)(0x80100007L)
-#	define SCARD_E_INSUFFICIENT_BUFFER (HRESULT)(0x80100008L)
-#	define SCARD_E_UNKNOWN_READER (HRESULT)(0x80100009L)
-#	define SCARD_E_TIMEOUT (HRESULT)(0x8010000AL)
-#	define SCARD_E_SHARING_VIOLATION (HRESULT)(0x8010000BL)
-#	define SCARD_E_NO_SMARTCARD (HRESULT)(0x8010000CL)
-#	define SCARD_E_UNKNOWN_CARD (HRESULT)(0x8010000DL)
-#	define SCARD_E_CANT_DISPOSE (HRESULT)(0x8010000EL)
-#	define SCARD_E_PROTO_MISMATCH (HRESULT)(0x8010000FL)
-#	define SCARD_E_NOT_READY (HRESULT)(0x80100010L)
-#	define SCARD_E_INVALID_VALUE (HRESULT)(0x80100011L)
-#	define SCARD_E_SYSTEM_CANCELLED (HRESULT)(0x80100012L)
-#	define SCARD_F_COMM_ERROR (HRESULT)(0x80100013L)
-#	define SCARD_F_UNKNOWN_ERROR (HRESULT)(0x80100014L)
-#	define SCARD_E_INVALID_ATR (HRESULT)(0x80100015L)
-#	define SCARD_E_NOT_TRANSACTED (HRESULT)(0x80100016L)
-#	define SCARD_E_READER_UNAVAILABLE (HRESULT)(0x80100017L)
-#	define SCARD_P_SHUTDOWN (HRESULT)(0x80100018L)
-#	define SCARD_E_PCI_TOO_SMALL (HRESULT)(0x80100019L)
-#	define SCARD_E_READER_UNSUPPORTED (HRESULT)(0x8010001AL)
-#	define SCARD_E_DUPLICATE_READER (HRESULT)(0x8010001BL)
-#	define SCARD_E_CARD_UNSUPPORTED (HRESULT)(0x8010001CL)
-#	define SCARD_E_NO_SERVICE (HRESULT)(0x8010001DL)
-#	define SCARD_E_SERVICE_STOPPED (HRESULT)(0x8010001EL)
-#	define SCARD_E_UNEXPECTED (HRESULT)(0x8010001FL)
-#	define SCARD_E_ICC_INSTALLATION (HRESULT)(0x80100020L)
-#	define SCARD_E_ICC_CREATEORDER (HRESULT)(0x80100021L)
-#	define SCARD_E_UNSUPPORTED_FEATURE (HRESULT)(0x80100022L)
-#	define SCARD_E_DIR_NOT_FOUND (HRESULT)(0x80100023L)
-#	define SCARD_E_FILE_NOT_FOUND (HRESULT)(0x80100024L)
-#	define SCARD_E_NO_DIR (HRESULT)(0x80100025L)
-#	define SCARD_E_NO_FILE (HRESULT)(0x80100026L)
-#	define SCARD_E_NO_ACCESS (HRESULT)(0x80100027L)
-#	define SCARD_E_WRITE_TOO_MANY (HRESULT)(0x80100028L)
-#	define SCARD_E_BAD_SEEK (HRESULT)(0x80100029L)
-#	define SCARD_E_INVALID_CHV (HRESULT)(0x8010002AL)
-#	define SCARD_E_UNKNOWN_RES_MNG (HRESULT)(0x8010002BL)
-#	define SCARD_E_NO_SUCH_CERTIFICATE (HRESULT)(0x8010002CL)
-#	define SCARD_E_CERTIFICATE_UNAVAILABLE (HRESULT)(0x8010002DL)
-#	define SCARD_E_NO_READERS_AVAILABLE (HRESULT)(0x8010002EL)
-#	define SCARD_E_COMM_DATA_LOST (HRESULT)(0x8010002FL)
-#	define SCARD_E_NO_KEY_CONTAINER (HRESULT)(0x80100030L)
-#	define SCARD_E_SERVER_TOO_BUSY (HRESULT)(0x80100031L)
-#	define SCARD_E_PIN_CACHE_EXPIRED (HRESULT)(0x80100032L)
-#	define SCARD_E_NO_PIN_CACHE (HRESULT)(0x80100033L)
-#	define SCARD_E_READ_ONLY_CARD (HRESULT)(0x80100034L)
-
-#	define SCARD_W_UNSUPPORTED_CARD (HRESULT)(0x80100065L)
-#	define SCARD_W_UNRESPONSIVE_CARD (HRESULT)(0x80100066L)
-#	define SCARD_W_UNPOWERED_CARD (HRESULT)(0x80100067L)
-#	define SCARD_W_RESET_CARD (HRESULT)(0x80100068L)
-#	define SCARD_W_REMOVED_CARD (HRESULT)(0x80100069L)
-#	define SCARD_W_SECURITY_VIOLATION (HRESULT)(0x8010006AL)
-#	define SCARD_W_WRONG_CHV (HRESULT)(0x8010006BL)
-#	define SCARD_W_CHV_BLOCKED (HRESULT)(0x8010006CL)
-#	define SCARD_W_EOF (HRESULT)(0x8010006DL)
-#	define SCARD_W_CANCELLED_BY_USER (HRESULT)(0x8010006EL)
-#	define SCARD_W_CARD_NOT_AUTHENTICATED (HRESULT)(0x8010006FL)
-#	define SCARD_W_CACHE_ITEM_NOT_FOUND (HRESULT)(0x80100070L)
-#	define SCARD_W_CACHE_ITEM_STALE (HRESULT)(0x80100071L)
-#	define SCARD_W_CACHE_ITEM_TOO_BIG (HRESULT)(0x80100072L)
+#	define SCARD_F_INTERNAL_ERROR ((DWORD)0x80100001L)
+#	define SCARD_E_CANCELLED ((DWORD)0x80100002L)
+#	define SCARD_E_INVALID_HANDLE ((DWORD)0x80100003L)
+#	define SCARD_E_INVALID_PARAMETER ((DWORD)0x80100004L)
+#	define SCARD_E_INVALID_TARGET ((DWORD)0x80100005L)
+#	define SCARD_E_NO_MEMORY ((DWORD)0x80100006L)
+#	define SCARD_F_WAITED_TOO_LONG ((DWORD)0x80100007L)
+#	define SCARD_E_INSUFFICIENT_BUFFER ((DWORD)0x80100008L)
+#	define SCARD_E_UNKNOWN_READER ((DWORD)0x80100009L)
+#	define SCARD_E_TIMEOUT ((DWORD)0x8010000AL)
+#	define SCARD_E_SHARING_VIOLATION ((DWORD)0x8010000BL)
+#	define SCARD_E_NO_SMARTCARD ((DWORD)0x8010000CL)
+#	define SCARD_E_UNKNOWN_CARD ((DWORD)0x8010000DL)
+#	define SCARD_E_CANT_DISPOSE ((DWORD)0x8010000EL)
+#	define SCARD_E_PROTO_MISMATCH ((DWORD)0x8010000FL)
+#	define SCARD_E_NOT_READY ((DWORD)0x80100010L)
+#	define SCARD_E_INVALID_VALUE ((DWORD)0x80100011L)
+#	define SCARD_E_SYSTEM_CANCELLED ((DWORD)0x80100012L)
+#	define SCARD_F_COMM_ERROR ((DWORD)0x80100013L)
+#	define SCARD_F_UNKNOWN_ERROR ((DWORD)0x80100014L)
+#	define SCARD_E_INVALID_ATR ((DWORD)0x80100015L)
+#	define SCARD_E_NOT_TRANSACTED ((DWORD)0x80100016L)
+#	define SCARD_E_READER_UNAVAILABLE ((DWORD)0x80100017L)
+#	define SCARD_P_SHUTDOWN ((DWORD)0x80100018L)
+#	define SCARD_E_PCI_TOO_SMALL ((DWORD)0x80100019L)
+#	define SCARD_E_READER_UNSUPPORTED ((DWORD)0x8010001AL)
+#	define SCARD_E_DUPLICATE_READER ((DWORD)0x8010001BL)
+#	define SCARD_E_CARD_UNSUPPORTED ((DWORD)0x8010001CL)
+#	define SCARD_E_NO_SERVICE ((DWORD)0x8010001DL)
+#	define SCARD_E_SERVICE_STOPPED ((DWORD)0x8010001EL)
+#	define SCARD_E_UNEXPECTED ((DWORD)0x8010001FL)
+#	define SCARD_E_ICC_INSTALLATION ((DWORD)0x80100020L)
+#	define SCARD_E_ICC_CREATEORDER ((DWORD)0x80100021L)
+#	define SCARD_E_UNSUPPORTED_FEATURE ((DWORD)0x80100022L)
+#	define SCARD_E_DIR_NOT_FOUND ((DWORD)0x80100023L)
+#	define SCARD_E_FILE_NOT_FOUND ((DWORD)0x80100024L)
+#	define SCARD_E_NO_DIR ((DWORD)0x80100025L)
+#	define SCARD_E_NO_FILE ((DWORD)0x80100026L)
+#	define SCARD_E_NO_ACCESS ((DWORD)0x80100027L)
+#	define SCARD_E_WRITE_TOO_MANY ((DWORD)0x80100028L)
+#	define SCARD_E_BAD_SEEK ((DWORD)0x80100029L)
+#	define SCARD_E_INVALID_CHV ((DWORD)0x8010002AL)
+#	define SCARD_E_UNKNOWN_RES_MNG ((DWORD)0x8010002BL)
+#	define SCARD_E_NO_SUCH_CERTIFICATE ((DWORD)0x8010002CL)
+#	define SCARD_E_CERTIFICATE_UNAVAILABLE ((DWORD)0x8010002DL)
+#	define SCARD_E_NO_READERS_AVAILABLE ((DWORD)0x8010002EL)
+#	define SCARD_E_COMM_DATA_LOST ((DWORD)0x8010002FL)
+#	define SCARD_E_NO_KEY_CONTAINER ((DWORD)0x80100030L)
+#	define SCARD_E_SERVER_TOO_BUSY ((DWORD)0x80100031L)
+#	define SCARD_E_PIN_CACHE_EXPIRED ((DWORD)0x80100032L)
+#	define SCARD_E_NO_PIN_CACHE ((DWORD)0x80100033L)
+#	define SCARD_E_READ_ONLY_CARD ((DWORD)0x80100034L)
+
+#	define SCARD_W_UNSUPPORTED_CARD ((DWORD)0x80100065L)
+#	define SCARD_W_UNRESPONSIVE_CARD ((DWORD)0x80100066L)
+#	define SCARD_W_UNPOWERED_CARD ((DWORD)0x80100067L)
+#	define SCARD_W_RESET_CARD ((DWORD)0x80100068L)
+#	define SCARD_W_REMOVED_CARD ((DWORD)0x80100069L)
+#	define SCARD_W_SECURITY_VIOLATION ((DWORD)0x8010006AL)
+#	define SCARD_W_WRONG_CHV ((DWORD)0x8010006BL)
+#	define SCARD_W_CHV_BLOCKED ((DWORD)0x8010006CL)
+#	define SCARD_W_EOF ((DWORD)0x8010006DL)
+#	define SCARD_W_CANCELLED_BY_USER ((DWORD)0x8010006EL)
+#	define SCARD_W_CARD_NOT_AUTHENTICATED ((DWORD)0x8010006FL)
+#	define SCARD_W_CACHE_ITEM_NOT_FOUND ((DWORD)0x80100070L)
+#	define SCARD_W_CACHE_ITEM_STALE ((DWORD)0x80100071L)
+#	define SCARD_W_CACHE_ITEM_TOO_BIG ((DWORD)0x80100072L)
 
 #endif
 
@@ -808,6 +808,8 @@
 
 	WINSCARDAPI LONG WINAPI SCardAudit(SCARDCONTEXT hContext, DWORD dwEvent);
 
+	WINSCARDAPI LONG WINAPI SCardAddReaderName(HANDLE* key, LPSTR readerName);
+
 #ifdef UNICODE
 #	define SCardListReaderGroups SCardListReaderGroupsW
 #	define SCardListReaders SCardListReadersW
@@ -1080,6 +1082,8 @@
 
 typedef LONG(WINAPI* fnSCardAudit)(SCARDCONTEXT hContext, DWORD dwEvent);
 
+typedef LONG(WINAPI* fnSCardAddReaderName)(HANDLE* key, LPSTR readerName);
+
 struct _SCardApiFunctionTable
 {
 	DWORD dwVersion;
@@ -1161,6 +1165,7 @@
 	fnSCardListReadersWithDeviceInstanceIdA pfnSCardListReadersWithDeviceInstanceIdA;
 	fnSCardListReadersWithDeviceInstanceIdW pfnSCardListReadersWithDeviceInstanceIdW;
 	fnSCardAudit pfnSCardAudit;
+	fnSCardAddReaderName pfnSCardAddReaderName;
 };
 
 typedef struct _SCardApiFunctionTable SCardApiFunctionTable;
--- winpr/include/winpr/strlst.h	2019-07-25 19:51:07.573930702 +0300
+++ ../../informatimago/FreeRDP/winpr/include/winpr/strlst.h	2019-07-25 20:11:31.524000314 +0300
@@ -29,10 +29,101 @@
 {
 #endif
 
+	/**
+	 * string_list_free frees each string in the string list.
+	 *
+	 * @param [in] string_list   A NULL-terminated array of strings.
+	 */
 	WINPR_API void string_list_free(char** string_list);
-	WINPR_API int string_list_length(const char* const* string_list);
-	WINPR_API char** string_list_copy(const char* const* string_list);
-	WINPR_API void string_list_print(FILE* out, const char* const* string_list);
+
+	/**
+	 * string_list_length return the number of strings in the string list.
+	 *
+	 * @param [in] string_list   A NULL-terminated array of strings.
+	 */
+	WINPR_API int string_list_length(char** string_list);
+
+	/**
+	 * string_list_copy return a new (deep) copy of the string list.
+	 *
+	 * @param [in] string_list   A NULL-terminated array of strings.
+	 *
+	 * If any of the strings or the array itself cannot be allocated, then
+	 * any allocated memory is freed,  and NULL is returned.
+	 */
+	WINPR_API char** string_list_copy(char** string_list);
+
+	/**
+	 * string_list_print prints each string in the string list prefixed by its index.
+	 *
+	 * @param [in] out           The output file.
+	 * @param [in] string_list   A NULL-terminated array of strings.
+	 */
+	WINPR_API void string_list_print(FILE* out, char** string_list);
+
+	/**
+	 * string_list_join concatenates the strings in the string list, separated by the separator
+	 * string.
+	 *
+	 * @result NULL when out of memory,  or a fresh NUL-terminated C string containing the
+	 * concatenation.
+	 * @param [in] string_list   A NULL-terminated array of strings.
+	 * @param [in] separator     A C string.
+	 */
+	WINPR_API char* string_list_join(char** string_list, const char* separator);
+
+	/**
+	 * string_concatenate concatenates the strings in the arguments, until NULL.
+	 *
+	 * @result NULL when out of memory,  or a fresh NUL-terminated C string containing the
+	 * concatenation.
+	 * @param [in] string   A NUL-terminated C string, or NULL.
+	 * @param [in] ...      Other NUL-terminated C strings,  the last one must be NULL;
+	 * @note The last string must be NULL,  not 0,  since on 64-bit, they're not the same parameter
+	 * size!
+	 */
+	WINPR_API char* string_concatenate(const char* string, ...);
+
+	/**
+	 * string_list_split_string splits a string into a string_list of substring,
+	 * each substring is separated in string by the separator string.
+	 *
+	 * @note the result is NULL if and only if some memory couldn't be allocated.
+	 *       if the string is empty,  then an empty string list is returned.
+	 *       If the separtor is empty, then a string list containing the string is returned,
+	 *       or an empty string list if the string is empty and remove_empty_subsrings is true.
+	 *       All the strings in the returned string list are fresh strings.
+	 *       The result can be freed by string_list_free().
+	 *
+	 * @param [in] string                  A C string.
+	 * @param [in] separator               A C string.
+	 * @param [in] remove_empty_substrings A boolean. If true, the empty substrings are not
+	 * collected.
+	 * @result A NULL-terminated array of strings containing the substrings.
+	 */
+	WINPR_API char** string_list_split_string(const char* string, const char* separator,
+	                                          int remove_empty_substrings);
+
+	/**
+	 * string_list_mismatch compares the two string lists a and b.
+	 *
+	 * @note if a[result] == b[result] then a[result] == NULL and b[result] == NULL,  and a and b
+	 * are equal.
+	 *
+	 * @param [in] a   A NULL-terminated array of strings.
+	 * @param [in] b   A NULL-terminated array of strings.
+	 * @result The index of the first element in a that is different in b.
+	 */
+	WINPR_API int string_list_mismatch(char** a, char** b);
+
+	/**
+	 * string_list_equal compares the two string lists a and b.
+	 *
+	 * @param [in] a   A NULL-terminated array of strings.
+	 * @param [in] b   A NULL-terminated array of strings.
+	 * @result whether the two string lists contains the same strings in the same order.
+	 */
+	WINPR_API BOOL string_list_equal(char** a, char** b);
 
 #ifdef __cplusplus
 }
--- winpr/include/winpr/wlog.h	2019-07-25 19:51:07.661931139 +0300
+++ ../../informatimago/FreeRDP/winpr/include/winpr/wlog.h	2019-07-25 20:11:31.608000731 +0300
@@ -106,47 +106,46 @@
 #define WLOG_PACKET_OUTBOUND 2
 
 	WINPR_API BOOL WLog_PrintMessage(wLog* log, DWORD type, DWORD level, DWORD line,
-	                                 const char* file, const char* function, ...);
+	                                 const char* file, const char* function, const void* format,
+	                                 ...);
 	WINPR_API BOOL WLog_PrintMessageVA(wLog* log, DWORD type, DWORD level, DWORD line,
-	                                   const char* file, const char* function, va_list args);
-
-	WINPR_API DWORD WLog_GetLogLevel(wLog* log);
-	WINPR_API BOOL WLog_IsLevelActive(wLog* _log, DWORD _log_level);
+	                                   const char* file, const char* function, const void* format,
+	                                   va_list args);
 
 #define WLog_Print(_log, _log_level, ...)                                              \
 	do                                                                                 \
 	{                                                                                  \
-		if (WLog_IsLevelActive(_log, _log_level))                                      \
+		if (_log && _log_level >= WLog_GetLogLevel(_log))                              \
 		{                                                                              \
 			WLog_PrintMessage(_log, WLOG_MESSAGE_TEXT, _log_level, __LINE__, __FILE__, \
-			                  __FUNCTION__, __VA_ARGS__);                              \
+			                  __FUNCTION__, ##__VA_ARGS__);                            \
 		}                                                                              \
 	} while (0)
 
-#define WLog_PrintVA(_log, _log_level, _args)                                            \
+#define WLog_PrintVA(_log, _log_level, _format, _args)                                   \
 	do                                                                                   \
 	{                                                                                    \
-		if (WLog_IsLevelActive(_log, _log_level))                                        \
+		if (_log && _log_level >= WLog_GetLogLevel(_log))                                \
 		{                                                                                \
 			WLog_PrintMessageVA(_log, WLOG_MESSAGE_TEXT, _log_level, __LINE__, __FILE__, \
-			                    __FUNCTION__, _args);                                    \
+			                    __FUNCTION__, _format, _args);                           \
 		}                                                                                \
 	} while (0)
 
 #define WLog_Data(_log, _log_level, ...)                                               \
 	do                                                                                 \
 	{                                                                                  \
-		if (WLog_IsLevelActive(_log, _log_level))                                      \
+		if (_log && _log_level >= WLog_GetLogLevel(_log))                              \
 		{                                                                              \
 			WLog_PrintMessage(_log, WLOG_MESSAGE_DATA, _log_level, __LINE__, __FILE__, \
-			                  __FUNCTION__, __VA_ARGS__);                              \
+			                  __FUNCTION__, ##__VA_ARGS__);                            \
 		}                                                                              \
 	} while (0)
 
 #define WLog_Image(_log, _log_level, ...)                                              \
 	do                                                                                 \
 	{                                                                                  \
-		if (WLog_IsLevelActive(_log, _log_level))                                      \
+		if (_log && _log_level >= WLog_GetLogLevel(_log))                              \
 		{                                                                              \
 			WLog_PrintMessage(_log, WLOG_MESSAGE_DATA, _log_level, __LINE__, __FILE__, \
 			                  __FUNCTION__, __VA_ARGS__);                              \
@@ -156,7 +155,7 @@
 #define WLog_Packet(_log, _log_level, ...)                                               \
 	do                                                                                   \
 	{                                                                                    \
-		if (WLog_IsLevelActive(_log, _log_level))                                        \
+		if (_log && _log_level >= WLog_GetLogLevel(_log))                                \
 		{                                                                                \
 			WLog_PrintMessage(_log, WLOG_MESSAGE_PACKET, _log_level, __LINE__, __FILE__, \
 			                  __FUNCTION__, __VA_ARGS__);                                \
@@ -171,10 +170,16 @@
 #define WLog_ERR(tag, ...) WLog_Print(WLog_Get(tag), WLOG_ERROR, __VA_ARGS__)
 #define WLog_FATAL(tag, ...) WLog_Print(WLog_Get(tag), WLOG_FATAL, __VA_ARGS__)
 
+	WINPR_API DWORD WLog_GetLogLevel(wLog* log);
 	WINPR_API BOOL WLog_SetLogLevel(wLog* log, DWORD logLevel);
 	WINPR_API BOOL WLog_SetStringLogLevel(wLog* log, LPCSTR level);
 	WINPR_API BOOL WLog_AddStringLogFilters(LPCSTR filter);
 
+	static INLINE BOOL WLog_IsLevelActive(wLog* _log, DWORD _log_level)
+	{
+		return _log ? _log_level >= WLog_GetLogLevel(_log) : FALSE;
+	}
+
 	WINPR_API BOOL WLog_SetLogAppenderType(wLog* log, DWORD logAppenderType);
 	WINPR_API wLogAppender* WLog_GetLogAppender(wLog* log);
 	WINPR_API BOOL WLog_OpenAppender(wLog* log);

diff -urN winpr/include/winpr/clipboard.h ../../informatimago/FreeRDP/winpr/include/winpr/clipboard.h
--- winpr/include/winpr/clipboard.h	2019-07-25 19:51:06.921927469 +0300
+++ ../../informatimago/FreeRDP/winpr/include/winpr/clipboard.h	2019-07-25 20:11:30.875997101 +0300
@@ -51,7 +51,6 @@
 {
 	wClipboard* clipboard;
 	void* custom;
-	char* basePath;
 
 	UINT (*ClientRequestFileSize)(wClipboardDelegate*, const wClipboardFileSizeRequest*);
 	UINT (*ClipboardFileSizeSuccess)
@@ -97,7 +96,7 @@
 
 	WINPR_API wClipboardDelegate* ClipboardGetDelegate(wClipboard* clipboard);
 
-	WINPR_API wClipboard* ClipboardCreate(void);
+	WINPR_API wClipboard* ClipboardCreate();
 	WINPR_API void ClipboardDestroy(wClipboard* clipboard);
 
 #ifdef __cplusplus
diff -urN winpr/include/winpr/cmdline.h ../../informatimago/FreeRDP/winpr/include/winpr/cmdline.h
--- winpr/include/winpr/cmdline.h	2019-07-25 19:51:06.925927490 +0300
+++ ../../informatimago/FreeRDP/winpr/include/winpr/cmdline.h	2019-07-25 20:11:30.879997121 +0300
@@ -62,7 +62,6 @@
 
 /* Supress COMMAND_LINE_ERROR_NO_KEYWORD return. */
 #define COMMAND_LINE_IGN_UNKNOWN_KEYWORD 0x00001000
-#define COMMAND_LINE_SILENCE_PARSER 0x00002000
 
 /* Command-Line Parsing Error Codes */
 
diff -urN winpr/include/winpr/collections.h ../../informatimago/FreeRDP/winpr/include/winpr/collections.h
--- winpr/include/winpr/collections.h	2019-07-25 19:51:06.937927549 +0300
+++ ../../informatimago/FreeRDP/winpr/include/winpr/collections.h	2019-07-25 20:11:30.891997180 +0300
@@ -657,8 +657,8 @@
 	WINPR_API BYTE* BipBuffer_ReadTryReserve(wBipBuffer* bb, size_t size, size_t* reserved);
 	WINPR_API void BipBuffer_ReadCommit(wBipBuffer* bb, size_t size);
 
-	WINPR_API SSIZE_T BipBuffer_Read(wBipBuffer* bb, BYTE* data, size_t size);
-	WINPR_API SSIZE_T BipBuffer_Write(wBipBuffer* bb, const BYTE* data, size_t size);
+	WINPR_API int BipBuffer_Read(wBipBuffer* bb, BYTE* data, size_t size);
+	WINPR_API int BipBuffer_Write(wBipBuffer* bb, BYTE* data, size_t size);
 
 	WINPR_API wBipBuffer* BipBuffer_New(size_t size);
 	WINPR_API void BipBuffer_Free(wBipBuffer* bb);
diff -urN winpr/include/winpr/error.h ../../informatimago/FreeRDP/winpr/include/winpr/error.h
--- winpr/include/winpr/error.h	2019-07-25 19:51:07.105928382 +0300
+++ ../../informatimago/FreeRDP/winpr/include/winpr/error.h	2019-07-25 20:11:31.055997993 +0300
@@ -33,16 +33,16 @@
 #		define NO_ERROR 0
 #	endif
 
-#	define E_UNEXPECTED (HRESULT)0x8000FFFFL
-#	define E_NOTIMPL (HRESULT)0x80004001L
-#	define E_OUTOFMEMORY (HRESULT)0x8007000EL
-#	define E_INVALIDARG (HRESULT)0x80070057L
-#	define E_NOINTERFACE (HRESULT)0x80004002L
-#	define E_POINTER (HRESULT)0x80004003L
-#	define E_HANDLE (HRESULT)0x80070006L
-#	define E_ABORT (HRESULT)0x80004004L
-#	define E_FAIL (HRESULT)0x80004005L
-#	define E_ACCESSDENIED (HRESULT)0x80070005L
+#	define E_UNEXPECTED 0x8000FFFF
+#	define E_NOTIMPL 0x80004001
+#	define E_OUTOFMEMORY 0x8007000E
+#	define E_INVALIDARG 0x80070057
+#	define E_NOINTERFACE 0x80004002
+#	define E_POINTER 0x80004003
+#	define E_HANDLE 0x80070006
+#	define E_ABORT 0x80004004
+#	define E_FAIL 0x80004005
+#	define E_ACCESSDENIED 0x80070005
 
 #	define CO_E_INIT_TLS 0x80004006
 #	define CO_E_INIT_SHARED_ALLOCATOR 0x80004007
diff -urN winpr/include/winpr/library.h ../../informatimago/FreeRDP/winpr/include/winpr/library.h
--- winpr/include/winpr/library.h	2019-07-25 19:51:07.161928660 +0300
+++ ../../informatimago/FreeRDP/winpr/include/winpr/library.h	2019-07-25 20:11:31.111998271 +0300
@@ -32,18 +32,6 @@
 #	define LOAD_LIBRARY_SEARCH_SYSTEM32 0x00000800
 #	define LOAD_LIBRARY_SEARCH_USER_DIRS 0x00000400
 
-#	define DONT_RESOLVE_DLL_REFERENCES 0x00000001
-#	define LOAD_LIBRARY_AS_DATAFILE 0x00000002
-#	define LOAD_WITH_ALTERED_SEARCH_PATH 0x00000008
-#	define LOAD_IGNORE_CODE_AUTHZ_LEVEL 0x00000010
-#	define LOAD_LIBRARY_AS_IMAGE_RESOURCE 0x00000020
-#	define LOAD_LIBRARY_AS_DATAFILE_EXCLUSIVE 0x00000040
-#	define LOAD_LIBRARY_SEARCH_DLL_LOAD_DIR 0x00000100
-#	define LOAD_LIBRARY_SEARCH_APPLICATION_DIR 0x00000200
-#	define LOAD_LIBRARY_SEARCH_USER_DIRS 0x00000400
-#	define LOAD_LIBRARY_SEARCH_SYSTEM32 0x00000800
-#	define LOAD_LIBRARY_SEARCH_DEFAULT_DIRS 0x00001000
-
 #	ifdef __cplusplus
 extern "C"
 {
diff -urN winpr/include/winpr/path.h ../../informatimago/FreeRDP/winpr/include/winpr/path.h
--- winpr/include/winpr/path.h	2019-07-25 19:51:07.301929354 +0300
+++ ../../informatimago/FreeRDP/winpr/include/winpr/path.h	2019-07-25 20:11:31.251998965 +0300
@@ -336,7 +336,7 @@
 #endif
 
 #ifdef _WIN32
-#	include <shlwapi.h>
+#	include <Shlwapi.h>
 #endif
 
 #endif /* WINPR_PATH_H */
diff -urN winpr/include/winpr/print.h ../../informatimago/FreeRDP/winpr/include/winpr/print.h
--- winpr/include/winpr/print.h	2019-07-25 19:51:07.321929453 +0300
+++ ../../informatimago/FreeRDP/winpr/include/winpr/print.h	2019-07-25 20:11:31.271999064 +0300
@@ -26,7 +26,6 @@
 
 #include <winpr/winpr.h>
 #include <winpr/wtypes.h>
-#include <winpr/wlog.h>
 
 #define WINPR_HEXDUMP_LINE_LENGTH 16
 
@@ -35,8 +34,7 @@
 {
 #endif
 
-	WINPR_API void winpr_HexDump(const char* tag, UINT32 lvl, const BYTE* data, size_t length);
-	WINPR_API void winpr_HexLogDump(wLog* log, UINT32 lvl, const BYTE* data, size_t length);
+	WINPR_API void winpr_HexDump(const char* tag, UINT32 lvl, const BYTE* data, int length);
 	WINPR_API void winpr_CArrayDump(const char* tag, UINT32 lvl, const BYTE* data, int length,
 	                                int width);
 
diff -urN winpr/include/winpr/smartcard.h ../../informatimago/FreeRDP/winpr/include/winpr/smartcard.h
--- winpr/include/winpr/smartcard.h	2019-07-25 19:51:07.417929929 +0300
+++ ../../informatimago/FreeRDP/winpr/include/winpr/smartcard.h	2019-07-25 20:11:31.367999541 +0300
@@ -34,73 +34,73 @@
 
 #	define SCARD_S_SUCCESS NO_ERROR
 
-#	define SCARD_F_INTERNAL_ERROR (HRESULT)(0x80100001L)
-#	define SCARD_E_CANCELLED (HRESULT)(0x80100002L)
-#	define SCARD_E_INVALID_HANDLE (HRESULT)(0x80100003L)
-#	define SCARD_E_INVALID_PARAMETER (HRESULT)(0x80100004L)
-#	define SCARD_E_INVALID_TARGET (HRESULT)(0x80100005L)
-#	define SCARD_E_NO_MEMORY (HRESULT)(0x80100006L)
-#	define SCARD_F_WAITED_TOO_LONG (HRESULT)(0x80100007L)
-#	define SCARD_E_INSUFFICIENT_BUFFER (HRESULT)(0x80100008L)
-#	define SCARD_E_UNKNOWN_READER (HRESULT)(0x80100009L)
-#	define SCARD_E_TIMEOUT (HRESULT)(0x8010000AL)
-#	define SCARD_E_SHARING_VIOLATION (HRESULT)(0x8010000BL)
-#	define SCARD_E_NO_SMARTCARD (HRESULT)(0x8010000CL)
-#	define SCARD_E_UNKNOWN_CARD (HRESULT)(0x8010000DL)
-#	define SCARD_E_CANT_DISPOSE (HRESULT)(0x8010000EL)
-#	define SCARD_E_PROTO_MISMATCH (HRESULT)(0x8010000FL)
-#	define SCARD_E_NOT_READY (HRESULT)(0x80100010L)
-#	define SCARD_E_INVALID_VALUE (HRESULT)(0x80100011L)
-#	define SCARD_E_SYSTEM_CANCELLED (HRESULT)(0x80100012L)
-#	define SCARD_F_COMM_ERROR (HRESULT)(0x80100013L)
-#	define SCARD_F_UNKNOWN_ERROR (HRESULT)(0x80100014L)
-#	define SCARD_E_INVALID_ATR (HRESULT)(0x80100015L)
-#	define SCARD_E_NOT_TRANSACTED (HRESULT)(0x80100016L)
-#	define SCARD_E_READER_UNAVAILABLE (HRESULT)(0x80100017L)
-#	define SCARD_P_SHUTDOWN (HRESULT)(0x80100018L)
-#	define SCARD_E_PCI_TOO_SMALL (HRESULT)(0x80100019L)
-#	define SCARD_E_READER_UNSUPPORTED (HRESULT)(0x8010001AL)
-#	define SCARD_E_DUPLICATE_READER (HRESULT)(0x8010001BL)
-#	define SCARD_E_CARD_UNSUPPORTED (HRESULT)(0x8010001CL)
-#	define SCARD_E_NO_SERVICE (HRESULT)(0x8010001DL)
-#	define SCARD_E_SERVICE_STOPPED (HRESULT)(0x8010001EL)
-#	define SCARD_E_UNEXPECTED (HRESULT)(0x8010001FL)
-#	define SCARD_E_ICC_INSTALLATION (HRESULT)(0x80100020L)
-#	define SCARD_E_ICC_CREATEORDER (HRESULT)(0x80100021L)
-#	define SCARD_E_UNSUPPORTED_FEATURE (HRESULT)(0x80100022L)
-#	define SCARD_E_DIR_NOT_FOUND (HRESULT)(0x80100023L)
-#	define SCARD_E_FILE_NOT_FOUND (HRESULT)(0x80100024L)
-#	define SCARD_E_NO_DIR (HRESULT)(0x80100025L)
-#	define SCARD_E_NO_FILE (HRESULT)(0x80100026L)
-#	define SCARD_E_NO_ACCESS (HRESULT)(0x80100027L)
-#	define SCARD_E_WRITE_TOO_MANY (HRESULT)(0x80100028L)
-#	define SCARD_E_BAD_SEEK (HRESULT)(0x80100029L)
-#	define SCARD_E_INVALID_CHV (HRESULT)(0x8010002AL)
-#	define SCARD_E_UNKNOWN_RES_MNG (HRESULT)(0x8010002BL)
-#	define SCARD_E_NO_SUCH_CERTIFICATE (HRESULT)(0x8010002CL)
-#	define SCARD_E_CERTIFICATE_UNAVAILABLE (HRESULT)(0x8010002DL)
-#	define SCARD_E_NO_READERS_AVAILABLE (HRESULT)(0x8010002EL)
-#	define SCARD_E_COMM_DATA_LOST (HRESULT)(0x8010002FL)
-#	define SCARD_E_NO_KEY_CONTAINER (HRESULT)(0x80100030L)
-#	define SCARD_E_SERVER_TOO_BUSY (HRESULT)(0x80100031L)
-#	define SCARD_E_PIN_CACHE_EXPIRED (HRESULT)(0x80100032L)
-#	define SCARD_E_NO_PIN_CACHE (HRESULT)(0x80100033L)
-#	define SCARD_E_READ_ONLY_CARD (HRESULT)(0x80100034L)
-
-#	define SCARD_W_UNSUPPORTED_CARD (HRESULT)(0x80100065L)
-#	define SCARD_W_UNRESPONSIVE_CARD (HRESULT)(0x80100066L)
-#	define SCARD_W_UNPOWERED_CARD (HRESULT)(0x80100067L)
-#	define SCARD_W_RESET_CARD (HRESULT)(0x80100068L)
-#	define SCARD_W_REMOVED_CARD (HRESULT)(0x80100069L)
-#	define SCARD_W_SECURITY_VIOLATION (HRESULT)(0x8010006AL)
-#	define SCARD_W_WRONG_CHV (HRESULT)(0x8010006BL)
-#	define SCARD_W_CHV_BLOCKED (HRESULT)(0x8010006CL)
-#	define SCARD_W_EOF (HRESULT)(0x8010006DL)
-#	define SCARD_W_CANCELLED_BY_USER (HRESULT)(0x8010006EL)
-#	define SCARD_W_CARD_NOT_AUTHENTICATED (HRESULT)(0x8010006FL)
-#	define SCARD_W_CACHE_ITEM_NOT_FOUND (HRESULT)(0x80100070L)
-#	define SCARD_W_CACHE_ITEM_STALE (HRESULT)(0x80100071L)
-#	define SCARD_W_CACHE_ITEM_TOO_BIG (HRESULT)(0x80100072L)
+#	define SCARD_F_INTERNAL_ERROR ((DWORD)0x80100001L)
+#	define SCARD_E_CANCELLED ((DWORD)0x80100002L)
+#	define SCARD_E_INVALID_HANDLE ((DWORD)0x80100003L)
+#	define SCARD_E_INVALID_PARAMETER ((DWORD)0x80100004L)
+#	define SCARD_E_INVALID_TARGET ((DWORD)0x80100005L)
+#	define SCARD_E_NO_MEMORY ((DWORD)0x80100006L)
+#	define SCARD_F_WAITED_TOO_LONG ((DWORD)0x80100007L)
+#	define SCARD_E_INSUFFICIENT_BUFFER ((DWORD)0x80100008L)
+#	define SCARD_E_UNKNOWN_READER ((DWORD)0x80100009L)
+#	define SCARD_E_TIMEOUT ((DWORD)0x8010000AL)
+#	define SCARD_E_SHARING_VIOLATION ((DWORD)0x8010000BL)
+#	define SCARD_E_NO_SMARTCARD ((DWORD)0x8010000CL)
+#	define SCARD_E_UNKNOWN_CARD ((DWORD)0x8010000DL)
+#	define SCARD_E_CANT_DISPOSE ((DWORD)0x8010000EL)
+#	define SCARD_E_PROTO_MISMATCH ((DWORD)0x8010000FL)
+#	define SCARD_E_NOT_READY ((DWORD)0x80100010L)
+#	define SCARD_E_INVALID_VALUE ((DWORD)0x80100011L)
+#	define SCARD_E_SYSTEM_CANCELLED ((DWORD)0x80100012L)
+#	define SCARD_F_COMM_ERROR ((DWORD)0x80100013L)
+#	define SCARD_F_UNKNOWN_ERROR ((DWORD)0x80100014L)
+#	define SCARD_E_INVALID_ATR ((DWORD)0x80100015L)
+#	define SCARD_E_NOT_TRANSACTED ((DWORD)0x80100016L)
+#	define SCARD_E_READER_UNAVAILABLE ((DWORD)0x80100017L)
+#	define SCARD_P_SHUTDOWN ((DWORD)0x80100018L)
+#	define SCARD_E_PCI_TOO_SMALL ((DWORD)0x80100019L)
+#	define SCARD_E_READER_UNSUPPORTED ((DWORD)0x8010001AL)
+#	define SCARD_E_DUPLICATE_READER ((DWORD)0x8010001BL)
+#	define SCARD_E_CARD_UNSUPPORTED ((DWORD)0x8010001CL)
+#	define SCARD_E_NO_SERVICE ((DWORD)0x8010001DL)
+#	define SCARD_E_SERVICE_STOPPED ((DWORD)0x8010001EL)
+#	define SCARD_E_UNEXPECTED ((DWORD)0x8010001FL)
+#	define SCARD_E_ICC_INSTALLATION ((DWORD)0x80100020L)
+#	define SCARD_E_ICC_CREATEORDER ((DWORD)0x80100021L)
+#	define SCARD_E_UNSUPPORTED_FEATURE ((DWORD)0x80100022L)
+#	define SCARD_E_DIR_NOT_FOUND ((DWORD)0x80100023L)
+#	define SCARD_E_FILE_NOT_FOUND ((DWORD)0x80100024L)
+#	define SCARD_E_NO_DIR ((DWORD)0x80100025L)
+#	define SCARD_E_NO_FILE ((DWORD)0x80100026L)
+#	define SCARD_E_NO_ACCESS ((DWORD)0x80100027L)
+#	define SCARD_E_WRITE_TOO_MANY ((DWORD)0x80100028L)
+#	define SCARD_E_BAD_SEEK ((DWORD)0x80100029L)
+#	define SCARD_E_INVALID_CHV ((DWORD)0x8010002AL)
+#	define SCARD_E_UNKNOWN_RES_MNG ((DWORD)0x8010002BL)
+#	define SCARD_E_NO_SUCH_CERTIFICATE ((DWORD)0x8010002CL)
+#	define SCARD_E_CERTIFICATE_UNAVAILABLE ((DWORD)0x8010002DL)
+#	define SCARD_E_NO_READERS_AVAILABLE ((DWORD)0x8010002EL)
+#	define SCARD_E_COMM_DATA_LOST ((DWORD)0x8010002FL)
+#	define SCARD_E_NO_KEY_CONTAINER ((DWORD)0x80100030L)
+#	define SCARD_E_SERVER_TOO_BUSY ((DWORD)0x80100031L)
+#	define SCARD_E_PIN_CACHE_EXPIRED ((DWORD)0x80100032L)
+#	define SCARD_E_NO_PIN_CACHE ((DWORD)0x80100033L)
+#	define SCARD_E_READ_ONLY_CARD ((DWORD)0x80100034L)
+
+#	define SCARD_W_UNSUPPORTED_CARD ((DWORD)0x80100065L)
+#	define SCARD_W_UNRESPONSIVE_CARD ((DWORD)0x80100066L)
+#	define SCARD_W_UNPOWERED_CARD ((DWORD)0x80100067L)
+#	define SCARD_W_RESET_CARD ((DWORD)0x80100068L)
+#	define SCARD_W_REMOVED_CARD ((DWORD)0x80100069L)
+#	define SCARD_W_SECURITY_VIOLATION ((DWORD)0x8010006AL)
+#	define SCARD_W_WRONG_CHV ((DWORD)0x8010006BL)
+#	define SCARD_W_CHV_BLOCKED ((DWORD)0x8010006CL)
+#	define SCARD_W_EOF ((DWORD)0x8010006DL)
+#	define SCARD_W_CANCELLED_BY_USER ((DWORD)0x8010006EL)
+#	define SCARD_W_CARD_NOT_AUTHENTICATED ((DWORD)0x8010006FL)
+#	define SCARD_W_CACHE_ITEM_NOT_FOUND ((DWORD)0x80100070L)
+#	define SCARD_W_CACHE_ITEM_STALE ((DWORD)0x80100071L)
+#	define SCARD_W_CACHE_ITEM_TOO_BIG ((DWORD)0x80100072L)
 
 #endif
 
@@ -808,6 +808,8 @@
 
 	WINSCARDAPI LONG WINAPI SCardAudit(SCARDCONTEXT hContext, DWORD dwEvent);
 
+	WINSCARDAPI LONG WINAPI SCardAddReaderName(HANDLE* key, LPSTR readerName);
+
 #ifdef UNICODE
 #	define SCardListReaderGroups SCardListReaderGroupsW
 #	define SCardListReaders SCardListReadersW
@@ -1080,6 +1082,8 @@
 
 typedef LONG(WINAPI* fnSCardAudit)(SCARDCONTEXT hContext, DWORD dwEvent);
 
+typedef LONG(WINAPI* fnSCardAddReaderName)(HANDLE* key, LPSTR readerName);
+
 struct _SCardApiFunctionTable
 {
 	DWORD dwVersion;
@@ -1161,6 +1165,7 @@
 	fnSCardListReadersWithDeviceInstanceIdA pfnSCardListReadersWithDeviceInstanceIdA;
 	fnSCardListReadersWithDeviceInstanceIdW pfnSCardListReadersWithDeviceInstanceIdW;
 	fnSCardAudit pfnSCardAudit;
+	fnSCardAddReaderName pfnSCardAddReaderName;
 };
 
 typedef struct _SCardApiFunctionTable SCardApiFunctionTable;
diff -urN winpr/include/winpr/sspi.h ../../informatimago/FreeRDP/winpr/include/winpr/sspi.h
--- winpr/include/winpr/sspi.h	2019-07-25 19:51:07.549930584 +0300
+++ ../../informatimago/FreeRDP/winpr/include/winpr/sspi.h	2019-07-25 20:11:31.500000195 +0300
@@ -125,91 +125,91 @@
 
 #ifndef _WINERROR_
 
-#	define SEC_E_OK (SECURITY_STATUS)0x00000000L
-#	define SEC_E_INSUFFICIENT_MEMORY (SECURITY_STATUS)0x80090300L
-#	define SEC_E_INVALID_HANDLE (SECURITY_STATUS)0x80090301L
-#	define SEC_E_UNSUPPORTED_FUNCTION (SECURITY_STATUS)0x80090302L
-#	define SEC_E_TARGET_UNKNOWN (SECURITY_STATUS)0x80090303L
-#	define SEC_E_INTERNAL_ERROR (SECURITY_STATUS)0x80090304L
-#	define SEC_E_SECPKG_NOT_FOUND (SECURITY_STATUS)0x80090305L
-#	define SEC_E_NOT_OWNER (SECURITY_STATUS)0x80090306L
-#	define SEC_E_CANNOT_INSTALL (SECURITY_STATUS)0x80090307L
-#	define SEC_E_INVALID_TOKEN (SECURITY_STATUS)0x80090308L
-#	define SEC_E_CANNOT_PACK (SECURITY_STATUS)0x80090309L
-#	define SEC_E_QOP_NOT_SUPPORTED (SECURITY_STATUS)0x8009030AL
-#	define SEC_E_NO_IMPERSONATION (SECURITY_STATUS)0x8009030BL
-#	define SEC_E_LOGON_DENIED (SECURITY_STATUS)0x8009030CL
-#	define SEC_E_UNKNOWN_CREDENTIALS (SECURITY_STATUS)0x8009030DL
-#	define SEC_E_NO_CREDENTIALS (SECURITY_STATUS)0x8009030EL
-#	define SEC_E_MESSAGE_ALTERED (SECURITY_STATUS)0x8009030FL
-#	define SEC_E_OUT_OF_SEQUENCE (SECURITY_STATUS)0x80090310L
-#	define SEC_E_NO_AUTHENTICATING_AUTHORITY (SECURITY_STATUS)0x80090311L
-#	define SEC_E_BAD_PKGID (SECURITY_STATUS)0x80090316L
-#	define SEC_E_CONTEXT_EXPIRED (SECURITY_STATUS)0x80090317L
-#	define SEC_E_INCOMPLETE_MESSAGE (SECURITY_STATUS)0x80090318L
-#	define SEC_E_INCOMPLETE_CREDENTIALS (SECURITY_STATUS)0x80090320L
-#	define SEC_E_BUFFER_TOO_SMALL (SECURITY_STATUS)0x80090321L
-#	define SEC_E_WRONG_PRINCIPAL (SECURITY_STATUS)0x80090322L
-#	define SEC_E_TIME_SKEW (SECURITY_STATUS)0x80090324L
-#	define SEC_E_UNTRUSTED_ROOT (SECURITY_STATUS)0x80090325L
-#	define SEC_E_ILLEGAL_MESSAGE (SECURITY_STATUS)0x80090326L
-#	define SEC_E_CERT_UNKNOWN (SECURITY_STATUS)0x80090327L
-#	define SEC_E_CERT_EXPIRED (SECURITY_STATUS)0x80090328L
-#	define SEC_E_ENCRYPT_FAILURE (SECURITY_STATUS)0x80090329L
-#	define SEC_E_DECRYPT_FAILURE (SECURITY_STATUS)0x80090330L
-#	define SEC_E_ALGORITHM_MISMATCH (SECURITY_STATUS)0x80090331L
-#	define SEC_E_SECURITY_QOS_FAILED (SECURITY_STATUS)0x80090332L
-#	define SEC_E_UNFINISHED_CONTEXT_DELETED (SECURITY_STATUS)0x80090333L
-#	define SEC_E_NO_TGT_REPLY (SECURITY_STATUS)0x80090334L
-#	define SEC_E_NO_IP_ADDRESSES (SECURITY_STATUS)0x80090335L
-#	define SEC_E_WRONG_CREDENTIAL_HANDLE (SECURITY_STATUS)0x80090336L
-#	define SEC_E_CRYPTO_SYSTEM_INVALID (SECURITY_STATUS)0x80090337L
-#	define SEC_E_MAX_REFERRALS_EXCEEDED (SECURITY_STATUS)0x80090338L
-#	define SEC_E_MUST_BE_KDC (SECURITY_STATUS)0x80090339L
-#	define SEC_E_STRONG_CRYPTO_NOT_SUPPORTED (SECURITY_STATUS)0x8009033AL
-#	define SEC_E_TOO_MANY_PRINCIPALS (SECURITY_STATUS)0x8009033BL
-#	define SEC_E_NO_PA_DATA (SECURITY_STATUS)0x8009033CL
-#	define SEC_E_PKINIT_NAME_MISMATCH (SECURITY_STATUS)0x8009033DL
-#	define SEC_E_SMARTCARD_LOGON_REQUIRED (SECURITY_STATUS)0x8009033EL
-#	define SEC_E_SHUTDOWN_IN_PROGRESS (SECURITY_STATUS)0x8009033FL
-#	define SEC_E_KDC_INVALID_REQUEST (SECURITY_STATUS)0x80090340L
-#	define SEC_E_KDC_UNABLE_TO_REFER (SECURITY_STATUS)0x80090341L
-#	define SEC_E_KDC_UNKNOWN_ETYPE (SECURITY_STATUS)0x80090342L
-#	define SEC_E_UNSUPPORTED_PREAUTH (SECURITY_STATUS)0x80090343L
-#	define SEC_E_DELEGATION_REQUIRED (SECURITY_STATUS)0x80090345L
-#	define SEC_E_BAD_BINDINGS (SECURITY_STATUS)0x80090346L
-#	define SEC_E_MULTIPLE_ACCOUNTS (SECURITY_STATUS)0x80090347L
-#	define SEC_E_NO_KERB_KEY (SECURITY_STATUS)0x80090348L
-#	define SEC_E_CERT_WRONG_USAGE (SECURITY_STATUS)0x80090349L
-#	define SEC_E_DOWNGRADE_DETECTED (SECURITY_STATUS)0x80090350L
-#	define SEC_E_SMARTCARD_CERT_REVOKED (SECURITY_STATUS)0x80090351L
-#	define SEC_E_ISSUING_CA_UNTRUSTED (SECURITY_STATUS)0x80090352L
-#	define SEC_E_REVOCATION_OFFLINE_C (SECURITY_STATUS)0x80090353L
-#	define SEC_E_PKINIT_CLIENT_FAILURE (SECURITY_STATUS)0x80090354L
-#	define SEC_E_SMARTCARD_CERT_EXPIRED (SECURITY_STATUS)0x80090355L
-#	define SEC_E_NO_S4U_PROT_SUPPORT (SECURITY_STATUS)0x80090356L
-#	define SEC_E_CROSSREALM_DELEGATION_FAILURE (SECURITY_STATUS)0x80090357L
-#	define SEC_E_REVOCATION_OFFLINE_KDC (SECURITY_STATUS)0x80090358L
-#	define SEC_E_ISSUING_CA_UNTRUSTED_KDC (SECURITY_STATUS)0x80090359L
-#	define SEC_E_KDC_CERT_EXPIRED (SECURITY_STATUS)0x8009035AL
-#	define SEC_E_KDC_CERT_REVOKED (SECURITY_STATUS)0x8009035BL
-#	define SEC_E_INVALID_PARAMETER (SECURITY_STATUS)0x8009035DL
-#	define SEC_E_DELEGATION_POLICY (SECURITY_STATUS)0x8009035EL
-#	define SEC_E_POLICY_NLTM_ONLY (SECURITY_STATUS)0x8009035FL
-#	define SEC_E_NO_CONTEXT (SECURITY_STATUS)0x80090361L
-#	define SEC_E_PKU2U_CERT_FAILURE (SECURITY_STATUS)0x80090362L
-#	define SEC_E_MUTUAL_AUTH_FAILED (SECURITY_STATUS)0x80090363L
+#	define SEC_E_OK 0x00000000
+#	define SEC_E_INSUFFICIENT_MEMORY 0x80090300
+#	define SEC_E_INVALID_HANDLE 0x80090301
+#	define SEC_E_UNSUPPORTED_FUNCTION 0x80090302
+#	define SEC_E_TARGET_UNKNOWN 0x80090303
+#	define SEC_E_INTERNAL_ERROR 0x80090304
+#	define SEC_E_SECPKG_NOT_FOUND 0x80090305
+#	define SEC_E_NOT_OWNER 0x80090306
+#	define SEC_E_CANNOT_INSTALL 0x80090307
+#	define SEC_E_INVALID_TOKEN 0x80090308
+#	define SEC_E_CANNOT_PACK 0x80090309
+#	define SEC_E_QOP_NOT_SUPPORTED 0x8009030A
+#	define SEC_E_NO_IMPERSONATION 0x8009030B
+#	define SEC_E_LOGON_DENIED 0x8009030C
+#	define SEC_E_UNKNOWN_CREDENTIALS 0x8009030D
+#	define SEC_E_NO_CREDENTIALS 0x8009030E
+#	define SEC_E_MESSAGE_ALTERED 0x8009030F
+#	define SEC_E_OUT_OF_SEQUENCE 0x80090310
+#	define SEC_E_NO_AUTHENTICATING_AUTHORITY 0x80090311
+#	define SEC_E_BAD_PKGID 0x80090316
+#	define SEC_E_CONTEXT_EXPIRED 0x80090317
+#	define SEC_E_INCOMPLETE_MESSAGE 0x80090318
+#	define SEC_E_INCOMPLETE_CREDENTIALS 0x80090320
+#	define SEC_E_BUFFER_TOO_SMALL 0x80090321
+#	define SEC_E_WRONG_PRINCIPAL 0x80090322
+#	define SEC_E_TIME_SKEW 0x80090324
+#	define SEC_E_UNTRUSTED_ROOT 0x80090325
+#	define SEC_E_ILLEGAL_MESSAGE 0x80090326
+#	define SEC_E_CERT_UNKNOWN 0x80090327
+#	define SEC_E_CERT_EXPIRED 0x80090328
+#	define SEC_E_ENCRYPT_FAILURE 0x80090329
+#	define SEC_E_DECRYPT_FAILURE 0x80090330
+#	define SEC_E_ALGORITHM_MISMATCH 0x80090331
+#	define SEC_E_SECURITY_QOS_FAILED 0x80090332
+#	define SEC_E_UNFINISHED_CONTEXT_DELETED 0x80090333
+#	define SEC_E_NO_TGT_REPLY 0x80090334
+#	define SEC_E_NO_IP_ADDRESSES 0x80090335
+#	define SEC_E_WRONG_CREDENTIAL_HANDLE 0x80090336
+#	define SEC_E_CRYPTO_SYSTEM_INVALID 0x80090337
+#	define SEC_E_MAX_REFERRALS_EXCEEDED 0x80090338
+#	define SEC_E_MUST_BE_KDC 0x80090339
+#	define SEC_E_STRONG_CRYPTO_NOT_SUPPORTED 0x8009033A
+#	define SEC_E_TOO_MANY_PRINCIPALS 0x8009033B
+#	define SEC_E_NO_PA_DATA 0x8009033C
+#	define SEC_E_PKINIT_NAME_MISMATCH 0x8009033D
+#	define SEC_E_SMARTCARD_LOGON_REQUIRED 0x8009033E
+#	define SEC_E_SHUTDOWN_IN_PROGRESS 0x8009033F
+#	define SEC_E_KDC_INVALID_REQUEST 0x80090340
+#	define SEC_E_KDC_UNABLE_TO_REFER 0x80090341
+#	define SEC_E_KDC_UNKNOWN_ETYPE 0x80090342
+#	define SEC_E_UNSUPPORTED_PREAUTH 0x80090343
+#	define SEC_E_DELEGATION_REQUIRED 0x80090345
+#	define SEC_E_BAD_BINDINGS 0x80090346
+#	define SEC_E_MULTIPLE_ACCOUNTS 0x80090347
+#	define SEC_E_NO_KERB_KEY 0x80090348
+#	define SEC_E_CERT_WRONG_USAGE 0x80090349
+#	define SEC_E_DOWNGRADE_DETECTED 0x80090350
+#	define SEC_E_SMARTCARD_CERT_REVOKED 0x80090351
+#	define SEC_E_ISSUING_CA_UNTRUSTED 0x80090352
+#	define SEC_E_REVOCATION_OFFLINE_C 0x80090353
+#	define SEC_E_PKINIT_CLIENT_FAILURE 0x80090354
+#	define SEC_E_SMARTCARD_CERT_EXPIRED 0x80090355
+#	define SEC_E_NO_S4U_PROT_SUPPORT 0x80090356
+#	define SEC_E_CROSSREALM_DELEGATION_FAILURE 0x80090357
+#	define SEC_E_REVOCATION_OFFLINE_KDC 0x80090358
+#	define SEC_E_ISSUING_CA_UNTRUSTED_KDC 0x80090359
+#	define SEC_E_KDC_CERT_EXPIRED 0x8009035A
+#	define SEC_E_KDC_CERT_REVOKED 0x8009035B
+#	define SEC_E_INVALID_PARAMETER 0x8009035D
+#	define SEC_E_DELEGATION_POLICY 0x8009035E
+#	define SEC_E_POLICY_NLTM_ONLY 0x8009035F
+#	define SEC_E_NO_CONTEXT 0x80090361
+#	define SEC_E_PKU2U_CERT_FAILURE 0x80090362
+#	define SEC_E_MUTUAL_AUTH_FAILED 0x80090363
 
-#	define SEC_I_CONTINUE_NEEDED (SECURITY_STATUS)0x00090312L
-#	define SEC_I_COMPLETE_NEEDED (SECURITY_STATUS)0x00090313L
-#	define SEC_I_COMPLETE_AND_CONTINUE (SECURITY_STATUS)0x00090314L
-#	define SEC_I_LOCAL_LOGON (SECURITY_STATUS)0x00090315L
-#	define SEC_I_CONTEXT_EXPIRED (SECURITY_STATUS)0x00090317L
-#	define SEC_I_INCOMPLETE_CREDENTIALS (SECURITY_STATUS)0x00090320L
-#	define SEC_I_RENEGOTIATE (SECURITY_STATUS)0x00090321L
-#	define SEC_I_NO_LSA_CONTEXT (SECURITY_STATUS)0x00090323L
-#	define SEC_I_SIGNATURE_NEEDED (SECURITY_STATUS)0x0009035CL
-#	define SEC_I_NO_RENEGOTIATION (SECURITY_STATUS)0x00090360L
+#	define SEC_I_CONTINUE_NEEDED 0x00090312
+#	define SEC_I_COMPLETE_NEEDED 0x00090313
+#	define SEC_I_COMPLETE_AND_CONTINUE 0x00090314
+#	define SEC_I_LOCAL_LOGON 0x00090315
+#	define SEC_I_CONTEXT_EXPIRED 0x00090317
+#	define SEC_I_INCOMPLETE_CREDENTIALS 0x00090320
+#	define SEC_I_RENEGOTIATE 0x00090321
+#	define SEC_I_NO_LSA_CONTEXT 0x00090323
+#	define SEC_I_SIGNATURE_NEEDED 0x0009035C
+#	define SEC_I_NO_RENEGOTIATION 0x00090360
 
 #endif
 
diff -urN winpr/include/winpr/stream.h ../../informatimago/FreeRDP/winpr/include/winpr/stream.h
--- winpr/include/winpr/stream.h	2019-07-25 19:51:07.565930663 +0300
+++ ../../informatimago/FreeRDP/winpr/include/winpr/stream.h	2019-07-25 20:11:31.512000255 +0300
@@ -69,65 +69,65 @@
 #define _stream_read_n8(_t, _s, _v, _p)  \
 	do                                   \
 	{                                    \
-		(_v) = (_t)(*(_s)->pointer);     \
+		_v = (_t)(*_s->pointer);         \
 		if (_p)                          \
 			Stream_Seek(_s, sizeof(_t)); \
 	} while (0)
 
-#define _stream_read_n16_le(_t, _s, _v, _p)                                    \
-	do                                                                         \
-	{                                                                          \
-		(_v) = (_t)(*(_s)->pointer) + (_t)(((_t)(*((_s)->pointer + 1))) << 8); \
-		if (_p)                                                                \
-			Stream_Seek(_s, sizeof(_t));                                       \
-	} while (0)
-
-#define _stream_read_n16_be(_t, _s, _v, _p)                                    \
-	do                                                                         \
-	{                                                                          \
-		(_v) = (_t)(((_t)(*(_s)->pointer)) << 8) + (_t)(*((_s)->pointer + 1)); \
-		if (_p)                                                                \
-			Stream_Seek(_s, sizeof(_t));                                       \
-	} while (0)
-
-#define _stream_read_n32_le(_t, _s, _v, _p)                                                 \
-	do                                                                                      \
-	{                                                                                       \
-		(_v) = (_t)(*(_s)->pointer) + (((_t)(*((_s)->pointer + 1))) << 8) +                 \
-		       (((_t)(*((_s)->pointer + 2))) << 16) + (((_t)(*((_s)->pointer + 3))) << 24); \
-		if (_p)                                                                             \
-			Stream_Seek(_s, sizeof(_t));                                                    \
-	} while (0)
-
-#define _stream_read_n32_be(_t, _s, _v, _p)                                              \
-	do                                                                                   \
-	{                                                                                    \
-		(_v) = (((_t)(*((_s)->pointer))) << 24) + (((_t)(*((_s)->pointer + 1))) << 16) + \
-		       (((_t)(*((_s)->pointer + 2))) << 8) + (((_t)(*((_s)->pointer + 3))));     \
-		if (_p)                                                                          \
-			Stream_Seek(_s, sizeof(_t));                                                 \
-	} while (0)
-
-#define _stream_read_n64_le(_t, _s, _v, _p)                                                  \
-	do                                                                                       \
-	{                                                                                        \
-		(_v) = (_t)(*(_s)->pointer) + (((_t)(*((_s)->pointer + 1))) << 8) +                  \
-		       (((_t)(*((_s)->pointer + 2))) << 16) + (((_t)(*((_s)->pointer + 3))) << 24) + \
-		       (((_t)(*((_s)->pointer + 4))) << 32) + (((_t)(*((_s)->pointer + 5))) << 40) + \
-		       (((_t)(*((_s)->pointer + 6))) << 48) + (((_t)(*((_s)->pointer + 7))) << 56);  \
-		if (_p)                                                                              \
-			Stream_Seek(_s, sizeof(_t));                                                     \
-	} while (0)
-
-#define _stream_read_n64_be(_t, _s, _v, _p)                                                  \
-	do                                                                                       \
-	{                                                                                        \
-		(_v) = (((_t)(*((_s)->pointer))) << 56) + (((_t)(*((_s)->pointer + 1))) << 48) +     \
-		       (((_t)(*((_s)->pointer + 2))) << 40) + (((_t)(*((_s)->pointer + 3))) << 32) + \
-		       (((_t)(*((_s)->pointer + 4))) << 24) + (((_t)(*((_s)->pointer + 5))) << 16) + \
-		       (((_t)(*((_s)->pointer + 6))) << 8) + (((_t)(*((_s)->pointer + 7))));         \
-		if (_p)                                                                              \
-			Stream_Seek(_s, sizeof(_t));                                                     \
+#define _stream_read_n16_le(_t, _s, _v, _p)                              \
+	do                                                                   \
+	{                                                                    \
+		_v = (_t)(*_s->pointer) + (_t)(((_t)(*(_s->pointer + 1))) << 8); \
+		if (_p)                                                          \
+			Stream_Seek(_s, sizeof(_t));                                 \
+	} while (0)
+
+#define _stream_read_n16_be(_t, _s, _v, _p)                              \
+	do                                                                   \
+	{                                                                    \
+		_v = (_t)(((_t)(*_s->pointer)) << 8) + (_t)(*(_s->pointer + 1)); \
+		if (_p)                                                          \
+			Stream_Seek(_s, sizeof(_t));                                 \
+	} while (0)
+
+#define _stream_read_n32_le(_t, _s, _v, _p)                                           \
+	do                                                                                \
+	{                                                                                 \
+		_v = (_t)(*_s->pointer) + (((_t)(*(_s->pointer + 1))) << 8) +                 \
+		     (((_t)(*(_s->pointer + 2))) << 16) + (((_t)(*(_s->pointer + 3))) << 24); \
+		if (_p)                                                                       \
+			Stream_Seek(_s, sizeof(_t));                                              \
+	} while (0)
+
+#define _stream_read_n32_be(_t, _s, _v, _p)                                        \
+	do                                                                             \
+	{                                                                              \
+		_v = (((_t)(*(_s->pointer))) << 24) + (((_t)(*(_s->pointer + 1))) << 16) + \
+		     (((_t)(*(_s->pointer + 2))) << 8) + (((_t)(*(_s->pointer + 3))));     \
+		if (_p)                                                                    \
+			Stream_Seek(_s, sizeof(_t));                                           \
+	} while (0)
+
+#define _stream_read_n64_le(_t, _s, _v, _p)                                            \
+	do                                                                                 \
+	{                                                                                  \
+		_v = (_t)(*_s->pointer) + (((_t)(*(_s->pointer + 1))) << 8) +                  \
+		     (((_t)(*(_s->pointer + 2))) << 16) + (((_t)(*(_s->pointer + 3))) << 24) + \
+		     (((_t)(*(_s->pointer + 4))) << 32) + (((_t)(*(_s->pointer + 5))) << 40) + \
+		     (((_t)(*(_s->pointer + 6))) << 48) + (((_t)(*(_s->pointer + 7))) << 56);  \
+		if (_p)                                                                        \
+			Stream_Seek(_s, sizeof(_t));                                               \
+	} while (0)
+
+#define _stream_read_n64_be(_t, _s, _v, _p)                                            \
+	do                                                                                 \
+	{                                                                                  \
+		_v = (((_t)(*(_s->pointer))) << 56) + (((_t)(*(_s->pointer + 1))) << 48) +     \
+		     (((_t)(*(_s->pointer + 2))) << 40) + (((_t)(*(_s->pointer + 3))) << 32) + \
+		     (((_t)(*(_s->pointer + 4))) << 24) + (((_t)(*(_s->pointer + 5))) << 16) + \
+		     (((_t)(*(_s->pointer + 6))) << 8) + (((_t)(*(_s->pointer + 7))));         \
+		if (_p)                                                                        \
+			Stream_Seek(_s, sizeof(_t));                                               \
 	} while (0)
 
 #define Stream_Read_UINT8(_s, _v) _stream_read_n8(UINT8, _s, _v, TRUE)
diff -urN winpr/include/winpr/strlst.h ../../informatimago/FreeRDP/winpr/include/winpr/strlst.h
--- winpr/include/winpr/strlst.h	2019-07-25 19:51:07.573930702 +0300
+++ ../../informatimago/FreeRDP/winpr/include/winpr/strlst.h	2019-07-25 20:11:31.524000314 +0300
@@ -29,10 +29,101 @@
 {
 #endif
 
+	/**
+	 * string_list_free frees each string in the string list.
+	 *
+	 * @param [in] string_list   A NULL-terminated array of strings.
+	 */
 	WINPR_API void string_list_free(char** string_list);
-	WINPR_API int string_list_length(const char* const* string_list);
-	WINPR_API char** string_list_copy(const char* const* string_list);
-	WINPR_API void string_list_print(FILE* out, const char* const* string_list);
+
+	/**
+	 * string_list_length return the number of strings in the string list.
+	 *
+	 * @param [in] string_list   A NULL-terminated array of strings.
+	 */
+	WINPR_API int string_list_length(char** string_list);
+
+	/**
+	 * string_list_copy return a new (deep) copy of the string list.
+	 *
+	 * @param [in] string_list   A NULL-terminated array of strings.
+	 *
+	 * If any of the strings or the array itself cannot be allocated, then
+	 * any allocated memory is freed,  and NULL is returned.
+	 */
+	WINPR_API char** string_list_copy(char** string_list);
+
+	/**
+	 * string_list_print prints each string in the string list prefixed by its index.
+	 *
+	 * @param [in] out           The output file.
+	 * @param [in] string_list   A NULL-terminated array of strings.
+	 */
+	WINPR_API void string_list_print(FILE* out, char** string_list);
+
+	/**
+	 * string_list_join concatenates the strings in the string list, separated by the separator
+	 * string.
+	 *
+	 * @result NULL when out of memory,  or a fresh NUL-terminated C string containing the
+	 * concatenation.
+	 * @param [in] string_list   A NULL-terminated array of strings.
+	 * @param [in] separator     A C string.
+	 */
+	WINPR_API char* string_list_join(char** string_list, const char* separator);
+
+	/**
+	 * string_concatenate concatenates the strings in the arguments, until NULL.
+	 *
+	 * @result NULL when out of memory,  or a fresh NUL-terminated C string containing the
+	 * concatenation.
+	 * @param [in] string   A NUL-terminated C string, or NULL.
+	 * @param [in] ...      Other NUL-terminated C strings,  the last one must be NULL;
+	 * @note The last string must be NULL,  not 0,  since on 64-bit, they're not the same parameter
+	 * size!
+	 */
+	WINPR_API char* string_concatenate(const char* string, ...);
+
+	/**
+	 * string_list_split_string splits a string into a string_list of substring,
+	 * each substring is separated in string by the separator string.
+	 *
+	 * @note the result is NULL if and only if some memory couldn't be allocated.
+	 *       if the string is empty,  then an empty string list is returned.
+	 *       If the separtor is empty, then a string list containing the string is returned,
+	 *       or an empty string list if the string is empty and remove_empty_subsrings is true.
+	 *       All the strings in the returned string list are fresh strings.
+	 *       The result can be freed by string_list_free().
+	 *
+	 * @param [in] string                  A C string.
+	 * @param [in] separator               A C string.
+	 * @param [in] remove_empty_substrings A boolean. If true, the empty substrings are not
+	 * collected.
+	 * @result A NULL-terminated array of strings containing the substrings.
+	 */
+	WINPR_API char** string_list_split_string(const char* string, const char* separator,
+	                                          int remove_empty_substrings);
+
+	/**
+	 * string_list_mismatch compares the two string lists a and b.
+	 *
+	 * @note if a[result] == b[result] then a[result] == NULL and b[result] == NULL,  and a and b
+	 * are equal.
+	 *
+	 * @param [in] a   A NULL-terminated array of strings.
+	 * @param [in] b   A NULL-terminated array of strings.
+	 * @result The index of the first element in a that is different in b.
+	 */
+	WINPR_API int string_list_mismatch(char** a, char** b);
+
+	/**
+	 * string_list_equal compares the two string lists a and b.
+	 *
+	 * @param [in] a   A NULL-terminated array of strings.
+	 * @param [in] b   A NULL-terminated array of strings.
+	 * @result whether the two string lists contains the same strings in the same order.
+	 */
+	WINPR_API BOOL string_list_equal(char** a, char** b);
 
 #ifdef __cplusplus
 }
diff -urN winpr/include/winpr/synch.h ../../informatimago/FreeRDP/winpr/include/winpr/synch.h
--- winpr/include/winpr/synch.h	2019-07-25 19:51:07.589930782 +0300
+++ ../../informatimago/FreeRDP/winpr/include/winpr/synch.h	2019-07-25 20:11:31.536000373 +0300
@@ -40,15 +40,14 @@
 
 #ifndef _WIN32
 
-/* Mutex */
-#	define CREATE_MUTEX_INITIAL_OWNER 0x00000001
+	/* Mutex */
 
 	WINPR_API HANDLE CreateMutexA(LPSECURITY_ATTRIBUTES lpMutexAttributes, BOOL bInitialOwner,
 	                              LPCSTR lpName);
 	WINPR_API HANDLE CreateMutexW(LPSECURITY_ATTRIBUTES lpMutexAttributes, BOOL bInitialOwner,
 	                              LPCWSTR lpName);
 
-	WINPR_API HANDLE CreateMutexExA(LPSECURITY_ATTRIBUTES lpMutexAttributes, LPCSTR lpName,
+	WINPR_API HANDLE CreateMutexExA(LPSECURITY_ATTRIBUTES lpMutexAttributes, LPCTSTR lpName,
 	                                DWORD dwFlags, DWORD dwDesiredAccess);
 	WINPR_API HANDLE CreateMutexExW(LPSECURITY_ATTRIBUTES lpMutexAttributes, LPCWSTR lpName,
 	                                DWORD dwFlags, DWORD dwDesiredAccess);
@@ -88,9 +87,7 @@
 
 	WINPR_API BOOL ReleaseSemaphore(HANDLE hSemaphore, LONG lReleaseCount, LPLONG lpPreviousCount);
 
-/* Event */
-#	define CREATE_EVENT_MANUAL_RESET 0x00000001
-#	define CREATE_EVENT_INITIAL_SET 0x00000002
+	/* Event */
 
 	WINPR_API HANDLE CreateEventA(LPSECURITY_ATTRIBUTES lpEventAttributes, BOOL bManualReset,
 	                              BOOL bInitialState, LPCSTR lpName);
diff -urN winpr/include/winpr/version.h ../../informatimago/FreeRDP/winpr/include/winpr/version.h
--- winpr/include/winpr/version.h	2019-07-25 20:17:15.677706963 +0300
+++ ../../informatimago/FreeRDP/winpr/include/winpr/version.h	2019-07-20 18:23:23.693099695 +0300
@@ -27,6 +27,6 @@
 #define WINPR_API_VERSION "2"
 #define WINPR_VERSION "2.0.0"
 #define WINPR_VERSION_FULL "2.0.0"
-#define GIT_REVISION "743551db2"
+#define GIT_REVISION "da5355e90"
 
 #endif // _WINPR_VERSION_H_
diff -urN winpr/include/winpr/windows.h ../../informatimago/FreeRDP/winpr/include/winpr/windows.h
--- winpr/include/winpr/windows.h	2019-07-25 19:51:07.617930921 +0300
+++ ../../informatimago/FreeRDP/winpr/include/winpr/windows.h	2019-07-25 20:11:31.564000512 +0300
@@ -32,75 +32,6 @@
 #	include <windows.h>
 #	include <ws2tcpip.h>
 
-#else
-
-/* Client System Parameters Update PDU
- * defined in winuser.h
- */
-#	define SPI_SETCARETWIDTH 0x00002007
-#	define SPI_SETSTICKYKEYS 0x0000003B
-#	define SPI_SETTOGGLEKEYS 0x00000035
-#	define SPI_SETFILTERKEYS 0x00000033
-
-/* Server System Parameters Update PDU */
-#	define SPI_SETSCREENSAVEACTIVE 0x00000011
-
-/* HIGHCONTRAST flags values */
-#	define HCF_HIGHCONTRASTON 0x00000001
-#	define HCF_AVAILABLE 0x00000002
-#	define HCF_HOTKEYACTIVE 0x00000004
-#	define HCF_CONFIRMHOTKEY 0x00000008
-#	define HCF_HOTKEYSOUND 0x00000010
-#	define HCF_INDICATOR 0x00000020
-#	define HCF_HOTKEYAVAILABLE 0x00000040
-
-/* TS_FILTERKEYS */
-#	define FKF_FILTERKEYSON 0x00000001
-#	define FKF_AVAILABLE 0x00000002
-#	define FKF_HOTKEYACTIVE 0x00000004
-#	define FKF_CONFIRMHOTKEY 0x00000008
-#	define FKF_HOTKEYSOUND 0x00000010
-#	define FKF_INDICATOR 0x00000020
-#	define FKF_CLICKON 0x00000040
-
-/* TS_TOGGLEKEYS */
-#	define TKF_TOGGLEKEYSON 0x00000001
-#	define TKF_AVAILABLE 0x00000002
-#	define TKF_HOTKEYACTIVE 0x00000004
-#	define TKF_CONFIRMHOTKEY 0x00000008
-#	define TKF_HOTKEYSOUND 0x00000010
-
-/* TS_STICKYKEYS */
-#	define SKF_STICKYKEYSON 0x00000001
-#	define SKF_AVAILABLE 0x00000002
-#	define SKF_HOTKEYACTIVE 0x00000004
-#	define SKF_CONFIRMHOTKEY 0x00000008
-#	define SKF_HOTKEYSOUND 0x00000010
-#	define SKF_INDICATOR 0x00000020
-#	define SKF_AUDIBLEFEEDBACK 0x00000040
-#	define SKF_TRISTATE 0x00000080
-#	define SKF_TWOKEYSOFF 0x00000100
-#	define SKF_LSHIFTLOCKED 0x00010000
-#	define SKF_RSHIFTLOCKED 0x00020000
-#	define SKF_LCTLLOCKED 0x00040000
-#	define SKF_RCTLLOCKED 0x00080000
-#	define SKF_LALTLOCKED 0x00100000
-#	define SKF_RALTLOCKED 0x00200000
-#	define SKF_LWINLOCKED 0x00400000
-#	define SKF_RWINLOCKED 0x00800000
-#	define SKF_LSHIFTLATCHED 0x01000000
-#	define SKF_RSHIFTLATCHED 0x02000000
-#	define SKF_LCTLLATCHED 0x04000000
-#	define SKF_RCTLLATCHED 0x08000000
-#	define SKF_LALTLATCHED 0x10000000
-#	define SKF_RALTLATCHED 0x20000000
-#	define SKF_LWINLATCHED 0x40000000
-#	define SKF_RWINLATCHED 0x80000000
-
-#endif
-
-#ifndef SPI_SETSCREENSAVESECURE
-#	define SPI_SETSCREENSAVESECURE 0x00000077
 #endif
 
 #endif /* WINPR_WINDOWS_H */
diff -urN winpr/include/winpr/wlog.h ../../informatimago/FreeRDP/winpr/include/winpr/wlog.h
--- winpr/include/winpr/wlog.h	2019-07-25 19:51:07.661931139 +0300
+++ ../../informatimago/FreeRDP/winpr/include/winpr/wlog.h	2019-07-25 20:11:31.608000731 +0300
@@ -106,47 +106,46 @@
 #define WLOG_PACKET_OUTBOUND 2
 
 	WINPR_API BOOL WLog_PrintMessage(wLog* log, DWORD type, DWORD level, DWORD line,
-	                                 const char* file, const char* function, ...);
+	                                 const char* file, const char* function, const void* format,
+	                                 ...);
 	WINPR_API BOOL WLog_PrintMessageVA(wLog* log, DWORD type, DWORD level, DWORD line,
-	                                   const char* file, const char* function, va_list args);
-
-	WINPR_API DWORD WLog_GetLogLevel(wLog* log);
-	WINPR_API BOOL WLog_IsLevelActive(wLog* _log, DWORD _log_level);
+	                                   const char* file, const char* function, const void* format,
+	                                   va_list args);
 
 #define WLog_Print(_log, _log_level, ...)                                              \
 	do                                                                                 \
 	{                                                                                  \
-		if (WLog_IsLevelActive(_log, _log_level))                                      \
+		if (_log && _log_level >= WLog_GetLogLevel(_log))                              \
 		{                                                                              \
 			WLog_PrintMessage(_log, WLOG_MESSAGE_TEXT, _log_level, __LINE__, __FILE__, \
-			                  __FUNCTION__, __VA_ARGS__);                              \
+			                  __FUNCTION__, ##__VA_ARGS__);                            \
 		}                                                                              \
 	} while (0)
 
-#define WLog_PrintVA(_log, _log_level, _args)                                            \
+#define WLog_PrintVA(_log, _log_level, _format, _args)                                   \
 	do                                                                                   \
 	{                                                                                    \
-		if (WLog_IsLevelActive(_log, _log_level))                                        \
+		if (_log && _log_level >= WLog_GetLogLevel(_log))                                \
 		{                                                                                \
 			WLog_PrintMessageVA(_log, WLOG_MESSAGE_TEXT, _log_level, __LINE__, __FILE__, \
-			                    __FUNCTION__, _args);                                    \
+			                    __FUNCTION__, _format, _args);                           \
 		}                                                                                \
 	} while (0)
 
 #define WLog_Data(_log, _log_level, ...)                                               \
 	do                                                                                 \
 	{                                                                                  \
-		if (WLog_IsLevelActive(_log, _log_level))                                      \
+		if (_log && _log_level >= WLog_GetLogLevel(_log))                              \
 		{                                                                              \
 			WLog_PrintMessage(_log, WLOG_MESSAGE_DATA, _log_level, __LINE__, __FILE__, \
-			                  __FUNCTION__, __VA_ARGS__);                              \
+			                  __FUNCTION__, ##__VA_ARGS__);                            \
 		}                                                                              \
 	} while (0)
 
 #define WLog_Image(_log, _log_level, ...)                                              \
 	do                                                                                 \
 	{                                                                                  \
-		if (WLog_IsLevelActive(_log, _log_level))                                      \
+		if (_log && _log_level >= WLog_GetLogLevel(_log))                              \
 		{                                                                              \
 			WLog_PrintMessage(_log, WLOG_MESSAGE_DATA, _log_level, __LINE__, __FILE__, \
 			                  __FUNCTION__, __VA_ARGS__);                              \
@@ -156,7 +155,7 @@
 #define WLog_Packet(_log, _log_level, ...)                                               \
 	do                                                                                   \
 	{                                                                                    \
-		if (WLog_IsLevelActive(_log, _log_level))                                        \
+		if (_log && _log_level >= WLog_GetLogLevel(_log))                                \
 		{                                                                                \
 			WLog_PrintMessage(_log, WLOG_MESSAGE_PACKET, _log_level, __LINE__, __FILE__, \
 			                  __FUNCTION__, __VA_ARGS__);                                \
@@ -171,10 +170,16 @@
 #define WLog_ERR(tag, ...) WLog_Print(WLog_Get(tag), WLOG_ERROR, __VA_ARGS__)
 #define WLog_FATAL(tag, ...) WLog_Print(WLog_Get(tag), WLOG_FATAL, __VA_ARGS__)
 
+	WINPR_API DWORD WLog_GetLogLevel(wLog* log);
 	WINPR_API BOOL WLog_SetLogLevel(wLog* log, DWORD logLevel);
 	WINPR_API BOOL WLog_SetStringLogLevel(wLog* log, LPCSTR level);
 	WINPR_API BOOL WLog_AddStringLogFilters(LPCSTR filter);
 
+	static INLINE BOOL WLog_IsLevelActive(wLog* _log, DWORD _log_level)
+	{
+		return _log ? _log_level >= WLog_GetLogLevel(_log) : FALSE;
+	}
+
 	WINPR_API BOOL WLog_SetLogAppenderType(wLog* log, DWORD logAppenderType);
 	WINPR_API wLogAppender* WLog_GetLogAppender(wLog* log);
 	WINPR_API BOOL WLog_OpenAppender(wLog* log);
diff -urN winpr/include/winpr/wtypes.h ../../informatimago/FreeRDP/winpr/include/winpr/wtypes.h
--- winpr/include/winpr/wtypes.h	2019-07-25 20:17:15.677706963 +0300
+++ ../../informatimago/FreeRDP/winpr/include/winpr/wtypes.h	2019-07-25 20:11:31.768001524 +0300
@@ -26,7 +26,7 @@
 
 #if !defined(_MSC_VER) || _MSC_VER >= 1900
 /* Microsoft's inttypes.h is broken before MSVC 2015 */
-#define WINPR_HAVE_INTTYPES_H
+#	define WINPR_HAVE_INTTYPES_H
 #endif
 
 /* MSDN: Windows Data Types - http://msdn.microsoft.com/en-us/library/aa383751/ */
@@ -38,169 +38,168 @@
 #include <winpr/spec.h>
 
 #ifdef WINPR_HAVE_STDBOOL_H
-#include <stdbool.h>
+#	include <stdbool.h>
 #endif
 
 #ifdef WINPR_HAVE_STDINT_H
-#include <stdint.h>
+#	include <stdint.h>
 #endif
 
 #ifdef WINPR_HAVE_INTTYPES_H
-#include <inttypes.h>
+#	include <inttypes.h>
 #endif
 
 #include <limits.h>
 
 #ifdef _WIN32
-#include <wtypes.h>
+#	include <wtypes.h>
 
 /* Handle missing ssize_t on Windows */
-#ifdef _WIN64
+#	ifdef _WIN64
 typedef long long LONG_PTR;
-#else
+#	else
 typedef long LONG_PTR;
-#endif
+#	endif
 typedef LONG_PTR SSIZE_T;
 
 #endif
 
 #if defined(__OBJC__) && defined(__APPLE__)
-#include <objc/objc.h>
+#	include <objc/objc.h>
 #endif
 
 #ifndef CONST
-#define CONST const
+#	define CONST const
 #endif
 
 #ifndef VOID
-#define VOID void
+#	define VOID void
 #endif
 
 #ifndef _WIN32
 
-#define CALLBACK
+#	define CALLBACK
 
-#define WINAPI
-#define CDECL
-
-#ifndef FAR
-#define FAR
-#endif
+#	define WINAPI
+#	define CDECL
 
-#ifndef NEAR
-#define NEAR
-#endif
-
-#ifdef WINPR_HAVE_STDINT_H
-typedef int8_t                  __int8;
-typedef uint8_t                 __uint8;
-typedef int16_t                 __int16;
-typedef uint16_t                __uint16;
-typedef int32_t                 __int32;
-typedef uint32_t                __uint32;
-typedef int64_t                 __int64;
-typedef uint64_t                __uint64;
-#else
-#if UCHAR_MAX == 0xFF
-typedef signed char             __int8;
-typedef unsigned char           __uint8;
-#else
-#error "8-bit type not configured"
-#endif
-#if USHRT_MAX == 0xFFFF
-typedef short                   __int16;
-typedef unsigned short          __uint16;
-#elif UINT_MAX == 0xFFFF
-typedef int                     __int16;
-typedef unsigned int            __uint16;
-#error "16-bit type not configured"
-#endif
-#if UINT_MAX == 0xFFFFFFFF
-typedef int                     __int32;
-typedef unsigned int            __uint32;
-#elif ULONG_MAX == 0xFFFFFFFF
-typedef long                    __int32;
-typedef unsigned long           __uint32;
-#else
-#error "32-bit type not configured"
-#endif
-#if ULONG_MAX == 0xFFFFFFFFFFFFFFFF
-typedef long                    __int64;
-typedef unsigned long           __uint64;
-#elif ULLONG_MAX == 0xFFFFFFFFFFFFFFFF
-typedef long long               __int64;
-typedef unsigned long long      __uint64;
-#else
-#error "64-bit type not configured"
-#endif
-#endif /* WINPR_HAVE_STDINT_H */
-
-#ifdef WINPR_HAVE_STDINT_H
-#if defined(__ILP64__) || defined(__LP64__)
-#define __int3264 int64_t
-#define __uint3264 uint64_t
-#else
-#define __int3264 int32_t
-#define __uint3264 uint32_t
-#endif
-#else
-#if defined(__ILP64__) || defined(__LP64__)
-#define __int3264 __int64
-#define __uint3264 __uint64
-#else
-#define __int3264 __int32
-#define __uint3264 __uint32
-#endif
-#endif /* WINPR_HAVE_STDINT_H */
-
-
-typedef void* PVOID, *LPVOID, *PVOID64, *LPVOID64;
-
-#ifndef XMD_H /* X11/Xmd.h typedef collision with BOOL */
-#ifndef __OBJC__ /* objc.h typedef collision with BOOL */
-#ifndef __APPLE__
+#	ifndef FAR
+#		define FAR
+#	endif
+
+#	ifndef NEAR
+#		define NEAR
+#	endif
+
+#	ifdef WINPR_HAVE_STDINT_H
+typedef int8_t __int8;
+typedef uint8_t __uint8;
+typedef int16_t __int16;
+typedef uint16_t __uint16;
+typedef int32_t __int32;
+typedef uint32_t __uint32;
+typedef int64_t __int64;
+typedef uint64_t __uint64;
+#	else
+#		if UCHAR_MAX == 0xFF
+typedef signed char __int8;
+typedef unsigned char __uint8;
+#		else
+#			error "8-bit type not configured"
+#		endif
+#		if USHRT_MAX == 0xFFFF
+typedef short __int16;
+typedef unsigned short __uint16;
+#		elif UINT_MAX == 0xFFFF
+typedef int __int16;
+typedef unsigned int __uint16;
+#			error "16-bit type not configured"
+#		endif
+#		if UINT_MAX == 0xFFFFFFFF
+typedef int __int32;
+typedef unsigned int __uint32;
+#		elif ULONG_MAX == 0xFFFFFFFF
+typedef long __int32;
+typedef unsigned long __uint32;
+#		else
+#			error "32-bit type not configured"
+#		endif
+#		if ULONG_MAX == 0xFFFFFFFFFFFFFFFF
+typedef long __int64;
+typedef unsigned long __uint64;
+#		elif ULLONG_MAX == 0xFFFFFFFFFFFFFFFF
+typedef long long __int64;
+typedef unsigned long long __uint64;
+#		else
+#			error "64-bit type not configured"
+#		endif
+#	endif /* WINPR_HAVE_STDINT_H */
+
+#	ifdef WINPR_HAVE_STDINT_H
+#		if defined(__ILP64__) || defined(__LP64__)
+#			define __int3264 int64_t
+#			define __uint3264 uint64_t
+#		else
+#			define __int3264 int32_t
+#			define __uint3264 uint32_t
+#		endif
+#	else
+#		if defined(__ILP64__) || defined(__LP64__)
+#			define __int3264 __int64
+#			define __uint3264 __uint64
+#		else
+#			define __int3264 __int32
+#			define __uint3264 __uint32
+#		endif
+#	endif /* WINPR_HAVE_STDINT_H */
+
+typedef void *PVOID, *LPVOID, *PVOID64, *LPVOID64;
+
+#	ifndef XMD_H        /* X11/Xmd.h typedef collision with BOOL */
+#		ifndef __OBJC__ /* objc.h typedef collision with BOOL */
+#			ifndef __APPLE__
 typedef __int32 BOOL;
-#else /* __APPLE__ */
+#			else /* __APPLE__ */
 /* ensure compatibility with objc libraries */
-#if (TARGET_OS_IPHONE && __LP64__)  ||  TARGET_OS_WATCH
+#				if (TARGET_OS_IPHONE && __LP64__) || TARGET_OS_WATCH
 typedef bool BOOL;
-#else
+#				else
 typedef signed char BOOL;
-#endif
-#endif /* __APPLE__ */
-#endif /* __OBJC__ */
-#endif /* XMD_H */
-
-typedef BOOL* PBOOL, *LPBOOL;
-
-#ifndef FALSE
-#define FALSE 0
-#endif
+#				endif
+#			endif /* __APPLE__ */
+#		endif     /* __OBJC__ */
+#	endif         /* XMD_H */
+
+typedef BOOL *PBOOL, *LPBOOL;
+
+#	ifndef FALSE
+#		define FALSE 0
+#	endif
+
+#	ifndef TRUE
+#		define TRUE 1
+#	endif
 
-#ifndef TRUE
-#define TRUE 1
-#endif
-
-#ifndef XMD_H /* X11/Xmd.h typedef collision with BYTE */
+#	ifndef XMD_H /* X11/Xmd.h typedef collision with BYTE */
 typedef __uint8 BYTE;
-#endif /* XMD_H */
+#	endif /* XMD_H */
 typedef BYTE byte, *PBYTE, *LPBYTE;
 typedef BYTE BOOLEAN, PBOOLEAN;
 
-#if CHAR_BIT == 8
+#	if CHAR_BIT == 8
 typedef char CHAR;
 typedef unsigned char UCHAR;
-#else
+#	else
 typedef __int8 CHAR;
 typedef __uint8 UCHAR;
-#endif
+#	endif
 typedef CHAR CCHAR, *PCHAR, *LPCH, *PCH, *PSTR, *LPSTR;
-typedef const CHAR* LPCCH, *PCCH, *LPCSTR, *PCSTR;
+typedef const CHAR *LPCCH, *PCCH, *LPCSTR, *PCSTR;
 typedef UCHAR* PUCHAR;
 
 typedef __uint16 WCHAR;
 typedef WCHAR UNICODE, *PWCHAR, *LPWCH, *PWCH, *BSTR, *LMSTR, *LPWSTR, *PWSTR;
-typedef const WCHAR* LPCWCH, *PCWCH, *LMCSTR, *LPCWSTR, *PCWSTR;
+typedef const WCHAR *LPCWCH, *PCWCH, *LMCSTR, *LPCWSTR, *PCWSTR;
 
 typedef __int16 SHORT, *PSHORT;
 typedef __int32 INT, *PINT, *LPINT;
@@ -212,21 +211,21 @@
 typedef __uint32 ULONG, *PULONG;
 typedef __uint64 ULONGLONG, *PULONGLONG;
 
-#ifndef XMD_H /* X11/Xmd.h typedef collisions */
+#	ifndef XMD_H /* X11/Xmd.h typedef collisions */
 typedef __int8 INT8;
 typedef __int16 INT16;
 typedef __int32 INT32;
 typedef __int64 INT64;
-#endif
+#	endif
 typedef INT8* PINT8;
 typedef INT16* PINT16;
 typedef INT32* PINT32;
 typedef INT64* PINT64;
 
 typedef __int32 LONG32, *PLONG32;
-#ifndef LONG64 /* X11/Xmd.h uses/defines LONG64 */
+#	ifndef LONG64 /* X11/Xmd.h uses/defines LONG64 */
 typedef __int64 LONG64, *PLONG64;
-#endif
+#	endif
 
 typedef __uint8 UINT8, *PUINT8;
 typedef __uint16 UINT16, *PUINT16;
@@ -251,7 +250,7 @@
 
 typedef double DOUBLE;
 
-typedef void* HANDLE, *PHANDLE, *LPHANDLE;
+typedef void *HANDLE, *PHANDLE, *LPHANDLE;
 typedef HANDLE HINSTANCE;
 typedef HANDLE HMODULE;
 typedef HANDLE HWND;
@@ -279,32 +278,31 @@
 typedef struct _LUID
 {
 	DWORD LowPart;
-	LONG  HighPart;
+	LONG HighPart;
 } LUID, *PLUID;
 
 typedef GUID IID;
 typedef IID* REFIID;
 
-#ifdef UNICODE
-#define _T(x)	L ## x
-#else
-#define _T(x)	x
-#endif
+#	ifdef UNICODE
+#		define _T(x) L##x
+#	else
+#		define _T(x) x
+#	endif
 
-#ifdef UNICODE
+#	ifdef UNICODE
 typedef LPWSTR PTSTR;
 typedef LPWSTR LPTCH;
 typedef LPWSTR LPTSTR;
 typedef LPCWSTR LPCTSTR;
-#else
+#	else
 typedef LPSTR PTSTR;
 typedef LPSTR LPTCH;
 typedef LPSTR LPTSTR;
 typedef LPCSTR LPCTSTR;
-#endif
+#	endif
 
-typedef union _ULARGE_INTEGER
-{
+typedef union _ULARGE_INTEGER {
 	struct
 	{
 		DWORD LowPart;
@@ -320,18 +318,17 @@
 	ULONGLONG QuadPart;
 } ULARGE_INTEGER, *PULARGE_INTEGER;
 
-typedef union _LARGE_INTEGER
-{
+typedef union _LARGE_INTEGER {
 	struct
 	{
 		DWORD LowPart;
-		LONG  HighPart;
+		LONG HighPart;
 	};
 
 	struct
 	{
 		DWORD LowPart;
-		LONG  HighPart;
+		LONG HighPart;
 	} u;
 
 	LONGLONG QuadPart;
@@ -415,8 +412,7 @@
 typedef struct tagDEC
 {
 	USHORT wReserved;
-	union
-	{
+	union {
 		struct
 		{
 			BYTE scale;
@@ -425,8 +421,7 @@
 		USHORT signscale;
 	} DUMMYUNIONNAME;
 	ULONG Hi32;
-	union
-	{
+	union {
 		struct
 		{
 			ULONG Lo32;
@@ -438,8 +433,13 @@
 
 typedef DECIMAL* LPDECIMAL;
 
-#define DECIMAL_NEG		((BYTE) 0x80)
-#define DECIMAL_SETZERO(dec)	{ (dec).Lo64 = 0; (dec).Hi32 = 0; (dec).signscale = 0; }
+#	define DECIMAL_NEG ((BYTE)0x80)
+#	define DECIMAL_SETZERO(dec) \
+		{                        \
+			(dec).Lo64 = 0;      \
+			(dec).Hi32 = 0;      \
+			(dec).signscale = 0; \
+		}
 
 typedef DWORD LCID;
 typedef PDWORD PLCID;
@@ -456,102 +456,89 @@
 #endif
 
 #ifndef _LPCVOID_DEFINED
-#define _LPCVOID_DEFINED
+#	define _LPCVOID_DEFINED
 typedef const VOID* LPCVOID;
 #endif
 
 #ifndef _LPCBYTE_DEFINED
-#define _LPCBYTE_DEFINED
+#	define _LPCBYTE_DEFINED
 typedef const BYTE* LPCBYTE;
 #endif
 
 /* integer format specifiers */
 #ifndef WINPR_HAVE_INTTYPES_H
-#define PRId8           "hhd"
-#define PRIi8           "hhi"
-#define PRIu8           "hhu"
-#define PRIo8           "hho"
-#define PRIx8           "hhx"
-#define PRIX8           "hhX"
-#define PRId16          "hd"
-#define PRIi16          "hi"
-#define PRIu16          "hu"
-#define PRIo16          "ho"
-#define PRIx16          "hx"
-#define PRIX16          "hX"
-#if defined(_MSC_VER)
-#define PRId32          "I32d"
-#define PRIi32          "I32i"
-#define PRIu32          "I32u"
-#define PRIo32          "I32o"
-#define PRIx32          "I32x"
-#define PRIX32          "I32X"
-#define PRId64          "I64d"
-#define PRIi64          "I64i"
-#define PRIu64          "I64u"
-#define PRIo64          "I64o"
-#define PRIx64          "I64x"
-#define PRIX64          "I64X"
-#else
-#define PRId32          "d"
-#define PRIi32          "i"
-#define PRIu32          "u"
-#define PRIo32          "o"
-#define PRIx32          "x"
-#define PRIX32          "X"
-#if ULONG_MAX == 0xFFFFFFFFFFFFFFFF
-#define PRId64          "ld"
-#define PRIi64          "li"
-#define PRIu64          "lu"
-#define PRIo64          "lo"
-#define PRIx64          "lx"
-#define PRIX64          "lX"
-#else
-#define PRId64          "lld"
-#define PRIi64          "lli"
-#define PRIu64          "llu"
-#define PRIo64          "llo"
-#define PRIx64          "llx"
-#define PRIX64          "llX"
-#endif
-#endif /* _MSC_VER */
-#endif /* WINPR_HAVE_INTTYPES_H not defined*/
-
-#ifndef SSIZE_MAX
-#if defined(_POSIX_SSIZE_MAX)
-#define SSIZE_MAX _POSIX_SSIZE_MAX
-#elif defined(_WIN64)
-#define SSIZE_MAX _I64_MAX
-#elif defined(_WIN32)
-#define SSIZE_MAX LONG_MAX
-#else
-#define SSIZE_MAX LONG_MAX
-#endif
-#endif
+#	define PRId8 "hhd"
+#	define PRIi8 "hhi"
+#	define PRIu8 "hhu"
+#	define PRIo8 "hho"
+#	define PRIx8 "hhx"
+#	define PRIX8 "hhX"
+#	define PRId16 "hd"
+#	define PRIi16 "hi"
+#	define PRIu16 "hu"
+#	define PRIo16 "ho"
+#	define PRIx16 "hx"
+#	define PRIX16 "hX"
+#	if defined(_MSC_VER)
+#		define PRId32 "I32d"
+#		define PRIi32 "I32i"
+#		define PRIu32 "I32u"
+#		define PRIo32 "I32o"
+#		define PRIx32 "I32x"
+#		define PRIX32 "I32X"
+#		define PRId64 "I64d"
+#		define PRIi64 "I64i"
+#		define PRIu64 "I64u"
+#		define PRIo64 "I64o"
+#		define PRIx64 "I64x"
+#		define PRIX64 "I64X"
+#	else
+#		define PRId32 "d"
+#		define PRIi32 "i"
+#		define PRIu32 "u"
+#		define PRIo32 "o"
+#		define PRIx32 "x"
+#		define PRIX32 "X"
+#		if ULONG_MAX == 0xFFFFFFFFFFFFFFFF
+#			define PRId64 "ld"
+#			define PRIi64 "li"
+#			define PRIu64 "lu"
+#			define PRIo64 "lo"
+#			define PRIx64 "lx"
+#			define PRIX64 "lX"
+#		else
+#			define PRId64 "lld"
+#			define PRIi64 "lli"
+#			define PRIu64 "llu"
+#			define PRIo64 "llo"
+#			define PRIx64 "llx"
+#			define PRIX64 "llX"
+#		endif
+#	endif /* _MSC_VER */
+#endif     /* WINPR_HAVE_INTTYPES_H not defined*/
 
 #if defined(_MSC_VER) && _MSC_VER < 1900
 /* %z not supported before MSVC 2015 */
-#define PRIdz		"Id"
-#define PRIiz		"Ii"
-#define PRIuz		"Iu"
-#define PRIoz		"Io"
-#define PRIxz		"Ix"
-#define PRIXz		"IX"
-#else
-#define PRIdz		"zd"
-#define PRIiz		"zi"
-#define PRIuz		"zu"
-#define PRIoz		"zo"
-#define PRIxz		"zx"
-#define PRIXz		"zX"
+#	define PRIdz "Id"
+#	define PRIiz "Ii"
+#	define PRIuz "Iu"
+#	define PRIoz "Io"
+#	define PRIxz "Ix"
+#	define PRIXz "IX"
+#else
+#	define PRIdz "zd"
+#	define PRIiz "zi"
+#	define PRIuz "zu"
+#	define PRIoz "zo"
+#	define PRIxz "zx"
+#	define PRIXz "zX"
 #endif
 
-
 #include <winpr/user.h>
 
 #ifndef _WIN32
-#define _fseeki64(fp, offset, origin) fseeko(fp, offset, origin)
-#define _ftelli64(fp) ftello(fp)
+#	define _fseeki64(fp, offset, origin) fseeko(fp, offset, origin)
+#	define _ftelli64(fp) ftello(fp)
 #endif
 
 #endif /* WINPR_WTYPES_H */
diff -urN winpr/include/winpr/wtypes.h.in ../../informatimago/FreeRDP/winpr/include/winpr/wtypes.h.in
--- winpr/include/winpr/wtypes.h.in	2019-07-24 06:11:52.530197868 +0300
+++ ../../informatimago/FreeRDP/winpr/include/winpr/wtypes.h.in	2019-07-19 20:00:34.137156343 +0300
@@ -517,17 +517,6 @@
 #endif /* _MSC_VER */
 #endif /* WINPR_HAVE_INTTYPES_H not defined*/
 
-#ifndef SSIZE_MAX
-#if defined(_POSIX_SSIZE_MAX)
-#define SSIZE_MAX _POSIX_SSIZE_MAX
-#elif defined(_WIN64)
-#define SSIZE_MAX _I64_MAX
-#elif defined(_WIN32)
-#define SSIZE_MAX LONG_MAX
-#else
-#define SSIZE_MAX LONG_MAX
-#endif
-#endif
 
 #if defined(_MSC_VER) && _MSC_VER < 1900
 /* %z not supported before MSVC 2015 */
diff -urN winpr/libwinpr/asn1/test/TestAsn1.c ../../informatimago/FreeRDP/winpr/libwinpr/asn1/test/TestAsn1.c
--- winpr/libwinpr/asn1/test/TestAsn1.c	2019-07-25 20:17:16.401710552 +0300
+++ ../../informatimago/FreeRDP/winpr/libwinpr/asn1/test/TestAsn1.c	2019-07-25 20:11:31.776001564 +0300
@@ -4,11 +4,9 @@
 #include <string.h> /* NOLINT */
 
 #if defined(_MSC_VER)
-#pragma warning(disable : 4996) /* deprecation */
+#	pragma warning(disable : 4996) /* deprecation */
 #endif
 
-
-
 /* Forward declare test functions. */
 int TestAsn1Module(int, char*[]);
 int TestAsn1Encoder(int, char*[]);
@@ -23,175 +21,152 @@
 int TestAsn1DerEnc(int, char*[]);
 int TestAsn1DerDec(int, char*[]);
 
-
 #ifdef __cplusplus
-#define CM_CAST(TYPE, EXPR) static_cast<TYPE>(EXPR)
+#	define CM_CAST(TYPE, EXPR) static_cast<TYPE>(EXPR)
 #else
-#define CM_CAST(TYPE, EXPR) (TYPE)(EXPR)
+#	define CM_CAST(TYPE, EXPR) (TYPE)(EXPR)
 #endif
 
 /* Create map.  */
 
-typedef int (*MainFuncPointer)(int, char* []); /* NOLINT */
-typedef struct /* NOLINT */
+typedef int (*MainFuncPointer)(int, char*[]); /* NOLINT */
+typedef struct                                /* NOLINT */
 {
-  const char* name;
-  MainFuncPointer func;
+	const char* name;
+	MainFuncPointer func;
 } functionMapEntry;
 
 static functionMapEntry cmakeGeneratedFunctionMapEntries[] = {
-    {
-    "TestAsn1Module",
-    TestAsn1Module
-  },
-  {
-    "TestAsn1Encoder",
-    TestAsn1Encoder
-  },
-  {
-    "TestAsn1Decoder",
-    TestAsn1Decoder
-  },
-  {
-    "TestAsn1Encode",
-    TestAsn1Encode
-  },
-  {
-    "TestAsn1Decode",
-    TestAsn1Decode
-  },
-  {
-    "TestAsn1String",
-    TestAsn1String
-  },
-  {
-    "TestAsn1Integer",
-    TestAsn1Integer
-  },
-  {
-    "TestAsn1Compare",
-    TestAsn1Compare
-  },
-  {
-    "TestAsn1BerEnc",
-    TestAsn1BerEnc
-  },
-  {
-    "TestAsn1BerDec",
-    TestAsn1BerDec
-  },
-  {
-    "TestAsn1DerEnc",
-    TestAsn1DerEnc
-  },
-  {
-    "TestAsn1DerDec",
-    TestAsn1DerDec
-  },
+	{ "TestAsn1Module", TestAsn1Module },
+	{ "TestAsn1Encoder", TestAsn1Encoder },
+	{ "TestAsn1Decoder", TestAsn1Decoder },
+	{ "TestAsn1Encode", TestAsn1Encode },
+	{ "TestAsn1Decode", TestAsn1Decode },
+	{ "TestAsn1String", TestAsn1String },
+	{ "TestAsn1Integer", TestAsn1Integer },
+	{ "TestAsn1Compare", TestAsn1Compare },
+	{ "TestAsn1BerEnc", TestAsn1BerEnc },
+	{ "TestAsn1BerDec", TestAsn1BerDec },
+	{ "TestAsn1DerEnc", TestAsn1DerEnc },
+	{ "TestAsn1DerDec", TestAsn1DerDec },
 
-  { NULL, NULL } /* NOLINT */
+	{ NULL, NULL } /* NOLINT */
 };
 
-static const int NumTests = CM_CAST(int,
-  sizeof(cmakeGeneratedFunctionMapEntries) / sizeof(functionMapEntry)) - 1;
+static const int NumTests =
+    CM_CAST(int, sizeof(cmakeGeneratedFunctionMapEntries) / sizeof(functionMapEntry)) - 1;
 
 /* Allocate and create a lowercased copy of string
    (note that it has to be free'd manually) */
 static char* lowercase(const char* string)
 {
-  char *new_string, *p;
-  size_t stringSize;
+	char *new_string, *p;
+	size_t stringSize;
 
-  stringSize = CM_CAST(size_t, strlen(string) + 1);
-  new_string = CM_CAST(char*, malloc(sizeof(char) * stringSize));
+	stringSize = CM_CAST(size_t, strlen(string) + 1);
+	new_string = CM_CAST(char*, malloc(sizeof(char) * stringSize));
 
-  if (new_string == NULL) { /* NOLINT */
-    return NULL;            /* NOLINT */
-  }
-  strcpy(new_string, string);
-  for (p = new_string; *p != 0; ++p) {
-    *p = CM_CAST(char, tolower(*p));
-  }
-  return new_string;
+	if (new_string == NULL)
+	{                /* NOLINT */
+		return NULL; /* NOLINT */
+	}
+	strcpy(new_string, string);
+	for (p = new_string; *p != 0; ++p)
+	{
+		*p = CM_CAST(char, tolower(*p));
+	}
+	return new_string;
 }
 
 int main(int ac, char* av[])
 {
-  int i, testNum = 0, partial_match;
-  char *arg;
-  int testToRun = -1;
-
-  
-
-  /* If no test name was given */
-  /* process command line with user function.  */
-  if (ac < 2) {
-    /* Ask for a test.  */
-    printf("Available tests:\n");
-    for (i = 0; i < NumTests; ++i) {
-      printf("%3d. %s\n", i, cmakeGeneratedFunctionMapEntries[i].name);
-    }
-    printf("To run a test, enter the test number: ");
-    fflush(stdout);
-    if (scanf("%d", &testNum) != 1) {
-      printf("Couldn't parse that input as a number\n");
-      return -1;
-    }
-    if (testNum >= NumTests) {
-      printf("%3d is an invalid test number.\n", testNum);
-      return -1;
-    }
-    testToRun = testNum;
-    ac--;
-    av++;
-  }
-  partial_match = 0;
-  arg = NULL; /* NOLINT */
-  /* If partial match is requested.  */
-  if (testToRun == -1 && ac > 1) {
-    partial_match = (strcmp(av[1], "-R") == 0) ? 1 : 0;
-  }
-  if (partial_match != 0 && ac < 3) {
-    printf("-R needs an additional parameter.\n");
-    return -1;
-  }
-  if (testToRun == -1) {
-    arg = lowercase(av[1 + partial_match]);
-  }
-  for (i = 0; i < NumTests && testToRun == -1; ++i) {
-    char *test_name = lowercase(cmakeGeneratedFunctionMapEntries[i].name);
-    if (partial_match != 0 && strstr(test_name, arg) != NULL) { /* NOLINT */
-      testToRun = i;
-      ac -= 2;
-      av += 2;
-    } else if (partial_match == 0 && strcmp(test_name, arg) == 0) {
-      testToRun = i;
-      ac--;
-      av++;
-    }
-    free(test_name);
-  }
-  free(arg);
-  if (testToRun != -1) {
-    int result;
-
-    if (testToRun < 0 || testToRun >= NumTests) {
-      printf("testToRun was modified by TestDriver code to an invalid value: "
-             "%3d.\n",
-             testNum);
-      return -1;
-    }
-    result = (*cmakeGeneratedFunctionMapEntries[testToRun].func)(ac, av);
-
-    return result;
-  }
-
-  /* Nothing was run, display the test names.  */
-  printf("Available tests:\n");
-  for (i = 0; i < NumTests; ++i) {
-    printf("%3d. %s\n", i, cmakeGeneratedFunctionMapEntries[i].name);
-  }
-  printf("Failed: %s is an invalid test name.\n", av[1]);
+	int i, testNum = 0, partial_match;
+	char* arg;
+	int testToRun = -1;
+
+	/* If no test name was given */
+	/* process command line with user function.  */
+	if (ac < 2)
+	{
+		/* Ask for a test.  */
+		printf("Available tests:\n");
+		for (i = 0; i < NumTests; ++i)
+		{
+			printf("%3d. %s\n", i, cmakeGeneratedFunctionMapEntries[i].name);
+		}
+		printf("To run a test, enter the test number: ");
+		fflush(stdout);
+		if (scanf("%d", &testNum) != 1)
+		{
+			printf("Couldn't parse that input as a number\n");
+			return -1;
+		}
+		if (testNum >= NumTests)
+		{
+			printf("%3d is an invalid test number.\n", testNum);
+			return -1;
+		}
+		testToRun = testNum;
+		ac--;
+		av++;
+	}
+	partial_match = 0;
+	arg = NULL; /* NOLINT */
+	/* If partial match is requested.  */
+	if (testToRun == -1 && ac > 1)
+	{
+		partial_match = (strcmp(av[1], "-R") == 0) ? 1 : 0;
+	}
+	if (partial_match != 0 && ac < 3)
+	{
+		printf("-R needs an additional parameter.\n");
+		return -1;
+	}
+	if (testToRun == -1)
+	{
+		arg = lowercase(av[1 + partial_match]);
+	}
+	for (i = 0; i < NumTests && testToRun == -1; ++i)
+	{
+		char* test_name = lowercase(cmakeGeneratedFunctionMapEntries[i].name);
+		if (partial_match != 0 && strstr(test_name, arg) != NULL)
+		{ /* NOLINT */
+			testToRun = i;
+			ac -= 2;
+			av += 2;
+		}
+		else if (partial_match == 0 && strcmp(test_name, arg) == 0)
+		{
+			testToRun = i;
+			ac--;
+			av++;
+		}
+		free(test_name);
+	}
+	free(arg);
+	if (testToRun != -1)
+	{
+		int result;
+
+		if (testToRun < 0 || testToRun >= NumTests)
+		{
+			printf("testToRun was modified by TestDriver code to an invalid value: "
+			       "%3d.\n",
+			       testNum);
+			return -1;
+		}
+		result = (*cmakeGeneratedFunctionMapEntries[testToRun].func)(ac, av);
+
+		return result;
+	}
+
+	/* Nothing was run, display the test names.  */
+	printf("Available tests:\n");
+	for (i = 0; i < NumTests; ++i)
+	{
+		printf("%3d. %s\n", i, cmakeGeneratedFunctionMapEntries[i].name);
+	}
+	printf("Failed: %s is an invalid test name.\n", av[1]);
 
-  return -1;
+	return -1;
 }
diff -urN winpr/libwinpr/clipboard/clipboard.c ../../informatimago/FreeRDP/winpr/libwinpr/clipboard/clipboard.c
--- winpr/libwinpr/clipboard/clipboard.c	2019-07-25 19:51:07.945932547 +0300
+++ ../../informatimago/FreeRDP/winpr/libwinpr/clipboard/clipboard.c	2019-07-25 20:11:31.796001663 +0300
@@ -462,9 +462,7 @@
 
 		DstSize = SrcSize;
 		pDstData = synthesizer->pfnSynthesize(clipboard, format->formatId, pSrcData, &DstSize);
-
-		if (pDstData)
-			*pSize = DstSize;
+		*pSize = DstSize;
 	}
 
 	return pDstData;
@@ -519,7 +517,7 @@
 	return &clipboard->delegate;
 }
 
-static void ClipboardInitLocalFileSubsystem(wClipboard* clipboard)
+void ClipboardInitLocalFileSubsystem(wClipboard* clipboard)
 {
 	/*
 	 * There can be only one local file subsystem active.
@@ -540,7 +538,7 @@
 	WLog_INFO(TAG, "failed to initialize local file subsystem, file transfer not available");
 }
 
-wClipboard* ClipboardCreate(void)
+wClipboard* ClipboardCreate()
 {
 	wClipboard* clipboard;
 	clipboard = (wClipboard*)calloc(1, sizeof(wClipboard));
diff -urN winpr/libwinpr/clipboard/CMakeLists.txt ../../informatimago/FreeRDP/winpr/libwinpr/clipboard/CMakeLists.txt
--- winpr/libwinpr/clipboard/CMakeLists.txt	2019-07-24 06:11:52.534197888 +0300
+++ ../../informatimago/FreeRDP/winpr/libwinpr/clipboard/CMakeLists.txt	2019-07-19 20:00:34.137156343 +0300
@@ -20,8 +20,7 @@
 	clipboard.c
 	clipboard.h)
 
-# MinGW has unistd.h
-if(HAVE_UNISTD_H AND NOT WIN32)
+if(HAVE_UNISTD_H)
 	winpr_definition_add(-DWITH_WCLIPBOARD_POSIX)
 	winpr_module_add(
 		posix.h
diff -urN winpr/libwinpr/clipboard/posix.c ../../informatimago/FreeRDP/winpr/libwinpr/clipboard/posix.c
--- winpr/libwinpr/clipboard/posix.c	2019-07-25 19:51:07.957932607 +0300
+++ ../../informatimago/FreeRDP/winpr/libwinpr/clipboard/posix.c	2019-07-25 20:11:31.808001722 +0300
@@ -132,7 +132,7 @@
 {
 	BOOL valid = TRUE;
 
-	if ((end < str) || ((size_t)(end - str) < strlen("%20")))
+	if ((end < str) || (end - str < strlen("%20")))
 		return FALSE;
 
 	*value = 0;
@@ -244,7 +244,7 @@
 	WCHAR* buffer = NULL;
 	len_dir = _wcslen(dir);
 	len_file = _wcslen(file);
-	buffer = calloc(len_dir + 1 + len_file + 2, sizeof(WCHAR));
+	buffer = calloc(len_dir + 1 + len_file + 1, sizeof(WCHAR));
 
 	if (!buffer)
 		return NULL;
@@ -418,19 +418,17 @@
 
 static BOOL process_uri(const char* uri, size_t uri_len, wArrayList* files)
 {
-	const char prefix[] = "file://";
 	BOOL result = FALSE;
 	char* name = NULL;
-	const size_t prefixLen = strnlen(prefix, sizeof(prefix));
 	WLog_VRB(TAG, "processing URI: %.*s", uri_len, uri);
 
-	if ((uri_len < prefixLen) || strncmp(uri, prefix, prefixLen))
+	if ((uri_len < strlen("file://")) || strncmp(uri, "file://", strlen("file://")))
 	{
 		WLog_ERR(TAG, "non-'file://' URI schemes are not supported");
 		goto out;
 	}
 
-	name = decode_percent_encoded_string(uri + prefixLen, uri_len - prefixLen);
+	name = decode_percent_encoded_string(uri + strlen("file://"), uri_len - strlen("file://"));
 
 	if (!name)
 		goto out;
@@ -575,88 +573,6 @@
 	return descriptors;
 }
 
-static void* convert_filedescriptors_to_uri_list(wClipboard* clipboard, UINT32 formatId,
-                                                 const void* data, UINT32* pSize)
-{
-	const FILEDESCRIPTOR* descriptors;
-	UINT32 nrDescriptors = 0;
-	size_t count, x, alloc, pos, baseLength = 0;
-	const char* src = (const char*)data;
-	char* dst;
-
-	if (!clipboard || !data || !pSize)
-		return NULL;
-
-	if (*pSize < sizeof(UINT32))
-		return NULL;
-
-	if (clipboard->delegate.basePath)
-		baseLength = strnlen(clipboard->delegate.basePath, MAX_PATH);
-
-	if (baseLength < 1)
-		return NULL;
-
-	if (clipboard->delegate.ClientRequestFileSize)
-		nrDescriptors = (UINT32)(src[3] << 24) | (UINT32)(src[2] << 16) | (UINT32)(src[1] << 8) |
-		                (src[0] & 0xFF);
-
-	count = (*pSize - 4) / sizeof(FILEDESCRIPTOR);
-
-	if ((count < 1) || (count != nrDescriptors))
-		return NULL;
-
-	descriptors = (const FILEDESCRIPTOR*)&src[4];
-
-	if (formatId != ClipboardGetFormatId(clipboard, "FileGroupDescriptorW"))
-		return NULL;
-
-	alloc = 0;
-
-	/* Get total size of file names */
-	for (x = 0; x < count; x++)
-		alloc += _wcsnlen(descriptors[x].cFileName, ARRAYSIZE(descriptors[x].cFileName));
-
-	/* Append a prefix file:// and postfix \r\n for each file */
-	alloc += (sizeof("/\r\n") + baseLength) * count;
-	dst = calloc(alloc, sizeof(char));
-
-	if (!dst)
-		return NULL;
-
-	pos = 0;
-
-	for (x = 0; x < count; x++)
-	{
-		int rc;
-		const FILEDESCRIPTOR* cur = &descriptors[x];
-		size_t curLen = _wcsnlen(cur->cFileName, ARRAYSIZE(cur->cFileName));
-		char* curName = NULL;
-		rc = ConvertFromUnicode(CP_UTF8, 0, cur->cFileName, (int)curLen, &curName, 0, NULL, NULL);
-
-		if (rc != (int)curLen)
-		{
-			free(curName);
-			free(dst);
-			return NULL;
-		}
-
-		rc = _snprintf(&dst[pos], alloc - pos, "%s/%s\r\n", clipboard->delegate.basePath, curName);
-		free(curName);
-
-		if (rc < 0)
-		{
-			free(dst);
-			return NULL;
-		}
-
-		pos += (size_t)rc;
-	}
-
-	*pSize = (UINT32)alloc;
-	clipboard->fileListSequenceNumber = clipboard->sequenceNumber;
-	return dst;
-}
-
 static BOOL register_file_formats_and_synthesizers(wClipboard* clipboard)
 {
 	UINT32 file_group_format_id;
@@ -678,10 +594,6 @@
 	                                  convert_uri_list_to_filedescriptors))
 		goto error_free_local_files;
 
-	if (!ClipboardRegisterSynthesizer(clipboard, file_group_format_id, local_file_format_id,
-	                                  convert_filedescriptors_to_uri_list))
-		goto error_free_local_files;
-
 	return TRUE;
 error_free_local_files:
 	ArrayList_Free(clipboard->localFiles);
@@ -774,16 +686,13 @@
 	 * an accurate account of the current file offset and do not call
 	 * lseek() if the client requests file content sequentially.
 	 */
-	if (offset > INT64_MAX)
-		return ERROR_SEEK;
-
-	if (file->offset == (INT64)offset)
+	if (file->offset == offset)
 		return NO_ERROR;
 
 	WLog_VRB(TAG, "file %d force seeking to %" PRIu64 ", current %" PRIu64, file->fd, offset,
 	         file->offset);
 
-	if (lseek(file->fd, (off_t)offset, SEEK_SET) < 0)
+	if (lseek(file->fd, offset, SEEK_SET) < 0)
 	{
 		int err = errno;
 		WLog_ERR(TAG, "failed to seek file: %s", strerror(err));
diff -urN winpr/libwinpr/clipboard/test/TestClipboard.c ../../informatimago/FreeRDP/winpr/libwinpr/clipboard/test/TestClipboard.c
--- winpr/libwinpr/clipboard/test/TestClipboard.c	2019-07-25 20:17:16.421710651 +0300
+++ ../../informatimago/FreeRDP/winpr/libwinpr/clipboard/test/TestClipboard.c	2019-07-25 20:11:31.820001782 +0300
@@ -4,139 +4,147 @@
 #include <string.h> /* NOLINT */
 
 #if defined(_MSC_VER)
-#pragma warning(disable : 4996) /* deprecation */
+#	pragma warning(disable : 4996) /* deprecation */
 #endif
 
-
-
 /* Forward declare test functions. */
 int TestClipboardFormats(int, char*[]);
 
-
 #ifdef __cplusplus
-#define CM_CAST(TYPE, EXPR) static_cast<TYPE>(EXPR)
+#	define CM_CAST(TYPE, EXPR) static_cast<TYPE>(EXPR)
 #else
-#define CM_CAST(TYPE, EXPR) (TYPE)(EXPR)
+#	define CM_CAST(TYPE, EXPR) (TYPE)(EXPR)
 #endif
 
 /* Create map.  */
 
-typedef int (*MainFuncPointer)(int, char* []); /* NOLINT */
-typedef struct /* NOLINT */
+typedef int (*MainFuncPointer)(int, char*[]); /* NOLINT */
+typedef struct                                /* NOLINT */
 {
-  const char* name;
-  MainFuncPointer func;
+	const char* name;
+	MainFuncPointer func;
 } functionMapEntry;
 
 static functionMapEntry cmakeGeneratedFunctionMapEntries[] = {
-    {
-    "TestClipboardFormats",
-    TestClipboardFormats
-  },
+	{ "TestClipboardFormats", TestClipboardFormats },
 
-  { NULL, NULL } /* NOLINT */
+	{ NULL, NULL } /* NOLINT */
 };
 
-static const int NumTests = CM_CAST(int,
-  sizeof(cmakeGeneratedFunctionMapEntries) / sizeof(functionMapEntry)) - 1;
+static const int NumTests =
+    CM_CAST(int, sizeof(cmakeGeneratedFunctionMapEntries) / sizeof(functionMapEntry)) - 1;
 
 /* Allocate and create a lowercased copy of string
    (note that it has to be free'd manually) */
 static char* lowercase(const char* string)
 {
-  char *new_string, *p;
-  size_t stringSize;
+	char *new_string, *p;
+	size_t stringSize;
 
-  stringSize = CM_CAST(size_t, strlen(string) + 1);
-  new_string = CM_CAST(char*, malloc(sizeof(char) * stringSize));
+	stringSize = CM_CAST(size_t, strlen(string) + 1);
+	new_string = CM_CAST(char*, malloc(sizeof(char) * stringSize));
 
-  if (new_string == NULL) { /* NOLINT */
-    return NULL;            /* NOLINT */
-  }
-  strcpy(new_string, string);
-  for (p = new_string; *p != 0; ++p) {
-    *p = CM_CAST(char, tolower(*p));
-  }
-  return new_string;
+	if (new_string == NULL)
+	{                /* NOLINT */
+		return NULL; /* NOLINT */
+	}
+	strcpy(new_string, string);
+	for (p = new_string; *p != 0; ++p)
+	{
+		*p = CM_CAST(char, tolower(*p));
+	}
+	return new_string;
 }
 
 int main(int ac, char* av[])
 {
-  int i, testNum = 0, partial_match;
-  char *arg;
-  int testToRun = -1;
-
-  
-
-  /* If no test name was given */
-  /* process command line with user function.  */
-  if (ac < 2) {
-    /* Ask for a test.  */
-    printf("Available tests:\n");
-    for (i = 0; i < NumTests; ++i) {
-      printf("%3d. %s\n", i, cmakeGeneratedFunctionMapEntries[i].name);
-    }
-    printf("To run a test, enter the test number: ");
-    fflush(stdout);
-    if (scanf("%d", &testNum) != 1) {
-      printf("Couldn't parse that input as a number\n");
-      return -1;
-    }
-    if (testNum >= NumTests) {
-      printf("%3d is an invalid test number.\n", testNum);
-      return -1;
-    }
-    testToRun = testNum;
-    ac--;
-    av++;
-  }
-  partial_match = 0;
-  arg = NULL; /* NOLINT */
-  /* If partial match is requested.  */
-  if (testToRun == -1 && ac > 1) {
-    partial_match = (strcmp(av[1], "-R") == 0) ? 1 : 0;
-  }
-  if (partial_match != 0 && ac < 3) {
-    printf("-R needs an additional parameter.\n");
-    return -1;
-  }
-  if (testToRun == -1) {
-    arg = lowercase(av[1 + partial_match]);
-  }
-  for (i = 0; i < NumTests && testToRun == -1; ++i) {
-    char *test_name = lowercase(cmakeGeneratedFunctionMapEntries[i].name);
-    if (partial_match != 0 && strstr(test_name, arg) != NULL) { /* NOLINT */
-      testToRun = i;
-      ac -= 2;
-      av += 2;
-    } else if (partial_match == 0 && strcmp(test_name, arg) == 0) {
-      testToRun = i;
-      ac--;
-      av++;
-    }
-    free(test_name);
-  }
-  free(arg);
-  if (testToRun != -1) {
-    int result;
-
-    if (testToRun < 0 || testToRun >= NumTests) {
-      printf("testToRun was modified by TestDriver code to an invalid value: "
-             "%3d.\n",
-             testNum);
-      return -1;
-    }
-    result = (*cmakeGeneratedFunctionMapEntries[testToRun].func)(ac, av);
-
-    return result;
-  }
-
-  /* Nothing was run, display the test names.  */
-  printf("Available tests:\n");
-  for (i = 0; i < NumTests; ++i) {
-    printf("%3d. %s\n", i, cmakeGeneratedFunctionMapEntries[i].name);
-  }
-  printf("Failed: %s is an invalid test name.\n", av[1]);
+	int i, testNum = 0, partial_match;
+	char* arg;
+	int testToRun = -1;
+
+	/* If no test name was given */
+	/* process command line with user function.  */
+	if (ac < 2)
+	{
+		/* Ask for a test.  */
+		printf("Available tests:\n");
+		for (i = 0; i < NumTests; ++i)
+		{
+			printf("%3d. %s\n", i, cmakeGeneratedFunctionMapEntries[i].name);
+		}
+		printf("To run a test, enter the test number: ");
+		fflush(stdout);
+		if (scanf("%d", &testNum) != 1)
+		{
+			printf("Couldn't parse that input as a number\n");
+			return -1;
+		}
+		if (testNum >= NumTests)
+		{
+			printf("%3d is an invalid test number.\n", testNum);
+			return -1;
+		}
+		testToRun = testNum;
+		ac--;
+		av++;
+	}
+	partial_match = 0;
+	arg = NULL; /* NOLINT */
+	/* If partial match is requested.  */
+	if (testToRun == -1 && ac > 1)
+	{
+		partial_match = (strcmp(av[1], "-R") == 0) ? 1 : 0;
+	}
+	if (partial_match != 0 && ac < 3)
+	{
+		printf("-R needs an additional parameter.\n");
+		return -1;
+	}
+	if (testToRun == -1)
+	{
+		arg = lowercase(av[1 + partial_match]);
+	}
+	for (i = 0; i < NumTests && testToRun == -1; ++i)
+	{
+		char* test_name = lowercase(cmakeGeneratedFunctionMapEntries[i].name);
+		if (partial_match != 0 && strstr(test_name, arg) != NULL)
+		{ /* NOLINT */
+			testToRun = i;
+			ac -= 2;
+			av += 2;
+		}
+		else if (partial_match == 0 && strcmp(test_name, arg) == 0)
+		{
+			testToRun = i;
+			ac--;
+			av++;
+		}
+		free(test_name);
+	}
+	free(arg);
+	if (testToRun != -1)
+	{
+		int result;
+
+		if (testToRun < 0 || testToRun >= NumTests)
+		{
+			printf("testToRun was modified by TestDriver code to an invalid value: "
+			       "%3d.\n",
+			       testNum);
+			return -1;
+		}
+		result = (*cmakeGeneratedFunctionMapEntries[testToRun].func)(ac, av);
+
+		return result;
+	}
+
+	/* Nothing was run, display the test names.  */
+	printf("Available tests:\n");
+	for (i = 0; i < NumTests; ++i)
+	{
+		printf("%3d. %s\n", i, cmakeGeneratedFunctionMapEntries[i].name);
+	}
+	printf("Failed: %s is an invalid test name.\n", av[1]);
 
-  return -1;
+	return -1;
 }
diff -urN winpr/libwinpr/CMakeLists.txt ../../informatimago/FreeRDP/winpr/libwinpr/CMakeLists.txt
--- winpr/libwinpr/CMakeLists.txt	2019-07-24 06:11:52.530197868 +0300
+++ ../../informatimago/FreeRDP/winpr/libwinpr/CMakeLists.txt	2019-07-19 20:00:34.137156343 +0300
@@ -19,8 +19,7 @@
 
 set(WINPR_DIR ${CMAKE_CURRENT_SOURCE_DIR})
 set(WINPR_SRCS "")
-set(WINPR_LIBS_PRIVATE "")
-set(WINPR_LIBS_PUBLIC "")
+set(WINPR_LIBS "")
 set(WINPR_INCLUDES "")
 set(WINPR_DEFINITIONS "")
 
@@ -56,18 +55,11 @@
     endif()
 endmacro()
 
-macro (winpr_library_add_private)
+macro (winpr_library_add)
     foreach (_lib ${ARGN})
-            list (APPEND WINPR_LIBS_PRIVATE "${_lib}")
+            list (APPEND WINPR_LIBS "${_lib}")
     endforeach()
-     set (WINPR_LIBS_PRIVATE ${WINPR_LIBS_PRIVATE} PARENT_SCOPE)
-endmacro()
-
-macro (winpr_library_add_public)
-    foreach (_lib ${ARGN})
-            list (APPEND WINPR_LIBS_PUBLIC "${_lib}")
-    endforeach()
-     set (WINPR_LIBS_PUBLIC ${WINPR_LIBS_PUBLIC} PARENT_SCOPE)
+     set (WINPR_LIBS ${WINPR_LIBS} PARENT_SCOPE)
 endmacro()
 
 macro (winpr_definition_add)
@@ -84,11 +76,11 @@
 check_function_exists(timer_gettime TIMER_GETTIME)
 if (TIMER_CREATE AND TIMER_DELETE AND TIMER_SETTIME AND TIMER_GETTIME)
     add_definitions(-DWITH_POSIX_TIMER)
-	winpr_library_add_private(rt)
+	winpr_library_add(rt)
 endif()
 
 if (ANDROID)
-    winpr_library_add_private(log)
+    winpr_library_add(log)
 endif()
 
 # Level "1" API as defined for MinCore.lib
@@ -111,8 +103,7 @@
 
 set(MODULE_NAME winpr)
 list(REMOVE_DUPLICATES WINPR_DEFINITIONS)
-list(REMOVE_DUPLICATES WINPR_LIBS_PRIVATE)
-list(REMOVE_DUPLICATES WINPR_LIBS_PUBLIC)
+list(REMOVE_DUPLICATES WINPR_LIBS)
 list(REMOVE_DUPLICATES WINPR_INCLUDES)
 include_directories(${WINPR_INCLUDES})
 
@@ -130,7 +121,7 @@
     @ONLY)
 
   set (WINPR_SRCS ${WINPR_SRCS} ${CMAKE_CURRENT_BINARY_DIR}/version.rc)
-  winpr_library_add_public("shlwapi")
+  list(APPEND WINPR_LIBS "Shlwapi")
 endif()
 
 add_library(${MODULE_NAME} ${WINPR_SRCS})
@@ -141,7 +132,11 @@
 endif()
 
 add_definitions(${WINPR_DEFINITIONS})
-target_link_libraries(${MODULE_NAME} ${PRIVATE_KEYWORD} ${WINPR_LIBS_PRIVATE} ${PUBLIC_KEYWORD} ${WINPR_LIBS_PUBLIC})
+if (WIN32)
+	target_link_libraries(${MODULE_NAME} ${PUBLIC_KEYWORD} ${WINPR_LIBS})
+else()
+	target_link_libraries(${MODULE_NAME} ${PRIVATE_KEYWORD} ${WINPR_LIBS})
+endif(WIN32)
 install(TARGETS ${MODULE_NAME} DESTINATION ${CMAKE_INSTALL_LIBDIR} COMPONENT libraries EXPORT WinPRTargets)
 if (WITH_DEBUG_SYMBOLS AND MSVC AND BUILD_SHARED_LIBS)
     get_target_property(OUTPUT_FILENAME ${MODULE_NAME} OUTPUT_NAME)
diff -urN winpr/libwinpr/com/test/TestCom.c ../../informatimago/FreeRDP/winpr/libwinpr/com/test/TestCom.c
--- winpr/libwinpr/com/test/TestCom.c	2019-07-25 20:17:16.389710492 +0300
+++ ../../informatimago/FreeRDP/winpr/libwinpr/com/test/TestCom.c	2019-07-25 20:11:31.828001821 +0300
@@ -4,139 +4,147 @@
 #include <string.h> /* NOLINT */
 
 #if defined(_MSC_VER)
-#pragma warning(disable : 4996) /* deprecation */
+#	pragma warning(disable : 4996) /* deprecation */
 #endif
 
-
-
 /* Forward declare test functions. */
 int TestComReference(int, char*[]);
 
-
 #ifdef __cplusplus
-#define CM_CAST(TYPE, EXPR) static_cast<TYPE>(EXPR)
+#	define CM_CAST(TYPE, EXPR) static_cast<TYPE>(EXPR)
 #else
-#define CM_CAST(TYPE, EXPR) (TYPE)(EXPR)
+#	define CM_CAST(TYPE, EXPR) (TYPE)(EXPR)
 #endif
 
 /* Create map.  */
 
-typedef int (*MainFuncPointer)(int, char* []); /* NOLINT */
-typedef struct /* NOLINT */
+typedef int (*MainFuncPointer)(int, char*[]); /* NOLINT */
+typedef struct                                /* NOLINT */
 {
-  const char* name;
-  MainFuncPointer func;
+	const char* name;
+	MainFuncPointer func;
 } functionMapEntry;
 
 static functionMapEntry cmakeGeneratedFunctionMapEntries[] = {
-    {
-    "TestComReference",
-    TestComReference
-  },
+	{ "TestComReference", TestComReference },
 
-  { NULL, NULL } /* NOLINT */
+	{ NULL, NULL } /* NOLINT */
 };
 
-static const int NumTests = CM_CAST(int,
-  sizeof(cmakeGeneratedFunctionMapEntries) / sizeof(functionMapEntry)) - 1;
+static const int NumTests =
+    CM_CAST(int, sizeof(cmakeGeneratedFunctionMapEntries) / sizeof(functionMapEntry)) - 1;
 
 /* Allocate and create a lowercased copy of string
    (note that it has to be free'd manually) */
 static char* lowercase(const char* string)
 {
-  char *new_string, *p;
-  size_t stringSize;
+	char *new_string, *p;
+	size_t stringSize;
 
-  stringSize = CM_CAST(size_t, strlen(string) + 1);
-  new_string = CM_CAST(char*, malloc(sizeof(char) * stringSize));
+	stringSize = CM_CAST(size_t, strlen(string) + 1);
+	new_string = CM_CAST(char*, malloc(sizeof(char) * stringSize));
 
-  if (new_string == NULL) { /* NOLINT */
-    return NULL;            /* NOLINT */
-  }
-  strcpy(new_string, string);
-  for (p = new_string; *p != 0; ++p) {
-    *p = CM_CAST(char, tolower(*p));
-  }
-  return new_string;
+	if (new_string == NULL)
+	{                /* NOLINT */
+		return NULL; /* NOLINT */
+	}
+	strcpy(new_string, string);
+	for (p = new_string; *p != 0; ++p)
+	{
+		*p = CM_CAST(char, tolower(*p));
+	}
+	return new_string;
 }
 
 int main(int ac, char* av[])
 {
-  int i, testNum = 0, partial_match;
-  char *arg;
-  int testToRun = -1;
-
-  
-
-  /* If no test name was given */
-  /* process command line with user function.  */
-  if (ac < 2) {
-    /* Ask for a test.  */
-    printf("Available tests:\n");
-    for (i = 0; i < NumTests; ++i) {
-      printf("%3d. %s\n", i, cmakeGeneratedFunctionMapEntries[i].name);
-    }
-    printf("To run a test, enter the test number: ");
-    fflush(stdout);
-    if (scanf("%d", &testNum) != 1) {
-      printf("Couldn't parse that input as a number\n");
-      return -1;
-    }
-    if (testNum >= NumTests) {
-      printf("%3d is an invalid test number.\n", testNum);
-      return -1;
-    }
-    testToRun = testNum;
-    ac--;
-    av++;
-  }
-  partial_match = 0;
-  arg = NULL; /* NOLINT */
-  /* If partial match is requested.  */
-  if (testToRun == -1 && ac > 1) {
-    partial_match = (strcmp(av[1], "-R") == 0) ? 1 : 0;
-  }
-  if (partial_match != 0 && ac < 3) {
-    printf("-R needs an additional parameter.\n");
-    return -1;
-  }
-  if (testToRun == -1) {
-    arg = lowercase(av[1 + partial_match]);
-  }
-  for (i = 0; i < NumTests && testToRun == -1; ++i) {
-    char *test_name = lowercase(cmakeGeneratedFunctionMapEntries[i].name);
-    if (partial_match != 0 && strstr(test_name, arg) != NULL) { /* NOLINT */
-      testToRun = i;
-      ac -= 2;
-      av += 2;
-    } else if (partial_match == 0 && strcmp(test_name, arg) == 0) {
-      testToRun = i;
-      ac--;
-      av++;
-    }
-    free(test_name);
-  }
-  free(arg);
-  if (testToRun != -1) {
-    int result;
-
-    if (testToRun < 0 || testToRun >= NumTests) {
-      printf("testToRun was modified by TestDriver code to an invalid value: "
-             "%3d.\n",
-             testNum);
-      return -1;
-    }
-    result = (*cmakeGeneratedFunctionMapEntries[testToRun].func)(ac, av);
-
-    return result;
-  }
-
-  /* Nothing was run, display the test names.  */
-  printf("Available tests:\n");
-  for (i = 0; i < NumTests; ++i) {
-    printf("%3d. %s\n", i, cmakeGeneratedFunctionMapEntries[i].name);
-  }
-  printf("Failed: %s is an invalid test name.\n", av[1]);
+	int i, testNum = 0, partial_match;
+	char* arg;
+	int testToRun = -1;
+
+	/* If no test name was given */
+	/* process command line with user function.  */
+	if (ac < 2)
+	{
+		/* Ask for a test.  */
+		printf("Available tests:\n");
+		for (i = 0; i < NumTests; ++i)
+		{
+			printf("%3d. %s\n", i, cmakeGeneratedFunctionMapEntries[i].name);
+		}
+		printf("To run a test, enter the test number: ");
+		fflush(stdout);
+		if (scanf("%d", &testNum) != 1)
+		{
+			printf("Couldn't parse that input as a number\n");
+			return -1;
+		}
+		if (testNum >= NumTests)
+		{
+			printf("%3d is an invalid test number.\n", testNum);
+			return -1;
+		}
+		testToRun = testNum;
+		ac--;
+		av++;
+	}
+	partial_match = 0;
+	arg = NULL; /* NOLINT */
+	/* If partial match is requested.  */
+	if (testToRun == -1 && ac > 1)
+	{
+		partial_match = (strcmp(av[1], "-R") == 0) ? 1 : 0;
+	}
+	if (partial_match != 0 && ac < 3)
+	{
+		printf("-R needs an additional parameter.\n");
+		return -1;
+	}
+	if (testToRun == -1)
+	{
+		arg = lowercase(av[1 + partial_match]);
+	}
+	for (i = 0; i < NumTests && testToRun == -1; ++i)
+	{
+		char* test_name = lowercase(cmakeGeneratedFunctionMapEntries[i].name);
+		if (partial_match != 0 && strstr(test_name, arg) != NULL)
+		{ /* NOLINT */
+			testToRun = i;
+			ac -= 2;
+			av += 2;
+		}
+		else if (partial_match == 0 && strcmp(test_name, arg) == 0)
+		{
+			testToRun = i;
+			ac--;
+			av++;
+		}
+		free(test_name);
+	}
+	free(arg);
+	if (testToRun != -1)
+	{
+		int result;
+
+		if (testToRun < 0 || testToRun >= NumTests)
+		{
+			printf("testToRun was modified by TestDriver code to an invalid value: "
+			       "%3d.\n",
+			       testNum);
+			return -1;
+		}
+		result = (*cmakeGeneratedFunctionMapEntries[testToRun].func)(ac, av);
+
+		return result;
+	}
+
+	/* Nothing was run, display the test names.  */
+	printf("Available tests:\n");
+	for (i = 0; i < NumTests; ++i)
+	{
+		printf("%3d. %s\n", i, cmakeGeneratedFunctionMapEntries[i].name);
+	}
+	printf("Failed: %s is an invalid test name.\n", av[1]);
 
-  return -1;
+	return -1;
 }
diff -urN winpr/libwinpr/comm/comm.c ../../informatimago/FreeRDP/winpr/libwinpr/comm/comm.c
--- winpr/libwinpr/comm/comm.c	2019-07-25 19:51:08.001932825 +0300
+++ ../../informatimago/FreeRDP/winpr/libwinpr/comm/comm.c	2019-07-25 20:11:31.848001920 +0300
@@ -125,14 +125,14 @@
 	return TRUE;
 }
 
-void CommLog_Print(DWORD level, ...)
+void CommLog_Print(DWORD level, const char* format, ...)
 {
 	if (!CommInitialized())
 		return;
 
 	va_list ap;
-	va_start(ap, level);
-	WLog_PrintVA(_Log, level, ap);
+	va_start(ap, format);
+	WLog_PrintVA(_Log, level, format, ap);
 	va_end(ap);
 }
 
diff -urN winpr/libwinpr/comm/comm.h ../../informatimago/FreeRDP/winpr/libwinpr/comm/comm.h
--- winpr/libwinpr/comm/comm.h	2019-07-25 19:51:08.005932845 +0300
+++ ../../informatimago/FreeRDP/winpr/libwinpr/comm/comm.h	2019-07-25 20:11:31.848001920 +0300
@@ -94,7 +94,7 @@
 #	define FREERDP_PURGE_TXABORT 0x00000001 /* abort pending transmission */
 #	define FREERDP_PURGE_RXABORT 0x00000002 /* abort pending reception */
 
-void CommLog_Print(DWORD wlog_level, ...);
+void CommLog_Print(DWORD wlog_level, const char* format, ...);
 
 BOOL CommIsHandled(HANDLE handle);
 BOOL CommCloseHandle(HANDLE handle);
diff -urN winpr/libwinpr/comm/comm_serial_sys.c ../../informatimago/FreeRDP/winpr/libwinpr/comm/comm_serial_sys.c
--- winpr/libwinpr/comm/comm_serial_sys.c	2019-07-25 19:51:08.061933123 +0300
+++ ../../informatimago/FreeRDP/winpr/libwinpr/comm/comm_serial_sys.c	2019-07-25 20:11:31.908002218 +0300
@@ -1508,10 +1508,7 @@
 BOOL _config_size(WINPR_COMM* pComm, ULONG* pSize)
 {
 	/* http://msdn.microsoft.com/en-us/library/ff546548%28v=vs.85%29.aspx */
-	if (!pSize)
-		return FALSE;
-
-	*pSize = 0;
+	pSize = 0;
 	return TRUE;
 }
 
diff -urN winpr/libwinpr/credui/CMakeLists.txt ../../informatimago/FreeRDP/winpr/libwinpr/credui/CMakeLists.txt
--- winpr/libwinpr/credui/CMakeLists.txt	2019-07-24 06:11:52.534197888 +0300
+++ ../../informatimago/FreeRDP/winpr/libwinpr/credui/CMakeLists.txt	2019-07-19 20:00:17.493205441 +0300
@@ -18,7 +18,7 @@
 winpr_module_add(credui.c)
 
 if(WIN32)
-	winpr_library_add_public(credui)
+	winpr_library_add(credui)
 endif()
 
 if(BUILD_TESTING)
diff -urN winpr/libwinpr/credui/test/TestCredUI.c ../../informatimago/FreeRDP/winpr/libwinpr/credui/test/TestCredUI.c
--- winpr/libwinpr/credui/test/TestCredUI.c	2019-07-25 20:17:16.409710592 +0300
+++ ../../informatimago/FreeRDP/winpr/libwinpr/credui/test/TestCredUI.c	2019-07-25 20:11:31.940002376 +0300
@@ -4,154 +4,153 @@
 #include <string.h> /* NOLINT */
 
 #if defined(_MSC_VER)
-#pragma warning(disable : 4996) /* deprecation */
+#	pragma warning(disable : 4996) /* deprecation */
 #endif
 
-
-
 /* Forward declare test functions. */
 int TestCredUIParseUserName(int, char*[]);
 int TestCredUIConfirmCredentials(int, char*[]);
 int TestCredUIPromptForCredentials(int, char*[]);
 int TestCredUICmdLinePromptForCredentials(int, char*[]);
 
-
 #ifdef __cplusplus
-#define CM_CAST(TYPE, EXPR) static_cast<TYPE>(EXPR)
+#	define CM_CAST(TYPE, EXPR) static_cast<TYPE>(EXPR)
 #else
-#define CM_CAST(TYPE, EXPR) (TYPE)(EXPR)
+#	define CM_CAST(TYPE, EXPR) (TYPE)(EXPR)
 #endif
 
 /* Create map.  */
 
-typedef int (*MainFuncPointer)(int, char* []); /* NOLINT */
-typedef struct /* NOLINT */
+typedef int (*MainFuncPointer)(int, char*[]); /* NOLINT */
+typedef struct                                /* NOLINT */
 {
-  const char* name;
-  MainFuncPointer func;
+	const char* name;
+	MainFuncPointer func;
 } functionMapEntry;
 
 static functionMapEntry cmakeGeneratedFunctionMapEntries[] = {
-    {
-    "TestCredUIParseUserName",
-    TestCredUIParseUserName
-  },
-  {
-    "TestCredUIConfirmCredentials",
-    TestCredUIConfirmCredentials
-  },
-  {
-    "TestCredUIPromptForCredentials",
-    TestCredUIPromptForCredentials
-  },
-  {
-    "TestCredUICmdLinePromptForCredentials",
-    TestCredUICmdLinePromptForCredentials
-  },
+	{ "TestCredUIParseUserName", TestCredUIParseUserName },
+	{ "TestCredUIConfirmCredentials", TestCredUIConfirmCredentials },
+	{ "TestCredUIPromptForCredentials", TestCredUIPromptForCredentials },
+	{ "TestCredUICmdLinePromptForCredentials", TestCredUICmdLinePromptForCredentials },
 
-  { NULL, NULL } /* NOLINT */
+	{ NULL, NULL } /* NOLINT */
 };
 
-static const int NumTests = CM_CAST(int,
-  sizeof(cmakeGeneratedFunctionMapEntries) / sizeof(functionMapEntry)) - 1;
+static const int NumTests =
+    CM_CAST(int, sizeof(cmakeGeneratedFunctionMapEntries) / sizeof(functionMapEntry)) - 1;
 
 /* Allocate and create a lowercased copy of string
    (note that it has to be free'd manually) */
 static char* lowercase(const char* string)
 {
-  char *new_string, *p;
-  size_t stringSize;
+	char *new_string, *p;
+	size_t stringSize;
 
-  stringSize = CM_CAST(size_t, strlen(string) + 1);
-  new_string = CM_CAST(char*, malloc(sizeof(char) * stringSize));
+	stringSize = CM_CAST(size_t, strlen(string) + 1);
+	new_string = CM_CAST(char*, malloc(sizeof(char) * stringSize));
 
-  if (new_string == NULL) { /* NOLINT */
-    return NULL;            /* NOLINT */
-  }
-  strcpy(new_string, string);
-  for (p = new_string; *p != 0; ++p) {
-    *p = CM_CAST(char, tolower(*p));
-  }
-  return new_string;
+	if (new_string == NULL)
+	{                /* NOLINT */
+		return NULL; /* NOLINT */
+	}
+	strcpy(new_string, string);
+	for (p = new_string; *p != 0; ++p)
+	{
+		*p = CM_CAST(char, tolower(*p));
+	}
+	return new_string;
 }
 
 int main(int ac, char* av[])
 {
-  int i, testNum = 0, partial_match;
-  char *arg;
-  int testToRun = -1;
-
-  
-
-  /* If no test name was given */
-  /* process command line with user function.  */
-  if (ac < 2) {
-    /* Ask for a test.  */
-    printf("Available tests:\n");
-    for (i = 0; i < NumTests; ++i) {
-      printf("%3d. %s\n", i, cmakeGeneratedFunctionMapEntries[i].name);
-    }
-    printf("To run a test, enter the test number: ");
-    fflush(stdout);
-    if (scanf("%d", &testNum) != 1) {
-      printf("Couldn't parse that input as a number\n");
-      return -1;
-    }
-    if (testNum >= NumTests) {
-      printf("%3d is an invalid test number.\n", testNum);
-      return -1;
-    }
-    testToRun = testNum;
-    ac--;
-    av++;
-  }
-  partial_match = 0;
-  arg = NULL; /* NOLINT */
-  /* If partial match is requested.  */
-  if (testToRun == -1 && ac > 1) {
-    partial_match = (strcmp(av[1], "-R") == 0) ? 1 : 0;
-  }
-  if (partial_match != 0 && ac < 3) {
-    printf("-R needs an additional parameter.\n");
-    return -1;
-  }
-  if (testToRun == -1) {
-    arg = lowercase(av[1 + partial_match]);
-  }
-  for (i = 0; i < NumTests && testToRun == -1; ++i) {
-    char *test_name = lowercase(cmakeGeneratedFunctionMapEntries[i].name);
-    if (partial_match != 0 && strstr(test_name, arg) != NULL) { /* NOLINT */
-      testToRun = i;
-      ac -= 2;
-      av += 2;
-    } else if (partial_match == 0 && strcmp(test_name, arg) == 0) {
-      testToRun = i;
-      ac--;
-      av++;
-    }
-    free(test_name);
-  }
-  free(arg);
-  if (testToRun != -1) {
-    int result;
-
-    if (testToRun < 0 || testToRun >= NumTests) {
-      printf("testToRun was modified by TestDriver code to an invalid value: "
-             "%3d.\n",
-             testNum);
-      return -1;
-    }
-    result = (*cmakeGeneratedFunctionMapEntries[testToRun].func)(ac, av);
-
-    return result;
-  }
-
-  /* Nothing was run, display the test names.  */
-  printf("Available tests:\n");
-  for (i = 0; i < NumTests; ++i) {
-    printf("%3d. %s\n", i, cmakeGeneratedFunctionMapEntries[i].name);
-  }
-  printf("Failed: %s is an invalid test name.\n", av[1]);
+	int i, testNum = 0, partial_match;
+	char* arg;
+	int testToRun = -1;
+
+	/* If no test name was given */
+	/* process command line with user function.  */
+	if (ac < 2)
+	{
+		/* Ask for a test.  */
+		printf("Available tests:\n");
+		for (i = 0; i < NumTests; ++i)
+		{
+			printf("%3d. %s\n", i, cmakeGeneratedFunctionMapEntries[i].name);
+		}
+		printf("To run a test, enter the test number: ");
+		fflush(stdout);
+		if (scanf("%d", &testNum) != 1)
+		{
+			printf("Couldn't parse that input as a number\n");
+			return -1;
+		}
+		if (testNum >= NumTests)
+		{
+			printf("%3d is an invalid test number.\n", testNum);
+			return -1;
+		}
+		testToRun = testNum;
+		ac--;
+		av++;
+	}
+	partial_match = 0;
+	arg = NULL; /* NOLINT */
+	/* If partial match is requested.  */
+	if (testToRun == -1 && ac > 1)
+	{
+		partial_match = (strcmp(av[1], "-R") == 0) ? 1 : 0;
+	}
+	if (partial_match != 0 && ac < 3)
+	{
+		printf("-R needs an additional parameter.\n");
+		return -1;
+	}
+	if (testToRun == -1)
+	{
+		arg = lowercase(av[1 + partial_match]);
+	}
+	for (i = 0; i < NumTests && testToRun == -1; ++i)
+	{
+		char* test_name = lowercase(cmakeGeneratedFunctionMapEntries[i].name);
+		if (partial_match != 0 && strstr(test_name, arg) != NULL)
+		{ /* NOLINT */
+			testToRun = i;
+			ac -= 2;
+			av += 2;
+		}
+		else if (partial_match == 0 && strcmp(test_name, arg) == 0)
+		{
+			testToRun = i;
+			ac--;
+			av++;
+		}
+		free(test_name);
+	}
+	free(arg);
+	if (testToRun != -1)
+	{
+		int result;
+
+		if (testToRun < 0 || testToRun >= NumTests)
+		{
+			printf("testToRun was modified by TestDriver code to an invalid value: "
+			       "%3d.\n",
+			       testNum);
+			return -1;
+		}
+		result = (*cmakeGeneratedFunctionMapEntries[testToRun].func)(ac, av);
+
+		return result;
+	}
+
+	/* Nothing was run, display the test names.  */
+	printf("Available tests:\n");
+	for (i = 0; i < NumTests; ++i)
+	{
+		printf("%3d. %s\n", i, cmakeGeneratedFunctionMapEntries[i].name);
+	}
+	printf("Failed: %s is an invalid test name.\n", av[1]);
 
-  return -1;
+	return -1;
 }
diff -urN winpr/libwinpr/crt/CMakeLists.txt ../../informatimago/FreeRDP/winpr/libwinpr/crt/CMakeLists.txt
--- winpr/libwinpr/crt/CMakeLists.txt	2019-07-24 06:11:52.534197888 +0300
+++ ../../informatimago/FreeRDP/winpr/libwinpr/crt/CMakeLists.txt	2019-07-19 20:00:17.493205441 +0300
@@ -31,7 +31,7 @@
 if (WITH_ICU)
 	find_package(ICU REQUIRED i18n uc io)
 	include_directories(${ICU_INCLUDE_DIRS})
-	winpr_library_add_private(${ICU_LIBRARIES})
+	winpr_library_add(${ICU_LIBRARIES})
 endif (WITH_ICU)
 
 winpr_module_add(${CRT_FILES})
diff -urN winpr/libwinpr/crt/conversion.c ../../informatimago/FreeRDP/winpr/libwinpr/crt/conversion.c
--- winpr/libwinpr/crt/conversion.c	2019-07-25 19:51:08.557935582 +0300
+++ ../../informatimago/FreeRDP/winpr/libwinpr/crt/conversion.c	2019-07-25 20:11:32.400004658 +0300
@@ -33,10 +33,7 @@
 	int length;
 	length = sprintf_s(NULL, 0, "%d", value);
 
-	if (length < 0)
-		return -1;
-
-	if (sizeInCharacters < (size_t)length)
+	if (sizeInCharacters < length)
 		return -1;
 
 	sprintf_s(buffer, length + 1, "%d", value);
diff -urN winpr/libwinpr/crt/test/TestCrt.c ../../informatimago/FreeRDP/winpr/libwinpr/crt/test/TestCrt.c
--- winpr/libwinpr/crt/test/TestCrt.c	2019-07-25 20:17:16.405710571 +0300
+++ ../../informatimago/FreeRDP/winpr/libwinpr/crt/test/TestCrt.c	2019-07-25 20:11:32.420004756 +0300
@@ -4,11 +4,9 @@
 #include <string.h> /* NOLINT */
 
 #if defined(_MSC_VER)
-#pragma warning(disable : 4996) /* deprecation */
+#	pragma warning(disable : 4996) /* deprecation */
 #endif
 
-
-
 /* Forward declare test functions. */
 int TestTypes(int, char*[]);
 int TestFormatSpecifiers(int, char*[]);
@@ -16,147 +14,145 @@
 int TestString(int, char*[]);
 int TestUnicodeConversion(int, char*[]);
 
-
 #ifdef __cplusplus
-#define CM_CAST(TYPE, EXPR) static_cast<TYPE>(EXPR)
+#	define CM_CAST(TYPE, EXPR) static_cast<TYPE>(EXPR)
 #else
-#define CM_CAST(TYPE, EXPR) (TYPE)(EXPR)
+#	define CM_CAST(TYPE, EXPR) (TYPE)(EXPR)
 #endif
 
 /* Create map.  */
 
-typedef int (*MainFuncPointer)(int, char* []); /* NOLINT */
-typedef struct /* NOLINT */
+typedef int (*MainFuncPointer)(int, char*[]); /* NOLINT */
+typedef struct                                /* NOLINT */
 {
-  const char* name;
-  MainFuncPointer func;
+	const char* name;
+	MainFuncPointer func;
 } functionMapEntry;
 
 static functionMapEntry cmakeGeneratedFunctionMapEntries[] = {
-    {
-    "TestTypes",
-    TestTypes
-  },
-  {
-    "TestFormatSpecifiers",
-    TestFormatSpecifiers
-  },
-  {
-    "TestAlignment",
-    TestAlignment
-  },
-  {
-    "TestString",
-    TestString
-  },
-  {
-    "TestUnicodeConversion",
-    TestUnicodeConversion
-  },
+	{ "TestTypes", TestTypes },
+	{ "TestFormatSpecifiers", TestFormatSpecifiers },
+	{ "TestAlignment", TestAlignment },
+	{ "TestString", TestString },
+	{ "TestUnicodeConversion", TestUnicodeConversion },
 
-  { NULL, NULL } /* NOLINT */
+	{ NULL, NULL } /* NOLINT */
 };
 
-static const int NumTests = CM_CAST(int,
-  sizeof(cmakeGeneratedFunctionMapEntries) / sizeof(functionMapEntry)) - 1;
+static const int NumTests =
+    CM_CAST(int, sizeof(cmakeGeneratedFunctionMapEntries) / sizeof(functionMapEntry)) - 1;
 
 /* Allocate and create a lowercased copy of string
    (note that it has to be free'd manually) */
 static char* lowercase(const char* string)
 {
-  char *new_string, *p;
-  size_t stringSize;
+	char *new_string, *p;
+	size_t stringSize;
 
-  stringSize = CM_CAST(size_t, strlen(string) + 1);
-  new_string = CM_CAST(char*, malloc(sizeof(char) * stringSize));
+	stringSize = CM_CAST(size_t, strlen(string) + 1);
+	new_string = CM_CAST(char*, malloc(sizeof(char) * stringSize));
 
-  if (new_string == NULL) { /* NOLINT */
-    return NULL;            /* NOLINT */
-  }
-  strcpy(new_string, string);
-  for (p = new_string; *p != 0; ++p) {
-    *p = CM_CAST(char, tolower(*p));
-  }
-  return new_string;
+	if (new_string == NULL)
+	{                /* NOLINT */
+		return NULL; /* NOLINT */
+	}
+	strcpy(new_string, string);
+	for (p = new_string; *p != 0; ++p)
+	{
+		*p = CM_CAST(char, tolower(*p));
+	}
+	return new_string;
 }
 
 int main(int ac, char* av[])
 {
-  int i, testNum = 0, partial_match;
-  char *arg;
-  int testToRun = -1;
-
-  
-
-  /* If no test name was given */
-  /* process command line with user function.  */
-  if (ac < 2) {
-    /* Ask for a test.  */
-    printf("Available tests:\n");
-    for (i = 0; i < NumTests; ++i) {
-      printf("%3d. %s\n", i, cmakeGeneratedFunctionMapEntries[i].name);
-    }
-    printf("To run a test, enter the test number: ");
-    fflush(stdout);
-    if (scanf("%d", &testNum) != 1) {
-      printf("Couldn't parse that input as a number\n");
-      return -1;
-    }
-    if (testNum >= NumTests) {
-      printf("%3d is an invalid test number.\n", testNum);
-      return -1;
-    }
-    testToRun = testNum;
-    ac--;
-    av++;
-  }
-  partial_match = 0;
-  arg = NULL; /* NOLINT */
-  /* If partial match is requested.  */
-  if (testToRun == -1 && ac > 1) {
-    partial_match = (strcmp(av[1], "-R") == 0) ? 1 : 0;
-  }
-  if (partial_match != 0 && ac < 3) {
-    printf("-R needs an additional parameter.\n");
-    return -1;
-  }
-  if (testToRun == -1) {
-    arg = lowercase(av[1 + partial_match]);
-  }
-  for (i = 0; i < NumTests && testToRun == -1; ++i) {
-    char *test_name = lowercase(cmakeGeneratedFunctionMapEntries[i].name);
-    if (partial_match != 0 && strstr(test_name, arg) != NULL) { /* NOLINT */
-      testToRun = i;
-      ac -= 2;
-      av += 2;
-    } else if (partial_match == 0 && strcmp(test_name, arg) == 0) {
-      testToRun = i;
-      ac--;
-      av++;
-    }
-    free(test_name);
-  }
-  free(arg);
-  if (testToRun != -1) {
-    int result;
-
-    if (testToRun < 0 || testToRun >= NumTests) {
-      printf("testToRun was modified by TestDriver code to an invalid value: "
-             "%3d.\n",
-             testNum);
-      return -1;
-    }
-    result = (*cmakeGeneratedFunctionMapEntries[testToRun].func)(ac, av);
-
-    return result;
-  }
-
-  /* Nothing was run, display the test names.  */
-  printf("Available tests:\n");
-  for (i = 0; i < NumTests; ++i) {
-    printf("%3d. %s\n", i, cmakeGeneratedFunctionMapEntries[i].name);
-  }
-  printf("Failed: %s is an invalid test name.\n", av[1]);
+	int i, testNum = 0, partial_match;
+	char* arg;
+	int testToRun = -1;
+
+	/* If no test name was given */
+	/* process command line with user function.  */
+	if (ac < 2)
+	{
+		/* Ask for a test.  */
+		printf("Available tests:\n");
+		for (i = 0; i < NumTests; ++i)
+		{
+			printf("%3d. %s\n", i, cmakeGeneratedFunctionMapEntries[i].name);
+		}
+		printf("To run a test, enter the test number: ");
+		fflush(stdout);
+		if (scanf("%d", &testNum) != 1)
+		{
+			printf("Couldn't parse that input as a number\n");
+			return -1;
+		}
+		if (testNum >= NumTests)
+		{
+			printf("%3d is an invalid test number.\n", testNum);
+			return -1;
+		}
+		testToRun = testNum;
+		ac--;
+		av++;
+	}
+	partial_match = 0;
+	arg = NULL; /* NOLINT */
+	/* If partial match is requested.  */
+	if (testToRun == -1 && ac > 1)
+	{
+		partial_match = (strcmp(av[1], "-R") == 0) ? 1 : 0;
+	}
+	if (partial_match != 0 && ac < 3)
+	{
+		printf("-R needs an additional parameter.\n");
+		return -1;
+	}
+	if (testToRun == -1)
+	{
+		arg = lowercase(av[1 + partial_match]);
+	}
+	for (i = 0; i < NumTests && testToRun == -1; ++i)
+	{
+		char* test_name = lowercase(cmakeGeneratedFunctionMapEntries[i].name);
+		if (partial_match != 0 && strstr(test_name, arg) != NULL)
+		{ /* NOLINT */
+			testToRun = i;
+			ac -= 2;
+			av += 2;
+		}
+		else if (partial_match == 0 && strcmp(test_name, arg) == 0)
+		{
+			testToRun = i;
+			ac--;
+			av++;
+		}
+		free(test_name);
+	}
+	free(arg);
+	if (testToRun != -1)
+	{
+		int result;
+
+		if (testToRun < 0 || testToRun >= NumTests)
+		{
+			printf("testToRun was modified by TestDriver code to an invalid value: "
+			       "%3d.\n",
+			       testNum);
+			return -1;
+		}
+		result = (*cmakeGeneratedFunctionMapEntries[testToRun].func)(ac, av);
+
+		return result;
+	}
+
+	/* Nothing was run, display the test names.  */
+	printf("Available tests:\n");
+	for (i = 0; i < NumTests; ++i)
+	{
+		printf("%3d. %s\n", i, cmakeGeneratedFunctionMapEntries[i].name);
+	}
+	printf("Failed: %s is an invalid test name.\n", av[1]);
 
-  return -1;
+	return -1;
 }
diff -urN winpr/libwinpr/crt/test/TestUnicodeConversion.c ../../informatimago/FreeRDP/winpr/libwinpr/crt/test/TestUnicodeConversion.c
--- winpr/libwinpr/crt/test/TestUnicodeConversion.c	2019-07-25 19:51:08.597935780 +0300
+++ ../../informatimago/FreeRDP/winpr/libwinpr/crt/test/TestUnicodeConversion.c	2019-07-25 20:11:32.436004836 +0300
@@ -123,11 +123,10 @@
 int convert_utf8_to_utf16(BYTE* lpMultiByteStr, BYTE* expected_lpWideCharStr,
                           int expected_cchWideChar)
 {
-	int rc = -1;
 	int length;
 	int cbMultiByte;
 	int cchWideChar;
-	LPWSTR lpWideCharStr = NULL;
+	LPWSTR lpWideCharStr;
 	cbMultiByte = strlen((char*)lpMultiByteStr);
 	cchWideChar = MultiByteToWideChar(CP_UTF8, 0, (LPCSTR)lpMultiByteStr, -1, NULL, 0);
 	printf("MultiByteToWideChar Input UTF8 String:\n");
@@ -138,7 +137,7 @@
 	{
 		printf("MultiByteToWideChar unexpected cchWideChar: actual: %d expected: %d\n", cchWideChar,
 		       expected_cchWideChar);
-		goto fail;
+		return -1;
 	}
 
 	lpWideCharStr = (LPWSTR)calloc(cchWideChar, sizeof(WCHAR));
@@ -146,7 +145,7 @@
 	if (!lpWideCharStr)
 	{
 		printf("MultiByteToWideChar: unable to allocate memory for test\n");
-		goto fail;
+		return -1;
 	}
 
 	lpWideCharStr[cchWideChar - 1] =
@@ -159,14 +158,14 @@
 	{
 		DWORD error = GetLastError();
 		printf("MultiByteToWideChar error: 0x%08" PRIX32 "\n", error);
-		goto fail;
+		return -1;
 	}
 
 	if (length != expected_cchWideChar)
 	{
 		printf("MultiByteToWideChar unexpected converted length (WCHAR): actual: %d expected: %d\n",
 		       length, expected_cchWideChar);
-		goto fail;
+		return -1;
 	}
 
 	if (_wcscmp(lpWideCharStr, (WCHAR*)expected_lpWideCharStr) != 0)
@@ -178,22 +177,19 @@
 		string_hexdump((BYTE*)lpWideCharStr, length * sizeof(WCHAR));
 		printf("UTF16 String (expected):\n");
 		string_hexdump((BYTE*)expected_lpWideCharStr, expected_cchWideChar * sizeof(WCHAR));
-		goto fail;
+		return -1;
 	}
 
 	printf("MultiByteToWideChar Output UTF16 String:\n");
 	string_hexdump((BYTE*)lpWideCharStr, length * sizeof(WCHAR));
 	printf("\n");
-	rc = length;
-fail:
 	free(lpWideCharStr);
-	return rc;
+	return length;
 }
 
 int convert_utf16_to_utf8(BYTE* lpWideCharStr, BYTE* expected_lpMultiByteStr,
                           int expected_cbMultiByte)
 {
-	int rc = -1;
 	int length;
 	int cchWideChar;
 	int cbMultiByte;
@@ -208,7 +204,7 @@
 	{
 		printf("WideCharToMultiByte unexpected cbMultiByte: actual: %d expected: %d\n", cbMultiByte,
 		       expected_cbMultiByte);
-		goto fail;
+		return -1;
 	}
 
 	lpMultiByteStr = (LPSTR)malloc(cbMultiByte);
@@ -216,7 +212,7 @@
 	if (!lpMultiByteStr)
 	{
 		printf("WideCharToMultiByte: unable to allocate memory for test\n");
-		goto fail;
+		return -1;
 	}
 
 	lpMultiByteStr[cbMultiByte - 1] =
@@ -229,14 +225,14 @@
 	{
 		DWORD error = GetLastError();
 		printf("WideCharToMultiByte error: 0x%08" PRIX32 "\n", error);
-		goto fail;
+		return -1;
 	}
 
 	if (length != expected_cbMultiByte)
 	{
 		printf("WideCharToMultiByte unexpected converted length (BYTE): actual: %d expected: %d\n",
 		       length, expected_cbMultiByte);
-		goto fail;
+		return -1;
 	}
 
 	if (strcmp(lpMultiByteStr, (char*)expected_lpMultiByteStr) != 0)
@@ -248,16 +244,14 @@
 		string_hexdump((BYTE*)lpMultiByteStr, cbMultiByte);
 		printf("UTF8 String (expected):\n");
 		string_hexdump((BYTE*)expected_lpMultiByteStr, expected_cbMultiByte);
-		goto fail;
+		return -1;
 	}
 
 	printf("WideCharToMultiByte Output UTF8 String:\n");
 	string_hexdump((BYTE*)lpMultiByteStr, cbMultiByte);
 	printf("\n");
-	rc = length;
-fail:
 	free(lpMultiByteStr);
-	return rc;
+	return length;
 }
 
 BOOL test_unicode_uppercasing(BYTE* lower, BYTE* upper)
diff -urN winpr/libwinpr/crt/unicode.c ../../informatimago/FreeRDP/winpr/libwinpr/crt/unicode.c
--- winpr/libwinpr/crt/unicode.c	2019-07-25 19:51:08.605935820 +0300
+++ ../../informatimago/FreeRDP/winpr/libwinpr/crt/unicode.c	2019-07-25 20:11:32.444004876 +0300
@@ -169,19 +169,12 @@
 	/* If cbMultiByte is -1, the string is null-terminated */
 
 	if (cbMultiByte == -1)
-	{
-		size_t len = strlen((const char*)lpMultiByteStr);
-
-		if (len >= INT32_MAX)
-			return 0;
-
-		cbMultiByte = (int)len + 1;
-	}
+		cbMultiByte = strlen((char*)lpMultiByteStr) + 1;
 
-	/*
-	 * if cchWideChar is 0, the function returns the required buffer size
-	 * in characters for lpWideCharStr and makes no use of the output parameter itself.
-	 */
+		/*
+		 * if cchWideChar is 0, the function returns the required buffer size
+		 * in characters for lpWideCharStr and makes no use of the output parameter itself.
+		 */
 #	if defined(WITH_ICU)
 	{
 		UErrorCode error;
@@ -199,6 +192,9 @@
 			return 0;
 		}
 
+		if (cbMultiByte > UINT32_MAX)
+			return 0;
+
 		targetStart = lpWideCharStr;
 		targetCapacity = cchWideChar;
 		error = U_ZERO_ERROR;
@@ -297,19 +293,12 @@
 	/* If cchWideChar is -1, the string is null-terminated */
 
 	if (cchWideChar == -1)
-	{
-		size_t len = _wcslen(lpWideCharStr);
-
-		if (len >= INT32_MAX)
-			return 0;
+		cchWideChar = _wcslen(lpWideCharStr) + 1;
 
-		cchWideChar = (int)len + 1;
-	}
-
-	/*
-	 * if cbMultiByte is 0, the function returns the required buffer size
-	 * in bytes for lpMultiByteStr and makes no use of the output parameter itself.
-	 */
+		/*
+		 * if cbMultiByte is 0, the function returns the required buffer size
+		 * in bytes for lpMultiByteStr and makes no use of the output parameter itself.
+		 */
 #	if defined(WITH_ICU)
 	{
 		UErrorCode error;
@@ -327,6 +316,9 @@
 			return 0;
 		}
 
+		if (cchWideChar > UINT32_MAX)
+			return 0;
+
 		targetStart = lpMultiByteStr;
 		targetCapacity = cbMultiByte;
 		error = U_ZERO_ERROR;
@@ -395,14 +387,7 @@
 		return 0;
 
 	if (cbMultiByte == -1)
-	{
-		size_t len = strlen(lpMultiByteStr);
-
-		if (len >= INT_MAX)
-			return 0;
-
-		cbMultiByte = (int)(len + 1);
-	}
+		cbMultiByte = (int)(strlen(lpMultiByteStr) + 1);
 
 	if (cchWideChar == 0)
 	{
diff -urN winpr/libwinpr/crt/utf.c ../../informatimago/FreeRDP/winpr/libwinpr/crt/utf.c
--- winpr/libwinpr/crt/utf.c	2019-07-25 19:51:08.613935860 +0300
+++ ../../informatimago/FreeRDP/winpr/libwinpr/crt/utf.c	2019-07-25 20:11:32.456004936 +0300
@@ -41,8 +41,6 @@
 #include "utf.h"
 #include <winpr/endian.h>
 
-#pragma GCC diagnostic push
-#pragma GCC diagnostic ignored "-Wimplicit-fallthrough"
 static const int halfShift = 10; /* used for shifting by 10 bits */
 
 static const DWORD halfBase = 0x0010000UL;
@@ -866,4 +864,3 @@
     similarly unrolled loops.
 
    --------------------------------------------------------------------- */
-#pragma GCC diagnostic pop
diff -urN winpr/libwinpr/crypto/CMakeLists.txt ../../informatimago/FreeRDP/winpr/libwinpr/crypto/CMakeLists.txt
--- winpr/libwinpr/crypto/CMakeLists.txt	2019-07-24 06:11:52.538197907 +0300
+++ ../../informatimago/FreeRDP/winpr/libwinpr/crypto/CMakeLists.txt	2019-07-19 20:00:17.493205441 +0300
@@ -25,16 +25,16 @@
 
 if(OPENSSL_FOUND)
 	winpr_include_directory_add(${OPENSSL_INCLUDE_DIR})
-	winpr_library_add_private(${OPENSSL_LIBRARIES})
+	winpr_library_add(${OPENSSL_LIBRARIES})
 endif()
 
 if(MBEDTLS_FOUND)
 	winpr_include_directory_add(${MBEDTLS_INCLUDE_DIR})
-	winpr_library_add_private(${MBEDTLS_LIBRARIES})
+	winpr_library_add(${MBEDTLS_LIBRARIES})
 endif()
 
 if(WIN32)
-	winpr_library_add_public(crypt32)
+	winpr_library_add(crypt32)
 endif()
 
 if(BUILD_TESTING)
diff -urN winpr/libwinpr/crypto/test/TestCrypto.c ../../informatimago/FreeRDP/winpr/libwinpr/crypto/test/TestCrypto.c
--- winpr/libwinpr/crypto/test/TestCrypto.c	2019-07-25 20:17:16.373710413 +0300
+++ ../../informatimago/FreeRDP/winpr/libwinpr/crypto/test/TestCrypto.c	2019-07-25 20:11:32.492005114 +0300
@@ -4,11 +4,9 @@
 #include <string.h> /* NOLINT */
 
 #if defined(_MSC_VER)
-#pragma warning(disable : 4996) /* deprecation */
+#	pragma warning(disable : 4996) /* deprecation */
 #endif
 
-
-
 /* Forward declare test functions. */
 int TestCryptoHash(int, char*[]);
 int TestCryptoRand(int, char*[]);
@@ -17,151 +15,146 @@
 int TestCryptoProtectMemory(int, char*[]);
 int TestCryptoCertEnumCertificatesInStore(int, char*[]);
 
-
 #ifdef __cplusplus
-#define CM_CAST(TYPE, EXPR) static_cast<TYPE>(EXPR)
+#	define CM_CAST(TYPE, EXPR) static_cast<TYPE>(EXPR)
 #else
-#define CM_CAST(TYPE, EXPR) (TYPE)(EXPR)
+#	define CM_CAST(TYPE, EXPR) (TYPE)(EXPR)
 #endif
 
 /* Create map.  */
 
-typedef int (*MainFuncPointer)(int, char* []); /* NOLINT */
-typedef struct /* NOLINT */
+typedef int (*MainFuncPointer)(int, char*[]); /* NOLINT */
+typedef struct                                /* NOLINT */
 {
-  const char* name;
-  MainFuncPointer func;
+	const char* name;
+	MainFuncPointer func;
 } functionMapEntry;
 
 static functionMapEntry cmakeGeneratedFunctionMapEntries[] = {
-    {
-    "TestCryptoHash",
-    TestCryptoHash
-  },
-  {
-    "TestCryptoRand",
-    TestCryptoRand
-  },
-  {
-    "TestCryptoCipher",
-    TestCryptoCipher
-  },
-  {
-    "TestCryptoProtectData",
-    TestCryptoProtectData
-  },
-  {
-    "TestCryptoProtectMemory",
-    TestCryptoProtectMemory
-  },
-  {
-    "TestCryptoCertEnumCertificatesInStore",
-    TestCryptoCertEnumCertificatesInStore
-  },
+	{ "TestCryptoHash", TestCryptoHash },
+	{ "TestCryptoRand", TestCryptoRand },
+	{ "TestCryptoCipher", TestCryptoCipher },
+	{ "TestCryptoProtectData", TestCryptoProtectData },
+	{ "TestCryptoProtectMemory", TestCryptoProtectMemory },
+	{ "TestCryptoCertEnumCertificatesInStore", TestCryptoCertEnumCertificatesInStore },
 
-  { NULL, NULL } /* NOLINT */
+	{ NULL, NULL } /* NOLINT */
 };
 
-static const int NumTests = CM_CAST(int,
-  sizeof(cmakeGeneratedFunctionMapEntries) / sizeof(functionMapEntry)) - 1;
+static const int NumTests =
+    CM_CAST(int, sizeof(cmakeGeneratedFunctionMapEntries) / sizeof(functionMapEntry)) - 1;
 
 /* Allocate and create a lowercased copy of string
    (note that it has to be free'd manually) */
 static char* lowercase(const char* string)
 {
-  char *new_string, *p;
-  size_t stringSize;
+	char *new_string, *p;
+	size_t stringSize;
 
-  stringSize = CM_CAST(size_t, strlen(string) + 1);
-  new_string = CM_CAST(char*, malloc(sizeof(char) * stringSize));
+	stringSize = CM_CAST(size_t, strlen(string) + 1);
+	new_string = CM_CAST(char*, malloc(sizeof(char) * stringSize));
 
-  if (new_string == NULL) { /* NOLINT */
-    return NULL;            /* NOLINT */
-  }
-  strcpy(new_string, string);
-  for (p = new_string; *p != 0; ++p) {
-    *p = CM_CAST(char, tolower(*p));
-  }
-  return new_string;
+	if (new_string == NULL)
+	{                /* NOLINT */
+		return NULL; /* NOLINT */
+	}
+	strcpy(new_string, string);
+	for (p = new_string; *p != 0; ++p)
+	{
+		*p = CM_CAST(char, tolower(*p));
+	}
+	return new_string;
 }
 
 int main(int ac, char* av[])
 {
-  int i, testNum = 0, partial_match;
-  char *arg;
-  int testToRun = -1;
-
-  
-
-  /* If no test name was given */
-  /* process command line with user function.  */
-  if (ac < 2) {
-    /* Ask for a test.  */
-    printf("Available tests:\n");
-    for (i = 0; i < NumTests; ++i) {
-      printf("%3d. %s\n", i, cmakeGeneratedFunctionMapEntries[i].name);
-    }
-    printf("To run a test, enter the test number: ");
-    fflush(stdout);
-    if (scanf("%d", &testNum) != 1) {
-      printf("Couldn't parse that input as a number\n");
-      return -1;
-    }
-    if (testNum >= NumTests) {
-      printf("%3d is an invalid test number.\n", testNum);
-      return -1;
-    }
-    testToRun = testNum;
-    ac--;
-    av++;
-  }
-  partial_match = 0;
-  arg = NULL; /* NOLINT */
-  /* If partial match is requested.  */
-  if (testToRun == -1 && ac > 1) {
-    partial_match = (strcmp(av[1], "-R") == 0) ? 1 : 0;
-  }
-  if (partial_match != 0 && ac < 3) {
-    printf("-R needs an additional parameter.\n");
-    return -1;
-  }
-  if (testToRun == -1) {
-    arg = lowercase(av[1 + partial_match]);
-  }
-  for (i = 0; i < NumTests && testToRun == -1; ++i) {
-    char *test_name = lowercase(cmakeGeneratedFunctionMapEntries[i].name);
-    if (partial_match != 0 && strstr(test_name, arg) != NULL) { /* NOLINT */
-      testToRun = i;
-      ac -= 2;
-      av += 2;
-    } else if (partial_match == 0 && strcmp(test_name, arg) == 0) {
-      testToRun = i;
-      ac--;
-      av++;
-    }
-    free(test_name);
-  }
-  free(arg);
-  if (testToRun != -1) {
-    int result;
-
-    if (testToRun < 0 || testToRun >= NumTests) {
-      printf("testToRun was modified by TestDriver code to an invalid value: "
-             "%3d.\n",
-             testNum);
-      return -1;
-    }
-    result = (*cmakeGeneratedFunctionMapEntries[testToRun].func)(ac, av);
-
-    return result;
-  }
-
-  /* Nothing was run, display the test names.  */
-  printf("Available tests:\n");
-  for (i = 0; i < NumTests; ++i) {
-    printf("%3d. %s\n", i, cmakeGeneratedFunctionMapEntries[i].name);
-  }
-  printf("Failed: %s is an invalid test name.\n", av[1]);
+	int i, testNum = 0, partial_match;
+	char* arg;
+	int testToRun = -1;
+
+	/* If no test name was given */
+	/* process command line with user function.  */
+	if (ac < 2)
+	{
+		/* Ask for a test.  */
+		printf("Available tests:\n");
+		for (i = 0; i < NumTests; ++i)
+		{
+			printf("%3d. %s\n", i, cmakeGeneratedFunctionMapEntries[i].name);
+		}
+		printf("To run a test, enter the test number: ");
+		fflush(stdout);
+		if (scanf("%d", &testNum) != 1)
+		{
+			printf("Couldn't parse that input as a number\n");
+			return -1;
+		}
+		if (testNum >= NumTests)
+		{
+			printf("%3d is an invalid test number.\n", testNum);
+			return -1;
+		}
+		testToRun = testNum;
+		ac--;
+		av++;
+	}
+	partial_match = 0;
+	arg = NULL; /* NOLINT */
+	/* If partial match is requested.  */
+	if (testToRun == -1 && ac > 1)
+	{
+		partial_match = (strcmp(av[1], "-R") == 0) ? 1 : 0;
+	}
+	if (partial_match != 0 && ac < 3)
+	{
+		printf("-R needs an additional parameter.\n");
+		return -1;
+	}
+	if (testToRun == -1)
+	{
+		arg = lowercase(av[1 + partial_match]);
+	}
+	for (i = 0; i < NumTests && testToRun == -1; ++i)
+	{
+		char* test_name = lowercase(cmakeGeneratedFunctionMapEntries[i].name);
+		if (partial_match != 0 && strstr(test_name, arg) != NULL)
+		{ /* NOLINT */
+			testToRun = i;
+			ac -= 2;
+			av += 2;
+		}
+		else if (partial_match == 0 && strcmp(test_name, arg) == 0)
+		{
+			testToRun = i;
+			ac--;
+			av++;
+		}
+		free(test_name);
+	}
+	free(arg);
+	if (testToRun != -1)
+	{
+		int result;
+
+		if (testToRun < 0 || testToRun >= NumTests)
+		{
+			printf("testToRun was modified by TestDriver code to an invalid value: "
+			       "%3d.\n",
+			       testNum);
+			return -1;
+		}
+		result = (*cmakeGeneratedFunctionMapEntries[testToRun].func)(ac, av);
+
+		return result;
+	}
+
+	/* Nothing was run, display the test names.  */
+	printf("Available tests:\n");
+	for (i = 0; i < NumTests; ++i)
+	{
+		printf("%3d. %s\n", i, cmakeGeneratedFunctionMapEntries[i].name);
+	}
+	printf("Failed: %s is an invalid test name.\n", av[1]);
 
-  return -1;
+	return -1;
 }
diff -urN winpr/libwinpr/dsparse/CMakeLists.txt ../../informatimago/FreeRDP/winpr/libwinpr/dsparse/CMakeLists.txt
--- winpr/libwinpr/dsparse/CMakeLists.txt	2019-07-24 06:11:52.538197907 +0300
+++ ../../informatimago/FreeRDP/winpr/libwinpr/dsparse/CMakeLists.txt	2019-07-19 20:00:17.493205441 +0300
@@ -18,7 +18,7 @@
 winpr_module_add(dsparse.c)
 
 if(WIN32)
-	winpr_library_add_public(ntdsapi)
+	winpr_library_add(ntdsapi)
 endif()
 
 if(BUILD_TESTING)
diff -urN winpr/libwinpr/dsparse/test/TestDsParse.c ../../informatimago/FreeRDP/winpr/libwinpr/dsparse/test/TestDsParse.c
--- winpr/libwinpr/dsparse/test/TestDsParse.c	2019-07-25 20:17:16.413710612 +0300
+++ ../../informatimago/FreeRDP/winpr/libwinpr/dsparse/test/TestDsParse.c	2019-07-25 20:11:32.512005213 +0300
@@ -4,144 +4,149 @@
 #include <string.h> /* NOLINT */
 
 #if defined(_MSC_VER)
-#pragma warning(disable : 4996) /* deprecation */
+#	pragma warning(disable : 4996) /* deprecation */
 #endif
 
-
-
 /* Forward declare test functions. */
 int TestDsMakeSpn(int, char*[]);
 int TestDsCrackNames(int, char*[]);
 
-
 #ifdef __cplusplus
-#define CM_CAST(TYPE, EXPR) static_cast<TYPE>(EXPR)
+#	define CM_CAST(TYPE, EXPR) static_cast<TYPE>(EXPR)
 #else
-#define CM_CAST(TYPE, EXPR) (TYPE)(EXPR)
+#	define CM_CAST(TYPE, EXPR) (TYPE)(EXPR)
 #endif
 
 /* Create map.  */
 
-typedef int (*MainFuncPointer)(int, char* []); /* NOLINT */
-typedef struct /* NOLINT */
+typedef int (*MainFuncPointer)(int, char*[]); /* NOLINT */
+typedef struct                                /* NOLINT */
 {
-  const char* name;
-  MainFuncPointer func;
+	const char* name;
+	MainFuncPointer func;
 } functionMapEntry;
 
 static functionMapEntry cmakeGeneratedFunctionMapEntries[] = {
-    {
-    "TestDsMakeSpn",
-    TestDsMakeSpn
-  },
-  {
-    "TestDsCrackNames",
-    TestDsCrackNames
-  },
+	{ "TestDsMakeSpn", TestDsMakeSpn },
+	{ "TestDsCrackNames", TestDsCrackNames },
 
-  { NULL, NULL } /* NOLINT */
+	{ NULL, NULL } /* NOLINT */
 };
 
-static const int NumTests = CM_CAST(int,
-  sizeof(cmakeGeneratedFunctionMapEntries) / sizeof(functionMapEntry)) - 1;
+static const int NumTests =
+    CM_CAST(int, sizeof(cmakeGeneratedFunctionMapEntries) / sizeof(functionMapEntry)) - 1;
 
 /* Allocate and create a lowercased copy of string
    (note that it has to be free'd manually) */
 static char* lowercase(const char* string)
 {
-  char *new_string, *p;
-  size_t stringSize;
+	char *new_string, *p;
+	size_t stringSize;
 
-  stringSize = CM_CAST(size_t, strlen(string) + 1);
-  new_string = CM_CAST(char*, malloc(sizeof(char) * stringSize));
+	stringSize = CM_CAST(size_t, strlen(string) + 1);
+	new_string = CM_CAST(char*, malloc(sizeof(char) * stringSize));
 
-  if (new_string == NULL) { /* NOLINT */
-    return NULL;            /* NOLINT */
-  }
-  strcpy(new_string, string);
-  for (p = new_string; *p != 0; ++p) {
-    *p = CM_CAST(char, tolower(*p));
-  }
-  return new_string;
+	if (new_string == NULL)
+	{                /* NOLINT */
+		return NULL; /* NOLINT */
+	}
+	strcpy(new_string, string);
+	for (p = new_string; *p != 0; ++p)
+	{
+		*p = CM_CAST(char, tolower(*p));
+	}
+	return new_string;
 }
 
 int main(int ac, char* av[])
 {
-  int i, testNum = 0, partial_match;
-  char *arg;
-  int testToRun = -1;
-
-  
-
-  /* If no test name was given */
-  /* process command line with user function.  */
-  if (ac < 2) {
-    /* Ask for a test.  */
-    printf("Available tests:\n");
-    for (i = 0; i < NumTests; ++i) {
-      printf("%3d. %s\n", i, cmakeGeneratedFunctionMapEntries[i].name);
-    }
-    printf("To run a test, enter the test number: ");
-    fflush(stdout);
-    if (scanf("%d", &testNum) != 1) {
-      printf("Couldn't parse that input as a number\n");
-      return -1;
-    }
-    if (testNum >= NumTests) {
-      printf("%3d is an invalid test number.\n", testNum);
-      return -1;
-    }
-    testToRun = testNum;
-    ac--;
-    av++;
-  }
-  partial_match = 0;
-  arg = NULL; /* NOLINT */
-  /* If partial match is requested.  */
-  if (testToRun == -1 && ac > 1) {
-    partial_match = (strcmp(av[1], "-R") == 0) ? 1 : 0;
-  }
-  if (partial_match != 0 && ac < 3) {
-    printf("-R needs an additional parameter.\n");
-    return -1;
-  }
-  if (testToRun == -1) {
-    arg = lowercase(av[1 + partial_match]);
-  }
-  for (i = 0; i < NumTests && testToRun == -1; ++i) {
-    char *test_name = lowercase(cmakeGeneratedFunctionMapEntries[i].name);
-    if (partial_match != 0 && strstr(test_name, arg) != NULL) { /* NOLINT */
-      testToRun = i;
-      ac -= 2;
-      av += 2;
-    } else if (partial_match == 0 && strcmp(test_name, arg) == 0) {
-      testToRun = i;
-      ac--;
-      av++;
-    }
-    free(test_name);
-  }
-  free(arg);
-  if (testToRun != -1) {
-    int result;
-
-    if (testToRun < 0 || testToRun >= NumTests) {
-      printf("testToRun was modified by TestDriver code to an invalid value: "
-             "%3d.\n",
-             testNum);
-      return -1;
-    }
-    result = (*cmakeGeneratedFunctionMapEntries[testToRun].func)(ac, av);
-
-    return result;
-  }
-
-  /* Nothing was run, display the test names.  */
-  printf("Available tests:\n");
-  for (i = 0; i < NumTests; ++i) {
-    printf("%3d. %s\n", i, cmakeGeneratedFunctionMapEntries[i].name);
-  }
-  printf("Failed: %s is an invalid test name.\n", av[1]);
+	int i, testNum = 0, partial_match;
+	char* arg;
+	int testToRun = -1;
+
+	/* If no test name was given */
+	/* process command line with user function.  */
+	if (ac < 2)
+	{
+		/* Ask for a test.  */
+		printf("Available tests:\n");
+		for (i = 0; i < NumTests; ++i)
+		{
+			printf("%3d. %s\n", i, cmakeGeneratedFunctionMapEntries[i].name);
+		}
+		printf("To run a test, enter the test number: ");
+		fflush(stdout);
+		if (scanf("%d", &testNum) != 1)
+		{
+			printf("Couldn't parse that input as a number\n");
+			return -1;
+		}
+		if (testNum >= NumTests)
+		{
+			printf("%3d is an invalid test number.\n", testNum);
+			return -1;
+		}
+		testToRun = testNum;
+		ac--;
+		av++;
+	}
+	partial_match = 0;
+	arg = NULL; /* NOLINT */
+	/* If partial match is requested.  */
+	if (testToRun == -1 && ac > 1)
+	{
+		partial_match = (strcmp(av[1], "-R") == 0) ? 1 : 0;
+	}
+	if (partial_match != 0 && ac < 3)
+	{
+		printf("-R needs an additional parameter.\n");
+		return -1;
+	}
+	if (testToRun == -1)
+	{
+		arg = lowercase(av[1 + partial_match]);
+	}
+	for (i = 0; i < NumTests && testToRun == -1; ++i)
+	{
+		char* test_name = lowercase(cmakeGeneratedFunctionMapEntries[i].name);
+		if (partial_match != 0 && strstr(test_name, arg) != NULL)
+		{ /* NOLINT */
+			testToRun = i;
+			ac -= 2;
+			av += 2;
+		}
+		else if (partial_match == 0 && strcmp(test_name, arg) == 0)
+		{
+			testToRun = i;
+			ac--;
+			av++;
+		}
+		free(test_name);
+	}
+	free(arg);
+	if (testToRun != -1)
+	{
+		int result;
+
+		if (testToRun < 0 || testToRun >= NumTests)
+		{
+			printf("testToRun was modified by TestDriver code to an invalid value: "
+			       "%3d.\n",
+			       testNum);
+			return -1;
+		}
+		result = (*cmakeGeneratedFunctionMapEntries[testToRun].func)(ac, av);
+
+		return result;
+	}
+
+	/* Nothing was run, display the test names.  */
+	printf("Available tests:\n");
+	for (i = 0; i < NumTests; ++i)
+	{
+		printf("%3d. %s\n", i, cmakeGeneratedFunctionMapEntries[i].name);
+	}
+	printf("Failed: %s is an invalid test name.\n", av[1]);
 
-  return -1;
+	return -1;
 }
diff -urN winpr/libwinpr/environment/environment.c ../../informatimago/FreeRDP/winpr/libwinpr/environment/environment.c
--- winpr/libwinpr/environment/environment.c	2019-07-25 19:51:08.681936197 +0300
+++ ../../informatimago/FreeRDP/winpr/libwinpr/environment/environment.c	2019-07-25 20:11:32.524005272 +0300
@@ -51,7 +51,7 @@
 DWORD GetCurrentDirectoryA(DWORD nBufferLength, LPSTR lpBuffer)
 {
 	char* cwd;
-	size_t length;
+	int length;
 	cwd = getcwd(NULL, 0);
 
 	if (!cwd)
@@ -139,7 +139,7 @@
 DWORD GetEnvironmentVariableA(LPCSTR lpName, LPSTR lpBuffer, DWORD nSize)
 {
 #	if !defined(_UWP)
-	size_t length;
+	int length;
 	char* env = NULL;
 	env = getenv(lpName);
 
diff -urN winpr/libwinpr/environment/test/TestEnvironment.c ../../informatimago/FreeRDP/winpr/libwinpr/environment/test/TestEnvironment.c
--- winpr/libwinpr/environment/test/TestEnvironment.c	2019-07-25 20:17:16.369710394 +0300
+++ ../../informatimago/FreeRDP/winpr/libwinpr/environment/test/TestEnvironment.c	2019-07-25 20:11:32.528005292 +0300
@@ -4,154 +4,153 @@
 #include <string.h> /* NOLINT */
 
 #if defined(_MSC_VER)
-#pragma warning(disable : 4996) /* deprecation */
+#	pragma warning(disable : 4996) /* deprecation */
 #endif
 
-
-
 /* Forward declare test functions. */
 int TestEnvironmentGetEnvironmentStrings(int, char*[]);
 int TestEnvironmentSetEnvironmentVariable(int, char*[]);
 int TestEnvironmentMergeEnvironmentStrings(int, char*[]);
 int TestEnvironmentGetSetEB(int, char*[]);
 
-
 #ifdef __cplusplus
-#define CM_CAST(TYPE, EXPR) static_cast<TYPE>(EXPR)
+#	define CM_CAST(TYPE, EXPR) static_cast<TYPE>(EXPR)
 #else
-#define CM_CAST(TYPE, EXPR) (TYPE)(EXPR)
+#	define CM_CAST(TYPE, EXPR) (TYPE)(EXPR)
 #endif
 
 /* Create map.  */
 
-typedef int (*MainFuncPointer)(int, char* []); /* NOLINT */
-typedef struct /* NOLINT */
+typedef int (*MainFuncPointer)(int, char*[]); /* NOLINT */
+typedef struct                                /* NOLINT */
 {
-  const char* name;
-  MainFuncPointer func;
+	const char* name;
+	MainFuncPointer func;
 } functionMapEntry;
 
 static functionMapEntry cmakeGeneratedFunctionMapEntries[] = {
-    {
-    "TestEnvironmentGetEnvironmentStrings",
-    TestEnvironmentGetEnvironmentStrings
-  },
-  {
-    "TestEnvironmentSetEnvironmentVariable",
-    TestEnvironmentSetEnvironmentVariable
-  },
-  {
-    "TestEnvironmentMergeEnvironmentStrings",
-    TestEnvironmentMergeEnvironmentStrings
-  },
-  {
-    "TestEnvironmentGetSetEB",
-    TestEnvironmentGetSetEB
-  },
+	{ "TestEnvironmentGetEnvironmentStrings", TestEnvironmentGetEnvironmentStrings },
+	{ "TestEnvironmentSetEnvironmentVariable", TestEnvironmentSetEnvironmentVariable },
+	{ "TestEnvironmentMergeEnvironmentStrings", TestEnvironmentMergeEnvironmentStrings },
+	{ "TestEnvironmentGetSetEB", TestEnvironmentGetSetEB },
 
-  { NULL, NULL } /* NOLINT */
+	{ NULL, NULL } /* NOLINT */
 };
 
-static const int NumTests = CM_CAST(int,
-  sizeof(cmakeGeneratedFunctionMapEntries) / sizeof(functionMapEntry)) - 1;
+static const int NumTests =
+    CM_CAST(int, sizeof(cmakeGeneratedFunctionMapEntries) / sizeof(functionMapEntry)) - 1;
 
 /* Allocate and create a lowercased copy of string
    (note that it has to be free'd manually) */
 static char* lowercase(const char* string)
 {
-  char *new_string, *p;
-  size_t stringSize;
+	char *new_string, *p;
+	size_t stringSize;
 
-  stringSize = CM_CAST(size_t, strlen(string) + 1);
-  new_string = CM_CAST(char*, malloc(sizeof(char) * stringSize));
+	stringSize = CM_CAST(size_t, strlen(string) + 1);
+	new_string = CM_CAST(char*, malloc(sizeof(char) * stringSize));
 
-  if (new_string == NULL) { /* NOLINT */
-    return NULL;            /* NOLINT */
-  }
-  strcpy(new_string, string);
-  for (p = new_string; *p != 0; ++p) {
-    *p = CM_CAST(char, tolower(*p));
-  }
-  return new_string;
+	if (new_string == NULL)
+	{                /* NOLINT */
+		return NULL; /* NOLINT */
+	}
+	strcpy(new_string, string);
+	for (p = new_string; *p != 0; ++p)
+	{
+		*p = CM_CAST(char, tolower(*p));
+	}
+	return new_string;
 }
 
 int main(int ac, char* av[])
 {
-  int i, testNum = 0, partial_match;
-  char *arg;
-  int testToRun = -1;
-
-  
-
-  /* If no test name was given */
-  /* process command line with user function.  */
-  if (ac < 2) {
-    /* Ask for a test.  */
-    printf("Available tests:\n");
-    for (i = 0; i < NumTests; ++i) {
-      printf("%3d. %s\n", i, cmakeGeneratedFunctionMapEntries[i].name);
-    }
-    printf("To run a test, enter the test number: ");
-    fflush(stdout);
-    if (scanf("%d", &testNum) != 1) {
-      printf("Couldn't parse that input as a number\n");
-      return -1;
-    }
-    if (testNum >= NumTests) {
-      printf("%3d is an invalid test number.\n", testNum);
-      return -1;
-    }
-    testToRun = testNum;
-    ac--;
-    av++;
-  }
-  partial_match = 0;
-  arg = NULL; /* NOLINT */
-  /* If partial match is requested.  */
-  if (testToRun == -1 && ac > 1) {
-    partial_match = (strcmp(av[1], "-R") == 0) ? 1 : 0;
-  }
-  if (partial_match != 0 && ac < 3) {
-    printf("-R needs an additional parameter.\n");
-    return -1;
-  }
-  if (testToRun == -1) {
-    arg = lowercase(av[1 + partial_match]);
-  }
-  for (i = 0; i < NumTests && testToRun == -1; ++i) {
-    char *test_name = lowercase(cmakeGeneratedFunctionMapEntries[i].name);
-    if (partial_match != 0 && strstr(test_name, arg) != NULL) { /* NOLINT */
-      testToRun = i;
-      ac -= 2;
-      av += 2;
-    } else if (partial_match == 0 && strcmp(test_name, arg) == 0) {
-      testToRun = i;
-      ac--;
-      av++;
-    }
-    free(test_name);
-  }
-  free(arg);
-  if (testToRun != -1) {
-    int result;
-
-    if (testToRun < 0 || testToRun >= NumTests) {
-      printf("testToRun was modified by TestDriver code to an invalid value: "
-             "%3d.\n",
-             testNum);
-      return -1;
-    }
-    result = (*cmakeGeneratedFunctionMapEntries[testToRun].func)(ac, av);
-
-    return result;
-  }
-
-  /* Nothing was run, display the test names.  */
-  printf("Available tests:\n");
-  for (i = 0; i < NumTests; ++i) {
-    printf("%3d. %s\n", i, cmakeGeneratedFunctionMapEntries[i].name);
-  }
-  printf("Failed: %s is an invalid test name.\n", av[1]);
+	int i, testNum = 0, partial_match;
+	char* arg;
+	int testToRun = -1;
+
+	/* If no test name was given */
+	/* process command line with user function.  */
+	if (ac < 2)
+	{
+		/* Ask for a test.  */
+		printf("Available tests:\n");
+		for (i = 0; i < NumTests; ++i)
+		{
+			printf("%3d. %s\n", i, cmakeGeneratedFunctionMapEntries[i].name);
+		}
+		printf("To run a test, enter the test number: ");
+		fflush(stdout);
+		if (scanf("%d", &testNum) != 1)
+		{
+			printf("Couldn't parse that input as a number\n");
+			return -1;
+		}
+		if (testNum >= NumTests)
+		{
+			printf("%3d is an invalid test number.\n", testNum);
+			return -1;
+		}
+		testToRun = testNum;
+		ac--;
+		av++;
+	}
+	partial_match = 0;
+	arg = NULL; /* NOLINT */
+	/* If partial match is requested.  */
+	if (testToRun == -1 && ac > 1)
+	{
+		partial_match = (strcmp(av[1], "-R") == 0) ? 1 : 0;
+	}
+	if (partial_match != 0 && ac < 3)
+	{
+		printf("-R needs an additional parameter.\n");
+		return -1;
+	}
+	if (testToRun == -1)
+	{
+		arg = lowercase(av[1 + partial_match]);
+	}
+	for (i = 0; i < NumTests && testToRun == -1; ++i)
+	{
+		char* test_name = lowercase(cmakeGeneratedFunctionMapEntries[i].name);
+		if (partial_match != 0 && strstr(test_name, arg) != NULL)
+		{ /* NOLINT */
+			testToRun = i;
+			ac -= 2;
+			av += 2;
+		}
+		else if (partial_match == 0 && strcmp(test_name, arg) == 0)
+		{
+			testToRun = i;
+			ac--;
+			av++;
+		}
+		free(test_name);
+	}
+	free(arg);
+	if (testToRun != -1)
+	{
+		int result;
+
+		if (testToRun < 0 || testToRun >= NumTests)
+		{
+			printf("testToRun was modified by TestDriver code to an invalid value: "
+			       "%3d.\n",
+			       testNum);
+			return -1;
+		}
+		result = (*cmakeGeneratedFunctionMapEntries[testToRun].func)(ac, av);
+
+		return result;
+	}
+
+	/* Nothing was run, display the test names.  */
+	printf("Available tests:\n");
+	for (i = 0; i < NumTests; ++i)
+	{
+		printf("%3d. %s\n", i, cmakeGeneratedFunctionMapEntries[i].name);
+	}
+	printf("Failed: %s is an invalid test name.\n", av[1]);
 
-  return -1;
+	return -1;
 }
diff -urN winpr/libwinpr/environment/test/TestEnvironmentGetSetEB.c ../../informatimago/FreeRDP/winpr/libwinpr/environment/test/TestEnvironmentGetSetEB.c
--- winpr/libwinpr/environment/test/TestEnvironmentGetSetEB.c	2019-07-25 19:51:08.689936236 +0300
+++ ../../informatimago/FreeRDP/winpr/libwinpr/environment/test/TestEnvironmentGetSetEB.c	2019-07-25 20:11:32.532005312 +0300
@@ -6,14 +6,12 @@
 
 int TestEnvironmentGetSetEB(int argc, char* argv[])
 {
-	int rc = 0;
 #ifndef _WIN32
 	char test[1024];
-	TCHAR* p = NULL;
-	DWORD length;
+	TCHAR* p;
+	int length;
 	LPTCH lpszEnvironmentBlock = "SHELL=123\0test=1\0test1=2\0DISPLAY=WINPR_TEST_VALUE\0\0";
 	LPTCH lpszEnvironmentBlockNew = NULL;
-	rc = -1;
 	/* Get length of an variable */
 	length = GetEnvironmentVariableEBA(lpszEnvironmentBlock, "DISPLAY", NULL, 0);
 
@@ -24,23 +22,27 @@
 	p = (LPSTR)malloc(length);
 
 	if (!p)
-		goto fail;
+		return -1;
 
 	if (GetEnvironmentVariableEBA(lpszEnvironmentBlock, "DISPLAY", p, length) != length - 1)
-		goto fail;
+		return -1;
 
 	printf("GetEnvironmentVariableA(WINPR_TEST_VARIABLE) = %s\n", p);
 
 	if (strcmp(p, "WINPR_TEST_VALUE") != 0)
-		goto fail;
+	{
+		free(p);
+		return -1;
+	}
 
+	free(p);
 	/* Get length of an non-existing variable */
 	length = GetEnvironmentVariableEBA(lpszEnvironmentBlock, "BLA", NULL, 0);
 
 	if (0 != length)
 	{
 		printf("Unset variable returned\n");
-		goto fail;
+		return -1;
 	}
 
 	/* Get length of an similar called variables */
@@ -49,7 +51,7 @@
 	if (0 != length)
 	{
 		printf("Similar named variable returned (XDISPLAY, length %d)\n", length);
-		goto fail;
+		return -1;
 	}
 
 	length = GetEnvironmentVariableEBA(lpszEnvironmentBlock, "DISPLAYX", NULL, 0);
@@ -57,7 +59,7 @@
 	if (0 != length)
 	{
 		printf("Similar named variable returned (DISPLAYX, length %d)\n", length);
-		goto fail;
+		return -1;
 	}
 
 	length = GetEnvironmentVariableEBA(lpszEnvironmentBlock, "DISPLA", NULL, 0);
@@ -65,7 +67,7 @@
 	if (0 != length)
 	{
 		printf("Similar named variable returned (DISPLA, length %d)\n", length);
-		goto fail;
+		return -1;
 	}
 
 	length = GetEnvironmentVariableEBA(lpszEnvironmentBlock, "ISPLAY", NULL, 0);
@@ -73,7 +75,7 @@
 	if (0 != length)
 	{
 		printf("Similar named variable returned (ISPLAY, length %d)\n", length);
-		goto fail;
+		return -1;
 	}
 
 	/* Set variable in empty environment block */
@@ -82,17 +84,24 @@
 		if (GetEnvironmentVariableEBA(lpszEnvironmentBlockNew, "test", test, 1023))
 		{
 			if (strcmp(test, "5") != 0)
-				goto fail;
+			{
+				return -1;
+			}
 		}
 		else
-			goto fail;
+		{
+			return -1;
+		}
 	}
 
 	/* Clear variable */
 	if (SetEnvironmentVariableEBA(&lpszEnvironmentBlockNew, "test", NULL))
 	{
 		if (GetEnvironmentVariableEBA(lpszEnvironmentBlockNew, "test", test, 1023))
-			goto fail;
+		{
+			free(lpszEnvironmentBlockNew);
+			return -1;
+		}
 		else
 		{
 			// not found .. this is expected
@@ -103,7 +112,7 @@
 	lpszEnvironmentBlockNew = (LPTCH)calloc(1024, sizeof(TCHAR));
 
 	if (!lpszEnvironmentBlockNew)
-		goto fail;
+		return -1;
 
 	memcpy(lpszEnvironmentBlockNew, lpszEnvironmentBlock, length);
 
@@ -113,22 +122,26 @@
 		if (0 != GetEnvironmentVariableEBA(lpszEnvironmentBlockNew, "testr", test, 1023))
 		{
 			printf("GetEnvironmentVariableEBA returned unset variable\n");
-			goto fail;
+			free(lpszEnvironmentBlockNew);
+			return -1;
 		}
 
 		if (GetEnvironmentVariableEBA(lpszEnvironmentBlockNew, "test", test, 1023))
 		{
 			if (strcmp(test, "5") != 0)
-				goto fail;
+			{
+				free(lpszEnvironmentBlockNew);
+				return -1;
+			}
 		}
 		else
-			goto fail;
+		{
+			free(lpszEnvironmentBlockNew);
+			return -1;
+		}
 	}
 
-	rc = 0;
-fail:
-	free(p);
 	free(lpszEnvironmentBlockNew);
 #endif
-	return rc;
+	return 0;
 }
diff -urN winpr/libwinpr/environment/test/TestEnvironmentSetEnvironmentVariable.c ../../informatimago/FreeRDP/winpr/libwinpr/environment/test/TestEnvironmentSetEnvironmentVariable.c
--- winpr/libwinpr/environment/test/TestEnvironmentSetEnvironmentVariable.c	2019-07-25 19:51:08.693936256 +0300
+++ ../../informatimago/FreeRDP/winpr/libwinpr/environment/test/TestEnvironmentSetEnvironmentVariable.c	2019-07-25 20:11:32.532005312 +0300
@@ -9,9 +9,8 @@
 #define TEST_VALUE "WINPR_TEST_VALUE"
 int TestEnvironmentSetEnvironmentVariable(int argc, char* argv[])
 {
-	int rc = -1;
 	DWORD nSize;
-	LPSTR lpBuffer = NULL;
+	LPSTR lpBuffer;
 	DWORD error = 0;
 	SetEnvironmentVariableA(TEST_NAME, TEST_VALUE);
 	nSize = GetEnvironmentVariableA(TEST_NAME, NULL, 0);
@@ -33,13 +32,13 @@
 	if (nSize != strlen(TEST_VALUE))
 	{
 		printf("GetEnvironmentVariableA wrong size returned\n");
-		goto fail;
+		return -1;
 	}
 
 	if (strcmp(lpBuffer, TEST_VALUE) != 0)
 	{
 		printf("GetEnvironmentVariableA returned value doesn't match\n");
-		goto fail;
+		return -1;
 	}
 
 	nSize = GetEnvironmentVariableA("__xx__notset_", lpBuffer, nSize);
@@ -48,9 +47,10 @@
 	if (0 != nSize || ERROR_ENVVAR_NOT_FOUND != error)
 	{
 		printf("GetEnvironmentVariableA not found error\n");
-		goto fail;
+		return -1;
 	}
 
+	free(lpBuffer);
 	/* clear variable */
 	SetEnvironmentVariableA(TEST_NAME, NULL);
 	nSize = GetEnvironmentVariableA(TEST_VALUE, NULL, 0);
@@ -58,11 +58,8 @@
 	if (0 != nSize)
 	{
 		printf("SetEnvironmentVariableA failed to clear variable\n");
-		goto fail;
+		return -1;
 	}
 
-	rc = 0;
-fail:
-	free(lpBuffer);
-	return rc;
+	return 0;
 }
diff -urN winpr/libwinpr/error/test/TestError.c ../../informatimago/FreeRDP/winpr/libwinpr/error/test/TestError.c
--- winpr/libwinpr/error/test/TestError.c	2019-07-25 20:17:16.389710492 +0300
+++ ../../informatimago/FreeRDP/winpr/libwinpr/error/test/TestError.c	2019-07-25 20:11:32.540005352 +0300
@@ -4,139 +4,147 @@
 #include <string.h> /* NOLINT */
 
 #if defined(_MSC_VER)
-#pragma warning(disable : 4996) /* deprecation */
+#	pragma warning(disable : 4996) /* deprecation */
 #endif
 
-
-
 /* Forward declare test functions. */
 int TestErrorSetLastError(int, char*[]);
 
-
 #ifdef __cplusplus
-#define CM_CAST(TYPE, EXPR) static_cast<TYPE>(EXPR)
+#	define CM_CAST(TYPE, EXPR) static_cast<TYPE>(EXPR)
 #else
-#define CM_CAST(TYPE, EXPR) (TYPE)(EXPR)
+#	define CM_CAST(TYPE, EXPR) (TYPE)(EXPR)
 #endif
 
 /* Create map.  */
 
-typedef int (*MainFuncPointer)(int, char* []); /* NOLINT */
-typedef struct /* NOLINT */
+typedef int (*MainFuncPointer)(int, char*[]); /* NOLINT */
+typedef struct                                /* NOLINT */
 {
-  const char* name;
-  MainFuncPointer func;
+	const char* name;
+	MainFuncPointer func;
 } functionMapEntry;
 
 static functionMapEntry cmakeGeneratedFunctionMapEntries[] = {
-    {
-    "TestErrorSetLastError",
-    TestErrorSetLastError
-  },
+	{ "TestErrorSetLastError", TestErrorSetLastError },
 
-  { NULL, NULL } /* NOLINT */
+	{ NULL, NULL } /* NOLINT */
 };
 
-static const int NumTests = CM_CAST(int,
-  sizeof(cmakeGeneratedFunctionMapEntries) / sizeof(functionMapEntry)) - 1;
+static const int NumTests =
+    CM_CAST(int, sizeof(cmakeGeneratedFunctionMapEntries) / sizeof(functionMapEntry)) - 1;
 
 /* Allocate and create a lowercased copy of string
    (note that it has to be free'd manually) */
 static char* lowercase(const char* string)
 {
-  char *new_string, *p;
-  size_t stringSize;
+	char *new_string, *p;
+	size_t stringSize;
 
-  stringSize = CM_CAST(size_t, strlen(string) + 1);
-  new_string = CM_CAST(char*, malloc(sizeof(char) * stringSize));
+	stringSize = CM_CAST(size_t, strlen(string) + 1);
+	new_string = CM_CAST(char*, malloc(sizeof(char) * stringSize));
 
-  if (new_string == NULL) { /* NOLINT */
-    return NULL;            /* NOLINT */
-  }
-  strcpy(new_string, string);
-  for (p = new_string; *p != 0; ++p) {
-    *p = CM_CAST(char, tolower(*p));
-  }
-  return new_string;
+	if (new_string == NULL)
+	{                /* NOLINT */
+		return NULL; /* NOLINT */
+	}
+	strcpy(new_string, string);
+	for (p = new_string; *p != 0; ++p)
+	{
+		*p = CM_CAST(char, tolower(*p));
+	}
+	return new_string;
 }
 
 int main(int ac, char* av[])
 {
-  int i, testNum = 0, partial_match;
-  char *arg;
-  int testToRun = -1;
-
-  
-
-  /* If no test name was given */
-  /* process command line with user function.  */
-  if (ac < 2) {
-    /* Ask for a test.  */
-    printf("Available tests:\n");
-    for (i = 0; i < NumTests; ++i) {
-      printf("%3d. %s\n", i, cmakeGeneratedFunctionMapEntries[i].name);
-    }
-    printf("To run a test, enter the test number: ");
-    fflush(stdout);
-    if (scanf("%d", &testNum) != 1) {
-      printf("Couldn't parse that input as a number\n");
-      return -1;
-    }
-    if (testNum >= NumTests) {
-      printf("%3d is an invalid test number.\n", testNum);
-      return -1;
-    }
-    testToRun = testNum;
-    ac--;
-    av++;
-  }
-  partial_match = 0;
-  arg = NULL; /* NOLINT */
-  /* If partial match is requested.  */
-  if (testToRun == -1 && ac > 1) {
-    partial_match = (strcmp(av[1], "-R") == 0) ? 1 : 0;
-  }
-  if (partial_match != 0 && ac < 3) {
-    printf("-R needs an additional parameter.\n");
-    return -1;
-  }
-  if (testToRun == -1) {
-    arg = lowercase(av[1 + partial_match]);
-  }
-  for (i = 0; i < NumTests && testToRun == -1; ++i) {
-    char *test_name = lowercase(cmakeGeneratedFunctionMapEntries[i].name);
-    if (partial_match != 0 && strstr(test_name, arg) != NULL) { /* NOLINT */
-      testToRun = i;
-      ac -= 2;
-      av += 2;
-    } else if (partial_match == 0 && strcmp(test_name, arg) == 0) {
-      testToRun = i;
-      ac--;
-      av++;
-    }
-    free(test_name);
-  }
-  free(arg);
-  if (testToRun != -1) {
-    int result;
-
-    if (testToRun < 0 || testToRun >= NumTests) {
-      printf("testToRun was modified by TestDriver code to an invalid value: "
-             "%3d.\n",
-             testNum);
-      return -1;
-    }
-    result = (*cmakeGeneratedFunctionMapEntries[testToRun].func)(ac, av);
-
-    return result;
-  }
-
-  /* Nothing was run, display the test names.  */
-  printf("Available tests:\n");
-  for (i = 0; i < NumTests; ++i) {
-    printf("%3d. %s\n", i, cmakeGeneratedFunctionMapEntries[i].name);
-  }
-  printf("Failed: %s is an invalid test name.\n", av[1]);
+	int i, testNum = 0, partial_match;
+	char* arg;
+	int testToRun = -1;
+
+	/* If no test name was given */
+	/* process command line with user function.  */
+	if (ac < 2)
+	{
+		/* Ask for a test.  */
+		printf("Available tests:\n");
+		for (i = 0; i < NumTests; ++i)
+		{
+			printf("%3d. %s\n", i, cmakeGeneratedFunctionMapEntries[i].name);
+		}
+		printf("To run a test, enter the test number: ");
+		fflush(stdout);
+		if (scanf("%d", &testNum) != 1)
+		{
+			printf("Couldn't parse that input as a number\n");
+			return -1;
+		}
+		if (testNum >= NumTests)
+		{
+			printf("%3d is an invalid test number.\n", testNum);
+			return -1;
+		}
+		testToRun = testNum;
+		ac--;
+		av++;
+	}
+	partial_match = 0;
+	arg = NULL; /* NOLINT */
+	/* If partial match is requested.  */
+	if (testToRun == -1 && ac > 1)
+	{
+		partial_match = (strcmp(av[1], "-R") == 0) ? 1 : 0;
+	}
+	if (partial_match != 0 && ac < 3)
+	{
+		printf("-R needs an additional parameter.\n");
+		return -1;
+	}
+	if (testToRun == -1)
+	{
+		arg = lowercase(av[1 + partial_match]);
+	}
+	for (i = 0; i < NumTests && testToRun == -1; ++i)
+	{
+		char* test_name = lowercase(cmakeGeneratedFunctionMapEntries[i].name);
+		if (partial_match != 0 && strstr(test_name, arg) != NULL)
+		{ /* NOLINT */
+			testToRun = i;
+			ac -= 2;
+			av += 2;
+		}
+		else if (partial_match == 0 && strcmp(test_name, arg) == 0)
+		{
+			testToRun = i;
+			ac--;
+			av++;
+		}
+		free(test_name);
+	}
+	free(arg);
+	if (testToRun != -1)
+	{
+		int result;
+
+		if (testToRun < 0 || testToRun >= NumTests)
+		{
+			printf("testToRun was modified by TestDriver code to an invalid value: "
+			       "%3d.\n",
+			       testNum);
+			return -1;
+		}
+		result = (*cmakeGeneratedFunctionMapEntries[testToRun].func)(ac, av);
+
+		return result;
+	}
+
+	/* Nothing was run, display the test names.  */
+	printf("Available tests:\n");
+	for (i = 0; i < NumTests; ++i)
+	{
+		printf("%3d. %s\n", i, cmakeGeneratedFunctionMapEntries[i].name);
+	}
+	printf("Failed: %s is an invalid test name.\n", av[1]);
 
-  return -1;
+	return -1;
 }
diff -urN winpr/libwinpr/file/generic.c ../../informatimago/FreeRDP/winpr/libwinpr/file/generic.c
--- winpr/libwinpr/file/generic.c	2019-07-25 19:51:08.781936693 +0300
+++ ../../informatimago/FreeRDP/winpr/libwinpr/file/generic.c	2019-07-25 20:11:32.620005748 +0300
@@ -1076,14 +1076,9 @@
 			}
 
 			memcpy(fullpath, pFileSearch->lpPath, pathlen);
-
-			/* Ensure path is terminated with a separator, but prevent
-			 * duplicate separators */
-			if (fullpath[pathlen - 1] != '/')
-				fullpath[pathlen++] = '/';
-
-			memcpy(fullpath + pathlen, pFileSearch->pDirent->d_name, namelen);
-			fullpath[pathlen + namelen] = 0;
+			fullpath[pathlen] = '/';
+			memcpy(fullpath + pathlen + 1, pFileSearch->pDirent->d_name, namelen);
+			fullpath[pathlen + namelen + 1] = 0;
 
 			if (stat(fullpath, &fileStat) != 0)
 			{
@@ -1140,15 +1135,10 @@
 BOOL FindClose(HANDLE hFindFile)
 {
 	WIN32_FILE_SEARCH* pFileSearch = (WIN32_FILE_SEARCH*)hFindFile;
-	/* Since INVALID_HANDLE_VALUE != NULL the analyzer guesses that there
-	 * is a initialized HANDLE that is not freed properly.
-	 * Disable this return to stop confusing the analyzer. */
-#	ifndef __clang_analyzer__
 
 	if (!pFileSearch || (pFileSearch == INVALID_HANDLE_VALUE))
 		return FALSE;
 
-#	endif
 	free(pFileSearch->lpPath);
 	free(pFileSearch->lpPattern);
 
diff -urN winpr/libwinpr/file/test/TestFile.c ../../informatimago/FreeRDP/winpr/libwinpr/file/test/TestFile.c
--- winpr/libwinpr/file/test/TestFile.c	2019-07-25 20:17:16.361710354 +0300
+++ ../../informatimago/FreeRDP/winpr/libwinpr/file/test/TestFile.c	2019-07-25 20:11:32.636005828 +0300
@@ -4,11 +4,9 @@
 #include <string.h> /* NOLINT */
 
 #if defined(_MSC_VER)
-#pragma warning(disable : 4996) /* deprecation */
+#	pragma warning(disable : 4996) /* deprecation */
 #endif
 
-
-
 /* Forward declare test functions. */
 int TestFileCreateFile(int, char*[]);
 int TestFileDeleteFile(int, char*[]);
@@ -20,163 +18,149 @@
 int TestFileFindNextFile(int, char*[]);
 int TestFileGetStdHandle(int, char*[]);
 
-
 #ifdef __cplusplus
-#define CM_CAST(TYPE, EXPR) static_cast<TYPE>(EXPR)
+#	define CM_CAST(TYPE, EXPR) static_cast<TYPE>(EXPR)
 #else
-#define CM_CAST(TYPE, EXPR) (TYPE)(EXPR)
+#	define CM_CAST(TYPE, EXPR) (TYPE)(EXPR)
 #endif
 
 /* Create map.  */
 
-typedef int (*MainFuncPointer)(int, char* []); /* NOLINT */
-typedef struct /* NOLINT */
+typedef int (*MainFuncPointer)(int, char*[]); /* NOLINT */
+typedef struct                                /* NOLINT */
 {
-  const char* name;
-  MainFuncPointer func;
+	const char* name;
+	MainFuncPointer func;
 } functionMapEntry;
 
 static functionMapEntry cmakeGeneratedFunctionMapEntries[] = {
-    {
-    "TestFileCreateFile",
-    TestFileCreateFile
-  },
-  {
-    "TestFileDeleteFile",
-    TestFileDeleteFile
-  },
-  {
-    "TestFileReadFile",
-    TestFileReadFile
-  },
-  {
-    "TestFileWriteFile",
-    TestFileWriteFile
-  },
-  {
-    "TestFilePatternMatch",
-    TestFilePatternMatch
-  },
-  {
-    "TestFileFindFirstFile",
-    TestFileFindFirstFile
-  },
-  {
-    "TestFileFindFirstFileEx",
-    TestFileFindFirstFileEx
-  },
-  {
-    "TestFileFindNextFile",
-    TestFileFindNextFile
-  },
-  {
-    "TestFileGetStdHandle",
-    TestFileGetStdHandle
-  },
+	{ "TestFileCreateFile", TestFileCreateFile },
+	{ "TestFileDeleteFile", TestFileDeleteFile },
+	{ "TestFileReadFile", TestFileReadFile },
+	{ "TestFileWriteFile", TestFileWriteFile },
+	{ "TestFilePatternMatch", TestFilePatternMatch },
+	{ "TestFileFindFirstFile", TestFileFindFirstFile },
+	{ "TestFileFindFirstFileEx", TestFileFindFirstFileEx },
+	{ "TestFileFindNextFile", TestFileFindNextFile },
+	{ "TestFileGetStdHandle", TestFileGetStdHandle },
 
-  { NULL, NULL } /* NOLINT */
+	{ NULL, NULL } /* NOLINT */
 };
 
-static const int NumTests = CM_CAST(int,
-  sizeof(cmakeGeneratedFunctionMapEntries) / sizeof(functionMapEntry)) - 1;
+static const int NumTests =
+    CM_CAST(int, sizeof(cmakeGeneratedFunctionMapEntries) / sizeof(functionMapEntry)) - 1;
 
 /* Allocate and create a lowercased copy of string
    (note that it has to be free'd manually) */
 static char* lowercase(const char* string)
 {
-  char *new_string, *p;
-  size_t stringSize;
+	char *new_string, *p;
+	size_t stringSize;
 
-  stringSize = CM_CAST(size_t, strlen(string) + 1);
-  new_string = CM_CAST(char*, malloc(sizeof(char) * stringSize));
+	stringSize = CM_CAST(size_t, strlen(string) + 1);
+	new_string = CM_CAST(char*, malloc(sizeof(char) * stringSize));
 
-  if (new_string == NULL) { /* NOLINT */
-    return NULL;            /* NOLINT */
-  }
-  strcpy(new_string, string);
-  for (p = new_string; *p != 0; ++p) {
-    *p = CM_CAST(char, tolower(*p));
-  }
-  return new_string;
+	if (new_string == NULL)
+	{                /* NOLINT */
+		return NULL; /* NOLINT */
+	}
+	strcpy(new_string, string);
+	for (p = new_string; *p != 0; ++p)
+	{
+		*p = CM_CAST(char, tolower(*p));
+	}
+	return new_string;
 }
 
 int main(int ac, char* av[])
 {
-  int i, testNum = 0, partial_match;
-  char *arg;
-  int testToRun = -1;
-
-  
-
-  /* If no test name was given */
-  /* process command line with user function.  */
-  if (ac < 2) {
-    /* Ask for a test.  */
-    printf("Available tests:\n");
-    for (i = 0; i < NumTests; ++i) {
-      printf("%3d. %s\n", i, cmakeGeneratedFunctionMapEntries[i].name);
-    }
-    printf("To run a test, enter the test number: ");
-    fflush(stdout);
-    if (scanf("%d", &testNum) != 1) {
-      printf("Couldn't parse that input as a number\n");
-      return -1;
-    }
-    if (testNum >= NumTests) {
-      printf("%3d is an invalid test number.\n", testNum);
-      return -1;
-    }
-    testToRun = testNum;
-    ac--;
-    av++;
-  }
-  partial_match = 0;
-  arg = NULL; /* NOLINT */
-  /* If partial match is requested.  */
-  if (testToRun == -1 && ac > 1) {
-    partial_match = (strcmp(av[1], "-R") == 0) ? 1 : 0;
-  }
-  if (partial_match != 0 && ac < 3) {
-    printf("-R needs an additional parameter.\n");
-    return -1;
-  }
-  if (testToRun == -1) {
-    arg = lowercase(av[1 + partial_match]);
-  }
-  for (i = 0; i < NumTests && testToRun == -1; ++i) {
-    char *test_name = lowercase(cmakeGeneratedFunctionMapEntries[i].name);
-    if (partial_match != 0 && strstr(test_name, arg) != NULL) { /* NOLINT */
-      testToRun = i;
-      ac -= 2;
-      av += 2;
-    } else if (partial_match == 0 && strcmp(test_name, arg) == 0) {
-      testToRun = i;
-      ac--;
-      av++;
-    }
-    free(test_name);
-  }
-  free(arg);
-  if (testToRun != -1) {
-    int result;
-
-    if (testToRun < 0 || testToRun >= NumTests) {
-      printf("testToRun was modified by TestDriver code to an invalid value: "
-             "%3d.\n",
-             testNum);
-      return -1;
-    }
-    result = (*cmakeGeneratedFunctionMapEntries[testToRun].func)(ac, av);
-
-    return result;
-  }
-
-  /* Nothing was run, display the test names.  */
-  printf("Available tests:\n");
-  for (i = 0; i < NumTests; ++i) {
-    printf("%3d. %s\n", i, cmakeGeneratedFunctionMapEntries[i].name);
-  }
-  printf("Failed: %s is an invalid test name.\n", av[1]);
+	int i, testNum = 0, partial_match;
+	char* arg;
+	int testToRun = -1;
+
+	/* If no test name was given */
+	/* process command line with user function.  */
+	if (ac < 2)
+	{
+		/* Ask for a test.  */
+		printf("Available tests:\n");
+		for (i = 0; i < NumTests; ++i)
+		{
+			printf("%3d. %s\n", i, cmakeGeneratedFunctionMapEntries[i].name);
+		}
+		printf("To run a test, enter the test number: ");
+		fflush(stdout);
+		if (scanf("%d", &testNum) != 1)
+		{
+			printf("Couldn't parse that input as a number\n");
+			return -1;
+		}
+		if (testNum >= NumTests)
+		{
+			printf("%3d is an invalid test number.\n", testNum);
+			return -1;
+		}
+		testToRun = testNum;
+		ac--;
+		av++;
+	}
+	partial_match = 0;
+	arg = NULL; /* NOLINT */
+	/* If partial match is requested.  */
+	if (testToRun == -1 && ac > 1)
+	{
+		partial_match = (strcmp(av[1], "-R") == 0) ? 1 : 0;
+	}
+	if (partial_match != 0 && ac < 3)
+	{
+		printf("-R needs an additional parameter.\n");
+		return -1;
+	}
+	if (testToRun == -1)
+	{
+		arg = lowercase(av[1 + partial_match]);
+	}
+	for (i = 0; i < NumTests && testToRun == -1; ++i)
+	{
+		char* test_name = lowercase(cmakeGeneratedFunctionMapEntries[i].name);
+		if (partial_match != 0 && strstr(test_name, arg) != NULL)
+		{ /* NOLINT */
+			testToRun = i;
+			ac -= 2;
+			av += 2;
+		}
+		else if (partial_match == 0 && strcmp(test_name, arg) == 0)
+		{
+			testToRun = i;
+			ac--;
+			av++;
+		}
+		free(test_name);
+	}
+	free(arg);
+	if (testToRun != -1)
+	{
+		int result;
+
+		if (testToRun < 0 || testToRun >= NumTests)
+		{
+			printf("testToRun was modified by TestDriver code to an invalid value: "
+			       "%3d.\n",
+			       testNum);
+			return -1;
+		}
+		result = (*cmakeGeneratedFunctionMapEntries[testToRun].func)(ac, av);
+
+		return result;
+	}
+
+	/* Nothing was run, display the test names.  */
+	printf("Available tests:\n");
+	for (i = 0; i < NumTests; ++i)
+	{
+		printf("%3d. %s\n", i, cmakeGeneratedFunctionMapEntries[i].name);
+	}
+	printf("Failed: %s is an invalid test name.\n", av[1]);
 
-  return -1;
+	return -1;
 }
diff -urN winpr/libwinpr/handle/CMakeLists.txt ../../informatimago/FreeRDP/winpr/libwinpr/handle/CMakeLists.txt
--- winpr/libwinpr/handle/CMakeLists.txt	2019-07-24 06:11:52.538197907 +0300
+++ ../../informatimago/FreeRDP/winpr/libwinpr/handle/CMakeLists.txt	2019-07-19 20:00:17.497205428 +0300
@@ -19,5 +19,5 @@
 winpr_module_add(handle.c handle.h nonehandle.c nonehandle.h)
 	
 if(${CMAKE_SYSTEM_NAME} MATCHES SunOS)
-	winpr_library_add_private(rt)
+	winpr_library_add(rt)
 endif()
diff -urN winpr/libwinpr/handle/handle.h ../../informatimago/FreeRDP/winpr/libwinpr/handle/handle.h
--- winpr/libwinpr/handle/handle.h	2019-07-25 19:51:08.817936871 +0300
+++ ../../informatimago/FreeRDP/winpr/libwinpr/handle/handle.h	2019-07-25 20:11:32.656005927 +0300
@@ -125,17 +125,9 @@
 {
 	WINPR_HANDLE* wHandle;
 
-	if (handle == NULL)
+	if (handle == NULL || handle == INVALID_HANDLE_VALUE)
 		return FALSE;
 
-		/* INVALID_HANDLE_VALUE is an invalid value for every handle, but it
-		 * confuses the clang scanbuild analyzer. */
-#ifndef __clang_analyzer__
-
-	if (handle == INVALID_HANDLE_VALUE)
-		return FALSE;
-
-#endif
 	wHandle = (WINPR_HANDLE*)handle;
 	*pType = wHandle->Type;
 	*pObject = handle;
diff -urN winpr/libwinpr/interlocked/interlocked.c ../../informatimago/FreeRDP/winpr/libwinpr/interlocked/interlocked.c
--- winpr/libwinpr/interlocked/interlocked.c	2019-07-25 19:51:08.885937209 +0300
+++ ../../informatimago/FreeRDP/winpr/libwinpr/interlocked/interlocked.c	2019-07-25 20:11:32.720006245 +0300
@@ -78,18 +78,8 @@
 		ListEntry->Next = old.s.Next.Next;
 		newHeader.s.Depth = old.s.Depth + 1;
 		newHeader.s.Sequence = old.s.Sequence + 1;
-
-		if (old.Alignment > INT64_MAX)
-			return NULL;
-
-		if (newHeader.Alignment > INT64_MAX)
-			return NULL;
-
-		if (ListHead->Alignment > INT64_MAX)
-			return NULL;
-	} while (InterlockedCompareExchange64((LONGLONG*)&ListHead->Alignment,
-	                                      (LONGLONG)newHeader.Alignment,
-	                                      (LONGLONG)old.Alignment) != (LONGLONG)old.Alignment);
+	} while (InterlockedCompareExchange64((LONGLONG*)&ListHead->Alignment, newHeader.Alignment,
+	                                      old.Alignment) != old.Alignment);
 
 	return old.s.Next.Next;
 #	endif
@@ -145,18 +135,8 @@
 		newHeader.s.Next.Next = entry->Next;
 		newHeader.s.Depth = old.s.Depth - 1;
 		newHeader.s.Sequence = old.s.Sequence + 1;
-
-		if (old.Alignment > INT64_MAX)
-			return NULL;
-
-		if (newHeader.Alignment > INT64_MAX)
-			return NULL;
-
-		if (ListHead->Alignment > INT64_MAX)
-			return NULL;
-	} while (InterlockedCompareExchange64((LONGLONG*)&ListHead->Alignment,
-	                                      (LONGLONG)newHeader.Alignment,
-	                                      (LONGLONG)old.Alignment) != (LONGLONG)old.Alignment);
+	} while (InterlockedCompareExchange64((LONGLONG*)&ListHead->Alignment, newHeader.Alignment,
+	                                      old.Alignment) != old.Alignment);
 
 #	endif
 	return entry;
@@ -197,18 +177,8 @@
 	{
 		old = *ListHead;
 		newHeader.s.Sequence = old.s.Sequence + 1;
-
-		if (old.Alignment > INT64_MAX)
-			return NULL;
-
-		if (newHeader.Alignment > INT64_MAX)
-			return NULL;
-
-		if (ListHead->Alignment > INT64_MAX)
-			return NULL;
-	} while (InterlockedCompareExchange64((LONGLONG*)&ListHead->Alignment,
-	                                      (LONGLONG)newHeader.Alignment,
-	                                      (LONGLONG)old.Alignment) != (LONGLONG)old.Alignment);
+	} while (InterlockedCompareExchange64((LONGLONG*)&ListHead->Alignment, newHeader.Alignment,
+	                                      old.Alignment) != old.Alignment);
 
 	return old.s.Next.Next;
 #	endif
diff -urN winpr/libwinpr/interlocked/test/TestInterlockedAccess.c ../../informatimago/FreeRDP/winpr/libwinpr/interlocked/test/TestInterlockedAccess.c
--- winpr/libwinpr/interlocked/test/TestInterlockedAccess.c	2019-07-25 19:51:08.889937228 +0300
+++ ../../informatimago/FreeRDP/winpr/libwinpr/interlocked/test/TestInterlockedAccess.c	2019-07-25 20:11:32.728006284 +0300
@@ -92,10 +92,10 @@
 		return -1;
 	}
 
-	*Destination = (LONG)0xAABBCCDDL;
-	oldValue = InterlockedCompareExchange(Destination, (LONG)0xCCDDEEFFL, (LONG)0xAABBCCDDL);
+	*Destination = 0xAABBCCDD;
+	oldValue = InterlockedCompareExchange(Destination, 0xCCDDEEFF, 0xAABBCCDD);
 
-	if (oldValue != (LONG)0xAABBCCDDL)
+	if (oldValue != 0xAABBCCDD)
 	{
 		printf("InterlockedCompareExchange failure: Actual: 0x%08" PRIX32
 		       ", Expected: 0xAABBCCDD\n",
@@ -103,7 +103,7 @@
 		return -1;
 	}
 
-	if ((*Destination) != (LONG)0xCCDDEEFFL)
+	if (*Destination != 0xCCDDEEFF)
 	{
 		printf("InterlockedCompareExchange failure: Actual: 0x%08" PRIX32
 		       ", Expected: 0xCCDDEEFF\n",
@@ -112,10 +112,10 @@
 	}
 
 	/* InterlockedCompareExchange (*Destination != Comparand) */
-	*Destination = (LONG)0xAABBCCDDL;
-	oldValue = InterlockedCompareExchange(Destination, 0xCCDDEEFFL, 0x66778899);
+	*Destination = 0xAABBCCDD;
+	oldValue = InterlockedCompareExchange(Destination, 0xCCDDEEFF, 0x66778899);
 
-	if (oldValue != (LONG)0xAABBCCDDL)
+	if (oldValue != 0xAABBCCDD)
 	{
 		printf("InterlockedCompareExchange failure: Actual: 0x%08" PRIX32
 		       ", Expected: 0xAABBCCDD\n",
@@ -123,7 +123,7 @@
 		return -1;
 	}
 
-	if ((*Destination) != (LONG)0xAABBCCDDL)
+	if (*Destination != 0xAABBCCDD)
 	{
 		printf("InterlockedCompareExchange failure: Actual: 0x%08" PRIX32
 		       ", Expected: 0xAABBCCDD\n",
@@ -152,7 +152,7 @@
 		return -1;
 	}
 
-	if ((*Destination64) != (LONGLONG)0x8899AABBCCDDEEFFLL)
+	if (*Destination64 != 0x8899AABBCCDDEEFF)
 	{
 		printf("InterlockedCompareExchange failure: Actual: 0x%016" PRIX64
 		       ", Expected: 0x8899AABBCCDDEEFF\n",
@@ -161,10 +161,10 @@
 	}
 
 	/* InterlockedCompareExchange64 (*Destination != Comparand) */
-	*Destination64 = 0x66778899AABBCCDDLL;
-	oldValue64 = InterlockedCompareExchange64(Destination64, 0x8899AABBCCDDEEFFLL, 12345);
+	*Destination64 = 0x66778899AABBCCDD;
+	oldValue64 = InterlockedCompareExchange64(Destination64, 0x8899AABBCCDDEEFF, 12345);
 
-	if (oldValue64 != 0x66778899AABBCCDDLL)
+	if (oldValue64 != 0x66778899AABBCCDD)
 	{
 		printf("InterlockedCompareExchange failure: Actual: 0x%016" PRIX64
 		       ", Expected: 0x66778899AABBCCDD\n",
@@ -172,7 +172,7 @@
 		return -1;
 	}
 
-	if (*Destination64 != 0x66778899AABBCCDDLL)
+	if (*Destination64 != 0x66778899AABBCCDD)
 	{
 		printf("InterlockedCompareExchange failure: Actual: 0x%016" PRIX64
 		       ", Expected: 0x66778899AABBCCDD\n",
diff -urN winpr/libwinpr/interlocked/test/TestInterlocked.c ../../informatimago/FreeRDP/winpr/libwinpr/interlocked/test/TestInterlocked.c
--- winpr/libwinpr/interlocked/test/TestInterlocked.c	2019-07-25 20:17:16.365710374 +0300
+++ ../../informatimago/FreeRDP/winpr/libwinpr/interlocked/test/TestInterlocked.c	2019-07-25 20:11:32.724006264 +0300
@@ -4,149 +4,151 @@
 #include <string.h> /* NOLINT */
 
 #if defined(_MSC_VER)
-#pragma warning(disable : 4996) /* deprecation */
+#	pragma warning(disable : 4996) /* deprecation */
 #endif
 
-
-
 /* Forward declare test functions. */
 int TestInterlockedAccess(int, char*[]);
 int TestInterlockedSList(int, char*[]);
 int TestInterlockedDList(int, char*[]);
 
-
 #ifdef __cplusplus
-#define CM_CAST(TYPE, EXPR) static_cast<TYPE>(EXPR)
+#	define CM_CAST(TYPE, EXPR) static_cast<TYPE>(EXPR)
 #else
-#define CM_CAST(TYPE, EXPR) (TYPE)(EXPR)
+#	define CM_CAST(TYPE, EXPR) (TYPE)(EXPR)
 #endif
 
 /* Create map.  */
 
-typedef int (*MainFuncPointer)(int, char* []); /* NOLINT */
-typedef struct /* NOLINT */
+typedef int (*MainFuncPointer)(int, char*[]); /* NOLINT */
+typedef struct                                /* NOLINT */
 {
-  const char* name;
-  MainFuncPointer func;
+	const char* name;
+	MainFuncPointer func;
 } functionMapEntry;
 
 static functionMapEntry cmakeGeneratedFunctionMapEntries[] = {
-    {
-    "TestInterlockedAccess",
-    TestInterlockedAccess
-  },
-  {
-    "TestInterlockedSList",
-    TestInterlockedSList
-  },
-  {
-    "TestInterlockedDList",
-    TestInterlockedDList
-  },
+	{ "TestInterlockedAccess", TestInterlockedAccess },
+	{ "TestInterlockedSList", TestInterlockedSList },
+	{ "TestInterlockedDList", TestInterlockedDList },
 
-  { NULL, NULL } /* NOLINT */
+	{ NULL, NULL } /* NOLINT */
 };
 
-static const int NumTests = CM_CAST(int,
-  sizeof(cmakeGeneratedFunctionMapEntries) / sizeof(functionMapEntry)) - 1;
+static const int NumTests =
+    CM_CAST(int, sizeof(cmakeGeneratedFunctionMapEntries) / sizeof(functionMapEntry)) - 1;
 
 /* Allocate and create a lowercased copy of string
    (note that it has to be free'd manually) */
 static char* lowercase(const char* string)
 {
-  char *new_string, *p;
-  size_t stringSize;
+	char *new_string, *p;
+	size_t stringSize;
 
-  stringSize = CM_CAST(size_t, strlen(string) + 1);
-  new_string = CM_CAST(char*, malloc(sizeof(char) * stringSize));
+	stringSize = CM_CAST(size_t, strlen(string) + 1);
+	new_string = CM_CAST(char*, malloc(sizeof(char) * stringSize));
 
-  if (new_string == NULL) { /* NOLINT */
-    return NULL;            /* NOLINT */
-  }
-  strcpy(new_string, string);
-  for (p = new_string; *p != 0; ++p) {
-    *p = CM_CAST(char, tolower(*p));
-  }
-  return new_string;
+	if (new_string == NULL)
+	{                /* NOLINT */
+		return NULL; /* NOLINT */
+	}
+	strcpy(new_string, string);
+	for (p = new_string; *p != 0; ++p)
+	{
+		*p = CM_CAST(char, tolower(*p));
+	}
+	return new_string;
 }
 
 int main(int ac, char* av[])
 {
-  int i, testNum = 0, partial_match;
-  char *arg;
-  int testToRun = -1;
-
-  
-
-  /* If no test name was given */
-  /* process command line with user function.  */
-  if (ac < 2) {
-    /* Ask for a test.  */
-    printf("Available tests:\n");
-    for (i = 0; i < NumTests; ++i) {
-      printf("%3d. %s\n", i, cmakeGeneratedFunctionMapEntries[i].name);
-    }
-    printf("To run a test, enter the test number: ");
-    fflush(stdout);
-    if (scanf("%d", &testNum) != 1) {
-      printf("Couldn't parse that input as a number\n");
-      return -1;
-    }
-    if (testNum >= NumTests) {
-      printf("%3d is an invalid test number.\n", testNum);
-      return -1;
-    }
-    testToRun = testNum;
-    ac--;
-    av++;
-  }
-  partial_match = 0;
-  arg = NULL; /* NOLINT */
-  /* If partial match is requested.  */
-  if (testToRun == -1 && ac > 1) {
-    partial_match = (strcmp(av[1], "-R") == 0) ? 1 : 0;
-  }
-  if (partial_match != 0 && ac < 3) {
-    printf("-R needs an additional parameter.\n");
-    return -1;
-  }
-  if (testToRun == -1) {
-    arg = lowercase(av[1 + partial_match]);
-  }
-  for (i = 0; i < NumTests && testToRun == -1; ++i) {
-    char *test_name = lowercase(cmakeGeneratedFunctionMapEntries[i].name);
-    if (partial_match != 0 && strstr(test_name, arg) != NULL) { /* NOLINT */
-      testToRun = i;
-      ac -= 2;
-      av += 2;
-    } else if (partial_match == 0 && strcmp(test_name, arg) == 0) {
-      testToRun = i;
-      ac--;
-      av++;
-    }
-    free(test_name);
-  }
-  free(arg);
-  if (testToRun != -1) {
-    int result;
-
-    if (testToRun < 0 || testToRun >= NumTests) {
-      printf("testToRun was modified by TestDriver code to an invalid value: "
-             "%3d.\n",
-             testNum);
-      return -1;
-    }
-    result = (*cmakeGeneratedFunctionMapEntries[testToRun].func)(ac, av);
-
-    return result;
-  }
-
-  /* Nothing was run, display the test names.  */
-  printf("Available tests:\n");
-  for (i = 0; i < NumTests; ++i) {
-    printf("%3d. %s\n", i, cmakeGeneratedFunctionMapEntries[i].name);
-  }
-  printf("Failed: %s is an invalid test name.\n", av[1]);
+	int i, testNum = 0, partial_match;
+	char* arg;
+	int testToRun = -1;
+
+	/* If no test name was given */
+	/* process command line with user function.  */
+	if (ac < 2)
+	{
+		/* Ask for a test.  */
+		printf("Available tests:\n");
+		for (i = 0; i < NumTests; ++i)
+		{
+			printf("%3d. %s\n", i, cmakeGeneratedFunctionMapEntries[i].name);
+		}
+		printf("To run a test, enter the test number: ");
+		fflush(stdout);
+		if (scanf("%d", &testNum) != 1)
+		{
+			printf("Couldn't parse that input as a number\n");
+			return -1;
+		}
+		if (testNum >= NumTests)
+		{
+			printf("%3d is an invalid test number.\n", testNum);
+			return -1;
+		}
+		testToRun = testNum;
+		ac--;
+		av++;
+	}
+	partial_match = 0;
+	arg = NULL; /* NOLINT */
+	/* If partial match is requested.  */
+	if (testToRun == -1 && ac > 1)
+	{
+		partial_match = (strcmp(av[1], "-R") == 0) ? 1 : 0;
+	}
+	if (partial_match != 0 && ac < 3)
+	{
+		printf("-R needs an additional parameter.\n");
+		return -1;
+	}
+	if (testToRun == -1)
+	{
+		arg = lowercase(av[1 + partial_match]);
+	}
+	for (i = 0; i < NumTests && testToRun == -1; ++i)
+	{
+		char* test_name = lowercase(cmakeGeneratedFunctionMapEntries[i].name);
+		if (partial_match != 0 && strstr(test_name, arg) != NULL)
+		{ /* NOLINT */
+			testToRun = i;
+			ac -= 2;
+			av += 2;
+		}
+		else if (partial_match == 0 && strcmp(test_name, arg) == 0)
+		{
+			testToRun = i;
+			ac--;
+			av++;
+		}
+		free(test_name);
+	}
+	free(arg);
+	if (testToRun != -1)
+	{
+		int result;
+
+		if (testToRun < 0 || testToRun >= NumTests)
+		{
+			printf("testToRun was modified by TestDriver code to an invalid value: "
+			       "%3d.\n",
+			       testNum);
+			return -1;
+		}
+		result = (*cmakeGeneratedFunctionMapEntries[testToRun].func)(ac, av);
+
+		return result;
+	}
+
+	/* Nothing was run, display the test names.  */
+	printf("Available tests:\n");
+	for (i = 0; i < NumTests; ++i)
+	{
+		printf("%3d. %s\n", i, cmakeGeneratedFunctionMapEntries[i].name);
+	}
+	printf("Failed: %s is an invalid test name.\n", av[1]);
 
-  return -1;
+	return -1;
 }
diff -urN winpr/libwinpr/io/test/TestIo.c ../../informatimago/FreeRDP/winpr/libwinpr/io/test/TestIo.c
--- winpr/libwinpr/io/test/TestIo.c	2019-07-25 20:17:16.377710434 +0300
+++ ../../informatimago/FreeRDP/winpr/libwinpr/io/test/TestIo.c	2019-07-25 20:11:32.744006363 +0300
@@ -4,144 +4,149 @@
 #include <string.h> /* NOLINT */
 
 #if defined(_MSC_VER)
-#pragma warning(disable : 4996) /* deprecation */
+#	pragma warning(disable : 4996) /* deprecation */
 #endif
 
-
-
 /* Forward declare test functions. */
 int TestIoDevice(int, char*[]);
 int TestIoGetOverlappedResult(int, char*[]);
 
-
 #ifdef __cplusplus
-#define CM_CAST(TYPE, EXPR) static_cast<TYPE>(EXPR)
+#	define CM_CAST(TYPE, EXPR) static_cast<TYPE>(EXPR)
 #else
-#define CM_CAST(TYPE, EXPR) (TYPE)(EXPR)
+#	define CM_CAST(TYPE, EXPR) (TYPE)(EXPR)
 #endif
 
 /* Create map.  */
 
-typedef int (*MainFuncPointer)(int, char* []); /* NOLINT */
-typedef struct /* NOLINT */
+typedef int (*MainFuncPointer)(int, char*[]); /* NOLINT */
+typedef struct                                /* NOLINT */
 {
-  const char* name;
-  MainFuncPointer func;
+	const char* name;
+	MainFuncPointer func;
 } functionMapEntry;
 
 static functionMapEntry cmakeGeneratedFunctionMapEntries[] = {
-    {
-    "TestIoDevice",
-    TestIoDevice
-  },
-  {
-    "TestIoGetOverlappedResult",
-    TestIoGetOverlappedResult
-  },
+	{ "TestIoDevice", TestIoDevice },
+	{ "TestIoGetOverlappedResult", TestIoGetOverlappedResult },
 
-  { NULL, NULL } /* NOLINT */
+	{ NULL, NULL } /* NOLINT */
 };
 
-static const int NumTests = CM_CAST(int,
-  sizeof(cmakeGeneratedFunctionMapEntries) / sizeof(functionMapEntry)) - 1;
+static const int NumTests =
+    CM_CAST(int, sizeof(cmakeGeneratedFunctionMapEntries) / sizeof(functionMapEntry)) - 1;
 
 /* Allocate and create a lowercased copy of string
    (note that it has to be free'd manually) */
 static char* lowercase(const char* string)
 {
-  char *new_string, *p;
-  size_t stringSize;
+	char *new_string, *p;
+	size_t stringSize;
 
-  stringSize = CM_CAST(size_t, strlen(string) + 1);
-  new_string = CM_CAST(char*, malloc(sizeof(char) * stringSize));
+	stringSize = CM_CAST(size_t, strlen(string) + 1);
+	new_string = CM_CAST(char*, malloc(sizeof(char) * stringSize));
 
-  if (new_string == NULL) { /* NOLINT */
-    return NULL;            /* NOLINT */
-  }
-  strcpy(new_string, string);
-  for (p = new_string; *p != 0; ++p) {
-    *p = CM_CAST(char, tolower(*p));
-  }
-  return new_string;
+	if (new_string == NULL)
+	{                /* NOLINT */
+		return NULL; /* NOLINT */
+	}
+	strcpy(new_string, string);
+	for (p = new_string; *p != 0; ++p)
+	{
+		*p = CM_CAST(char, tolower(*p));
+	}
+	return new_string;
 }
 
 int main(int ac, char* av[])
 {
-  int i, testNum = 0, partial_match;
-  char *arg;
-  int testToRun = -1;
-
-  
-
-  /* If no test name was given */
-  /* process command line with user function.  */
-  if (ac < 2) {
-    /* Ask for a test.  */
-    printf("Available tests:\n");
-    for (i = 0; i < NumTests; ++i) {
-      printf("%3d. %s\n", i, cmakeGeneratedFunctionMapEntries[i].name);
-    }
-    printf("To run a test, enter the test number: ");
-    fflush(stdout);
-    if (scanf("%d", &testNum) != 1) {
-      printf("Couldn't parse that input as a number\n");
-      return -1;
-    }
-    if (testNum >= NumTests) {
-      printf("%3d is an invalid test number.\n", testNum);
-      return -1;
-    }
-    testToRun = testNum;
-    ac--;
-    av++;
-  }
-  partial_match = 0;
-  arg = NULL; /* NOLINT */
-  /* If partial match is requested.  */
-  if (testToRun == -1 && ac > 1) {
-    partial_match = (strcmp(av[1], "-R") == 0) ? 1 : 0;
-  }
-  if (partial_match != 0 && ac < 3) {
-    printf("-R needs an additional parameter.\n");
-    return -1;
-  }
-  if (testToRun == -1) {
-    arg = lowercase(av[1 + partial_match]);
-  }
-  for (i = 0; i < NumTests && testToRun == -1; ++i) {
-    char *test_name = lowercase(cmakeGeneratedFunctionMapEntries[i].name);
-    if (partial_match != 0 && strstr(test_name, arg) != NULL) { /* NOLINT */
-      testToRun = i;
-      ac -= 2;
-      av += 2;
-    } else if (partial_match == 0 && strcmp(test_name, arg) == 0) {
-      testToRun = i;
-      ac--;
-      av++;
-    }
-    free(test_name);
-  }
-  free(arg);
-  if (testToRun != -1) {
-    int result;
-
-    if (testToRun < 0 || testToRun >= NumTests) {
-      printf("testToRun was modified by TestDriver code to an invalid value: "
-             "%3d.\n",
-             testNum);
-      return -1;
-    }
-    result = (*cmakeGeneratedFunctionMapEntries[testToRun].func)(ac, av);
-
-    return result;
-  }
-
-  /* Nothing was run, display the test names.  */
-  printf("Available tests:\n");
-  for (i = 0; i < NumTests; ++i) {
-    printf("%3d. %s\n", i, cmakeGeneratedFunctionMapEntries[i].name);
-  }
-  printf("Failed: %s is an invalid test name.\n", av[1]);
+	int i, testNum = 0, partial_match;
+	char* arg;
+	int testToRun = -1;
+
+	/* If no test name was given */
+	/* process command line with user function.  */
+	if (ac < 2)
+	{
+		/* Ask for a test.  */
+		printf("Available tests:\n");
+		for (i = 0; i < NumTests; ++i)
+		{
+			printf("%3d. %s\n", i, cmakeGeneratedFunctionMapEntries[i].name);
+		}
+		printf("To run a test, enter the test number: ");
+		fflush(stdout);
+		if (scanf("%d", &testNum) != 1)
+		{
+			printf("Couldn't parse that input as a number\n");
+			return -1;
+		}
+		if (testNum >= NumTests)
+		{
+			printf("%3d is an invalid test number.\n", testNum);
+			return -1;
+		}
+		testToRun = testNum;
+		ac--;
+		av++;
+	}
+	partial_match = 0;
+	arg = NULL; /* NOLINT */
+	/* If partial match is requested.  */
+	if (testToRun == -1 && ac > 1)
+	{
+		partial_match = (strcmp(av[1], "-R") == 0) ? 1 : 0;
+	}
+	if (partial_match != 0 && ac < 3)
+	{
+		printf("-R needs an additional parameter.\n");
+		return -1;
+	}
+	if (testToRun == -1)
+	{
+		arg = lowercase(av[1 + partial_match]);
+	}
+	for (i = 0; i < NumTests && testToRun == -1; ++i)
+	{
+		char* test_name = lowercase(cmakeGeneratedFunctionMapEntries[i].name);
+		if (partial_match != 0 && strstr(test_name, arg) != NULL)
+		{ /* NOLINT */
+			testToRun = i;
+			ac -= 2;
+			av += 2;
+		}
+		else if (partial_match == 0 && strcmp(test_name, arg) == 0)
+		{
+			testToRun = i;
+			ac--;
+			av++;
+		}
+		free(test_name);
+	}
+	free(arg);
+	if (testToRun != -1)
+	{
+		int result;
+
+		if (testToRun < 0 || testToRun >= NumTests)
+		{
+			printf("testToRun was modified by TestDriver code to an invalid value: "
+			       "%3d.\n",
+			       testNum);
+			return -1;
+		}
+		result = (*cmakeGeneratedFunctionMapEntries[testToRun].func)(ac, av);
+
+		return result;
+	}
+
+	/* Nothing was run, display the test names.  */
+	printf("Available tests:\n");
+	for (i = 0; i < NumTests; ++i)
+	{
+		printf("%3d. %s\n", i, cmakeGeneratedFunctionMapEntries[i].name);
+	}
+	printf("Failed: %s is an invalid test name.\n", av[1]);
 
-  return -1;
+	return -1;
 }
diff -urN winpr/libwinpr/library/library.c ../../informatimago/FreeRDP/winpr/libwinpr/library/library.c
--- winpr/libwinpr/library/library.c	2019-07-25 19:51:08.913937347 +0300
+++ ../../informatimago/FreeRDP/winpr/libwinpr/library/library.c	2019-07-25 20:11:32.748006383 +0300
@@ -83,26 +83,17 @@
 
 DLL_DIRECTORY_COOKIE AddDllDirectory(PCWSTR NewDirectory)
 {
-	/* TODO: Implement */
-	WLog_ERR(TAG, "%s not implemented", __FUNCTION__);
-	SetLastError(ERROR_CALL_NOT_IMPLEMENTED);
 	return NULL;
 }
 
 BOOL RemoveDllDirectory(DLL_DIRECTORY_COOKIE Cookie)
 {
-	/* TODO: Implement */
-	WLog_ERR(TAG, "%s not implemented", __FUNCTION__);
-	SetLastError(ERROR_CALL_NOT_IMPLEMENTED);
-	return FALSE;
+	return TRUE;
 }
 
 BOOL SetDefaultDllDirectories(DWORD DirectoryFlags)
 {
-	/* TODO: Implement */
-	WLog_ERR(TAG, "%s not implemented", __FUNCTION__);
-	SetLastError(ERROR_CALL_NOT_IMPLEMENTED);
-	return FALSE;
+	return TRUE;
 }
 
 HMODULE LoadLibraryA(LPCSTR lpLibFileName)
@@ -120,7 +111,7 @@
 	if (status < 1)
 		return NULL;
 
-	hModule = LoadLibraryW(filenameW);
+	hModule = LoadPackagedLibrary(filenameW, 0);
 	free(filenameW);
 	return hModule;
 #	else
@@ -129,7 +120,7 @@
 
 	if (!library)
 	{
-		WLog_ERR(TAG, "%s failed with %s", __FUNCTION__, dlerror());
+		WLog_ERR(TAG, "LoadLibraryA: %s", dlerror());
 		return NULL;
 	}
 
@@ -142,39 +133,31 @@
 #	if defined(_UWP)
 	return LoadPackagedLibrary(lpLibFileName, 0);
 #	else
-	char* name = NULL;
-	HMODULE module;
-	int rc = ConvertFromUnicode(CP_UTF8, 0, lpLibFileName, -1, &name, 0, NULL, NULL);
-
-	if (rc < 0)
-		return NULL;
-
-	module = LoadLibraryA(name);
-	free(name);
-	return module;
+	return (HMODULE)NULL;
 #	endif
 }
 
 HMODULE LoadLibraryExA(LPCSTR lpLibFileName, HANDLE hFile, DWORD dwFlags)
 {
-	if (dwFlags != 0)
-		WLog_WARN(TAG, "%s does not support dwFlags 0x%08" PRIx32, __FUNCTION__, dwFlags);
+#	if !defined(_UWP)
+	HMODULE library;
+	library = dlopen(lpLibFileName, RTLD_LOCAL | RTLD_LAZY);
 
-	if (hFile)
-		WLog_WARN(TAG, "%s does not support hFile != NULL", __FUNCTION__);
+	if (!library)
+	{
+		WLog_ERR(TAG, "LoadLibraryExA: failed to open %s: %s", lpLibFileName, dlerror());
+		return NULL;
+	}
 
-	return LoadLibraryA(lpLibFileName);
+	return library;
+#	else
+	return (HMODULE)NULL;
+#	endif
 }
 
 HMODULE LoadLibraryExW(LPCWSTR lpLibFileName, HANDLE hFile, DWORD dwFlags)
 {
-	if (dwFlags != 0)
-		WLog_WARN(TAG, "%s does not support dwFlags 0x%08" PRIx32, __FUNCTION__, dwFlags);
-
-	if (hFile)
-		WLog_WARN(TAG, "%s does not support hFile != NULL", __FUNCTION__);
-
-	return LoadLibraryW(lpLibFileName);
+	return (HMODULE)NULL;
 }
 
 #endif
@@ -208,17 +191,11 @@
 
 HMODULE GetModuleHandleA(LPCSTR lpModuleName)
 {
-	/* TODO: Implement */
-	WLog_ERR(TAG, "%s not implemented", __FUNCTION__);
-	SetLastError(ERROR_CALL_NOT_IMPLEMENTED);
 	return NULL;
 }
 
 HMODULE GetModuleHandleW(LPCWSTR lpModuleName)
 {
-	/* TODO: Implement */
-	WLog_ERR(TAG, "%s not implemented", __FUNCTION__);
-	SetLastError(ERROR_CALL_NOT_IMPLEMENTED);
 	return NULL;
 }
 
@@ -232,37 +209,9 @@
 
 DWORD GetModuleFileNameW(HMODULE hModule, LPWSTR lpFilename, DWORD nSize)
 {
-	DWORD status;
-	char* name = calloc(nSize, sizeof(char));
-
-	if (!name)
-	{
-		SetLastError(ERROR_INTERNAL_ERROR);
-		return 0;
-	}
-
-	status = GetModuleFileNameA(hModule, name, nSize);
-
-	if ((status > INT_MAX) || (nSize > INT_MAX))
-	{
-		SetLastError(ERROR_INTERNAL_ERROR);
-		status = 0;
-	}
-
-	if (status > 0)
-	{
-		int rc = ConvertToUnicode(CP_UTF8, 0, name, (int)status, &lpFilename, (int)nSize);
-
-		if (rc < 0)
-		{
-			free(name);
-			SetLastError(ERROR_INTERNAL_ERROR);
-			return 0;
-		}
-	}
-
-	free(name);
-	return status;
+	WLog_ERR(TAG, "%s is not implemented", __FUNCTION__);
+	SetLastError(ERROR_CALL_NOT_IMPLEMENTED);
+	return 0;
 }
 
 DWORD GetModuleFileNameA(HMODULE hModule, LPSTR lpFilename, DWORD nSize)
@@ -302,7 +251,7 @@
 
 #	elif defined(__MACOSX__)
 	int status;
-	size_t length;
+	int length;
 
 	if (!hModule)
 	{
@@ -329,7 +278,7 @@
 		{
 			CopyMemory(lpFilename, buffer, length);
 			lpFilename[length] = '\0';
-			return (DWORD)length;
+			return length;
 		}
 
 		CopyMemory(lpFilename, buffer, nSize - 1);
diff -urN winpr/libwinpr/library/test/TestLibrary.c ../../informatimago/FreeRDP/winpr/libwinpr/library/test/TestLibrary.c
--- winpr/libwinpr/library/test/TestLibrary.c	2019-07-25 20:17:16.353710314 +0300
+++ ../../informatimago/FreeRDP/winpr/libwinpr/library/test/TestLibrary.c	2019-07-25 20:11:32.752006403 +0300
@@ -4,149 +4,151 @@
 #include <string.h> /* NOLINT */
 
 #if defined(_MSC_VER)
-#pragma warning(disable : 4996) /* deprecation */
+#	pragma warning(disable : 4996) /* deprecation */
 #endif
 
-
-
 /* Forward declare test functions. */
 int TestLibraryLoadLibrary(int, char*[]);
 int TestLibraryGetProcAddress(int, char*[]);
 int TestLibraryGetModuleFileName(int, char*[]);
 
-
 #ifdef __cplusplus
-#define CM_CAST(TYPE, EXPR) static_cast<TYPE>(EXPR)
+#	define CM_CAST(TYPE, EXPR) static_cast<TYPE>(EXPR)
 #else
-#define CM_CAST(TYPE, EXPR) (TYPE)(EXPR)
+#	define CM_CAST(TYPE, EXPR) (TYPE)(EXPR)
 #endif
 
 /* Create map.  */
 
-typedef int (*MainFuncPointer)(int, char* []); /* NOLINT */
-typedef struct /* NOLINT */
+typedef int (*MainFuncPointer)(int, char*[]); /* NOLINT */
+typedef struct                                /* NOLINT */
 {
-  const char* name;
-  MainFuncPointer func;
+	const char* name;
+	MainFuncPointer func;
 } functionMapEntry;
 
 static functionMapEntry cmakeGeneratedFunctionMapEntries[] = {
-    {
-    "TestLibraryLoadLibrary",
-    TestLibraryLoadLibrary
-  },
-  {
-    "TestLibraryGetProcAddress",
-    TestLibraryGetProcAddress
-  },
-  {
-    "TestLibraryGetModuleFileName",
-    TestLibraryGetModuleFileName
-  },
+	{ "TestLibraryLoadLibrary", TestLibraryLoadLibrary },
+	{ "TestLibraryGetProcAddress", TestLibraryGetProcAddress },
+	{ "TestLibraryGetModuleFileName", TestLibraryGetModuleFileName },
 
-  { NULL, NULL } /* NOLINT */
+	{ NULL, NULL } /* NOLINT */
 };
 
-static const int NumTests = CM_CAST(int,
-  sizeof(cmakeGeneratedFunctionMapEntries) / sizeof(functionMapEntry)) - 1;
+static const int NumTests =
+    CM_CAST(int, sizeof(cmakeGeneratedFunctionMapEntries) / sizeof(functionMapEntry)) - 1;
 
 /* Allocate and create a lowercased copy of string
    (note that it has to be free'd manually) */
 static char* lowercase(const char* string)
 {
-  char *new_string, *p;
-  size_t stringSize;
+	char *new_string, *p;
+	size_t stringSize;
 
-  stringSize = CM_CAST(size_t, strlen(string) + 1);
-  new_string = CM_CAST(char*, malloc(sizeof(char) * stringSize));
+	stringSize = CM_CAST(size_t, strlen(string) + 1);
+	new_string = CM_CAST(char*, malloc(sizeof(char) * stringSize));
 
-  if (new_string == NULL) { /* NOLINT */
-    return NULL;            /* NOLINT */
-  }
-  strcpy(new_string, string);
-  for (p = new_string; *p != 0; ++p) {
-    *p = CM_CAST(char, tolower(*p));
-  }
-  return new_string;
+	if (new_string == NULL)
+	{                /* NOLINT */
+		return NULL; /* NOLINT */
+	}
+	strcpy(new_string, string);
+	for (p = new_string; *p != 0; ++p)
+	{
+		*p = CM_CAST(char, tolower(*p));
+	}
+	return new_string;
 }
 
 int main(int ac, char* av[])
 {
-  int i, testNum = 0, partial_match;
-  char *arg;
-  int testToRun = -1;
-
-  
-
-  /* If no test name was given */
-  /* process command line with user function.  */
-  if (ac < 2) {
-    /* Ask for a test.  */
-    printf("Available tests:\n");
-    for (i = 0; i < NumTests; ++i) {
-      printf("%3d. %s\n", i, cmakeGeneratedFunctionMapEntries[i].name);
-    }
-    printf("To run a test, enter the test number: ");
-    fflush(stdout);
-    if (scanf("%d", &testNum) != 1) {
-      printf("Couldn't parse that input as a number\n");
-      return -1;
-    }
-    if (testNum >= NumTests) {
-      printf("%3d is an invalid test number.\n", testNum);
-      return -1;
-    }
-    testToRun = testNum;
-    ac--;
-    av++;
-  }
-  partial_match = 0;
-  arg = NULL; /* NOLINT */
-  /* If partial match is requested.  */
-  if (testToRun == -1 && ac > 1) {
-    partial_match = (strcmp(av[1], "-R") == 0) ? 1 : 0;
-  }
-  if (partial_match != 0 && ac < 3) {
-    printf("-R needs an additional parameter.\n");
-    return -1;
-  }
-  if (testToRun == -1) {
-    arg = lowercase(av[1 + partial_match]);
-  }
-  for (i = 0; i < NumTests && testToRun == -1; ++i) {
-    char *test_name = lowercase(cmakeGeneratedFunctionMapEntries[i].name);
-    if (partial_match != 0 && strstr(test_name, arg) != NULL) { /* NOLINT */
-      testToRun = i;
-      ac -= 2;
-      av += 2;
-    } else if (partial_match == 0 && strcmp(test_name, arg) == 0) {
-      testToRun = i;
-      ac--;
-      av++;
-    }
-    free(test_name);
-  }
-  free(arg);
-  if (testToRun != -1) {
-    int result;
-
-    if (testToRun < 0 || testToRun >= NumTests) {
-      printf("testToRun was modified by TestDriver code to an invalid value: "
-             "%3d.\n",
-             testNum);
-      return -1;
-    }
-    result = (*cmakeGeneratedFunctionMapEntries[testToRun].func)(ac, av);
-
-    return result;
-  }
-
-  /* Nothing was run, display the test names.  */
-  printf("Available tests:\n");
-  for (i = 0; i < NumTests; ++i) {
-    printf("%3d. %s\n", i, cmakeGeneratedFunctionMapEntries[i].name);
-  }
-  printf("Failed: %s is an invalid test name.\n", av[1]);
+	int i, testNum = 0, partial_match;
+	char* arg;
+	int testToRun = -1;
+
+	/* If no test name was given */
+	/* process command line with user function.  */
+	if (ac < 2)
+	{
+		/* Ask for a test.  */
+		printf("Available tests:\n");
+		for (i = 0; i < NumTests; ++i)
+		{
+			printf("%3d. %s\n", i, cmakeGeneratedFunctionMapEntries[i].name);
+		}
+		printf("To run a test, enter the test number: ");
+		fflush(stdout);
+		if (scanf("%d", &testNum) != 1)
+		{
+			printf("Couldn't parse that input as a number\n");
+			return -1;
+		}
+		if (testNum >= NumTests)
+		{
+			printf("%3d is an invalid test number.\n", testNum);
+			return -1;
+		}
+		testToRun = testNum;
+		ac--;
+		av++;
+	}
+	partial_match = 0;
+	arg = NULL; /* NOLINT */
+	/* If partial match is requested.  */
+	if (testToRun == -1 && ac > 1)
+	{
+		partial_match = (strcmp(av[1], "-R") == 0) ? 1 : 0;
+	}
+	if (partial_match != 0 && ac < 3)
+	{
+		printf("-R needs an additional parameter.\n");
+		return -1;
+	}
+	if (testToRun == -1)
+	{
+		arg = lowercase(av[1 + partial_match]);
+	}
+	for (i = 0; i < NumTests && testToRun == -1; ++i)
+	{
+		char* test_name = lowercase(cmakeGeneratedFunctionMapEntries[i].name);
+		if (partial_match != 0 && strstr(test_name, arg) != NULL)
+		{ /* NOLINT */
+			testToRun = i;
+			ac -= 2;
+			av += 2;
+		}
+		else if (partial_match == 0 && strcmp(test_name, arg) == 0)
+		{
+			testToRun = i;
+			ac--;
+			av++;
+		}
+		free(test_name);
+	}
+	free(arg);
+	if (testToRun != -1)
+	{
+		int result;
+
+		if (testToRun < 0 || testToRun >= NumTests)
+		{
+			printf("testToRun was modified by TestDriver code to an invalid value: "
+			       "%3d.\n",
+			       testNum);
+			return -1;
+		}
+		result = (*cmakeGeneratedFunctionMapEntries[testToRun].func)(ac, av);
+
+		return result;
+	}
+
+	/* Nothing was run, display the test names.  */
+	printf("Available tests:\n");
+	for (i = 0; i < NumTests; ++i)
+	{
+		printf("%3d. %s\n", i, cmakeGeneratedFunctionMapEntries[i].name);
+	}
+	printf("Failed: %s is an invalid test name.\n", av[1]);
 
-  return -1;
+	return -1;
 }
diff -urN winpr/libwinpr/locale/CMakeLists.txt ../../informatimago/FreeRDP/winpr/libwinpr/locale/CMakeLists.txt
--- winpr/libwinpr/locale/CMakeLists.txt	2019-07-24 06:11:52.542197927 +0300
+++ ../../informatimago/FreeRDP/winpr/libwinpr/locale/CMakeLists.txt	2019-07-19 20:00:17.501205415 +0300
@@ -18,7 +18,7 @@
 winpr_module_add(locale.c)
 
 if(WIN32)
-	winpr_library_add_public(ntdsapi)
+	winpr_library_add(ntdsapi)
 endif()
 
 if(BUILD_TESTING)
diff -urN winpr/libwinpr/locale/test/TestLocale.c ../../informatimago/FreeRDP/winpr/libwinpr/locale/test/TestLocale.c
--- winpr/libwinpr/locale/test/TestLocale.c	2019-07-25 20:17:16.349710295 +0300
+++ ../../informatimago/FreeRDP/winpr/libwinpr/locale/test/TestLocale.c	2019-07-25 20:11:32.764006462 +0300
@@ -4,139 +4,147 @@
 #include <string.h> /* NOLINT */
 
 #if defined(_MSC_VER)
-#pragma warning(disable : 4996) /* deprecation */
+#	pragma warning(disable : 4996) /* deprecation */
 #endif
 
-
-
 /* Forward declare test functions. */
 int TestLocaleFormatMessage(int, char*[]);
 
-
 #ifdef __cplusplus
-#define CM_CAST(TYPE, EXPR) static_cast<TYPE>(EXPR)
+#	define CM_CAST(TYPE, EXPR) static_cast<TYPE>(EXPR)
 #else
-#define CM_CAST(TYPE, EXPR) (TYPE)(EXPR)
+#	define CM_CAST(TYPE, EXPR) (TYPE)(EXPR)
 #endif
 
 /* Create map.  */
 
-typedef int (*MainFuncPointer)(int, char* []); /* NOLINT */
-typedef struct /* NOLINT */
+typedef int (*MainFuncPointer)(int, char*[]); /* NOLINT */
+typedef struct                                /* NOLINT */
 {
-  const char* name;
-  MainFuncPointer func;
+	const char* name;
+	MainFuncPointer func;
 } functionMapEntry;
 
 static functionMapEntry cmakeGeneratedFunctionMapEntries[] = {
-    {
-    "TestLocaleFormatMessage",
-    TestLocaleFormatMessage
-  },
+	{ "TestLocaleFormatMessage", TestLocaleFormatMessage },
 
-  { NULL, NULL } /* NOLINT */
+	{ NULL, NULL } /* NOLINT */
 };
 
-static const int NumTests = CM_CAST(int,
-  sizeof(cmakeGeneratedFunctionMapEntries) / sizeof(functionMapEntry)) - 1;
+static const int NumTests =
+    CM_CAST(int, sizeof(cmakeGeneratedFunctionMapEntries) / sizeof(functionMapEntry)) - 1;
 
 /* Allocate and create a lowercased copy of string
    (note that it has to be free'd manually) */
 static char* lowercase(const char* string)
 {
-  char *new_string, *p;
-  size_t stringSize;
+	char *new_string, *p;
+	size_t stringSize;
 
-  stringSize = CM_CAST(size_t, strlen(string) + 1);
-  new_string = CM_CAST(char*, malloc(sizeof(char) * stringSize));
+	stringSize = CM_CAST(size_t, strlen(string) + 1);
+	new_string = CM_CAST(char*, malloc(sizeof(char) * stringSize));
 
-  if (new_string == NULL) { /* NOLINT */
-    return NULL;            /* NOLINT */
-  }
-  strcpy(new_string, string);
-  for (p = new_string; *p != 0; ++p) {
-    *p = CM_CAST(char, tolower(*p));
-  }
-  return new_string;
+	if (new_string == NULL)
+	{                /* NOLINT */
+		return NULL; /* NOLINT */
+	}
+	strcpy(new_string, string);
+	for (p = new_string; *p != 0; ++p)
+	{
+		*p = CM_CAST(char, tolower(*p));
+	}
+	return new_string;
 }
 
 int main(int ac, char* av[])
 {
-  int i, testNum = 0, partial_match;
-  char *arg;
-  int testToRun = -1;
-
-  
-
-  /* If no test name was given */
-  /* process command line with user function.  */
-  if (ac < 2) {
-    /* Ask for a test.  */
-    printf("Available tests:\n");
-    for (i = 0; i < NumTests; ++i) {
-      printf("%3d. %s\n", i, cmakeGeneratedFunctionMapEntries[i].name);
-    }
-    printf("To run a test, enter the test number: ");
-    fflush(stdout);
-    if (scanf("%d", &testNum) != 1) {
-      printf("Couldn't parse that input as a number\n");
-      return -1;
-    }
-    if (testNum >= NumTests) {
-      printf("%3d is an invalid test number.\n", testNum);
-      return -1;
-    }
-    testToRun = testNum;
-    ac--;
-    av++;
-  }
-  partial_match = 0;
-  arg = NULL; /* NOLINT */
-  /* If partial match is requested.  */
-  if (testToRun == -1 && ac > 1) {
-    partial_match = (strcmp(av[1], "-R") == 0) ? 1 : 0;
-  }
-  if (partial_match != 0 && ac < 3) {
-    printf("-R needs an additional parameter.\n");
-    return -1;
-  }
-  if (testToRun == -1) {
-    arg = lowercase(av[1 + partial_match]);
-  }
-  for (i = 0; i < NumTests && testToRun == -1; ++i) {
-    char *test_name = lowercase(cmakeGeneratedFunctionMapEntries[i].name);
-    if (partial_match != 0 && strstr(test_name, arg) != NULL) { /* NOLINT */
-      testToRun = i;
-      ac -= 2;
-      av += 2;
-    } else if (partial_match == 0 && strcmp(test_name, arg) == 0) {
-      testToRun = i;
-      ac--;
-      av++;
-    }
-    free(test_name);
-  }
-  free(arg);
-  if (testToRun != -1) {
-    int result;
-
-    if (testToRun < 0 || testToRun >= NumTests) {
-      printf("testToRun was modified by TestDriver code to an invalid value: "
-             "%3d.\n",
-             testNum);
-      return -1;
-    }
-    result = (*cmakeGeneratedFunctionMapEntries[testToRun].func)(ac, av);
-
-    return result;
-  }
-
-  /* Nothing was run, display the test names.  */
-  printf("Available tests:\n");
-  for (i = 0; i < NumTests; ++i) {
-    printf("%3d. %s\n", i, cmakeGeneratedFunctionMapEntries[i].name);
-  }
-  printf("Failed: %s is an invalid test name.\n", av[1]);
+	int i, testNum = 0, partial_match;
+	char* arg;
+	int testToRun = -1;
+
+	/* If no test name was given */
+	/* process command line with user function.  */
+	if (ac < 2)
+	{
+		/* Ask for a test.  */
+		printf("Available tests:\n");
+		for (i = 0; i < NumTests; ++i)
+		{
+			printf("%3d. %s\n", i, cmakeGeneratedFunctionMapEntries[i].name);
+		}
+		printf("To run a test, enter the test number: ");
+		fflush(stdout);
+		if (scanf("%d", &testNum) != 1)
+		{
+			printf("Couldn't parse that input as a number\n");
+			return -1;
+		}
+		if (testNum >= NumTests)
+		{
+			printf("%3d is an invalid test number.\n", testNum);
+			return -1;
+		}
+		testToRun = testNum;
+		ac--;
+		av++;
+	}
+	partial_match = 0;
+	arg = NULL; /* NOLINT */
+	/* If partial match is requested.  */
+	if (testToRun == -1 && ac > 1)
+	{
+		partial_match = (strcmp(av[1], "-R") == 0) ? 1 : 0;
+	}
+	if (partial_match != 0 && ac < 3)
+	{
+		printf("-R needs an additional parameter.\n");
+		return -1;
+	}
+	if (testToRun == -1)
+	{
+		arg = lowercase(av[1 + partial_match]);
+	}
+	for (i = 0; i < NumTests && testToRun == -1; ++i)
+	{
+		char* test_name = lowercase(cmakeGeneratedFunctionMapEntries[i].name);
+		if (partial_match != 0 && strstr(test_name, arg) != NULL)
+		{ /* NOLINT */
+			testToRun = i;
+			ac -= 2;
+			av += 2;
+		}
+		else if (partial_match == 0 && strcmp(test_name, arg) == 0)
+		{
+			testToRun = i;
+			ac--;
+			av++;
+		}
+		free(test_name);
+	}
+	free(arg);
+	if (testToRun != -1)
+	{
+		int result;
+
+		if (testToRun < 0 || testToRun >= NumTests)
+		{
+			printf("testToRun was modified by TestDriver code to an invalid value: "
+			       "%3d.\n",
+			       testNum);
+			return -1;
+		}
+		result = (*cmakeGeneratedFunctionMapEntries[testToRun].func)(ac, av);
+
+		return result;
+	}
+
+	/* Nothing was run, display the test names.  */
+	printf("Available tests:\n");
+	for (i = 0; i < NumTests; ++i)
+	{
+		printf("%3d. %s\n", i, cmakeGeneratedFunctionMapEntries[i].name);
+	}
+	printf("Failed: %s is an invalid test name.\n", av[1]);
 
-  return -1;
+	return -1;
 }
diff -urN winpr/libwinpr/memory/test/TestMemory.c ../../informatimago/FreeRDP/winpr/libwinpr/memory/test/TestMemory.c
--- winpr/libwinpr/memory/test/TestMemory.c	2019-07-25 20:17:16.381710453 +0300
+++ ../../informatimago/FreeRDP/winpr/libwinpr/memory/test/TestMemory.c	2019-07-25 20:11:32.772006502 +0300
@@ -4,139 +4,147 @@
 #include <string.h> /* NOLINT */
 
 #if defined(_MSC_VER)
-#pragma warning(disable : 4996) /* deprecation */
+#	pragma warning(disable : 4996) /* deprecation */
 #endif
 
-
-
 /* Forward declare test functions. */
 int TestMemoryCreateFileMapping(int, char*[]);
 
-
 #ifdef __cplusplus
-#define CM_CAST(TYPE, EXPR) static_cast<TYPE>(EXPR)
+#	define CM_CAST(TYPE, EXPR) static_cast<TYPE>(EXPR)
 #else
-#define CM_CAST(TYPE, EXPR) (TYPE)(EXPR)
+#	define CM_CAST(TYPE, EXPR) (TYPE)(EXPR)
 #endif
 
 /* Create map.  */
 
-typedef int (*MainFuncPointer)(int, char* []); /* NOLINT */
-typedef struct /* NOLINT */
+typedef int (*MainFuncPointer)(int, char*[]); /* NOLINT */
+typedef struct                                /* NOLINT */
 {
-  const char* name;
-  MainFuncPointer func;
+	const char* name;
+	MainFuncPointer func;
 } functionMapEntry;
 
 static functionMapEntry cmakeGeneratedFunctionMapEntries[] = {
-    {
-    "TestMemoryCreateFileMapping",
-    TestMemoryCreateFileMapping
-  },
+	{ "TestMemoryCreateFileMapping", TestMemoryCreateFileMapping },
 
-  { NULL, NULL } /* NOLINT */
+	{ NULL, NULL } /* NOLINT */
 };
 
-static const int NumTests = CM_CAST(int,
-  sizeof(cmakeGeneratedFunctionMapEntries) / sizeof(functionMapEntry)) - 1;
+static const int NumTests =
+    CM_CAST(int, sizeof(cmakeGeneratedFunctionMapEntries) / sizeof(functionMapEntry)) - 1;
 
 /* Allocate and create a lowercased copy of string
    (note that it has to be free'd manually) */
 static char* lowercase(const char* string)
 {
-  char *new_string, *p;
-  size_t stringSize;
+	char *new_string, *p;
+	size_t stringSize;
 
-  stringSize = CM_CAST(size_t, strlen(string) + 1);
-  new_string = CM_CAST(char*, malloc(sizeof(char) * stringSize));
+	stringSize = CM_CAST(size_t, strlen(string) + 1);
+	new_string = CM_CAST(char*, malloc(sizeof(char) * stringSize));
 
-  if (new_string == NULL) { /* NOLINT */
-    return NULL;            /* NOLINT */
-  }
-  strcpy(new_string, string);
-  for (p = new_string; *p != 0; ++p) {
-    *p = CM_CAST(char, tolower(*p));
-  }
-  return new_string;
+	if (new_string == NULL)
+	{                /* NOLINT */
+		return NULL; /* NOLINT */
+	}
+	strcpy(new_string, string);
+	for (p = new_string; *p != 0; ++p)
+	{
+		*p = CM_CAST(char, tolower(*p));
+	}
+	return new_string;
 }
 
 int main(int ac, char* av[])
 {
-  int i, testNum = 0, partial_match;
-  char *arg;
-  int testToRun = -1;
-
-  
-
-  /* If no test name was given */
-  /* process command line with user function.  */
-  if (ac < 2) {
-    /* Ask for a test.  */
-    printf("Available tests:\n");
-    for (i = 0; i < NumTests; ++i) {
-      printf("%3d. %s\n", i, cmakeGeneratedFunctionMapEntries[i].name);
-    }
-    printf("To run a test, enter the test number: ");
-    fflush(stdout);
-    if (scanf("%d", &testNum) != 1) {
-      printf("Couldn't parse that input as a number\n");
-      return -1;
-    }
-    if (testNum >= NumTests) {
-      printf("%3d is an invalid test number.\n", testNum);
-      return -1;
-    }
-    testToRun = testNum;
-    ac--;
-    av++;
-  }
-  partial_match = 0;
-  arg = NULL; /* NOLINT */
-  /* If partial match is requested.  */
-  if (testToRun == -1 && ac > 1) {
-    partial_match = (strcmp(av[1], "-R") == 0) ? 1 : 0;
-  }
-  if (partial_match != 0 && ac < 3) {
-    printf("-R needs an additional parameter.\n");
-    return -1;
-  }
-  if (testToRun == -1) {
-    arg = lowercase(av[1 + partial_match]);
-  }
-  for (i = 0; i < NumTests && testToRun == -1; ++i) {
-    char *test_name = lowercase(cmakeGeneratedFunctionMapEntries[i].name);
-    if (partial_match != 0 && strstr(test_name, arg) != NULL) { /* NOLINT */
-      testToRun = i;
-      ac -= 2;
-      av += 2;
-    } else if (partial_match == 0 && strcmp(test_name, arg) == 0) {
-      testToRun = i;
-      ac--;
-      av++;
-    }
-    free(test_name);
-  }
-  free(arg);
-  if (testToRun != -1) {
-    int result;
-
-    if (testToRun < 0 || testToRun >= NumTests) {
-      printf("testToRun was modified by TestDriver code to an invalid value: "
-             "%3d.\n",
-             testNum);
-      return -1;
-    }
-    result = (*cmakeGeneratedFunctionMapEntries[testToRun].func)(ac, av);
-
-    return result;
-  }
-
-  /* Nothing was run, display the test names.  */
-  printf("Available tests:\n");
-  for (i = 0; i < NumTests; ++i) {
-    printf("%3d. %s\n", i, cmakeGeneratedFunctionMapEntries[i].name);
-  }
-  printf("Failed: %s is an invalid test name.\n", av[1]);
+	int i, testNum = 0, partial_match;
+	char* arg;
+	int testToRun = -1;
+
+	/* If no test name was given */
+	/* process command line with user function.  */
+	if (ac < 2)
+	{
+		/* Ask for a test.  */
+		printf("Available tests:\n");
+		for (i = 0; i < NumTests; ++i)
+		{
+			printf("%3d. %s\n", i, cmakeGeneratedFunctionMapEntries[i].name);
+		}
+		printf("To run a test, enter the test number: ");
+		fflush(stdout);
+		if (scanf("%d", &testNum) != 1)
+		{
+			printf("Couldn't parse that input as a number\n");
+			return -1;
+		}
+		if (testNum >= NumTests)
+		{
+			printf("%3d is an invalid test number.\n", testNum);
+			return -1;
+		}
+		testToRun = testNum;
+		ac--;
+		av++;
+	}
+	partial_match = 0;
+	arg = NULL; /* NOLINT */
+	/* If partial match is requested.  */
+	if (testToRun == -1 && ac > 1)
+	{
+		partial_match = (strcmp(av[1], "-R") == 0) ? 1 : 0;
+	}
+	if (partial_match != 0 && ac < 3)
+	{
+		printf("-R needs an additional parameter.\n");
+		return -1;
+	}
+	if (testToRun == -1)
+	{
+		arg = lowercase(av[1 + partial_match]);
+	}
+	for (i = 0; i < NumTests && testToRun == -1; ++i)
+	{
+		char* test_name = lowercase(cmakeGeneratedFunctionMapEntries[i].name);
+		if (partial_match != 0 && strstr(test_name, arg) != NULL)
+		{ /* NOLINT */
+			testToRun = i;
+			ac -= 2;
+			av += 2;
+		}
+		else if (partial_match == 0 && strcmp(test_name, arg) == 0)
+		{
+			testToRun = i;
+			ac--;
+			av++;
+		}
+		free(test_name);
+	}
+	free(arg);
+	if (testToRun != -1)
+	{
+		int result;
+
+		if (testToRun < 0 || testToRun >= NumTests)
+		{
+			printf("testToRun was modified by TestDriver code to an invalid value: "
+			       "%3d.\n",
+			       testNum);
+			return -1;
+		}
+		result = (*cmakeGeneratedFunctionMapEntries[testToRun].func)(ac, av);
+
+		return result;
+	}
+
+	/* Nothing was run, display the test names.  */
+	printf("Available tests:\n");
+	for (i = 0; i < NumTests; ++i)
+	{
+		printf("%3d. %s\n", i, cmakeGeneratedFunctionMapEntries[i].name);
+	}
+	printf("Failed: %s is an invalid test name.\n", av[1]);
 
-  return -1;
+	return -1;
 }
diff -urN winpr/libwinpr/nt/CMakeLists.txt ../../informatimago/FreeRDP/winpr/libwinpr/nt/CMakeLists.txt
--- winpr/libwinpr/nt/CMakeLists.txt	2019-07-24 06:11:52.542197927 +0300
+++ ../../informatimago/FreeRDP/winpr/libwinpr/nt/CMakeLists.txt	2019-07-19 20:00:17.501205415 +0300
@@ -17,12 +17,12 @@
 
 winpr_module_add(nt.c)
 
-winpr_library_add_private(
+winpr_library_add(
 	${CMAKE_THREAD_LIBS_INIT}
 	${CMAKE_DL_LIBS})
 
 if(${CMAKE_SYSTEM_NAME} MATCHES SunOS)
-	winpr_library_add_private(rt)
+	winpr_library_add(rt)
 endif()
 
 if(BUILD_TESTING)
diff -urN winpr/libwinpr/nt/test/TestNt.c ../../informatimago/FreeRDP/winpr/libwinpr/nt/test/TestNt.c
--- winpr/libwinpr/nt/test/TestNt.c	2019-07-25 20:17:16.417710632 +0300
+++ ../../informatimago/FreeRDP/winpr/libwinpr/nt/test/TestNt.c	2019-07-25 20:11:32.792006601 +0300
@@ -4,144 +4,149 @@
 #include <string.h> /* NOLINT */
 
 #if defined(_MSC_VER)
-#pragma warning(disable : 4996) /* deprecation */
+#	pragma warning(disable : 4996) /* deprecation */
 #endif
 
-
-
 /* Forward declare test functions. */
 int TestNtCreateFile(int, char*[]);
 int TestNtCurrentTeb(int, char*[]);
 
-
 #ifdef __cplusplus
-#define CM_CAST(TYPE, EXPR) static_cast<TYPE>(EXPR)
+#	define CM_CAST(TYPE, EXPR) static_cast<TYPE>(EXPR)
 #else
-#define CM_CAST(TYPE, EXPR) (TYPE)(EXPR)
+#	define CM_CAST(TYPE, EXPR) (TYPE)(EXPR)
 #endif
 
 /* Create map.  */
 
-typedef int (*MainFuncPointer)(int, char* []); /* NOLINT */
-typedef struct /* NOLINT */
+typedef int (*MainFuncPointer)(int, char*[]); /* NOLINT */
+typedef struct                                /* NOLINT */
 {
-  const char* name;
-  MainFuncPointer func;
+	const char* name;
+	MainFuncPointer func;
 } functionMapEntry;
 
 static functionMapEntry cmakeGeneratedFunctionMapEntries[] = {
-    {
-    "TestNtCreateFile",
-    TestNtCreateFile
-  },
-  {
-    "TestNtCurrentTeb",
-    TestNtCurrentTeb
-  },
+	{ "TestNtCreateFile", TestNtCreateFile },
+	{ "TestNtCurrentTeb", TestNtCurrentTeb },
 
-  { NULL, NULL } /* NOLINT */
+	{ NULL, NULL } /* NOLINT */
 };
 
-static const int NumTests = CM_CAST(int,
-  sizeof(cmakeGeneratedFunctionMapEntries) / sizeof(functionMapEntry)) - 1;
+static const int NumTests =
+    CM_CAST(int, sizeof(cmakeGeneratedFunctionMapEntries) / sizeof(functionMapEntry)) - 1;
 
 /* Allocate and create a lowercased copy of string
    (note that it has to be free'd manually) */
 static char* lowercase(const char* string)
 {
-  char *new_string, *p;
-  size_t stringSize;
+	char *new_string, *p;
+	size_t stringSize;
 
-  stringSize = CM_CAST(size_t, strlen(string) + 1);
-  new_string = CM_CAST(char*, malloc(sizeof(char) * stringSize));
+	stringSize = CM_CAST(size_t, strlen(string) + 1);
+	new_string = CM_CAST(char*, malloc(sizeof(char) * stringSize));
 
-  if (new_string == NULL) { /* NOLINT */
-    return NULL;            /* NOLINT */
-  }
-  strcpy(new_string, string);
-  for (p = new_string; *p != 0; ++p) {
-    *p = CM_CAST(char, tolower(*p));
-  }
-  return new_string;
+	if (new_string == NULL)
+	{                /* NOLINT */
+		return NULL; /* NOLINT */
+	}
+	strcpy(new_string, string);
+	for (p = new_string; *p != 0; ++p)
+	{
+		*p = CM_CAST(char, tolower(*p));
+	}
+	return new_string;
 }
 
 int main(int ac, char* av[])
 {
-  int i, testNum = 0, partial_match;
-  char *arg;
-  int testToRun = -1;
-
-  
-
-  /* If no test name was given */
-  /* process command line with user function.  */
-  if (ac < 2) {
-    /* Ask for a test.  */
-    printf("Available tests:\n");
-    for (i = 0; i < NumTests; ++i) {
-      printf("%3d. %s\n", i, cmakeGeneratedFunctionMapEntries[i].name);
-    }
-    printf("To run a test, enter the test number: ");
-    fflush(stdout);
-    if (scanf("%d", &testNum) != 1) {
-      printf("Couldn't parse that input as a number\n");
-      return -1;
-    }
-    if (testNum >= NumTests) {
-      printf("%3d is an invalid test number.\n", testNum);
-      return -1;
-    }
-    testToRun = testNum;
-    ac--;
-    av++;
-  }
-  partial_match = 0;
-  arg = NULL; /* NOLINT */
-  /* If partial match is requested.  */
-  if (testToRun == -1 && ac > 1) {
-    partial_match = (strcmp(av[1], "-R") == 0) ? 1 : 0;
-  }
-  if (partial_match != 0 && ac < 3) {
-    printf("-R needs an additional parameter.\n");
-    return -1;
-  }
-  if (testToRun == -1) {
-    arg = lowercase(av[1 + partial_match]);
-  }
-  for (i = 0; i < NumTests && testToRun == -1; ++i) {
-    char *test_name = lowercase(cmakeGeneratedFunctionMapEntries[i].name);
-    if (partial_match != 0 && strstr(test_name, arg) != NULL) { /* NOLINT */
-      testToRun = i;
-      ac -= 2;
-      av += 2;
-    } else if (partial_match == 0 && strcmp(test_name, arg) == 0) {
-      testToRun = i;
-      ac--;
-      av++;
-    }
-    free(test_name);
-  }
-  free(arg);
-  if (testToRun != -1) {
-    int result;
-
-    if (testToRun < 0 || testToRun >= NumTests) {
-      printf("testToRun was modified by TestDriver code to an invalid value: "
-             "%3d.\n",
-             testNum);
-      return -1;
-    }
-    result = (*cmakeGeneratedFunctionMapEntries[testToRun].func)(ac, av);
-
-    return result;
-  }
-
-  /* Nothing was run, display the test names.  */
-  printf("Available tests:\n");
-  for (i = 0; i < NumTests; ++i) {
-    printf("%3d. %s\n", i, cmakeGeneratedFunctionMapEntries[i].name);
-  }
-  printf("Failed: %s is an invalid test name.\n", av[1]);
+	int i, testNum = 0, partial_match;
+	char* arg;
+	int testToRun = -1;
+
+	/* If no test name was given */
+	/* process command line with user function.  */
+	if (ac < 2)
+	{
+		/* Ask for a test.  */
+		printf("Available tests:\n");
+		for (i = 0; i < NumTests; ++i)
+		{
+			printf("%3d. %s\n", i, cmakeGeneratedFunctionMapEntries[i].name);
+		}
+		printf("To run a test, enter the test number: ");
+		fflush(stdout);
+		if (scanf("%d", &testNum) != 1)
+		{
+			printf("Couldn't parse that input as a number\n");
+			return -1;
+		}
+		if (testNum >= NumTests)
+		{
+			printf("%3d is an invalid test number.\n", testNum);
+			return -1;
+		}
+		testToRun = testNum;
+		ac--;
+		av++;
+	}
+	partial_match = 0;
+	arg = NULL; /* NOLINT */
+	/* If partial match is requested.  */
+	if (testToRun == -1 && ac > 1)
+	{
+		partial_match = (strcmp(av[1], "-R") == 0) ? 1 : 0;
+	}
+	if (partial_match != 0 && ac < 3)
+	{
+		printf("-R needs an additional parameter.\n");
+		return -1;
+	}
+	if (testToRun == -1)
+	{
+		arg = lowercase(av[1 + partial_match]);
+	}
+	for (i = 0; i < NumTests && testToRun == -1; ++i)
+	{
+		char* test_name = lowercase(cmakeGeneratedFunctionMapEntries[i].name);
+		if (partial_match != 0 && strstr(test_name, arg) != NULL)
+		{ /* NOLINT */
+			testToRun = i;
+			ac -= 2;
+			av += 2;
+		}
+		else if (partial_match == 0 && strcmp(test_name, arg) == 0)
+		{
+			testToRun = i;
+			ac--;
+			av++;
+		}
+		free(test_name);
+	}
+	free(arg);
+	if (testToRun != -1)
+	{
+		int result;
+
+		if (testToRun < 0 || testToRun >= NumTests)
+		{
+			printf("testToRun was modified by TestDriver code to an invalid value: "
+			       "%3d.\n",
+			       testNum);
+			return -1;
+		}
+		result = (*cmakeGeneratedFunctionMapEntries[testToRun].func)(ac, av);
+
+		return result;
+	}
+
+	/* Nothing was run, display the test names.  */
+	printf("Available tests:\n");
+	for (i = 0; i < NumTests; ++i)
+	{
+		printf("%3d. %s\n", i, cmakeGeneratedFunctionMapEntries[i].name);
+	}
+	printf("Failed: %s is an invalid test name.\n", av[1]);
 
-  return -1;
+	return -1;
 }
diff -urN winpr/libwinpr/path/path.c ../../informatimago/FreeRDP/winpr/libwinpr/path/path.c
--- winpr/libwinpr/path/path.c	2019-07-25 19:51:08.985937704 +0300
+++ ../../informatimago/FreeRDP/winpr/libwinpr/path/path.c	2019-07-25 20:11:32.820006740 +0300
@@ -730,17 +730,13 @@
 
 	if (hasPrefix)
 	{
-		int rc;
-
 		if (cchPath < 6)
 			return S_FALSE;
 
-		rc = (lstrlenW(&pszPath[4]) + 1);
-
-		if ((rc < 0) || ((INT64)cchPath < rc))
+		if (cchPath < (lstrlenW(&pszPath[4]) + 1))
 			return HRESULT_FROM_WIN32(ERROR_INSUFFICIENT_BUFFER);
 
-		if (IsCharAlphaW(pszPath[4]) && (pszPath[5] == L':')) /* like C: */
+		if (IsCharAlpha(pszPath[4]) && (pszPath[5] == ':')) /* like C: */
 		{
 			wmemmove_s(pszPath, cchPath, &pszPath[4], cchPath - 4);
 			/* since the passed pszPath must not necessarily be null terminated
diff -urN winpr/libwinpr/path/shell.c ../../informatimago/FreeRDP/winpr/libwinpr/path/shell.c
--- winpr/libwinpr/path/shell.c	2019-07-25 19:51:09.001937783 +0300
+++ ../../informatimago/FreeRDP/winpr/libwinpr/path/shell.c	2019-07-25 20:11:32.836006819 +0300
@@ -41,7 +41,7 @@
 #endif
 
 #if defined(WIN32)
-#	include <shlobj.h>
+#	include <Shlobj.h>
 #else
 #	include <errno.h>
 #	include <dirent.h>
@@ -483,29 +483,15 @@
 	char* dup;
 	char* p;
 	BOOL result = TRUE;
-	/* we only operate on a non-null, absolute path */
-#	if defined(__OS2__)
-
-	if (!path)
-		return FALSE;
-
-#	else
 
+	/* we only operate on a non-null, absolute path */
 	if (!path || *path != delim)
 		return FALSE;
 
-#	endif
-
 	if (!(dup = _strdup(path)))
 		return FALSE;
 
-#	ifdef __OS2__
-	p = (strlen(dup) > 3) && (dup[1] == ':') && (dup[2] == delim)) ? &dup[3] : dup;
-
-	while (p)
-#	else
 	for (p = dup; p;)
-#	endif
 	{
 		if ((p = strchr(p + 1, delim)))
 			*p = '\0';
diff -urN winpr/libwinpr/path/test/TestPath.c ../../informatimago/FreeRDP/winpr/libwinpr/path/test/TestPath.c
--- winpr/libwinpr/path/test/TestPath.c	2019-07-25 20:17:16.377710434 +0300
+++ ../../informatimago/FreeRDP/winpr/libwinpr/path/test/TestPath.c	2019-07-25 20:11:32.844006859 +0300
@@ -4,11 +4,9 @@
 #include <string.h> /* NOLINT */
 
 #if defined(_MSC_VER)
-#pragma warning(disable : 4996) /* deprecation */
+#	pragma warning(disable : 4996) /* deprecation */
 #endif
 
-
-
 /* Forward declare test functions. */
 int TestPathCchAddBackslash(int, char*[]);
 int TestPathCchRemoveBackslash(int, char*[]);
@@ -35,223 +33,164 @@
 int TestPathShell(int, char*[]);
 int TestPathMakePath(int, char*[]);
 
-
 #ifdef __cplusplus
-#define CM_CAST(TYPE, EXPR) static_cast<TYPE>(EXPR)
+#	define CM_CAST(TYPE, EXPR) static_cast<TYPE>(EXPR)
 #else
-#define CM_CAST(TYPE, EXPR) (TYPE)(EXPR)
+#	define CM_CAST(TYPE, EXPR) (TYPE)(EXPR)
 #endif
 
 /* Create map.  */
 
-typedef int (*MainFuncPointer)(int, char* []); /* NOLINT */
-typedef struct /* NOLINT */
+typedef int (*MainFuncPointer)(int, char*[]); /* NOLINT */
+typedef struct                                /* NOLINT */
 {
-  const char* name;
-  MainFuncPointer func;
+	const char* name;
+	MainFuncPointer func;
 } functionMapEntry;
 
 static functionMapEntry cmakeGeneratedFunctionMapEntries[] = {
-    {
-    "TestPathCchAddBackslash",
-    TestPathCchAddBackslash
-  },
-  {
-    "TestPathCchRemoveBackslash",
-    TestPathCchRemoveBackslash
-  },
-  {
-    "TestPathCchAddBackslashEx",
-    TestPathCchAddBackslashEx
-  },
-  {
-    "TestPathCchRemoveBackslashEx",
-    TestPathCchRemoveBackslashEx
-  },
-  {
-    "TestPathCchAddExtension",
-    TestPathCchAddExtension
-  },
-  {
-    "TestPathCchAppend",
-    TestPathCchAppend
-  },
-  {
-    "TestPathCchAppendEx",
-    TestPathCchAppendEx
-  },
-  {
-    "TestPathCchCanonicalize",
-    TestPathCchCanonicalize
-  },
-  {
-    "TestPathCchCanonicalizeEx",
-    TestPathCchCanonicalizeEx
-  },
-  {
-    "TestPathAllocCanonicalize",
-    TestPathAllocCanonicalize
-  },
-  {
-    "TestPathCchCombine",
-    TestPathCchCombine
-  },
-  {
-    "TestPathCchCombineEx",
-    TestPathCchCombineEx
-  },
-  {
-    "TestPathAllocCombine",
-    TestPathAllocCombine
-  },
-  {
-    "TestPathCchFindExtension",
-    TestPathCchFindExtension
-  },
-  {
-    "TestPathCchRenameExtension",
-    TestPathCchRenameExtension
-  },
-  {
-    "TestPathCchRemoveExtension",
-    TestPathCchRemoveExtension
-  },
-  {
-    "TestPathCchIsRoot",
-    TestPathCchIsRoot
-  },
-  {
-    "TestPathIsUNCEx",
-    TestPathIsUNCEx
-  },
-  {
-    "TestPathCchSkipRoot",
-    TestPathCchSkipRoot
-  },
-  {
-    "TestPathCchStripToRoot",
-    TestPathCchStripToRoot
-  },
-  {
-    "TestPathCchStripPrefix",
-    TestPathCchStripPrefix
-  },
-  {
-    "TestPathCchRemoveFileSpec",
-    TestPathCchRemoveFileSpec
-  },
-  {
-    "TestPathShell",
-    TestPathShell
-  },
-  {
-    "TestPathMakePath",
-    TestPathMakePath
-  },
+	{ "TestPathCchAddBackslash", TestPathCchAddBackslash },
+	{ "TestPathCchRemoveBackslash", TestPathCchRemoveBackslash },
+	{ "TestPathCchAddBackslashEx", TestPathCchAddBackslashEx },
+	{ "TestPathCchRemoveBackslashEx", TestPathCchRemoveBackslashEx },
+	{ "TestPathCchAddExtension", TestPathCchAddExtension },
+	{ "TestPathCchAppend", TestPathCchAppend },
+	{ "TestPathCchAppendEx", TestPathCchAppendEx },
+	{ "TestPathCchCanonicalize", TestPathCchCanonicalize },
+	{ "TestPathCchCanonicalizeEx", TestPathCchCanonicalizeEx },
+	{ "TestPathAllocCanonicalize", TestPathAllocCanonicalize },
+	{ "TestPathCchCombine", TestPathCchCombine },
+	{ "TestPathCchCombineEx", TestPathCchCombineEx },
+	{ "TestPathAllocCombine", TestPathAllocCombine },
+	{ "TestPathCchFindExtension", TestPathCchFindExtension },
+	{ "TestPathCchRenameExtension", TestPathCchRenameExtension },
+	{ "TestPathCchRemoveExtension", TestPathCchRemoveExtension },
+	{ "TestPathCchIsRoot", TestPathCchIsRoot },
+	{ "TestPathIsUNCEx", TestPathIsUNCEx },
+	{ "TestPathCchSkipRoot", TestPathCchSkipRoot },
+	{ "TestPathCchStripToRoot", TestPathCchStripToRoot },
+	{ "TestPathCchStripPrefix", TestPathCchStripPrefix },
+	{ "TestPathCchRemoveFileSpec", TestPathCchRemoveFileSpec },
+	{ "TestPathShell", TestPathShell },
+	{ "TestPathMakePath", TestPathMakePath },
 
-  { NULL, NULL } /* NOLINT */
+	{ NULL, NULL } /* NOLINT */
 };
 
-static const int NumTests = CM_CAST(int,
-  sizeof(cmakeGeneratedFunctionMapEntries) / sizeof(functionMapEntry)) - 1;
+static const int NumTests =
+    CM_CAST(int, sizeof(cmakeGeneratedFunctionMapEntries) / sizeof(functionMapEntry)) - 1;
 
 /* Allocate and create a lowercased copy of string
    (note that it has to be free'd manually) */
 static char* lowercase(const char* string)
 {
-  char *new_string, *p;
-  size_t stringSize;
+	char *new_string, *p;
+	size_t stringSize;
 
-  stringSize = CM_CAST(size_t, strlen(string) + 1);
-  new_string = CM_CAST(char*, malloc(sizeof(char) * stringSize));
+	stringSize = CM_CAST(size_t, strlen(string) + 1);
+	new_string = CM_CAST(char*, malloc(sizeof(char) * stringSize));
 
-  if (new_string == NULL) { /* NOLINT */
-    return NULL;            /* NOLINT */
-  }
-  strcpy(new_string, string);
-  for (p = new_string; *p != 0; ++p) {
-    *p = CM_CAST(char, tolower(*p));
-  }
-  return new_string;
+	if (new_string == NULL)
+	{                /* NOLINT */
+		return NULL; /* NOLINT */
+	}
+	strcpy(new_string, string);
+	for (p = new_string; *p != 0; ++p)
+	{
+		*p = CM_CAST(char, tolower(*p));
+	}
+	return new_string;
 }
 
 int main(int ac, char* av[])
 {
-  int i, testNum = 0, partial_match;
-  char *arg;
-  int testToRun = -1;
-
-  
-
-  /* If no test name was given */
-  /* process command line with user function.  */
-  if (ac < 2) {
-    /* Ask for a test.  */
-    printf("Available tests:\n");
-    for (i = 0; i < NumTests; ++i) {
-      printf("%3d. %s\n", i, cmakeGeneratedFunctionMapEntries[i].name);
-    }
-    printf("To run a test, enter the test number: ");
-    fflush(stdout);
-    if (scanf("%d", &testNum) != 1) {
-      printf("Couldn't parse that input as a number\n");
-      return -1;
-    }
-    if (testNum >= NumTests) {
-      printf("%3d is an invalid test number.\n", testNum);
-      return -1;
-    }
-    testToRun = testNum;
-    ac--;
-    av++;
-  }
-  partial_match = 0;
-  arg = NULL; /* NOLINT */
-  /* If partial match is requested.  */
-  if (testToRun == -1 && ac > 1) {
-    partial_match = (strcmp(av[1], "-R") == 0) ? 1 : 0;
-  }
-  if (partial_match != 0 && ac < 3) {
-    printf("-R needs an additional parameter.\n");
-    return -1;
-  }
-  if (testToRun == -1) {
-    arg = lowercase(av[1 + partial_match]);
-  }
-  for (i = 0; i < NumTests && testToRun == -1; ++i) {
-    char *test_name = lowercase(cmakeGeneratedFunctionMapEntries[i].name);
-    if (partial_match != 0 && strstr(test_name, arg) != NULL) { /* NOLINT */
-      testToRun = i;
-      ac -= 2;
-      av += 2;
-    } else if (partial_match == 0 && strcmp(test_name, arg) == 0) {
-      testToRun = i;
-      ac--;
-      av++;
-    }
-    free(test_name);
-  }
-  free(arg);
-  if (testToRun != -1) {
-    int result;
-
-    if (testToRun < 0 || testToRun >= NumTests) {
-      printf("testToRun was modified by TestDriver code to an invalid value: "
-             "%3d.\n",
-             testNum);
-      return -1;
-    }
-    result = (*cmakeGeneratedFunctionMapEntries[testToRun].func)(ac, av);
-
-    return result;
-  }
-
-  /* Nothing was run, display the test names.  */
-  printf("Available tests:\n");
-  for (i = 0; i < NumTests; ++i) {
-    printf("%3d. %s\n", i, cmakeGeneratedFunctionMapEntries[i].name);
-  }
-  printf("Failed: %s is an invalid test name.\n", av[1]);
+	int i, testNum = 0, partial_match;
+	char* arg;
+	int testToRun = -1;
+
+	/* If no test name was given */
+	/* process command line with user function.  */
+	if (ac < 2)
+	{
+		/* Ask for a test.  */
+		printf("Available tests:\n");
+		for (i = 0; i < NumTests; ++i)
+		{
+			printf("%3d. %s\n", i, cmakeGeneratedFunctionMapEntries[i].name);
+		}
+		printf("To run a test, enter the test number: ");
+		fflush(stdout);
+		if (scanf("%d", &testNum) != 1)
+		{
+			printf("Couldn't parse that input as a number\n");
+			return -1;
+		}
+		if (testNum >= NumTests)
+		{
+			printf("%3d is an invalid test number.\n", testNum);
+			return -1;
+		}
+		testToRun = testNum;
+		ac--;
+		av++;
+	}
+	partial_match = 0;
+	arg = NULL; /* NOLINT */
+	/* If partial match is requested.  */
+	if (testToRun == -1 && ac > 1)
+	{
+		partial_match = (strcmp(av[1], "-R") == 0) ? 1 : 0;
+	}
+	if (partial_match != 0 && ac < 3)
+	{
+		printf("-R needs an additional parameter.\n");
+		return -1;
+	}
+	if (testToRun == -1)
+	{
+		arg = lowercase(av[1 + partial_match]);
+	}
+	for (i = 0; i < NumTests && testToRun == -1; ++i)
+	{
+		char* test_name = lowercase(cmakeGeneratedFunctionMapEntries[i].name);
+		if (partial_match != 0 && strstr(test_name, arg) != NULL)
+		{ /* NOLINT */
+			testToRun = i;
+			ac -= 2;
+			av += 2;
+		}
+		else if (partial_match == 0 && strcmp(test_name, arg) == 0)
+		{
+			testToRun = i;
+			ac--;
+			av++;
+		}
+		free(test_name);
+	}
+	free(arg);
+	if (testToRun != -1)
+	{
+		int result;
+
+		if (testToRun < 0 || testToRun >= NumTests)
+		{
+			printf("testToRun was modified by TestDriver code to an invalid value: "
+			       "%3d.\n",
+			       testNum);
+			return -1;
+		}
+		result = (*cmakeGeneratedFunctionMapEntries[testToRun].func)(ac, av);
+
+		return result;
+	}
+
+	/* Nothing was run, display the test names.  */
+	printf("Available tests:\n");
+	for (i = 0; i < NumTests; ++i)
+	{
+		printf("%3d. %s\n", i, cmakeGeneratedFunctionMapEntries[i].name);
+	}
+	printf("Failed: %s is an invalid test name.\n", av[1]);
 
-  return -1;
+	return -1;
 }
diff -urN winpr/libwinpr/pipe/pipe.c ../../informatimago/FreeRDP/winpr/libwinpr/pipe/pipe.c
--- winpr/libwinpr/pipe/pipe.c	2019-07-25 19:51:09.057938061 +0300
+++ ../../informatimago/FreeRDP/winpr/libwinpr/pipe/pipe.c	2019-07-25 20:11:32.892007097 +0300
@@ -234,16 +234,10 @@
 static BOOL NamedPipeCloseHandle(HANDLE handle)
 {
 	WINPR_NAMED_PIPE* pNamedPipe = (WINPR_NAMED_PIPE*)handle;
-	/* This check confuses the analyzer. Since not all handle
-	 * types are handled here, it guesses that the memory of a
-	 * NamedPipeHandle may leak. */
-#	ifndef __clang_analyzer__
 
 	if (!NamedPipeIsHandled(handle))
 		return FALSE;
 
-#	endif
-
 	if (pNamedPipe->pfnUnrefNamedPipe)
 		pNamedPipe->pfnUnrefNamedPipe(pNamedPipe);
 
diff -urN winpr/libwinpr/pipe/test/TestPipe.c ../../informatimago/FreeRDP/winpr/libwinpr/pipe/test/TestPipe.c
--- winpr/libwinpr/pipe/test/TestPipe.c	2019-07-25 20:17:16.365710374 +0300
+++ ../../informatimago/FreeRDP/winpr/libwinpr/pipe/test/TestPipe.c	2019-07-25 20:11:32.896007117 +0300
@@ -4,149 +4,151 @@
 #include <string.h> /* NOLINT */
 
 #if defined(_MSC_VER)
-#pragma warning(disable : 4996) /* deprecation */
+#	pragma warning(disable : 4996) /* deprecation */
 #endif
 
-
-
 /* Forward declare test functions. */
 int TestPipeCreatePipe(int, char*[]);
 int TestPipeCreateNamedPipe(int, char*[]);
 int TestPipeCreateNamedPipeOverlapped(int, char*[]);
 
-
 #ifdef __cplusplus
-#define CM_CAST(TYPE, EXPR) static_cast<TYPE>(EXPR)
+#	define CM_CAST(TYPE, EXPR) static_cast<TYPE>(EXPR)
 #else
-#define CM_CAST(TYPE, EXPR) (TYPE)(EXPR)
+#	define CM_CAST(TYPE, EXPR) (TYPE)(EXPR)
 #endif
 
 /* Create map.  */
 
-typedef int (*MainFuncPointer)(int, char* []); /* NOLINT */
-typedef struct /* NOLINT */
+typedef int (*MainFuncPointer)(int, char*[]); /* NOLINT */
+typedef struct                                /* NOLINT */
 {
-  const char* name;
-  MainFuncPointer func;
+	const char* name;
+	MainFuncPointer func;
 } functionMapEntry;
 
 static functionMapEntry cmakeGeneratedFunctionMapEntries[] = {
-    {
-    "TestPipeCreatePipe",
-    TestPipeCreatePipe
-  },
-  {
-    "TestPipeCreateNamedPipe",
-    TestPipeCreateNamedPipe
-  },
-  {
-    "TestPipeCreateNamedPipeOverlapped",
-    TestPipeCreateNamedPipeOverlapped
-  },
+	{ "TestPipeCreatePipe", TestPipeCreatePipe },
+	{ "TestPipeCreateNamedPipe", TestPipeCreateNamedPipe },
+	{ "TestPipeCreateNamedPipeOverlapped", TestPipeCreateNamedPipeOverlapped },
 
-  { NULL, NULL } /* NOLINT */
+	{ NULL, NULL } /* NOLINT */
 };
 
-static const int NumTests = CM_CAST(int,
-  sizeof(cmakeGeneratedFunctionMapEntries) / sizeof(functionMapEntry)) - 1;
+static const int NumTests =
+    CM_CAST(int, sizeof(cmakeGeneratedFunctionMapEntries) / sizeof(functionMapEntry)) - 1;
 
 /* Allocate and create a lowercased copy of string
    (note that it has to be free'd manually) */
 static char* lowercase(const char* string)
 {
-  char *new_string, *p;
-  size_t stringSize;
+	char *new_string, *p;
+	size_t stringSize;
 
-  stringSize = CM_CAST(size_t, strlen(string) + 1);
-  new_string = CM_CAST(char*, malloc(sizeof(char) * stringSize));
+	stringSize = CM_CAST(size_t, strlen(string) + 1);
+	new_string = CM_CAST(char*, malloc(sizeof(char) * stringSize));
 
-  if (new_string == NULL) { /* NOLINT */
-    return NULL;            /* NOLINT */
-  }
-  strcpy(new_string, string);
-  for (p = new_string; *p != 0; ++p) {
-    *p = CM_CAST(char, tolower(*p));
-  }
-  return new_string;
+	if (new_string == NULL)
+	{                /* NOLINT */
+		return NULL; /* NOLINT */
+	}
+	strcpy(new_string, string);
+	for (p = new_string; *p != 0; ++p)
+	{
+		*p = CM_CAST(char, tolower(*p));
+	}
+	return new_string;
 }
 
 int main(int ac, char* av[])
 {
-  int i, testNum = 0, partial_match;
-  char *arg;
-  int testToRun = -1;
-
-  
-
-  /* If no test name was given */
-  /* process command line with user function.  */
-  if (ac < 2) {
-    /* Ask for a test.  */
-    printf("Available tests:\n");
-    for (i = 0; i < NumTests; ++i) {
-      printf("%3d. %s\n", i, cmakeGeneratedFunctionMapEntries[i].name);
-    }
-    printf("To run a test, enter the test number: ");
-    fflush(stdout);
-    if (scanf("%d", &testNum) != 1) {
-      printf("Couldn't parse that input as a number\n");
-      return -1;
-    }
-    if (testNum >= NumTests) {
-      printf("%3d is an invalid test number.\n", testNum);
-      return -1;
-    }
-    testToRun = testNum;
-    ac--;
-    av++;
-  }
-  partial_match = 0;
-  arg = NULL; /* NOLINT */
-  /* If partial match is requested.  */
-  if (testToRun == -1 && ac > 1) {
-    partial_match = (strcmp(av[1], "-R") == 0) ? 1 : 0;
-  }
-  if (partial_match != 0 && ac < 3) {
-    printf("-R needs an additional parameter.\n");
-    return -1;
-  }
-  if (testToRun == -1) {
-    arg = lowercase(av[1 + partial_match]);
-  }
-  for (i = 0; i < NumTests && testToRun == -1; ++i) {
-    char *test_name = lowercase(cmakeGeneratedFunctionMapEntries[i].name);
-    if (partial_match != 0 && strstr(test_name, arg) != NULL) { /* NOLINT */
-      testToRun = i;
-      ac -= 2;
-      av += 2;
-    } else if (partial_match == 0 && strcmp(test_name, arg) == 0) {
-      testToRun = i;
-      ac--;
-      av++;
-    }
-    free(test_name);
-  }
-  free(arg);
-  if (testToRun != -1) {
-    int result;
-
-    if (testToRun < 0 || testToRun >= NumTests) {
-      printf("testToRun was modified by TestDriver code to an invalid value: "
-             "%3d.\n",
-             testNum);
-      return -1;
-    }
-    result = (*cmakeGeneratedFunctionMapEntries[testToRun].func)(ac, av);
-
-    return result;
-  }
-
-  /* Nothing was run, display the test names.  */
-  printf("Available tests:\n");
-  for (i = 0; i < NumTests; ++i) {
-    printf("%3d. %s\n", i, cmakeGeneratedFunctionMapEntries[i].name);
-  }
-  printf("Failed: %s is an invalid test name.\n", av[1]);
+	int i, testNum = 0, partial_match;
+	char* arg;
+	int testToRun = -1;
+
+	/* If no test name was given */
+	/* process command line with user function.  */
+	if (ac < 2)
+	{
+		/* Ask for a test.  */
+		printf("Available tests:\n");
+		for (i = 0; i < NumTests; ++i)
+		{
+			printf("%3d. %s\n", i, cmakeGeneratedFunctionMapEntries[i].name);
+		}
+		printf("To run a test, enter the test number: ");
+		fflush(stdout);
+		if (scanf("%d", &testNum) != 1)
+		{
+			printf("Couldn't parse that input as a number\n");
+			return -1;
+		}
+		if (testNum >= NumTests)
+		{
+			printf("%3d is an invalid test number.\n", testNum);
+			return -1;
+		}
+		testToRun = testNum;
+		ac--;
+		av++;
+	}
+	partial_match = 0;
+	arg = NULL; /* NOLINT */
+	/* If partial match is requested.  */
+	if (testToRun == -1 && ac > 1)
+	{
+		partial_match = (strcmp(av[1], "-R") == 0) ? 1 : 0;
+	}
+	if (partial_match != 0 && ac < 3)
+	{
+		printf("-R needs an additional parameter.\n");
+		return -1;
+	}
+	if (testToRun == -1)
+	{
+		arg = lowercase(av[1 + partial_match]);
+	}
+	for (i = 0; i < NumTests && testToRun == -1; ++i)
+	{
+		char* test_name = lowercase(cmakeGeneratedFunctionMapEntries[i].name);
+		if (partial_match != 0 && strstr(test_name, arg) != NULL)
+		{ /* NOLINT */
+			testToRun = i;
+			ac -= 2;
+			av += 2;
+		}
+		else if (partial_match == 0 && strcmp(test_name, arg) == 0)
+		{
+			testToRun = i;
+			ac--;
+			av++;
+		}
+		free(test_name);
+	}
+	free(arg);
+	if (testToRun != -1)
+	{
+		int result;
+
+		if (testToRun < 0 || testToRun >= NumTests)
+		{
+			printf("testToRun was modified by TestDriver code to an invalid value: "
+			       "%3d.\n",
+			       testNum);
+			return -1;
+		}
+		result = (*cmakeGeneratedFunctionMapEntries[testToRun].func)(ac, av);
+
+		return result;
+	}
+
+	/* Nothing was run, display the test names.  */
+	printf("Available tests:\n");
+	for (i = 0; i < NumTests; ++i)
+	{
+		printf("%3d. %s\n", i, cmakeGeneratedFunctionMapEntries[i].name);
+	}
+	printf("Failed: %s is an invalid test name.\n", av[1]);
 
-  return -1;
+	return -1;
 }
diff -urN winpr/libwinpr/pool/CMakeLists.txt ../../informatimago/FreeRDP/winpr/libwinpr/pool/CMakeLists.txt
--- winpr/libwinpr/pool/CMakeLists.txt	2019-07-24 06:11:52.542197927 +0300
+++ ../../informatimago/FreeRDP/winpr/libwinpr/pool/CMakeLists.txt	2019-07-19 20:00:17.501205415 +0300
@@ -26,12 +26,12 @@
 	callback.c
 	callback_cleanup.c)
 
-winpr_library_add_private(
+winpr_library_add(
 	${CMAKE_THREAD_LIBS_INIT}
 	${CMAKE_DL_LIBS})
 
 if(${CMAKE_SYSTEM_NAME} MATCHES SunOS)
-	winpr_library_add_private(rt)
+	winpr_library_add(rt)
 endif()
 
 if(BUILD_TESTING)
diff -urN winpr/libwinpr/pool/pool.c ../../informatimago/FreeRDP/winpr/libwinpr/pool/pool.c
--- winpr/libwinpr/pool/pool.c	2019-07-25 19:51:09.089938220 +0300
+++ ../../informatimago/FreeRDP/winpr/libwinpr/pool/pool.c	2019-07-25 20:11:32.924007256 +0300
@@ -234,7 +234,7 @@
 #	endif
 	ptpp->Minimum = cthrdMic;
 
-	while (ArrayList_Count(ptpp->Threads) < (INT64)ptpp->Minimum)
+	while (ArrayList_Count(ptpp->Threads) < ptpp->Minimum)
 	{
 		if (!(thread = CreateThread(NULL, 0, thread_pool_work_func, (void*)ptpp, 0, NULL)))
 		{
diff -urN winpr/libwinpr/pool/test/TestPool.c ../../informatimago/FreeRDP/winpr/libwinpr/pool/test/TestPool.c
--- winpr/libwinpr/pool/test/TestPool.c	2019-07-25 20:17:16.393710513 +0300
+++ ../../informatimago/FreeRDP/winpr/libwinpr/pool/test/TestPool.c	2019-07-25 20:11:32.932007295 +0300
@@ -4,11 +4,9 @@
 #include <string.h> /* NOLINT */
 
 #if defined(_MSC_VER)
-#pragma warning(disable : 4996) /* deprecation */
+#	pragma warning(disable : 4996) /* deprecation */
 #endif
 
-
-
 /* Forward declare test functions. */
 int TestPoolIO(int, char*[]);
 int TestPoolSynch(int, char*[]);
@@ -16,147 +14,145 @@
 int TestPoolTimer(int, char*[]);
 int TestPoolWork(int, char*[]);
 
-
 #ifdef __cplusplus
-#define CM_CAST(TYPE, EXPR) static_cast<TYPE>(EXPR)
+#	define CM_CAST(TYPE, EXPR) static_cast<TYPE>(EXPR)
 #else
-#define CM_CAST(TYPE, EXPR) (TYPE)(EXPR)
+#	define CM_CAST(TYPE, EXPR) (TYPE)(EXPR)
 #endif
 
 /* Create map.  */
 
-typedef int (*MainFuncPointer)(int, char* []); /* NOLINT */
-typedef struct /* NOLINT */
+typedef int (*MainFuncPointer)(int, char*[]); /* NOLINT */
+typedef struct                                /* NOLINT */
 {
-  const char* name;
-  MainFuncPointer func;
+	const char* name;
+	MainFuncPointer func;
 } functionMapEntry;
 
 static functionMapEntry cmakeGeneratedFunctionMapEntries[] = {
-    {
-    "TestPoolIO",
-    TestPoolIO
-  },
-  {
-    "TestPoolSynch",
-    TestPoolSynch
-  },
-  {
-    "TestPoolThread",
-    TestPoolThread
-  },
-  {
-    "TestPoolTimer",
-    TestPoolTimer
-  },
-  {
-    "TestPoolWork",
-    TestPoolWork
-  },
+	{ "TestPoolIO", TestPoolIO },
+	{ "TestPoolSynch", TestPoolSynch },
+	{ "TestPoolThread", TestPoolThread },
+	{ "TestPoolTimer", TestPoolTimer },
+	{ "TestPoolWork", TestPoolWork },
 
-  { NULL, NULL } /* NOLINT */
+	{ NULL, NULL } /* NOLINT */
 };
 
-static const int NumTests = CM_CAST(int,
-  sizeof(cmakeGeneratedFunctionMapEntries) / sizeof(functionMapEntry)) - 1;
+static const int NumTests =
+    CM_CAST(int, sizeof(cmakeGeneratedFunctionMapEntries) / sizeof(functionMapEntry)) - 1;
 
 /* Allocate and create a lowercased copy of string
    (note that it has to be free'd manually) */
 static char* lowercase(const char* string)
 {
-  char *new_string, *p;
-  size_t stringSize;
+	char *new_string, *p;
+	size_t stringSize;
 
-  stringSize = CM_CAST(size_t, strlen(string) + 1);
-  new_string = CM_CAST(char*, malloc(sizeof(char) * stringSize));
+	stringSize = CM_CAST(size_t, strlen(string) + 1);
+	new_string = CM_CAST(char*, malloc(sizeof(char) * stringSize));
 
-  if (new_string == NULL) { /* NOLINT */
-    return NULL;            /* NOLINT */
-  }
-  strcpy(new_string, string);
-  for (p = new_string; *p != 0; ++p) {
-    *p = CM_CAST(char, tolower(*p));
-  }
-  return new_string;
+	if (new_string == NULL)
+	{                /* NOLINT */
+		return NULL; /* NOLINT */
+	}
+	strcpy(new_string, string);
+	for (p = new_string; *p != 0; ++p)
+	{
+		*p = CM_CAST(char, tolower(*p));
+	}
+	return new_string;
 }
 
 int main(int ac, char* av[])
 {
-  int i, testNum = 0, partial_match;
-  char *arg;
-  int testToRun = -1;
-
-  
-
-  /* If no test name was given */
-  /* process command line with user function.  */
-  if (ac < 2) {
-    /* Ask for a test.  */
-    printf("Available tests:\n");
-    for (i = 0; i < NumTests; ++i) {
-      printf("%3d. %s\n", i, cmakeGeneratedFunctionMapEntries[i].name);
-    }
-    printf("To run a test, enter the test number: ");
-    fflush(stdout);
-    if (scanf("%d", &testNum) != 1) {
-      printf("Couldn't parse that input as a number\n");
-      return -1;
-    }
-    if (testNum >= NumTests) {
-      printf("%3d is an invalid test number.\n", testNum);
-      return -1;
-    }
-    testToRun = testNum;
-    ac--;
-    av++;
-  }
-  partial_match = 0;
-  arg = NULL; /* NOLINT */
-  /* If partial match is requested.  */
-  if (testToRun == -1 && ac > 1) {
-    partial_match = (strcmp(av[1], "-R") == 0) ? 1 : 0;
-  }
-  if (partial_match != 0 && ac < 3) {
-    printf("-R needs an additional parameter.\n");
-    return -1;
-  }
-  if (testToRun == -1) {
-    arg = lowercase(av[1 + partial_match]);
-  }
-  for (i = 0; i < NumTests && testToRun == -1; ++i) {
-    char *test_name = lowercase(cmakeGeneratedFunctionMapEntries[i].name);
-    if (partial_match != 0 && strstr(test_name, arg) != NULL) { /* NOLINT */
-      testToRun = i;
-      ac -= 2;
-      av += 2;
-    } else if (partial_match == 0 && strcmp(test_name, arg) == 0) {
-      testToRun = i;
-      ac--;
-      av++;
-    }
-    free(test_name);
-  }
-  free(arg);
-  if (testToRun != -1) {
-    int result;
-
-    if (testToRun < 0 || testToRun >= NumTests) {
-      printf("testToRun was modified by TestDriver code to an invalid value: "
-             "%3d.\n",
-             testNum);
-      return -1;
-    }
-    result = (*cmakeGeneratedFunctionMapEntries[testToRun].func)(ac, av);
-
-    return result;
-  }
-
-  /* Nothing was run, display the test names.  */
-  printf("Available tests:\n");
-  for (i = 0; i < NumTests; ++i) {
-    printf("%3d. %s\n", i, cmakeGeneratedFunctionMapEntries[i].name);
-  }
-  printf("Failed: %s is an invalid test name.\n", av[1]);
+	int i, testNum = 0, partial_match;
+	char* arg;
+	int testToRun = -1;
+
+	/* If no test name was given */
+	/* process command line with user function.  */
+	if (ac < 2)
+	{
+		/* Ask for a test.  */
+		printf("Available tests:\n");
+		for (i = 0; i < NumTests; ++i)
+		{
+			printf("%3d. %s\n", i, cmakeGeneratedFunctionMapEntries[i].name);
+		}
+		printf("To run a test, enter the test number: ");
+		fflush(stdout);
+		if (scanf("%d", &testNum) != 1)
+		{
+			printf("Couldn't parse that input as a number\n");
+			return -1;
+		}
+		if (testNum >= NumTests)
+		{
+			printf("%3d is an invalid test number.\n", testNum);
+			return -1;
+		}
+		testToRun = testNum;
+		ac--;
+		av++;
+	}
+	partial_match = 0;
+	arg = NULL; /* NOLINT */
+	/* If partial match is requested.  */
+	if (testToRun == -1 && ac > 1)
+	{
+		partial_match = (strcmp(av[1], "-R") == 0) ? 1 : 0;
+	}
+	if (partial_match != 0 && ac < 3)
+	{
+		printf("-R needs an additional parameter.\n");
+		return -1;
+	}
+	if (testToRun == -1)
+	{
+		arg = lowercase(av[1 + partial_match]);
+	}
+	for (i = 0; i < NumTests && testToRun == -1; ++i)
+	{
+		char* test_name = lowercase(cmakeGeneratedFunctionMapEntries[i].name);
+		if (partial_match != 0 && strstr(test_name, arg) != NULL)
+		{ /* NOLINT */
+			testToRun = i;
+			ac -= 2;
+			av += 2;
+		}
+		else if (partial_match == 0 && strcmp(test_name, arg) == 0)
+		{
+			testToRun = i;
+			ac--;
+			av++;
+		}
+		free(test_name);
+	}
+	free(arg);
+	if (testToRun != -1)
+	{
+		int result;
+
+		if (testToRun < 0 || testToRun >= NumTests)
+		{
+			printf("testToRun was modified by TestDriver code to an invalid value: "
+			       "%3d.\n",
+			       testNum);
+			return -1;
+		}
+		result = (*cmakeGeneratedFunctionMapEntries[testToRun].func)(ac, av);
+
+		return result;
+	}
+
+	/* Nothing was run, display the test names.  */
+	printf("Available tests:\n");
+	for (i = 0; i < NumTests; ++i)
+	{
+		printf("%3d. %s\n", i, cmakeGeneratedFunctionMapEntries[i].name);
+	}
+	printf("Failed: %s is an invalid test name.\n", av[1]);
 
-  return -1;
+	return -1;
 }
diff -urN winpr/libwinpr/rpc/CMakeLists.txt ../../informatimago/FreeRDP/winpr/libwinpr/rpc/CMakeLists.txt
--- winpr/libwinpr/rpc/CMakeLists.txt	2019-07-24 06:11:52.546197946 +0300
+++ ../../informatimago/FreeRDP/winpr/libwinpr/rpc/CMakeLists.txt	2019-07-19 20:00:17.505205403 +0300
@@ -40,8 +40,8 @@
 
 winpr_include_directory_add(${OPENSSL_INCLUDE_DIR})
 
-winpr_library_add_private(${OPENSSL_LIBRARIES})
+winpr_library_add(${OPENSSL_LIBRARIES})
 
 if(WIN32)
-	winpr_library_add_public(ws2_32 rpcrt4)
+	winpr_library_add(ws2_32 rpcrt4)
 endif()
diff -urN winpr/libwinpr/rpc/ndr_correlation.c ../../informatimago/FreeRDP/winpr/libwinpr/rpc/ndr_correlation.c
--- winpr/libwinpr/rpc/ndr_correlation.c	2019-07-25 19:51:09.137938458 +0300
+++ ../../informatimago/FreeRDP/winpr/libwinpr/rpc/ndr_correlation.c	2019-07-25 20:11:32.968007474 +0300
@@ -85,9 +85,6 @@
 	switch (correlation_operator)
 	{
 	case FC_DEREFERENCE:
-		if (!ptr)
-			return pFormat;
-
 		ptr = *(LPVOID*)((char*)ptr + offset);
 		break;
 
diff -urN winpr/libwinpr/security/test/TestSecurity.c ../../informatimago/FreeRDP/winpr/libwinpr/security/test/TestSecurity.c
--- winpr/libwinpr/security/test/TestSecurity.c	2019-07-25 20:17:16.369710394 +0300
+++ ../../informatimago/FreeRDP/winpr/libwinpr/security/test/TestSecurity.c	2019-07-25 20:11:33.028007771 +0300
@@ -4,139 +4,147 @@
 #include <string.h> /* NOLINT */
 
 #if defined(_MSC_VER)
-#pragma warning(disable : 4996) /* deprecation */
+#	pragma warning(disable : 4996) /* deprecation */
 #endif
 
-
-
 /* Forward declare test functions. */
 int TestSecurityToken(int, char*[]);
 
-
 #ifdef __cplusplus
-#define CM_CAST(TYPE, EXPR) static_cast<TYPE>(EXPR)
+#	define CM_CAST(TYPE, EXPR) static_cast<TYPE>(EXPR)
 #else
-#define CM_CAST(TYPE, EXPR) (TYPE)(EXPR)
+#	define CM_CAST(TYPE, EXPR) (TYPE)(EXPR)
 #endif
 
 /* Create map.  */
 
-typedef int (*MainFuncPointer)(int, char* []); /* NOLINT */
-typedef struct /* NOLINT */
+typedef int (*MainFuncPointer)(int, char*[]); /* NOLINT */
+typedef struct                                /* NOLINT */
 {
-  const char* name;
-  MainFuncPointer func;
+	const char* name;
+	MainFuncPointer func;
 } functionMapEntry;
 
 static functionMapEntry cmakeGeneratedFunctionMapEntries[] = {
-    {
-    "TestSecurityToken",
-    TestSecurityToken
-  },
+	{ "TestSecurityToken", TestSecurityToken },
 
-  { NULL, NULL } /* NOLINT */
+	{ NULL, NULL } /* NOLINT */
 };
 
-static const int NumTests = CM_CAST(int,
-  sizeof(cmakeGeneratedFunctionMapEntries) / sizeof(functionMapEntry)) - 1;
+static const int NumTests =
+    CM_CAST(int, sizeof(cmakeGeneratedFunctionMapEntries) / sizeof(functionMapEntry)) - 1;
 
 /* Allocate and create a lowercased copy of string
    (note that it has to be free'd manually) */
 static char* lowercase(const char* string)
 {
-  char *new_string, *p;
-  size_t stringSize;
+	char *new_string, *p;
+	size_t stringSize;
 
-  stringSize = CM_CAST(size_t, strlen(string) + 1);
-  new_string = CM_CAST(char*, malloc(sizeof(char) * stringSize));
+	stringSize = CM_CAST(size_t, strlen(string) + 1);
+	new_string = CM_CAST(char*, malloc(sizeof(char) * stringSize));
 
-  if (new_string == NULL) { /* NOLINT */
-    return NULL;            /* NOLINT */
-  }
-  strcpy(new_string, string);
-  for (p = new_string; *p != 0; ++p) {
-    *p = CM_CAST(char, tolower(*p));
-  }
-  return new_string;
+	if (new_string == NULL)
+	{                /* NOLINT */
+		return NULL; /* NOLINT */
+	}
+	strcpy(new_string, string);
+	for (p = new_string; *p != 0; ++p)
+	{
+		*p = CM_CAST(char, tolower(*p));
+	}
+	return new_string;
 }
 
 int main(int ac, char* av[])
 {
-  int i, testNum = 0, partial_match;
-  char *arg;
-  int testToRun = -1;
-
-  
-
-  /* If no test name was given */
-  /* process command line with user function.  */
-  if (ac < 2) {
-    /* Ask for a test.  */
-    printf("Available tests:\n");
-    for (i = 0; i < NumTests; ++i) {
-      printf("%3d. %s\n", i, cmakeGeneratedFunctionMapEntries[i].name);
-    }
-    printf("To run a test, enter the test number: ");
-    fflush(stdout);
-    if (scanf("%d", &testNum) != 1) {
-      printf("Couldn't parse that input as a number\n");
-      return -1;
-    }
-    if (testNum >= NumTests) {
-      printf("%3d is an invalid test number.\n", testNum);
-      return -1;
-    }
-    testToRun = testNum;
-    ac--;
-    av++;
-  }
-  partial_match = 0;
-  arg = NULL; /* NOLINT */
-  /* If partial match is requested.  */
-  if (testToRun == -1 && ac > 1) {
-    partial_match = (strcmp(av[1], "-R") == 0) ? 1 : 0;
-  }
-  if (partial_match != 0 && ac < 3) {
-    printf("-R needs an additional parameter.\n");
-    return -1;
-  }
-  if (testToRun == -1) {
-    arg = lowercase(av[1 + partial_match]);
-  }
-  for (i = 0; i < NumTests && testToRun == -1; ++i) {
-    char *test_name = lowercase(cmakeGeneratedFunctionMapEntries[i].name);
-    if (partial_match != 0 && strstr(test_name, arg) != NULL) { /* NOLINT */
-      testToRun = i;
-      ac -= 2;
-      av += 2;
-    } else if (partial_match == 0 && strcmp(test_name, arg) == 0) {
-      testToRun = i;
-      ac--;
-      av++;
-    }
-    free(test_name);
-  }
-  free(arg);
-  if (testToRun != -1) {
-    int result;
-
-    if (testToRun < 0 || testToRun >= NumTests) {
-      printf("testToRun was modified by TestDriver code to an invalid value: "
-             "%3d.\n",
-             testNum);
-      return -1;
-    }
-    result = (*cmakeGeneratedFunctionMapEntries[testToRun].func)(ac, av);
-
-    return result;
-  }
-
-  /* Nothing was run, display the test names.  */
-  printf("Available tests:\n");
-  for (i = 0; i < NumTests; ++i) {
-    printf("%3d. %s\n", i, cmakeGeneratedFunctionMapEntries[i].name);
-  }
-  printf("Failed: %s is an invalid test name.\n", av[1]);
+	int i, testNum = 0, partial_match;
+	char* arg;
+	int testToRun = -1;
+
+	/* If no test name was given */
+	/* process command line with user function.  */
+	if (ac < 2)
+	{
+		/* Ask for a test.  */
+		printf("Available tests:\n");
+		for (i = 0; i < NumTests; ++i)
+		{
+			printf("%3d. %s\n", i, cmakeGeneratedFunctionMapEntries[i].name);
+		}
+		printf("To run a test, enter the test number: ");
+		fflush(stdout);
+		if (scanf("%d", &testNum) != 1)
+		{
+			printf("Couldn't parse that input as a number\n");
+			return -1;
+		}
+		if (testNum >= NumTests)
+		{
+			printf("%3d is an invalid test number.\n", testNum);
+			return -1;
+		}
+		testToRun = testNum;
+		ac--;
+		av++;
+	}
+	partial_match = 0;
+	arg = NULL; /* NOLINT */
+	/* If partial match is requested.  */
+	if (testToRun == -1 && ac > 1)
+	{
+		partial_match = (strcmp(av[1], "-R") == 0) ? 1 : 0;
+	}
+	if (partial_match != 0 && ac < 3)
+	{
+		printf("-R needs an additional parameter.\n");
+		return -1;
+	}
+	if (testToRun == -1)
+	{
+		arg = lowercase(av[1 + partial_match]);
+	}
+	for (i = 0; i < NumTests && testToRun == -1; ++i)
+	{
+		char* test_name = lowercase(cmakeGeneratedFunctionMapEntries[i].name);
+		if (partial_match != 0 && strstr(test_name, arg) != NULL)
+		{ /* NOLINT */
+			testToRun = i;
+			ac -= 2;
+			av += 2;
+		}
+		else if (partial_match == 0 && strcmp(test_name, arg) == 0)
+		{
+			testToRun = i;
+			ac--;
+			av++;
+		}
+		free(test_name);
+	}
+	free(arg);
+	if (testToRun != -1)
+	{
+		int result;
+
+		if (testToRun < 0 || testToRun >= NumTests)
+		{
+			printf("testToRun was modified by TestDriver code to an invalid value: "
+			       "%3d.\n",
+			       testNum);
+			return -1;
+		}
+		result = (*cmakeGeneratedFunctionMapEntries[testToRun].func)(ac, av);
+
+		return result;
+	}
+
+	/* Nothing was run, display the test names.  */
+	printf("Available tests:\n");
+	for (i = 0; i < NumTests; ++i)
+	{
+		printf("%3d. %s\n", i, cmakeGeneratedFunctionMapEntries[i].name);
+	}
+	printf("Failed: %s is an invalid test name.\n", av[1]);
 
-  return -1;
+	return -1;
 }
diff -urN winpr/libwinpr/smartcard/CMakeLists.txt ../../informatimago/FreeRDP/winpr/libwinpr/smartcard/CMakeLists.txt
--- winpr/libwinpr/smartcard/CMakeLists.txt	2019-07-24 06:11:52.546197946 +0300
+++ ../../informatimago/FreeRDP/winpr/libwinpr/smartcard/CMakeLists.txt	2019-07-19 20:00:17.505205403 +0300
@@ -42,7 +42,7 @@
 winpr_module_add(${${MODULE_PREFIX}_SRCS})
 
 if(PCSC_WINPR_FOUND)
-	winpr_library_add_private(${PCSC_WINPR_LIBRARY})
+	winpr_library_add(${PCSC_WINPR_LIBRARY})
 endif()
 
 if(BUILD_TESTING)
diff -urN winpr/libwinpr/smartcard/smartcard.c ../../informatimago/FreeRDP/winpr/libwinpr/smartcard/smartcard.c
--- winpr/libwinpr/smartcard/smartcard.c	2019-07-25 19:51:09.217938854 +0300
+++ ../../informatimago/FreeRDP/winpr/libwinpr/smartcard/smartcard.c	2019-07-25 20:11:33.048007871 +0300
@@ -563,6 +563,11 @@
 	SCARDAPI_STUB_CALL_LONG(SCardAudit, hContext, dwEvent);
 }
 
+WINSCARDAPI LONG WINAPI SCardAddReaderName(HANDLE* key, LPSTR readerName)
+{
+	SCARDAPI_STUB_CALL_LONG(SCardAddReaderName, key, readerName);
+}
+
 /**
  * Extended API
  */
diff -urN winpr/libwinpr/smartcard/smartcard_pcsc.c ../../informatimago/FreeRDP/winpr/libwinpr/smartcard/smartcard_pcsc.c
--- winpr/libwinpr/smartcard/smartcard_pcsc.c	2019-07-25 19:51:09.297939251 +0300
+++ ../../informatimago/FreeRDP/winpr/libwinpr/smartcard/smartcard_pcsc.c	2019-07-25 20:11:33.132008287 +0300
@@ -2051,7 +2051,7 @@
 WINSCARDAPI LONG WINAPI PCSC_SCardGetAttrib_FriendlyName(SCARDHANDLE hCard, DWORD dwAttrId,
                                                          LPBYTE pbAttr, LPDWORD pcbAttrLen)
 {
-	size_t length = 0;
+	int length = 0;
 	char* namePCSC = NULL;
 	DWORD cbAttrLen = 0;
 	char* pbAttrA = NULL;
diff -urN winpr/libwinpr/smartcard/smartcard_pcsc.h ../../informatimago/FreeRDP/winpr/libwinpr/smartcard/smartcard_pcsc.h
--- winpr/libwinpr/smartcard/smartcard_pcsc.h	2019-07-25 19:51:09.305939291 +0300
+++ ../../informatimago/FreeRDP/winpr/libwinpr/smartcard/smartcard_pcsc.h	2019-07-25 20:11:33.136008307 +0300
@@ -156,6 +156,7 @@
 	(SCARDHANDLE hCard, PCSC_DWORD dwAttrId, LPBYTE pbAttr, PCSC_LPDWORD pcbAttrLen);
 	PCSC_LONG (*pfnSCardSetAttrib)
 	(SCARDHANDLE hCard, PCSC_DWORD dwAttrId, LPCBYTE pbAttr, PCSC_DWORD cbAttrLen);
+	PCSC_LONG (*pfnSCardAddReaderName)(HANDLE* key, LPSTR readerName);
 };
 typedef struct _PCSCFunctionTable PCSCFunctionTable;
 
diff -urN winpr/libwinpr/smartcard/smartcard_winscard.c ../../informatimago/FreeRDP/winpr/libwinpr/smartcard/smartcard_winscard.c
--- winpr/libwinpr/smartcard/smartcard_winscard.c	2019-07-25 19:51:09.309939311 +0300
+++ ../../informatimago/FreeRDP/winpr/libwinpr/smartcard/smartcard_winscard.c	2019-07-25 20:11:33.140008327 +0300
@@ -110,7 +110,8 @@
 	NULL, /* SCardGetReaderDeviceInstanceIdW */
 	NULL, /* SCardListReadersWithDeviceInstanceIdA */
 	NULL, /* SCardListReadersWithDeviceInstanceIdW */
-	NULL  /* SCardAudit */
+	NULL, /* SCardAudit */
+	NULL  /* SCardAddReaderName */
 };
 
 PSCardApiFunctionTable WinSCard_GetSCardApiFunctionTable(void)
diff -urN winpr/libwinpr/smartcard/test/TestSmartCard.c ../../informatimago/FreeRDP/winpr/libwinpr/smartcard/test/TestSmartCard.c
--- winpr/libwinpr/smartcard/test/TestSmartCard.c	2019-07-25 20:17:16.417710632 +0300
+++ ../../informatimago/FreeRDP/winpr/libwinpr/smartcard/test/TestSmartCard.c	2019-07-25 20:11:33.148008366 +0300
@@ -4,139 +4,147 @@
 #include <string.h> /* NOLINT */
 
 #if defined(_MSC_VER)
-#pragma warning(disable : 4996) /* deprecation */
+#	pragma warning(disable : 4996) /* deprecation */
 #endif
 
-
-
 /* Forward declare test functions. */
 int TestSmartCardListReaders(int, char*[]);
 
-
 #ifdef __cplusplus
-#define CM_CAST(TYPE, EXPR) static_cast<TYPE>(EXPR)
+#	define CM_CAST(TYPE, EXPR) static_cast<TYPE>(EXPR)
 #else
-#define CM_CAST(TYPE, EXPR) (TYPE)(EXPR)
+#	define CM_CAST(TYPE, EXPR) (TYPE)(EXPR)
 #endif
 
 /* Create map.  */
 
-typedef int (*MainFuncPointer)(int, char* []); /* NOLINT */
-typedef struct /* NOLINT */
+typedef int (*MainFuncPointer)(int, char*[]); /* NOLINT */
+typedef struct                                /* NOLINT */
 {
-  const char* name;
-  MainFuncPointer func;
+	const char* name;
+	MainFuncPointer func;
 } functionMapEntry;
 
 static functionMapEntry cmakeGeneratedFunctionMapEntries[] = {
-    {
-    "TestSmartCardListReaders",
-    TestSmartCardListReaders
-  },
+	{ "TestSmartCardListReaders", TestSmartCardListReaders },
 
-  { NULL, NULL } /* NOLINT */
+	{ NULL, NULL } /* NOLINT */
 };
 
-static const int NumTests = CM_CAST(int,
-  sizeof(cmakeGeneratedFunctionMapEntries) / sizeof(functionMapEntry)) - 1;
+static const int NumTests =
+    CM_CAST(int, sizeof(cmakeGeneratedFunctionMapEntries) / sizeof(functionMapEntry)) - 1;
 
 /* Allocate and create a lowercased copy of string
    (note that it has to be free'd manually) */
 static char* lowercase(const char* string)
 {
-  char *new_string, *p;
-  size_t stringSize;
+	char *new_string, *p;
+	size_t stringSize;
 
-  stringSize = CM_CAST(size_t, strlen(string) + 1);
-  new_string = CM_CAST(char*, malloc(sizeof(char) * stringSize));
+	stringSize = CM_CAST(size_t, strlen(string) + 1);
+	new_string = CM_CAST(char*, malloc(sizeof(char) * stringSize));
 
-  if (new_string == NULL) { /* NOLINT */
-    return NULL;            /* NOLINT */
-  }
-  strcpy(new_string, string);
-  for (p = new_string; *p != 0; ++p) {
-    *p = CM_CAST(char, tolower(*p));
-  }
-  return new_string;
+	if (new_string == NULL)
+	{                /* NOLINT */
+		return NULL; /* NOLINT */
+	}
+	strcpy(new_string, string);
+	for (p = new_string; *p != 0; ++p)
+	{
+		*p = CM_CAST(char, tolower(*p));
+	}
+	return new_string;
 }
 
 int main(int ac, char* av[])
 {
-  int i, testNum = 0, partial_match;
-  char *arg;
-  int testToRun = -1;
-
-  
-
-  /* If no test name was given */
-  /* process command line with user function.  */
-  if (ac < 2) {
-    /* Ask for a test.  */
-    printf("Available tests:\n");
-    for (i = 0; i < NumTests; ++i) {
-      printf("%3d. %s\n", i, cmakeGeneratedFunctionMapEntries[i].name);
-    }
-    printf("To run a test, enter the test number: ");
-    fflush(stdout);
-    if (scanf("%d", &testNum) != 1) {
-      printf("Couldn't parse that input as a number\n");
-      return -1;
-    }
-    if (testNum >= NumTests) {
-      printf("%3d is an invalid test number.\n", testNum);
-      return -1;
-    }
-    testToRun = testNum;
-    ac--;
-    av++;
-  }
-  partial_match = 0;
-  arg = NULL; /* NOLINT */
-  /* If partial match is requested.  */
-  if (testToRun == -1 && ac > 1) {
-    partial_match = (strcmp(av[1], "-R") == 0) ? 1 : 0;
-  }
-  if (partial_match != 0 && ac < 3) {
-    printf("-R needs an additional parameter.\n");
-    return -1;
-  }
-  if (testToRun == -1) {
-    arg = lowercase(av[1 + partial_match]);
-  }
-  for (i = 0; i < NumTests && testToRun == -1; ++i) {
-    char *test_name = lowercase(cmakeGeneratedFunctionMapEntries[i].name);
-    if (partial_match != 0 && strstr(test_name, arg) != NULL) { /* NOLINT */
-      testToRun = i;
-      ac -= 2;
-      av += 2;
-    } else if (partial_match == 0 && strcmp(test_name, arg) == 0) {
-      testToRun = i;
-      ac--;
-      av++;
-    }
-    free(test_name);
-  }
-  free(arg);
-  if (testToRun != -1) {
-    int result;
-
-    if (testToRun < 0 || testToRun >= NumTests) {
-      printf("testToRun was modified by TestDriver code to an invalid value: "
-             "%3d.\n",
-             testNum);
-      return -1;
-    }
-    result = (*cmakeGeneratedFunctionMapEntries[testToRun].func)(ac, av);
-
-    return result;
-  }
-
-  /* Nothing was run, display the test names.  */
-  printf("Available tests:\n");
-  for (i = 0; i < NumTests; ++i) {
-    printf("%3d. %s\n", i, cmakeGeneratedFunctionMapEntries[i].name);
-  }
-  printf("Failed: %s is an invalid test name.\n", av[1]);
+	int i, testNum = 0, partial_match;
+	char* arg;
+	int testToRun = -1;
+
+	/* If no test name was given */
+	/* process command line with user function.  */
+	if (ac < 2)
+	{
+		/* Ask for a test.  */
+		printf("Available tests:\n");
+		for (i = 0; i < NumTests; ++i)
+		{
+			printf("%3d. %s\n", i, cmakeGeneratedFunctionMapEntries[i].name);
+		}
+		printf("To run a test, enter the test number: ");
+		fflush(stdout);
+		if (scanf("%d", &testNum) != 1)
+		{
+			printf("Couldn't parse that input as a number\n");
+			return -1;
+		}
+		if (testNum >= NumTests)
+		{
+			printf("%3d is an invalid test number.\n", testNum);
+			return -1;
+		}
+		testToRun = testNum;
+		ac--;
+		av++;
+	}
+	partial_match = 0;
+	arg = NULL; /* NOLINT */
+	/* If partial match is requested.  */
+	if (testToRun == -1 && ac > 1)
+	{
+		partial_match = (strcmp(av[1], "-R") == 0) ? 1 : 0;
+	}
+	if (partial_match != 0 && ac < 3)
+	{
+		printf("-R needs an additional parameter.\n");
+		return -1;
+	}
+	if (testToRun == -1)
+	{
+		arg = lowercase(av[1 + partial_match]);
+	}
+	for (i = 0; i < NumTests && testToRun == -1; ++i)
+	{
+		char* test_name = lowercase(cmakeGeneratedFunctionMapEntries[i].name);
+		if (partial_match != 0 && strstr(test_name, arg) != NULL)
+		{ /* NOLINT */
+			testToRun = i;
+			ac -= 2;
+			av += 2;
+		}
+		else if (partial_match == 0 && strcmp(test_name, arg) == 0)
+		{
+			testToRun = i;
+			ac--;
+			av++;
+		}
+		free(test_name);
+	}
+	free(arg);
+	if (testToRun != -1)
+	{
+		int result;
+
+		if (testToRun < 0 || testToRun >= NumTests)
+		{
+			printf("testToRun was modified by TestDriver code to an invalid value: "
+			       "%3d.\n",
+			       testNum);
+			return -1;
+		}
+		result = (*cmakeGeneratedFunctionMapEntries[testToRun].func)(ac, av);
+
+		return result;
+	}
+
+	/* Nothing was run, display the test names.  */
+	printf("Available tests:\n");
+	for (i = 0; i < NumTests; ++i)
+	{
+		printf("%3d. %s\n", i, cmakeGeneratedFunctionMapEntries[i].name);
+	}
+	printf("Failed: %s is an invalid test name.\n", av[1]);
 
-  return -1;
+	return -1;
 }
diff -urN winpr/libwinpr/sspi/CMakeLists.txt ../../informatimago/FreeRDP/winpr/libwinpr/sspi/CMakeLists.txt
--- winpr/libwinpr/sspi/CMakeLists.txt	2019-07-24 06:11:52.546197946 +0300
+++ ../../informatimago/FreeRDP/winpr/libwinpr/sspi/CMakeLists.txt	2019-07-19 20:00:17.505205403 +0300
@@ -63,21 +63,21 @@
 
 if(OPENSSL_FOUND)
 	winpr_include_directory_add(${OPENSSL_INCLUDE_DIR})
-	winpr_library_add_private(${OPENSSL_LIBRARIES})
+	winpr_library_add(${OPENSSL_LIBRARIES})
 endif()
 
 if(MBEDTLS_FOUND)
 	winpr_include_directory_add(${MBEDTLS_INCLUDE_DIR})
-	winpr_library_add_private(${MBEDTLS_LIBRARIES})
+	winpr_library_add(${MBEDTLS_LIBRARIES})
 endif()
 
 if(GSS_FOUND)
 	winpr_include_directory_add(${GSS_INCLUDE_DIR})
-	winpr_library_add_private(${GSS_LIBRARIES})
+	winpr_library_add(${GSS_LIBRARIES})
 endif()
 
 if(WIN32)
-	winpr_library_add_public(ws2_32)
+	winpr_library_add(ws2_32)
 endif()
 
 if(BUILD_TESTING)
diff -urN winpr/libwinpr/sspi/Kerberos/kerberos.c ../../informatimago/FreeRDP/winpr/libwinpr/sspi/Kerberos/kerberos.c
--- winpr/libwinpr/sspi/Kerberos/kerberos.c	2019-07-25 19:51:09.337939450 +0300
+++ ../../informatimago/FreeRDP/winpr/libwinpr/sspi/Kerberos/kerberos.c	2019-07-25 20:11:33.172008486 +0300
@@ -393,7 +393,7 @@
 	/* Set buffer */
 	_snprintf(krb_name, krb_name_len + 1, "%s@%s", lusername, lrealm);
 #	ifdef WITH_DEBUG_NLA
-	WLog_DBG(TAG, "copied string is %s\n", krb_name);
+	WLog_DBG(TAG, "copied string is %s", krb_name);
 #	endif
 	pstr = strchr(lusername, '@');
 
@@ -495,11 +495,17 @@
 				 * If we use smartcard-logon, the credentials have already
 				 * been acquired by pkinit process. If not, returned error previously.
 				 */
-				if (init_creds(context->credentials->identity.User,
+				if ((context->credentials->identity.User == NULL) ||
+				    (context->credentials->identity.UserLength == 0) ||
+				    (context->credentials->identity.Password == NULL) ||
+				    (context->credentials->identity.PasswordLength == 0) ||
+				    init_creds(context->credentials->identity.User,
 				               context->credentials->identity.UserLength,
 				               context->credentials->identity.Password,
 				               context->credentials->identity.PasswordLength))
+				{
 					return SEC_E_NO_CREDENTIALS;
+				}
 
 				WLog_INFO(TAG, "Authenticated to Kerberos v5 via login/password");
 				/* retry GSSAPI call */
@@ -513,7 +519,9 @@
 				if (SSPI_GSS_ERROR(context->major_status))
 				{
 					/* We can't use Kerberos */
-					WLog_ERR(TAG, "Init GSS security context failed : can't use Kerberos");
+					WLog_ERR(TAG,
+					         "Init GSS security context failed : can't use Kerberos because % s",
+					         krb5_get_error_message(NULL, context->minor_status));
 					return SEC_E_INTERNAL_ERROR;
 				}
 			}
diff -urN winpr/libwinpr/sspi/NTLM/ntlm_av_pairs.c ../../informatimago/FreeRDP/winpr/libwinpr/sspi/NTLM/ntlm_av_pairs.c
--- winpr/libwinpr/sspi/NTLM/ntlm_av_pairs.c	2019-07-25 19:51:09.373939628 +0300
+++ ../../informatimago/FreeRDP/winpr/libwinpr/sspi/NTLM/ntlm_av_pairs.c	2019-07-25 20:11:33.208008664 +0300
@@ -45,15 +45,14 @@
 	"MsvAvRestrictions",  "MsvAvTargetName",     "MsvChannelBindings"
 };
 
-static BOOL ntlm_av_pair_check(NTLM_AV_PAIR* pAvPair, size_t cbAvPair);
-static NTLM_AV_PAIR* ntlm_av_pair_next(NTLM_AV_PAIR* pAvPairList, size_t* pcbAvPairList);
+static NTLM_AV_PAIR* ntlm_av_pair_get_next_pointer(NTLM_AV_PAIR* pAvPair, size_t* pcbAvPair);
 
-static INLINE void ntlm_av_pair_set_id(NTLM_AV_PAIR* pAvPair, UINT16 id)
+static void ntlm_av_pair_set_id(NTLM_AV_PAIR* pAvPair, UINT16 id)
 {
 	Data_Write_UINT16(&pAvPair->AvId, id);
 }
 
-static INLINE void ntlm_av_pair_set_len(NTLM_AV_PAIR* pAvPair, UINT16 len)
+static void ntlm_av_pair_set_len(NTLM_AV_PAIR* pAvPair, UINT16 len)
 {
 	Data_Write_UINT16(&pAvPair->AvLen, len);
 }
@@ -73,47 +72,63 @@
 static INLINE UINT16 ntlm_av_pair_get_id(const NTLM_AV_PAIR* pAvPair)
 {
 	UINT16 AvId;
+
+	if (!pAvPair)
+		return MsvAvEOL;
+
 	Data_Read_UINT16(&pAvPair->AvId, AvId);
 	return AvId;
 }
 
-ULONG ntlm_av_pair_list_length(NTLM_AV_PAIR* pAvPairList, size_t cbAvPairList)
+ULONG ntlm_av_pair_list_length(NTLM_AV_PAIR* pAvPairList, size_t cbAvPairListMaxLength)
 {
-	size_t cbAvPair;
-	NTLM_AV_PAIR* pAvPair;
-	pAvPair = ntlm_av_pair_get(pAvPairList, cbAvPairList, MsvAvEOL, &cbAvPair);
+	ULONG length;
+	NTLM_AV_PAIR* pAvPair = pAvPairList;
 
 	if (!pAvPair)
 		return 0;
 
-	return ((PBYTE)pAvPair - (PBYTE)pAvPairList) + sizeof(NTLM_AV_PAIR);
+	while (ntlm_av_pair_get_id(pAvPair) != MsvAvEOL)
+	{
+		pAvPair = ntlm_av_pair_get_next_pointer(pAvPair, &cbAvPairListMaxLength);
+	}
+
+	length = (pAvPair - pAvPairList) + sizeof(NTLM_AV_PAIR);
+	return length;
 }
 
-static INLINE SIZE_T ntlm_av_pair_get_len(const NTLM_AV_PAIR* pAvPair)
+static INLINE SSIZE_T ntlm_av_pair_get_len(const NTLM_AV_PAIR* pAvPair, size_t cbAvPair)
 {
 	UINT16 AvLen;
+
+	if (!pAvPair || (cbAvPair < sizeof(NTLM_AV_PAIR)))
+		return -1;
+
 	Data_Read_UINT16(&pAvPair->AvLen, AvLen);
+
+	if (cbAvPair < sizeof(NTLM_AV_PAIR) + pAvPair->AvLen)
+		return -1;
+
 	return AvLen;
 }
 
 void ntlm_print_av_pair_list(NTLM_AV_PAIR* pAvPairList, size_t cbAvPairList)
 {
-	size_t cbAvPair = cbAvPairList;
 	NTLM_AV_PAIR* pAvPair = pAvPairList;
 
-	if (!ntlm_av_pair_check(pAvPair, cbAvPair))
+	if (!pAvPair)
 		return;
 
 	WLog_INFO(TAG, "AV_PAIRs =");
 
-	while (pAvPair && ntlm_av_pair_get_id(pAvPair) != MsvAvEOL)
+	while (ntlm_av_pair_get_id(pAvPair) != MsvAvEOL)
 	{
 		WLog_INFO(TAG, "\t%s AvId: %" PRIu16 " AvLen: %" PRIu16 "",
 		          AV_PAIR_STRINGS[ntlm_av_pair_get_id(pAvPair)], ntlm_av_pair_get_id(pAvPair),
-		          ntlm_av_pair_get_len(pAvPair));
-		winpr_HexDump(TAG, WLOG_INFO, ntlm_av_pair_get_value_pointer(pAvPair),
-		              ntlm_av_pair_get_len(pAvPair));
-		pAvPair = ntlm_av_pair_next(pAvPair, &cbAvPair);
+		          ntlm_av_pair_get_len(pAvPair, cbAvPairList));
+		winpr_HexDump(TAG, WLOG_INFO, ntlm_av_pair_get_value_pointer(pAvPair, cbAvPairList),
+		              ntlm_av_pair_get_len(pAvPair, cbAvPairList));
+		pAvPair = ntlm_av_pair_get_next_pointer(pAvPair, &cbAvPairList);
 	}
 }
 
@@ -123,105 +138,95 @@
 	return ((AvPairsCount + 1) * 4) + AvPairsValueLength;
 }
 
-PBYTE ntlm_av_pair_get_value_pointer(NTLM_AV_PAIR* pAvPair)
+PBYTE ntlm_av_pair_get_value_pointer(NTLM_AV_PAIR* pAvPair, size_t cbAvPairListMaxLength)
 {
-	return (PBYTE)pAvPair + sizeof(NTLM_AV_PAIR);
-}
+	if (cbAvPairListMaxLength < 2 * sizeof(NTLM_AV_PAIR))
+		return NULL;
 
-static size_t ntlm_av_pair_get_next_offset(NTLM_AV_PAIR* pAvPair)
-{
-	return ntlm_av_pair_get_len(pAvPair) + sizeof(NTLM_AV_PAIR);
+	return &((PBYTE)pAvPair)[sizeof(NTLM_AV_PAIR)];
 }
 
-static BOOL ntlm_av_pair_check(NTLM_AV_PAIR* pAvPair, size_t cbAvPair)
+static SSIZE_T ntlm_av_pair_get_next_offset(NTLM_AV_PAIR* pAvPair, size_t cbAvPairListMaxLength)
 {
-	if (!pAvPair || cbAvPair < sizeof(NTLM_AV_PAIR))
-		return FALSE;
-
-	return cbAvPair >= ntlm_av_pair_get_next_offset(pAvPair);
+	return ntlm_av_pair_get_len(pAvPair, cbAvPairListMaxLength) + sizeof(NTLM_AV_PAIR);
 }
 
-static NTLM_AV_PAIR* ntlm_av_pair_next(NTLM_AV_PAIR* pAvPair, size_t* pcbAvPair)
+NTLM_AV_PAIR* ntlm_av_pair_get_next_pointer(NTLM_AV_PAIR* pAvPair, size_t* pcbAvPair)
 {
-	size_t offset;
+	SSIZE_T offset;
 
-	if (!pcbAvPair)
+	if (!pAvPair || !pcbAvPair)
 		return NULL;
 
-	if (!ntlm_av_pair_check(pAvPair, *pcbAvPair))
+	offset = ntlm_av_pair_get_next_offset(pAvPair, *pcbAvPair);
+
+	if ((offset <= 0) || (offset > *pcbAvPair))
 		return NULL;
 
-	offset = ntlm_av_pair_get_next_offset(pAvPair);
 	*pcbAvPair -= offset;
 	return (NTLM_AV_PAIR*)((PBYTE)pAvPair + offset);
 }
 
-NTLM_AV_PAIR* ntlm_av_pair_get(NTLM_AV_PAIR* pAvPairList, size_t cbAvPairList, NTLM_AV_ID AvId,
-                               size_t* pcbAvPairListRemaining)
+NTLM_AV_PAIR* ntlm_av_pair_get(void* pAvPairList, size_t avPairListLength, NTLM_AV_ID AvId,
+                               size_t* pcbAvPairListRemainingLength)
 {
-	size_t cbAvPair = cbAvPairList;
 	NTLM_AV_PAIR* pAvPair = pAvPairList;
 
-	if (!ntlm_av_pair_check(pAvPair, cbAvPair))
-		pAvPair = NULL;
+	if (pcbAvPairListRemainingLength)
+		*pcbAvPairListRemainingLength = 0;
 
 	while (pAvPair)
 	{
-		UINT16 id = ntlm_av_pair_get_id(pAvPair);
-
-		if (id == AvId)
-			break;
-
-		if (id == MsvAvEOL)
+		if (ntlm_av_pair_get_id(pAvPair) == AvId)
 		{
-			pAvPair = NULL;
-			break;
-		}
+			if (pcbAvPairListRemainingLength)
+				*pcbAvPairListRemainingLength = avPairListLength;
 
-		pAvPair = ntlm_av_pair_next(pAvPair, &cbAvPair);
-	}
+			return pAvPair;
+		}
 
-	if (!pAvPair)
-		cbAvPair = 0;
+		if (ntlm_av_pair_get_id(pAvPair) == MsvAvEOL)
+			return NULL;
 
-	if (pcbAvPairListRemaining)
-		*pcbAvPairListRemaining = cbAvPair;
+		pAvPair = ntlm_av_pair_get_next_pointer(pAvPair, &avPairListLength);
+	}
 
-	return pAvPair;
+	return NULL;
 }
 
-static BOOL ntlm_av_pair_add(NTLM_AV_PAIR* pAvPairList, size_t cbAvPairList, NTLM_AV_ID AvId,
-                             PBYTE Value, UINT16 AvLen)
+static NTLM_AV_PAIR* ntlm_av_pair_add(NTLM_AV_PAIR* pAvPairList, size_t cbAvPairListLength,
+                                      NTLM_AV_ID AvId, PBYTE Value, UINT16 AvLen)
 {
 	size_t cbAvPair;
 	NTLM_AV_PAIR* pAvPair;
-	pAvPair = ntlm_av_pair_get(pAvPairList, cbAvPairList, MsvAvEOL, &cbAvPair);
+	pAvPair = ntlm_av_pair_get(pAvPairList, cbAvPairListLength, MsvAvEOL, &cbAvPair);
 
-	/* size of header + value length + terminating MsvAvEOL AV_PAIR */
-	if (!pAvPair || cbAvPair < 2 * sizeof(NTLM_AV_PAIR) + AvLen)
-		return FALSE;
+	if (!pAvPair)
+		return NULL;
 
+	assert(Value != NULL);
 	ntlm_av_pair_set_id(pAvPair, AvId);
 	ntlm_av_pair_set_len(pAvPair, AvLen);
-
-	if (AvLen)
-	{
-		assert(Value != NULL);
-		CopyMemory(ntlm_av_pair_get_value_pointer(pAvPair), Value, AvLen);
-	}
-
-	pAvPair = ntlm_av_pair_next(pAvPair, &cbAvPair);
-	return ntlm_av_pair_list_init(pAvPair, cbAvPair);
+	CopyMemory(ntlm_av_pair_get_value_pointer(pAvPair, cbAvPair), Value, AvLen);
+	return pAvPair;
 }
 
-static BOOL ntlm_av_pair_add_copy(NTLM_AV_PAIR* pAvPairList, size_t cbAvPairList,
-                                  NTLM_AV_PAIR* pAvPair, size_t cbAvPair)
+static NTLM_AV_PAIR* ntlm_av_pair_add_copy(NTLM_AV_PAIR* pAvPairList, size_t cbAvPairListLength,
+                                           NTLM_AV_PAIR* pAvPair, size_t cbAvPair)
 {
-	if (!ntlm_av_pair_check(pAvPair, cbAvPair))
-		return FALSE;
+	NTLM_AV_PAIR* pAvPairCopy;
+	size_t cbAvPairCopy;
+	pAvPairCopy = ntlm_av_pair_get(pAvPairList, cbAvPairListLength, MsvAvEOL, &cbAvPairCopy);
+
+	if (!pAvPairCopy)
+		return NULL;
 
-	return ntlm_av_pair_add(pAvPairList, cbAvPairList, ntlm_av_pair_get_id(pAvPair),
-	                        ntlm_av_pair_get_value_pointer(pAvPair), ntlm_av_pair_get_len(pAvPair));
+	CopyMemory(&pAvPairCopy->AvId, &pAvPair->AvId, 2);
+	CopyMemory(&pAvPairCopy->AvLen, &pAvPair->AvLen, 2);
+	CopyMemory(ntlm_av_pair_get_value_pointer(pAvPairCopy, cbAvPairCopy),
+	           ntlm_av_pair_get_value_pointer(pAvPair, cbAvPair),
+	           ntlm_av_pair_get_len(pAvPair, cbAvPair));
+	return pAvPairCopy;
 }
 
 static int ntlm_get_target_computer_name(PUNICODE_STRING pName, COMPUTER_NAME_FORMAT type)
@@ -430,24 +435,24 @@
 	if (!ntlm_av_pair_list_init(pAvPairList, cbAvPairList))
 		goto fail;
 
-	if (!ntlm_av_pair_add(pAvPairList, cbAvPairList, MsvAvNbDomainName, (PBYTE)NbDomainName.Buffer,
-	                      NbDomainName.Length))
+	if (ntlm_av_pair_add(pAvPairList, cbAvPairList, MsvAvNbDomainName, (PBYTE)NbDomainName.Buffer,
+	                     NbDomainName.Length) == NULL)
 		goto fail;
 
-	if (!ntlm_av_pair_add(pAvPairList, cbAvPairList, MsvAvNbComputerName,
-	                      (PBYTE)NbComputerName.Buffer, NbComputerName.Length))
+	if (ntlm_av_pair_add(pAvPairList, cbAvPairList, MsvAvNbComputerName,
+	                     (PBYTE)NbComputerName.Buffer, NbComputerName.Length) == NULL)
 		goto fail;
 
-	if (!ntlm_av_pair_add(pAvPairList, cbAvPairList, MsvAvDnsDomainName,
-	                      (PBYTE)DnsDomainName.Buffer, DnsDomainName.Length))
+	if (ntlm_av_pair_add(pAvPairList, cbAvPairList, MsvAvDnsDomainName, (PBYTE)DnsDomainName.Buffer,
+	                     DnsDomainName.Length) == NULL)
 		goto fail;
 
-	if (!ntlm_av_pair_add(pAvPairList, cbAvPairList, MsvAvDnsComputerName,
-	                      (PBYTE)DnsComputerName.Buffer, DnsComputerName.Length))
+	if (ntlm_av_pair_add(pAvPairList, cbAvPairList, MsvAvDnsComputerName,
+	                     (PBYTE)DnsComputerName.Buffer, DnsComputerName.Length) == NULL)
 		goto fail;
 
-	if (!ntlm_av_pair_add(pAvPairList, cbAvPairList, MsvAvTimestamp, context->Timestamp,
-	                      sizeof(context->Timestamp)))
+	if (ntlm_av_pair_add(pAvPairList, cbAvPairList, MsvAvTimestamp, context->Timestamp,
+	                     sizeof(context->Timestamp)) == NULL)
 		goto fail;
 
 	rc = 1;
@@ -500,31 +505,31 @@
 	if (AvNbDomainName)
 	{
 		AvPairsCount++; /* MsvAvNbDomainName */
-		AvPairsValueLength += ntlm_av_pair_get_len(AvNbDomainName);
+		AvPairsValueLength += ntlm_av_pair_get_len(AvNbDomainName, cbAvNbDomainName);
 	}
 
 	if (AvNbComputerName)
 	{
 		AvPairsCount++; /* MsvAvNbComputerName */
-		AvPairsValueLength += ntlm_av_pair_get_len(AvNbComputerName);
+		AvPairsValueLength += ntlm_av_pair_get_len(AvNbComputerName, cbAvNbComputerName);
 	}
 
 	if (AvDnsDomainName)
 	{
 		AvPairsCount++; /* MsvAvDnsDomainName */
-		AvPairsValueLength += ntlm_av_pair_get_len(AvDnsDomainName);
+		AvPairsValueLength += ntlm_av_pair_get_len(AvDnsDomainName, cbAvDnsDomainName);
 	}
 
 	if (AvDnsComputerName)
 	{
 		AvPairsCount++; /* MsvAvDnsComputerName */
-		AvPairsValueLength += ntlm_av_pair_get_len(AvDnsComputerName);
+		AvPairsValueLength += ntlm_av_pair_get_len(AvDnsComputerName, cbAvDnsComputerName);
 	}
 
 	if (AvDnsTreeName)
 	{
 		AvPairsCount++; /* MsvAvDnsTreeName */
-		AvPairsValueLength += ntlm_av_pair_get_len(AvDnsTreeName);
+		AvPairsValueLength += ntlm_av_pair_get_len(AvDnsTreeName, cbAvDnsTreeName);
 	}
 
 	AvPairsCount++; /* MsvAvTimestamp */
@@ -581,43 +586,43 @@
 
 	if (AvNbDomainName)
 	{
-		if (!ntlm_av_pair_add_copy(AuthenticateTargetInfo, cbAuthenticateTargetInfo, AvNbDomainName,
-		                           cbAvNbDomainName))
+		if (ntlm_av_pair_add_copy(AuthenticateTargetInfo, cbAuthenticateTargetInfo, AvNbDomainName,
+		                          cbAvNbDomainName) == NULL)
 			return -1;
 	}
 
 	if (AvNbComputerName)
 	{
-		if (!ntlm_av_pair_add_copy(AuthenticateTargetInfo, cbAuthenticateTargetInfo,
-		                           AvNbComputerName, cbAvNbComputerName))
+		if (ntlm_av_pair_add_copy(AuthenticateTargetInfo, cbAuthenticateTargetInfo,
+		                          AvNbComputerName, cbAvNbComputerName) == NULL)
 			return -1;
 	}
 
 	if (AvDnsDomainName)
 	{
-		if (!ntlm_av_pair_add_copy(AuthenticateTargetInfo, cbAuthenticateTargetInfo,
-		                           AvDnsDomainName, cbAvDnsDomainName))
+		if (ntlm_av_pair_add_copy(AuthenticateTargetInfo, cbAuthenticateTargetInfo, AvDnsDomainName,
+		                          cbAvDnsDomainName) == NULL)
 			return -1;
 	}
 
 	if (AvDnsComputerName)
 	{
-		if (!ntlm_av_pair_add_copy(AuthenticateTargetInfo, cbAuthenticateTargetInfo,
-		                           AvDnsComputerName, cbAvDnsComputerName))
+		if (ntlm_av_pair_add_copy(AuthenticateTargetInfo, cbAuthenticateTargetInfo,
+		                          AvDnsComputerName, cbAvDnsComputerName) == NULL)
 			return -1;
 	}
 
 	if (AvDnsTreeName)
 	{
-		if (!ntlm_av_pair_add_copy(AuthenticateTargetInfo, cbAuthenticateTargetInfo, AvDnsTreeName,
-		                           cbAvDnsTreeName))
+		if (ntlm_av_pair_add_copy(AuthenticateTargetInfo, cbAuthenticateTargetInfo, AvDnsTreeName,
+		                          cbAvDnsTreeName) == NULL)
 			return -1;
 	}
 
 	if (AvTimestamp)
 	{
-		if (!ntlm_av_pair_add_copy(AuthenticateTargetInfo, cbAuthenticateTargetInfo, AvTimestamp,
-		                           cbAvTimestamp))
+		if (ntlm_av_pair_add_copy(AuthenticateTargetInfo, cbAuthenticateTargetInfo, AvTimestamp,
+		                          cbAvTimestamp) == NULL)
 			return -1;
 	}
 
@@ -626,29 +631,29 @@
 		UINT32 flags;
 		Data_Write_UINT32(&flags, MSV_AV_FLAGS_MESSAGE_INTEGRITY_CHECK);
 
-		if (!ntlm_av_pair_add(AuthenticateTargetInfo, cbAuthenticateTargetInfo, MsvAvFlags,
-		                      (PBYTE)&flags, 4))
+		if (ntlm_av_pair_add(AuthenticateTargetInfo, cbAuthenticateTargetInfo, MsvAvFlags,
+		                     (PBYTE)&flags, 4) == NULL)
 			return -1;
 	}
 
 	if (context->SendSingleHostData)
 	{
-		if (!ntlm_av_pair_add(AuthenticateTargetInfo, cbAuthenticateTargetInfo, MsvAvSingleHost,
-		                      (PBYTE)&context->SingleHostData, context->SingleHostData.Size))
+		if (ntlm_av_pair_add(AuthenticateTargetInfo, cbAuthenticateTargetInfo, MsvAvSingleHost,
+		                     (PBYTE)&context->SingleHostData, context->SingleHostData.Size) == NULL)
 			return -1;
 	}
 
 	if (!context->SuppressExtendedProtection)
 	{
-		if (!ntlm_av_pair_add(AuthenticateTargetInfo, cbAuthenticateTargetInfo, MsvChannelBindings,
-		                      context->ChannelBindingsHash, 16))
+		if (ntlm_av_pair_add(AuthenticateTargetInfo, cbAuthenticateTargetInfo, MsvChannelBindings,
+		                     context->ChannelBindingsHash, 16) == NULL)
 			return -1;
 
 		if (context->ServicePrincipalName.Length > 0)
 		{
-			if (!ntlm_av_pair_add(AuthenticateTargetInfo, cbAuthenticateTargetInfo, MsvAvTargetName,
-			                      (PBYTE)context->ServicePrincipalName.Buffer,
-			                      context->ServicePrincipalName.Length))
+			if (ntlm_av_pair_add(AuthenticateTargetInfo, cbAuthenticateTargetInfo, MsvAvTargetName,
+			                     (PBYTE)context->ServicePrincipalName.Buffer,
+			                     context->ServicePrincipalName.Length) == NULL)
 				return -1;
 		}
 	}
diff -urN winpr/libwinpr/sspi/NTLM/ntlm_av_pairs.h ../../informatimago/FreeRDP/winpr/libwinpr/sspi/NTLM/ntlm_av_pairs.h
--- winpr/libwinpr/sspi/NTLM/ntlm_av_pairs.h	2019-07-25 19:51:09.377939647 +0300
+++ ../../informatimago/FreeRDP/winpr/libwinpr/sspi/NTLM/ntlm_av_pairs.h	2019-07-19 20:00:34.145156321 +0300
@@ -24,11 +24,11 @@
 
 #include <winpr/stream.h>
 
-ULONG ntlm_av_pair_list_length(NTLM_AV_PAIR* pAvPairList, size_t cbAvPairList);
+ULONG ntlm_av_pair_list_length(NTLM_AV_PAIR* pAvPairList, size_t cbAvPairListMaxLength);
 void ntlm_print_av_pair_list(NTLM_AV_PAIR* pAvPairList, size_t cbAvPairList);
-PBYTE ntlm_av_pair_get_value_pointer(NTLM_AV_PAIR* pAvPair);
-NTLM_AV_PAIR* ntlm_av_pair_get(NTLM_AV_PAIR* pAvPairList, size_t cbAvPairList, NTLM_AV_ID AvId,
-                               size_t* pcbAvPairListRemaining);
+PBYTE ntlm_av_pair_get_value_pointer(NTLM_AV_PAIR* pAvPair, size_t cbAvPairListMaxLength);
+NTLM_AV_PAIR* ntlm_av_pair_get(void* pAvPairList, size_t avPairListLength, NTLM_AV_ID AvId,
+                               size_t* pcbAvPairListRemainingLength);
 
 int ntlm_construct_challenge_target_info(NTLM_CONTEXT* context);
 int ntlm_construct_authenticate_target_info(NTLM_CONTEXT* context);
diff -urN winpr/libwinpr/sspi/NTLM/ntlm_message.c ../../informatimago/FreeRDP/winpr/libwinpr/sspi/NTLM/ntlm_message.c
--- winpr/libwinpr/sspi/NTLM/ntlm_message.c	2019-07-25 19:51:09.409939806 +0300
+++ ../../informatimago/FreeRDP/winpr/libwinpr/sspi/NTLM/ntlm_message.c	2019-07-25 20:11:33.244008842 +0300
@@ -459,12 +459,12 @@
 
 		context->ChallengeTargetInfo.pvBuffer = message->TargetInfo.Buffer;
 		context->ChallengeTargetInfo.cbBuffer = message->TargetInfo.Len;
-		AvTimestamp = ntlm_av_pair_get((NTLM_AV_PAIR*)message->TargetInfo.Buffer,
-		                               message->TargetInfo.Len, MsvAvTimestamp, &cbAvTimestamp);
+		AvTimestamp = ntlm_av_pair_get(message->TargetInfo.Buffer, message->TargetInfo.Len,
+		                               MsvAvTimestamp, &cbAvTimestamp);
 
 		if (AvTimestamp)
 		{
-			PBYTE ptr = ntlm_av_pair_get_value_pointer(AvTimestamp);
+			PBYTE ptr = ntlm_av_pair_get_value_pointer(AvTimestamp, cbAvTimestamp);
 
 			if (!ptr)
 				return SEC_E_INTERNAL_ERROR;
@@ -826,7 +826,7 @@
 		                     context->NTLMv2Response.Challenge.cbAvPairs, MsvAvFlags, &cbAvFlags);
 
 		if (AvFlags)
-			Data_Read_UINT32(ntlm_av_pair_get_value_pointer(AvFlags), flags);
+			Data_Read_UINT32(ntlm_av_pair_get_value_pointer(AvFlags, cbAvFlags), flags);
 	}
 
 	if (ntlm_read_message_fields_buffer(s, &(message->EncryptedRandomSessionKey)) <
@@ -1140,7 +1140,7 @@
 	                           context->NTLMv2Response.Challenge.cbAvPairs, MsvAvFlags, &cbAvFlags);
 
 	if (AvFlags)
-		Data_Read_UINT32(ntlm_av_pair_get_value_pointer(AvFlags), flags);
+		Data_Read_UINT32(ntlm_av_pair_get_value_pointer(AvFlags, cbAvFlags), flags);
 
 	if (ntlm_compute_lm_v2_response(context) < 0) /* LmChallengeResponse */
 		return SEC_E_INTERNAL_ERROR;
diff -urN winpr/libwinpr/sspi/Schannel/schannel_openssl.c ../../informatimago/FreeRDP/winpr/libwinpr/sspi/Schannel/schannel_openssl.c
--- winpr/libwinpr/sspi/Schannel/schannel_openssl.c	2019-07-25 19:51:09.445939985 +0300
+++ ../../informatimago/FreeRDP/winpr/libwinpr/sspi/Schannel/schannel_openssl.c	2019-07-25 20:11:33.276009001 +0300
@@ -461,6 +461,8 @@
 SECURITY_STATUS schannel_openssl_encrypt_message(SCHANNEL_OPENSSL* context, PSecBufferDesc pMessage)
 {
 	int status;
+	int length;
+	int offset;
 	int ssl_error;
 	PSecBuffer pStreamBodyBuffer;
 	PSecBuffer pStreamHeaderBuffer;
@@ -484,20 +486,22 @@
 
 	if (status > 0)
 	{
-		size_t ustatus = (size_t)status;
-		size_t length;
-		size_t offset = 0;
-		length =
-		    (pStreamHeaderBuffer->cbBuffer > ustatus) ? ustatus : pStreamHeaderBuffer->cbBuffer;
+		offset = 0;
+		length = (pStreamHeaderBuffer->cbBuffer > (unsigned long)status)
+		             ? status
+		             : pStreamHeaderBuffer->cbBuffer;
 		CopyMemory(pStreamHeaderBuffer->pvBuffer, &context->ReadBuffer[offset], length);
-		ustatus -= length;
+		status -= length;
 		offset += length;
-		length = (pStreamBodyBuffer->cbBuffer > ustatus) ? ustatus : pStreamBodyBuffer->cbBuffer;
+		length = (pStreamBodyBuffer->cbBuffer > (unsigned long)status)
+		             ? status
+		             : pStreamBodyBuffer->cbBuffer;
 		CopyMemory(pStreamBodyBuffer->pvBuffer, &context->ReadBuffer[offset], length);
-		ustatus -= length;
+		status -= length;
 		offset += length;
-		length =
-		    (pStreamTrailerBuffer->cbBuffer > ustatus) ? ustatus : pStreamTrailerBuffer->cbBuffer;
+		length = (pStreamTrailerBuffer->cbBuffer > (unsigned long)status)
+		             ? status
+		             : pStreamTrailerBuffer->cbBuffer;
 		CopyMemory(pStreamTrailerBuffer->pvBuffer, &context->ReadBuffer[offset], length);
 	}
 
diff -urN winpr/libwinpr/sspi/sspi_winpr.c ../../informatimago/FreeRDP/winpr/libwinpr/sspi/sspi_winpr.c
--- winpr/libwinpr/sspi/sspi_winpr.c	2019-07-25 19:51:09.549940500 +0300
+++ ../../informatimago/FreeRDP/winpr/libwinpr/sspi/sspi_winpr.c	2019-07-25 20:11:33.384009536 +0300
@@ -218,6 +218,17 @@
 	return credentials;
 }
 
+void memory_clear_and_free(void** memory, size_t size)
+{
+	if (*memory != NULL)
+	{
+		memset(*memory, 0, size);
+		free(*memory);
+	}
+
+	(*memory) = NULL;
+}
+
 void sspi_CredentialsFree(SSPI_CREDENTIALS* credentials)
 {
 	size_t userLength = 0;
@@ -241,12 +252,9 @@
 		passwordLength *= 2;
 	}
 
-	memset(credentials->identity.User, 0, userLength);
-	memset(credentials->identity.Domain, 0, domainLength);
-	memset(credentials->identity.Password, 0, passwordLength);
-	free(credentials->identity.User);
-	free(credentials->identity.Domain);
-	free(credentials->identity.Password);
+	memory_clear_and_free((void**)&credentials->identity.User, userLength);
+	memory_clear_and_free((void**)&credentials->identity.Domain, domainLength);
+	memory_clear_and_free((void**)&credentials->identity.Password, passwordLength);
 	free(credentials);
 }
 
@@ -666,9 +674,6 @@
 	SecPkgInfoA* pPackageInfo = (SecPkgInfoA*)contextBuffer;
 	cPackages = sizeof(SecPkgInfoA_LIST) / sizeof(*(SecPkgInfoA_LIST));
 
-	if (!pPackageInfo)
-		return;
-
 	for (index = 0; index < (int)cPackages; index++)
 	{
 		free(pPackageInfo[index].Name);
diff -urN winpr/libwinpr/sspi/test/TestSspi.c ../../informatimago/FreeRDP/winpr/libwinpr/sspi/test/TestSspi.c
--- winpr/libwinpr/sspi/test/TestSspi.c	2019-07-25 20:17:16.401710552 +0300
+++ ../../informatimago/FreeRDP/winpr/libwinpr/sspi/test/TestSspi.c	2019-07-25 20:11:33.452009874 +0300
@@ -4,11 +4,9 @@
 #include <string.h> /* NOLINT */
 
 #if defined(_MSC_VER)
-#pragma warning(disable : 4996) /* deprecation */
+#	pragma warning(disable : 4996) /* deprecation */
 #endif
 
-
-
 /* Forward declare test functions. */
 int TestQuerySecurityPackageInfo(int, char*[]);
 int TestEnumerateSecurityPackages(int, char*[]);
@@ -17,151 +15,146 @@
 int TestCredSSP(int, char*[]);
 int TestNTLM(int, char*[]);
 
-
 #ifdef __cplusplus
-#define CM_CAST(TYPE, EXPR) static_cast<TYPE>(EXPR)
+#	define CM_CAST(TYPE, EXPR) static_cast<TYPE>(EXPR)
 #else
-#define CM_CAST(TYPE, EXPR) (TYPE)(EXPR)
+#	define CM_CAST(TYPE, EXPR) (TYPE)(EXPR)
 #endif
 
 /* Create map.  */
 
-typedef int (*MainFuncPointer)(int, char* []); /* NOLINT */
-typedef struct /* NOLINT */
+typedef int (*MainFuncPointer)(int, char*[]); /* NOLINT */
+typedef struct                                /* NOLINT */
 {
-  const char* name;
-  MainFuncPointer func;
+	const char* name;
+	MainFuncPointer func;
 } functionMapEntry;
 
 static functionMapEntry cmakeGeneratedFunctionMapEntries[] = {
-    {
-    "TestQuerySecurityPackageInfo",
-    TestQuerySecurityPackageInfo
-  },
-  {
-    "TestEnumerateSecurityPackages",
-    TestEnumerateSecurityPackages
-  },
-  {
-    "TestInitializeSecurityContext",
-    TestInitializeSecurityContext
-  },
-  {
-    "TestAcquireCredentialsHandle",
-    TestAcquireCredentialsHandle
-  },
-  {
-    "TestCredSSP",
-    TestCredSSP
-  },
-  {
-    "TestNTLM",
-    TestNTLM
-  },
+	{ "TestQuerySecurityPackageInfo", TestQuerySecurityPackageInfo },
+	{ "TestEnumerateSecurityPackages", TestEnumerateSecurityPackages },
+	{ "TestInitializeSecurityContext", TestInitializeSecurityContext },
+	{ "TestAcquireCredentialsHandle", TestAcquireCredentialsHandle },
+	{ "TestCredSSP", TestCredSSP },
+	{ "TestNTLM", TestNTLM },
 
-  { NULL, NULL } /* NOLINT */
+	{ NULL, NULL } /* NOLINT */
 };
 
-static const int NumTests = CM_CAST(int,
-  sizeof(cmakeGeneratedFunctionMapEntries) / sizeof(functionMapEntry)) - 1;
+static const int NumTests =
+    CM_CAST(int, sizeof(cmakeGeneratedFunctionMapEntries) / sizeof(functionMapEntry)) - 1;
 
 /* Allocate and create a lowercased copy of string
    (note that it has to be free'd manually) */
 static char* lowercase(const char* string)
 {
-  char *new_string, *p;
-  size_t stringSize;
+	char *new_string, *p;
+	size_t stringSize;
 
-  stringSize = CM_CAST(size_t, strlen(string) + 1);
-  new_string = CM_CAST(char*, malloc(sizeof(char) * stringSize));
+	stringSize = CM_CAST(size_t, strlen(string) + 1);
+	new_string = CM_CAST(char*, malloc(sizeof(char) * stringSize));
 
-  if (new_string == NULL) { /* NOLINT */
-    return NULL;            /* NOLINT */
-  }
-  strcpy(new_string, string);
-  for (p = new_string; *p != 0; ++p) {
-    *p = CM_CAST(char, tolower(*p));
-  }
-  return new_string;
+	if (new_string == NULL)
+	{                /* NOLINT */
+		return NULL; /* NOLINT */
+	}
+	strcpy(new_string, string);
+	for (p = new_string; *p != 0; ++p)
+	{
+		*p = CM_CAST(char, tolower(*p));
+	}
+	return new_string;
 }
 
 int main(int ac, char* av[])
 {
-  int i, testNum = 0, partial_match;
-  char *arg;
-  int testToRun = -1;
-
-  
-
-  /* If no test name was given */
-  /* process command line with user function.  */
-  if (ac < 2) {
-    /* Ask for a test.  */
-    printf("Available tests:\n");
-    for (i = 0; i < NumTests; ++i) {
-      printf("%3d. %s\n", i, cmakeGeneratedFunctionMapEntries[i].name);
-    }
-    printf("To run a test, enter the test number: ");
-    fflush(stdout);
-    if (scanf("%d", &testNum) != 1) {
-      printf("Couldn't parse that input as a number\n");
-      return -1;
-    }
-    if (testNum >= NumTests) {
-      printf("%3d is an invalid test number.\n", testNum);
-      return -1;
-    }
-    testToRun = testNum;
-    ac--;
-    av++;
-  }
-  partial_match = 0;
-  arg = NULL; /* NOLINT */
-  /* If partial match is requested.  */
-  if (testToRun == -1 && ac > 1) {
-    partial_match = (strcmp(av[1], "-R") == 0) ? 1 : 0;
-  }
-  if (partial_match != 0 && ac < 3) {
-    printf("-R needs an additional parameter.\n");
-    return -1;
-  }
-  if (testToRun == -1) {
-    arg = lowercase(av[1 + partial_match]);
-  }
-  for (i = 0; i < NumTests && testToRun == -1; ++i) {
-    char *test_name = lowercase(cmakeGeneratedFunctionMapEntries[i].name);
-    if (partial_match != 0 && strstr(test_name, arg) != NULL) { /* NOLINT */
-      testToRun = i;
-      ac -= 2;
-      av += 2;
-    } else if (partial_match == 0 && strcmp(test_name, arg) == 0) {
-      testToRun = i;
-      ac--;
-      av++;
-    }
-    free(test_name);
-  }
-  free(arg);
-  if (testToRun != -1) {
-    int result;
-
-    if (testToRun < 0 || testToRun >= NumTests) {
-      printf("testToRun was modified by TestDriver code to an invalid value: "
-             "%3d.\n",
-             testNum);
-      return -1;
-    }
-    result = (*cmakeGeneratedFunctionMapEntries[testToRun].func)(ac, av);
-
-    return result;
-  }
-
-  /* Nothing was run, display the test names.  */
-  printf("Available tests:\n");
-  for (i = 0; i < NumTests; ++i) {
-    printf("%3d. %s\n", i, cmakeGeneratedFunctionMapEntries[i].name);
-  }
-  printf("Failed: %s is an invalid test name.\n", av[1]);
+	int i, testNum = 0, partial_match;
+	char* arg;
+	int testToRun = -1;
+
+	/* If no test name was given */
+	/* process command line with user function.  */
+	if (ac < 2)
+	{
+		/* Ask for a test.  */
+		printf("Available tests:\n");
+		for (i = 0; i < NumTests; ++i)
+		{
+			printf("%3d. %s\n", i, cmakeGeneratedFunctionMapEntries[i].name);
+		}
+		printf("To run a test, enter the test number: ");
+		fflush(stdout);
+		if (scanf("%d", &testNum) != 1)
+		{
+			printf("Couldn't parse that input as a number\n");
+			return -1;
+		}
+		if (testNum >= NumTests)
+		{
+			printf("%3d is an invalid test number.\n", testNum);
+			return -1;
+		}
+		testToRun = testNum;
+		ac--;
+		av++;
+	}
+	partial_match = 0;
+	arg = NULL; /* NOLINT */
+	/* If partial match is requested.  */
+	if (testToRun == -1 && ac > 1)
+	{
+		partial_match = (strcmp(av[1], "-R") == 0) ? 1 : 0;
+	}
+	if (partial_match != 0 && ac < 3)
+	{
+		printf("-R needs an additional parameter.\n");
+		return -1;
+	}
+	if (testToRun == -1)
+	{
+		arg = lowercase(av[1 + partial_match]);
+	}
+	for (i = 0; i < NumTests && testToRun == -1; ++i)
+	{
+		char* test_name = lowercase(cmakeGeneratedFunctionMapEntries[i].name);
+		if (partial_match != 0 && strstr(test_name, arg) != NULL)
+		{ /* NOLINT */
+			testToRun = i;
+			ac -= 2;
+			av += 2;
+		}
+		else if (partial_match == 0 && strcmp(test_name, arg) == 0)
+		{
+			testToRun = i;
+			ac--;
+			av++;
+		}
+		free(test_name);
+	}
+	free(arg);
+	if (testToRun != -1)
+	{
+		int result;
+
+		if (testToRun < 0 || testToRun >= NumTests)
+		{
+			printf("testToRun was modified by TestDriver code to an invalid value: "
+			       "%3d.\n",
+			       testNum);
+			return -1;
+		}
+		result = (*cmakeGeneratedFunctionMapEntries[testToRun].func)(ac, av);
+
+		return result;
+	}
+
+	/* Nothing was run, display the test names.  */
+	printf("Available tests:\n");
+	for (i = 0; i < NumTests; ++i)
+	{
+		printf("%3d. %s\n", i, cmakeGeneratedFunctionMapEntries[i].name);
+	}
+	printf("Failed: %s is an invalid test name.\n", av[1]);
 
-  return -1;
+	return -1;
 }
diff -urN winpr/libwinpr/sspicli/sspicli.c ../../informatimago/FreeRDP/winpr/libwinpr/sspicli/sspicli.c
--- winpr/libwinpr/sspicli/sspicli.c	2019-07-25 19:51:09.625940877 +0300
+++ ../../informatimago/FreeRDP/winpr/libwinpr/sspicli/sspicli.c	2019-07-25 20:11:33.456009894 +0300
@@ -200,7 +200,7 @@
 
 BOOL GetUserNameExA(EXTENDED_NAME_FORMAT NameFormat, LPSTR lpNameBuffer, PULONG nSize)
 {
-	size_t length;
+	int length;
 	char* login;
 
 	switch (NameFormat)
diff -urN winpr/libwinpr/synch/barrier.c ../../informatimago/FreeRDP/winpr/libwinpr/synch/barrier.c
--- winpr/libwinpr/synch/barrier.c	2019-07-25 19:51:09.629940898 +0300
+++ ../../informatimago/FreeRDP/winpr/libwinpr/synch/barrier.c	2019-07-25 20:11:33.460009913 +0300
@@ -187,7 +187,7 @@
 		 * of processors.
 		 */
 
-		if (spinOnly || (((ULONG)remainingThreads < dwProcessors) && !blockOnly))
+		if (spinOnly || (remainingThreads < dwProcessors && !blockOnly))
 		{
 			DWORD dwSpinCount = lpBarrier->Reserved5;
 			DWORD sp = 0;
diff -urN winpr/libwinpr/synch/CMakeLists.txt ../../informatimago/FreeRDP/winpr/libwinpr/synch/CMakeLists.txt
--- winpr/libwinpr/synch/CMakeLists.txt	2019-07-24 06:11:52.550197966 +0300
+++ ../../informatimago/FreeRDP/winpr/libwinpr/synch/CMakeLists.txt	2019-07-19 20:00:17.509205390 +0300
@@ -32,7 +32,7 @@
 
 if(FREEBSD)
 	winpr_include_directory_add(${EPOLLSHIM_INCLUDE_DIR})
-	winpr_library_add_private(${EPOLLSHIM_LIBS})
+	winpr_library_add(${EPOLLSHIM_LIBS})
 endif()
 
 if(BUILD_TESTING)
diff -urN winpr/libwinpr/synch/event.c ../../informatimago/FreeRDP/winpr/libwinpr/synch/event.c
--- winpr/libwinpr/synch/event.c	2019-07-25 19:51:09.645940977 +0300
+++ ../../informatimago/FreeRDP/winpr/libwinpr/synch/event.c	2019-07-25 20:11:33.476009993 +0300
@@ -74,9 +74,11 @@
 	return event->pipe_fd[0];
 }
 
-static BOOL EventCloseHandle_(WINPR_EVENT* event)
+static BOOL EventCloseHandle(HANDLE handle)
 {
-	if (!event)
+	WINPR_EVENT* event = (WINPR_EVENT*)handle;
+
+	if (!EventIsHandled(handle))
 		return FALSE;
 
 	if (!event->bAttached)
@@ -94,21 +96,10 @@
 		}
 	}
 
-	free(event->name);
 	free(event);
 	return TRUE;
 }
 
-static BOOL EventCloseHandle(HANDLE handle)
-{
-	WINPR_EVENT* event = (WINPR_EVENT*)handle;
-
-	if (!EventIsHandled(handle))
-		return FALSE;
-
-	return EventCloseHandle_(event);
-}
-
 static HANDLE_OPS ops = { EventIsHandled, EventCloseHandle,
 	                      EventGetFd,     NULL, /* CleanupHandle */
 	                      NULL,           NULL,
@@ -123,36 +114,11 @@
 HANDLE CreateEventW(LPSECURITY_ATTRIBUTES lpEventAttributes, BOOL bManualReset, BOOL bInitialState,
                     LPCWSTR lpName)
 {
-	HANDLE handle;
-	char* name = NULL;
-
-	if (lpName)
-	{
-		int rc = ConvertFromUnicode(CP_UTF8, 0, lpName, -1, &name, 0, NULL, NULL);
-
-		if (rc < 0)
-			return NULL;
-	}
-
-	handle = CreateEventA(lpEventAttributes, bManualReset, bInitialState, name);
-	free(name);
-	return handle;
-}
-
-HANDLE CreateEventA(LPSECURITY_ATTRIBUTES lpEventAttributes, BOOL bManualReset, BOOL bInitialState,
-                    LPCSTR lpName)
-{
 	WINPR_EVENT* event = (WINPR_EVENT*)calloc(1, sizeof(WINPR_EVENT));
 
-	if (lpEventAttributes)
-		WLog_WARN(TAG, "%s [%s] does not support lpEventAttributes", __FUNCTION__, lpName);
-
 	if (!event)
 		return NULL;
 
-	if (lpName)
-		event->name = strdup(lpName);
-
 	event->bAttached = FALSE;
 	event->bManualReset = bManualReset;
 	event->ops = &ops;
@@ -177,72 +143,39 @@
 #	endif
 
 	if (bInitialState)
-	{
-		if (!SetEvent(event))
-			goto fail;
-	}
+		SetEvent(event);
 
 	return (HANDLE)event;
 fail:
-	EventCloseHandle_(event);
+	free(event);
 	return NULL;
 }
 
+HANDLE CreateEventA(LPSECURITY_ATTRIBUTES lpEventAttributes, BOOL bManualReset, BOOL bInitialState,
+                    LPCSTR lpName)
+{
+	return CreateEventW(lpEventAttributes, bManualReset, bInitialState, NULL);
+}
+
 HANDLE CreateEventExW(LPSECURITY_ATTRIBUTES lpEventAttributes, LPCWSTR lpName, DWORD dwFlags,
                       DWORD dwDesiredAccess)
 {
-	BOOL initial = FALSE;
-	BOOL manual = FALSE;
-
-	if (dwFlags & CREATE_EVENT_INITIAL_SET)
-		initial = TRUE;
-
-	if (dwFlags & CREATE_EVENT_MANUAL_RESET)
-		manual = TRUE;
-
-	if (dwDesiredAccess != 0)
-		WLog_WARN(TAG, "%s [%s] does not support dwDesiredAccess 0x%08" PRIx32, __FUNCTION__,
-		          lpName, dwDesiredAccess);
-
-	return CreateEventW(lpEventAttributes, manual, initial, lpName);
+	return NULL;
 }
 
 HANDLE CreateEventExA(LPSECURITY_ATTRIBUTES lpEventAttributes, LPCSTR lpName, DWORD dwFlags,
                       DWORD dwDesiredAccess)
 {
-	BOOL initial = FALSE;
-	BOOL manual = FALSE;
-
-	if (dwFlags & CREATE_EVENT_INITIAL_SET)
-		initial = TRUE;
-
-	if (dwFlags & CREATE_EVENT_MANUAL_RESET)
-		manual = TRUE;
-
-	if (dwDesiredAccess != 0)
-		WLog_WARN(TAG, "%s [%s] does not support dwDesiredAccess 0x%08" PRIx32, __FUNCTION__,
-		          lpName, dwDesiredAccess);
-
-	return CreateEventA(lpEventAttributes, manual, initial, lpName);
+	return NULL;
 }
 
 HANDLE OpenEventW(DWORD dwDesiredAccess, BOOL bInheritHandle, LPCWSTR lpName)
 {
-	/* TODO: Implement */
-	WINPR_UNUSED(dwDesiredAccess);
-	WINPR_UNUSED(bInheritHandle);
-	WINPR_UNUSED(lpName);
-	WLog_ERR(TAG, "%s not implemented", __FUNCTION__);
 	return NULL;
 }
 
 HANDLE OpenEventA(DWORD dwDesiredAccess, BOOL bInheritHandle, LPCSTR lpName)
 {
-	/* TODO: Implement */
-	WINPR_UNUSED(dwDesiredAccess);
-	WINPR_UNUSED(bInheritHandle);
-	WINPR_UNUSED(lpName);
-	WLog_ERR(TAG, "%s not implemented", __FUNCTION__);
 	return NULL;
 }
 
diff -urN winpr/libwinpr/synch/mutex.c ../../informatimago/FreeRDP/winpr/libwinpr/synch/mutex.c
--- winpr/libwinpr/synch/mutex.c	2019-07-25 19:51:09.649940997 +0300
+++ ../../informatimago/FreeRDP/winpr/libwinpr/synch/mutex.c	2019-07-25 20:11:33.480010013 +0300
@@ -24,7 +24,6 @@
 #include <winpr/synch.h>
 #include <winpr/debug.h>
 #include <winpr/wlog.h>
-#include <winpr/string.h>
 
 #include "synch.h"
 
@@ -100,7 +99,6 @@
 		 */
 	}
 
-	free(mutex->name);
 	free(handle);
 	return TRUE;
 }
@@ -118,31 +116,10 @@
 
 HANDLE CreateMutexW(LPSECURITY_ATTRIBUTES lpMutexAttributes, BOOL bInitialOwner, LPCWSTR lpName)
 {
-	HANDLE handle;
-	char* name = NULL;
-
-	if (lpName)
-	{
-		int rc = ConvertFromUnicode(CP_UTF8, 0, lpName, -1, &name, 0, NULL, NULL);
-
-		if (rc < 0)
-			return NULL;
-	}
-
-	handle = CreateMutexA(lpMutexAttributes, bInitialOwner, name);
-	free(name);
-	return handle;
-}
-
-HANDLE CreateMutexA(LPSECURITY_ATTRIBUTES lpMutexAttributes, BOOL bInitialOwner, LPCSTR lpName)
-{
 	HANDLE handle = NULL;
 	WINPR_MUTEX* mutex;
 	mutex = (WINPR_MUTEX*)calloc(1, sizeof(WINPR_MUTEX));
 
-	if (lpMutexAttributes)
-		WLog_WARN(TAG, "%s [%s] does not support lpMutexAttributes", __FUNCTION__, lpName);
-
 	if (mutex)
 	{
 		pthread_mutexattr_t attr;
@@ -155,63 +132,35 @@
 
 		if (bInitialOwner)
 			pthread_mutex_lock(&mutex->mutex);
-
-		if (lpName)
-			mutex->name = strdup(lpName); /* Non runtime relevant information, skip NULL check */
 	}
 
 	return handle;
 }
 
-HANDLE CreateMutexExA(LPSECURITY_ATTRIBUTES lpMutexAttributes, LPCSTR lpName, DWORD dwFlags,
-                      DWORD dwDesiredAccess)
+HANDLE CreateMutexA(LPSECURITY_ATTRIBUTES lpMutexAttributes, BOOL bInitialOwner, LPCSTR lpName)
 {
-	BOOL initial = FALSE;
-	/* TODO: support access modes */
-
-	if (dwDesiredAccess != 0)
-		WLog_WARN(TAG, "%s [%s] does not support dwDesiredAccess 0x%08" PRIx32, __FUNCTION__,
-		          lpName, dwDesiredAccess);
-
-	if (dwFlags & CREATE_MUTEX_INITIAL_OWNER)
-		initial = TRUE;
+	return CreateMutexW(lpMutexAttributes, bInitialOwner, NULL);
+}
 
-	return CreateMutexA(lpMutexAttributes, initial, lpName);
+HANDLE CreateMutexExA(LPSECURITY_ATTRIBUTES lpMutexAttributes, LPCTSTR lpName, DWORD dwFlags,
+                      DWORD dwDesiredAccess)
+{
+	return CreateMutexW(lpMutexAttributes, FALSE, NULL);
 }
 
 HANDLE CreateMutexExW(LPSECURITY_ATTRIBUTES lpMutexAttributes, LPCWSTR lpName, DWORD dwFlags,
                       DWORD dwDesiredAccess)
 {
-	BOOL initial = FALSE;
-
-	/* TODO: support access modes */
-	if (dwDesiredAccess != 0)
-		WLog_WARN(TAG, "%s [%s] does not support dwDesiredAccess 0x%08" PRIx32, __FUNCTION__,
-		          lpName, dwDesiredAccess);
-
-	if (dwFlags & CREATE_MUTEX_INITIAL_OWNER)
-		initial = TRUE;
-
-	return CreateMutexW(lpMutexAttributes, initial, lpName);
+	return CreateMutexW(lpMutexAttributes, FALSE, NULL);
 }
 
 HANDLE OpenMutexA(DWORD dwDesiredAccess, BOOL bInheritHandle, LPCSTR lpName)
 {
-	/* TODO: Implement */
-	WINPR_UNUSED(dwDesiredAccess);
-	WINPR_UNUSED(bInheritHandle);
-	WINPR_UNUSED(lpName);
-	WLog_ERR(TAG, "%s not implemented", __FUNCTION__);
 	return NULL;
 }
 
 HANDLE OpenMutexW(DWORD dwDesiredAccess, BOOL bInheritHandle, LPCWSTR lpName)
 {
-	/* TODO: Implement */
-	WINPR_UNUSED(dwDesiredAccess);
-	WINPR_UNUSED(bInheritHandle);
-	WINPR_UNUSED(lpName);
-	WLog_ERR(TAG, "%s not implemented", __FUNCTION__);
 	return NULL;
 }
 
diff -urN winpr/libwinpr/synch/semaphore.c ../../informatimago/FreeRDP/winpr/libwinpr/synch/semaphore.c
--- winpr/libwinpr/synch/semaphore.c	2019-07-25 19:51:09.657941036 +0300
+++ ../../informatimago/FreeRDP/winpr/libwinpr/synch/semaphore.c	2019-07-25 20:11:33.484010033 +0300
@@ -243,16 +243,11 @@
 		}
 
 #	else
-
-		while (lReleaseCount > 0)
-		{
 #		if defined __APPLE__
-			semaphore_signal(*((winpr_sem_t*)semaphore->sem));
+		semaphore_signal(*((winpr_sem_t*)semaphore->sem));
 #		else
-			sem_post((winpr_sem_t*)semaphore->sem);
+		sem_post((winpr_sem_t*)semaphore->sem);
 #		endif
-		}
-
 #	endif
 		return TRUE;
 	}
diff -urN winpr/libwinpr/synch/sleep.c ../../informatimago/FreeRDP/winpr/libwinpr/synch/sleep.c
--- winpr/libwinpr/synch/sleep.c	2019-07-25 19:51:09.657941036 +0300
+++ ../../informatimago/FreeRDP/winpr/libwinpr/synch/sleep.c	2019-07-25 20:11:33.488010052 +0300
@@ -25,10 +25,6 @@
 
 #include <winpr/synch.h>
 
-#include "../log.h"
-
-#define TAG WINPR_TAG("synch.sleep")
-
 #ifndef _WIN32
 
 #	include <time.h>
@@ -47,12 +43,8 @@
 
 DWORD SleepEx(DWORD dwMilliseconds, BOOL bAlertable)
 {
-	/* TODO: Implement bAlertable support */
-	if (bAlertable)
-		WLog_WARN(TAG, "%s does not support bAlertable", __FUNCTION__);
-
-	Sleep(dwMilliseconds);
-	return 0;
+	usleep(dwMilliseconds * 1000);
+	return TRUE;
 }
 
 #endif
diff -urN winpr/libwinpr/synch/synch.h ../../informatimago/FreeRDP/winpr/libwinpr/synch/synch.h
--- winpr/libwinpr/synch/synch.h	2019-07-25 19:51:09.661941056 +0300
+++ ../../informatimago/FreeRDP/winpr/libwinpr/synch/synch.h	2019-07-25 20:11:33.492010072 +0300
@@ -51,7 +51,7 @@
 struct winpr_mutex
 {
 	WINPR_HANDLE_DEF();
-	char* name;
+
 	pthread_mutex_t mutex;
 };
 typedef struct winpr_mutex WINPR_MUTEX;
@@ -68,7 +68,6 @@
 struct winpr_event
 {
 	WINPR_HANDLE_DEF();
-	char* name;
 
 	int pipe_fd[2];
 	BOOL bAttached;
@@ -97,7 +96,6 @@
 	BOOL bManualReset;
 	PTIMERAPCROUTINE pfnCompletionRoutine;
 	LPVOID lpArgToCompletionRoutine;
-	char* name;
 
 #	ifdef WITH_POSIX_TIMER
 	timer_t tid;
diff -urN winpr/libwinpr/synch/test/TestSynchBarrier.c ../../informatimago/FreeRDP/winpr/libwinpr/synch/test/TestSynchBarrier.c
--- winpr/libwinpr/synch/test/TestSynchBarrier.c	2019-07-25 19:51:09.669941096 +0300
+++ ../../informatimago/FreeRDP/winpr/libwinpr/synch/test/TestSynchBarrier.c	2019-07-25 20:11:33.500010112 +0300
@@ -148,13 +148,13 @@
 
 	DeleteSynchronizationBarrier(&gBarrier);
 
-	if (p.threadCount != (INT64)dwThreads)
+	if (p.threadCount != dwThreads)
 		InterlockedIncrement(&gErrorCount);
 
-	if (p.trueCount != (INT64)expectedTrueCount)
+	if (p.trueCount != expectedTrueCount)
 		InterlockedIncrement(&gErrorCount);
 
-	if (p.falseCount != (INT64)expectedFalseCount)
+	if (p.falseCount != expectedFalseCount)
 		InterlockedIncrement(&gErrorCount);
 
 	printf("%s: error count:  %" PRId32 "\n", __FUNCTION__, gErrorCount);
diff -urN winpr/libwinpr/synch/test/TestSynch.c ../../informatimago/FreeRDP/winpr/libwinpr/synch/test/TestSynch.c
--- winpr/libwinpr/synch/test/TestSynch.c	2019-07-25 20:17:16.349710295 +0300
+++ ../../informatimago/FreeRDP/winpr/libwinpr/synch/test/TestSynch.c	2019-07-25 20:11:33.496010092 +0300
@@ -4,11 +4,9 @@
 #include <string.h> /* NOLINT */
 
 #if defined(_MSC_VER)
-#pragma warning(disable : 4996) /* deprecation */
+#	pragma warning(disable : 4996) /* deprecation */
 #endif
 
-
-
 /* Forward declare test functions. */
 int TestSynchInit(int, char*[]);
 int TestSynchEvent(int, char*[]);
@@ -22,171 +20,151 @@
 int TestSynchWaitableTimer(int, char*[]);
 int TestSynchWaitableTimerAPC(int, char*[]);
 
-
 #ifdef __cplusplus
-#define CM_CAST(TYPE, EXPR) static_cast<TYPE>(EXPR)
+#	define CM_CAST(TYPE, EXPR) static_cast<TYPE>(EXPR)
 #else
-#define CM_CAST(TYPE, EXPR) (TYPE)(EXPR)
+#	define CM_CAST(TYPE, EXPR) (TYPE)(EXPR)
 #endif
 
 /* Create map.  */
 
-typedef int (*MainFuncPointer)(int, char* []); /* NOLINT */
-typedef struct /* NOLINT */
+typedef int (*MainFuncPointer)(int, char*[]); /* NOLINT */
+typedef struct                                /* NOLINT */
 {
-  const char* name;
-  MainFuncPointer func;
+	const char* name;
+	MainFuncPointer func;
 } functionMapEntry;
 
 static functionMapEntry cmakeGeneratedFunctionMapEntries[] = {
-    {
-    "TestSynchInit",
-    TestSynchInit
-  },
-  {
-    "TestSynchEvent",
-    TestSynchEvent
-  },
-  {
-    "TestSynchMutex",
-    TestSynchMutex
-  },
-  {
-    "TestSynchBarrier",
-    TestSynchBarrier
-  },
-  {
-    "TestSynchCritical",
-    TestSynchCritical
-  },
-  {
-    "TestSynchSemaphore",
-    TestSynchSemaphore
-  },
-  {
-    "TestSynchThread",
-    TestSynchThread
-  },
-  {
-    "TestSynchMultipleThreads",
-    TestSynchMultipleThreads
-  },
-  {
-    "TestSynchTimerQueue",
-    TestSynchTimerQueue
-  },
-  {
-    "TestSynchWaitableTimer",
-    TestSynchWaitableTimer
-  },
-  {
-    "TestSynchWaitableTimerAPC",
-    TestSynchWaitableTimerAPC
-  },
+	{ "TestSynchInit", TestSynchInit },
+	{ "TestSynchEvent", TestSynchEvent },
+	{ "TestSynchMutex", TestSynchMutex },
+	{ "TestSynchBarrier", TestSynchBarrier },
+	{ "TestSynchCritical", TestSynchCritical },
+	{ "TestSynchSemaphore", TestSynchSemaphore },
+	{ "TestSynchThread", TestSynchThread },
+	{ "TestSynchMultipleThreads", TestSynchMultipleThreads },
+	{ "TestSynchTimerQueue", TestSynchTimerQueue },
+	{ "TestSynchWaitableTimer", TestSynchWaitableTimer },
+	{ "TestSynchWaitableTimerAPC", TestSynchWaitableTimerAPC },
 
-  { NULL, NULL } /* NOLINT */
+	{ NULL, NULL } /* NOLINT */
 };
 
-static const int NumTests = CM_CAST(int,
-  sizeof(cmakeGeneratedFunctionMapEntries) / sizeof(functionMapEntry)) - 1;
+static const int NumTests =
+    CM_CAST(int, sizeof(cmakeGeneratedFunctionMapEntries) / sizeof(functionMapEntry)) - 1;
 
 /* Allocate and create a lowercased copy of string
    (note that it has to be free'd manually) */
 static char* lowercase(const char* string)
 {
-  char *new_string, *p;
-  size_t stringSize;
+	char *new_string, *p;
+	size_t stringSize;
 
-  stringSize = CM_CAST(size_t, strlen(string) + 1);
-  new_string = CM_CAST(char*, malloc(sizeof(char) * stringSize));
+	stringSize = CM_CAST(size_t, strlen(string) + 1);
+	new_string = CM_CAST(char*, malloc(sizeof(char) * stringSize));
 
-  if (new_string == NULL) { /* NOLINT */
-    return NULL;            /* NOLINT */
-  }
-  strcpy(new_string, string);
-  for (p = new_string; *p != 0; ++p) {
-    *p = CM_CAST(char, tolower(*p));
-  }
-  return new_string;
+	if (new_string == NULL)
+	{                /* NOLINT */
+		return NULL; /* NOLINT */
+	}
+	strcpy(new_string, string);
+	for (p = new_string; *p != 0; ++p)
+	{
+		*p = CM_CAST(char, tolower(*p));
+	}
+	return new_string;
 }
 
 int main(int ac, char* av[])
 {
-  int i, testNum = 0, partial_match;
-  char *arg;
-  int testToRun = -1;
-
-  
-
-  /* If no test name was given */
-  /* process command line with user function.  */
-  if (ac < 2) {
-    /* Ask for a test.  */
-    printf("Available tests:\n");
-    for (i = 0; i < NumTests; ++i) {
-      printf("%3d. %s\n", i, cmakeGeneratedFunctionMapEntries[i].name);
-    }
-    printf("To run a test, enter the test number: ");
-    fflush(stdout);
-    if (scanf("%d", &testNum) != 1) {
-      printf("Couldn't parse that input as a number\n");
-      return -1;
-    }
-    if (testNum >= NumTests) {
-      printf("%3d is an invalid test number.\n", testNum);
-      return -1;
-    }
-    testToRun = testNum;
-    ac--;
-    av++;
-  }
-  partial_match = 0;
-  arg = NULL; /* NOLINT */
-  /* If partial match is requested.  */
-  if (testToRun == -1 && ac > 1) {
-    partial_match = (strcmp(av[1], "-R") == 0) ? 1 : 0;
-  }
-  if (partial_match != 0 && ac < 3) {
-    printf("-R needs an additional parameter.\n");
-    return -1;
-  }
-  if (testToRun == -1) {
-    arg = lowercase(av[1 + partial_match]);
-  }
-  for (i = 0; i < NumTests && testToRun == -1; ++i) {
-    char *test_name = lowercase(cmakeGeneratedFunctionMapEntries[i].name);
-    if (partial_match != 0 && strstr(test_name, arg) != NULL) { /* NOLINT */
-      testToRun = i;
-      ac -= 2;
-      av += 2;
-    } else if (partial_match == 0 && strcmp(test_name, arg) == 0) {
-      testToRun = i;
-      ac--;
-      av++;
-    }
-    free(test_name);
-  }
-  free(arg);
-  if (testToRun != -1) {
-    int result;
-
-    if (testToRun < 0 || testToRun >= NumTests) {
-      printf("testToRun was modified by TestDriver code to an invalid value: "
-             "%3d.\n",
-             testNum);
-      return -1;
-    }
-    result = (*cmakeGeneratedFunctionMapEntries[testToRun].func)(ac, av);
-
-    return result;
-  }
-
-  /* Nothing was run, display the test names.  */
-  printf("Available tests:\n");
-  for (i = 0; i < NumTests; ++i) {
-    printf("%3d. %s\n", i, cmakeGeneratedFunctionMapEntries[i].name);
-  }
-  printf("Failed: %s is an invalid test name.\n", av[1]);
+	int i, testNum = 0, partial_match;
+	char* arg;
+	int testToRun = -1;
+
+	/* If no test name was given */
+	/* process command line with user function.  */
+	if (ac < 2)
+	{
+		/* Ask for a test.  */
+		printf("Available tests:\n");
+		for (i = 0; i < NumTests; ++i)
+		{
+			printf("%3d. %s\n", i, cmakeGeneratedFunctionMapEntries[i].name);
+		}
+		printf("To run a test, enter the test number: ");
+		fflush(stdout);
+		if (scanf("%d", &testNum) != 1)
+		{
+			printf("Couldn't parse that input as a number\n");
+			return -1;
+		}
+		if (testNum >= NumTests)
+		{
+			printf("%3d is an invalid test number.\n", testNum);
+			return -1;
+		}
+		testToRun = testNum;
+		ac--;
+		av++;
+	}
+	partial_match = 0;
+	arg = NULL; /* NOLINT */
+	/* If partial match is requested.  */
+	if (testToRun == -1 && ac > 1)
+	{
+		partial_match = (strcmp(av[1], "-R") == 0) ? 1 : 0;
+	}
+	if (partial_match != 0 && ac < 3)
+	{
+		printf("-R needs an additional parameter.\n");
+		return -1;
+	}
+	if (testToRun == -1)
+	{
+		arg = lowercase(av[1 + partial_match]);
+	}
+	for (i = 0; i < NumTests && testToRun == -1; ++i)
+	{
+		char* test_name = lowercase(cmakeGeneratedFunctionMapEntries[i].name);
+		if (partial_match != 0 && strstr(test_name, arg) != NULL)
+		{ /* NOLINT */
+			testToRun = i;
+			ac -= 2;
+			av += 2;
+		}
+		else if (partial_match == 0 && strcmp(test_name, arg) == 0)
+		{
+			testToRun = i;
+			ac--;
+			av++;
+		}
+		free(test_name);
+	}
+	free(arg);
+	if (testToRun != -1)
+	{
+		int result;
+
+		if (testToRun < 0 || testToRun >= NumTests)
+		{
+			printf("testToRun was modified by TestDriver code to an invalid value: "
+			       "%3d.\n",
+			       testNum);
+			return -1;
+		}
+		result = (*cmakeGeneratedFunctionMapEntries[testToRun].func)(ac, av);
+
+		return result;
+	}
+
+	/* Nothing was run, display the test names.  */
+	printf("Available tests:\n");
+	for (i = 0; i < NumTests; ++i)
+	{
+		printf("%3d. %s\n", i, cmakeGeneratedFunctionMapEntries[i].name);
+	}
+	printf("Failed: %s is an invalid test name.\n", av[1]);
 
-  return -1;
+	return -1;
 }
diff -urN winpr/libwinpr/synch/test/TestSynchMultipleThreads.c ../../informatimago/FreeRDP/winpr/libwinpr/synch/test/TestSynchMultipleThreads.c
--- winpr/libwinpr/synch/test/TestSynchMultipleThreads.c	2019-07-25 19:51:09.681941155 +0300
+++ ../../informatimago/FreeRDP/winpr/libwinpr/synch/test/TestSynchMultipleThreads.c	2019-07-25 20:11:33.512010172 +0300
@@ -83,7 +83,7 @@
 
 	ev = WaitForMultipleObjects(THREADS, threads, FALSE, INFINITE);
 
-	if (ev > (WAIT_OBJECT_0 + THREADS))
+	if ((ev < WAIT_OBJECT_0) || (ev > (WAIT_OBJECT_0 + THREADS)))
 	{
 		printf("WaitForMultipleObjects INFINITE failed\n");
 		rc = 6;
diff -urN winpr/libwinpr/synch/test/TestSynchMutex.c ../../informatimago/FreeRDP/winpr/libwinpr/synch/test/TestSynchMutex.c
--- winpr/libwinpr/synch/test/TestSynchMutex.c	2019-07-25 19:51:09.685941175 +0300
+++ ../../informatimago/FreeRDP/winpr/libwinpr/synch/test/TestSynchMutex.c	2019-07-25 20:11:33.516010191 +0300
@@ -239,19 +239,15 @@
 
 int TestSynchMutex(int argc, char* argv[])
 {
-	int rc = 0;
-	WINPR_UNUSED(argc);
-	WINPR_UNUSED(argv);
-
 	if (!test_mutex_basic())
-		rc += 1;
+		return 1;
 
 	if (!test_mutex_recursive())
-		rc += 2;
+		return 2;
 
 	if (!test_mutex_threading())
-		rc += 4;
+		return 3;
 
-	printf("TestSynchMutex result %d\n", rc);
-	return rc;
+	printf("TestSynchMutex succeeded\n");
+	return 0;
 }
diff -urN winpr/libwinpr/synch/test/TestSynchWaitableTimerAPC.c ../../informatimago/FreeRDP/winpr/libwinpr/synch/test/TestSynchWaitableTimerAPC.c
--- winpr/libwinpr/synch/test/TestSynchWaitableTimerAPC.c	2019-07-25 19:51:09.693941215 +0300
+++ ../../informatimago/FreeRDP/winpr/libwinpr/synch/test/TestSynchWaitableTimerAPC.c	2019-07-25 20:11:33.524010231 +0300
@@ -16,8 +16,6 @@
 {
 	APC_DATA* apcData;
 	UINT32 CurrentTime = GetTickCount();
-	WINPR_UNUSED(dwTimerLowValue);
-	WINPR_UNUSED(dwTimerHighValue);
 
 	if (!lpArg)
 		return;
@@ -38,9 +36,15 @@
 	HANDLE hTimer = NULL;
 	BOOL bSuccess;
 	LARGE_INTEGER due;
-	APC_DATA apcData = { 0 };
-	WINPR_UNUSED(argc);
-	WINPR_UNUSED(argv);
+	APC_DATA* apcData = NULL;
+	apcData = (APC_DATA*)malloc(sizeof(APC_DATA));
+
+	if (!apcData)
+	{
+		printf("Memory allocation failed\n");
+		goto cleanup;
+	}
+
 	g_Event = CreateEvent(NULL, TRUE, FALSE, NULL);
 
 	if (!g_Event)
@@ -55,8 +59,8 @@
 		goto cleanup;
 
 	due.QuadPart = -15000000LL; /* 1.5 seconds */
-	apcData.StartTime = GetTickCount();
-	bSuccess = SetWaitableTimer(hTimer, &due, 2000, TimerAPCProc, &apcData, FALSE);
+	apcData->StartTime = GetTickCount();
+	bSuccess = SetWaitableTimer(hTimer, &due, 2000, TimerAPCProc, apcData, FALSE);
 
 	if (!bSuccess)
 		goto cleanup;
@@ -103,5 +107,6 @@
 	if (g_Event)
 		CloseHandle(g_Event);
 
+	free(apcData);
 	return status;
 }
diff -urN winpr/libwinpr/synch/test/TestSynchWaitableTimer.c ../../informatimago/FreeRDP/winpr/libwinpr/synch/test/TestSynchWaitableTimer.c
--- winpr/libwinpr/synch/test/TestSynchWaitableTimer.c	2019-07-25 19:51:09.693941215 +0300
+++ ../../informatimago/FreeRDP/winpr/libwinpr/synch/test/TestSynchWaitableTimer.c	2019-07-25 20:11:33.520010211 +0300
@@ -9,8 +9,6 @@
 	LONG period;
 	LARGE_INTEGER due;
 	int result = -1;
-	WINPR_UNUSED(argc);
-	WINPR_UNUSED(argv);
 	timer = CreateWaitableTimer(NULL, FALSE, NULL);
 
 	if (!timer)
diff -urN winpr/libwinpr/synch/timer.c ../../informatimago/FreeRDP/winpr/libwinpr/synch/timer.c
--- winpr/libwinpr/synch/timer.c	2019-07-25 19:51:09.713941314 +0300
+++ ../../informatimago/FreeRDP/winpr/libwinpr/synch/timer.c	2019-07-25 20:11:33.544010330 +0300
@@ -144,7 +144,6 @@
 		close(timer->pipe[1]);
 
 #	endif
-	free(timer->name);
 	free(timer);
 	return TRUE;
 }
@@ -180,7 +179,6 @@
 static void WaitableTimerSignalHandler(int signum, siginfo_t* siginfo, void* arg)
 {
 	WINPR_TIMER* timer = siginfo->si_value.sival_ptr;
-	WINPR_UNUSED(arg);
 
 	if (!timer || (signum != SIGALRM))
 		return;
@@ -299,10 +297,6 @@
 {
 	HANDLE handle = NULL;
 	WINPR_TIMER* timer;
-
-	if (lpTimerAttributes)
-		WLog_WARN(TAG, "%s [%s] does not support lpTimerAttributes", __FUNCTION__, lpTimerName);
-
 	timer = (WINPR_TIMER*)calloc(1, sizeof(WINPR_TIMER));
 
 	if (timer)
@@ -315,10 +309,6 @@
 		timer->pfnCompletionRoutine = NULL;
 		timer->lpArgToCompletionRoutine = NULL;
 		timer->bInit = FALSE;
-
-		if (lpTimerName)
-			timer->name = strdup(lpTimerName);
-
 		timer->ops = &ops;
 #	if defined(__APPLE__)
 
@@ -372,12 +362,8 @@
 HANDLE CreateWaitableTimerExA(LPSECURITY_ATTRIBUTES lpTimerAttributes, LPCSTR lpTimerName,
                               DWORD dwFlags, DWORD dwDesiredAccess)
 {
-	BOOL bManualReset = (dwFlags & CREATE_WAITABLE_TIMER_MANUAL_RESET) ? TRUE : FALSE;
-
-	if (dwDesiredAccess != 0)
-		WLog_WARN(TAG, "%s [%s] does not support dwDesiredAccess 0x%08" PRIx32, __FUNCTION__,
-		          lpTimerName, dwDesiredAccess);
-
+	BOOL bManualReset;
+	bManualReset = (dwFlags & CREATE_WAITABLE_TIMER_MANUAL_RESET) ? TRUE : FALSE;
 	return CreateWaitableTimerA(lpTimerAttributes, bManualReset, lpTimerName);
 }
 
@@ -424,12 +410,6 @@
 	if (lPeriod < 0)
 		return FALSE;
 
-	if (fResume)
-	{
-		WLog_ERR(TAG, "%s does not support fResume", __FUNCTION__);
-		return FALSE;
-	}
-
 	timer = (WINPR_TIMER*)Object;
 	timer->lPeriod = lPeriod; /* milliseconds */
 	timer->pfnCompletionRoutine = pfnCompletionRoutine;
@@ -556,15 +536,11 @@
 
 HANDLE OpenWaitableTimerA(DWORD dwDesiredAccess, BOOL bInheritHandle, LPCSTR lpTimerName)
 {
-	/* TODO: Implement */
-	WLog_ERR(TAG, "%s not implemented", __FUNCTION__);
 	return NULL;
 }
 
 HANDLE OpenWaitableTimerW(DWORD dwDesiredAccess, BOOL bInheritHandle, LPCWSTR lpTimerName)
 {
-	/* TODO: Implement */
-	WLog_ERR(TAG, "%s not implemented", __FUNCTION__);
 	return NULL;
 }
 
diff -urN winpr/libwinpr/synch/wait.c ../../informatimago/FreeRDP/winpr/libwinpr/synch/wait.c
--- winpr/libwinpr/synch/wait.c	2019-07-25 19:51:09.729941393 +0300
+++ ../../informatimago/FreeRDP/winpr/libwinpr/synch/wait.c	2019-07-25 20:11:33.556010389 +0300
@@ -315,14 +315,9 @@
 
 DWORD WaitForSingleObjectEx(HANDLE hHandle, DWORD dwMilliseconds, BOOL bAlertable)
 {
-	if (bAlertable)
-	{
-		/* TODO: Implement */
-		WLog_ERR(TAG, "%s: Not implemented: bAlertable", __FUNCTION__);
-		return WAIT_FAILED;
-	}
-
-	return WaitForSingleObject(hHandle, dwMilliseconds);
+	WLog_ERR(TAG, "%s: Not implemented.", __FUNCTION__);
+	SetLastError(ERROR_NOT_SUPPORTED);
+	return WAIT_FAILED;
 }
 
 DWORD WaitForMultipleObjects(DWORD nCount, const HANDLE* lpHandles, BOOL bWaitAll,
@@ -561,13 +556,6 @@
 DWORD WaitForMultipleObjectsEx(DWORD nCount, const HANDLE* lpHandles, BOOL bWaitAll,
                                DWORD dwMilliseconds, BOOL bAlertable)
 {
-	if (bAlertable)
-	{
-		/* TODO: Implement */
-		WLog_ERR(TAG, "%s: Not implemented: bAlertable", __FUNCTION__);
-		return WAIT_FAILED;
-	}
-
 	return WaitForMultipleObjects(nCount, lpHandles, bWaitAll, dwMilliseconds);
 }
 
diff -urN winpr/libwinpr/sysinfo/CMakeLists.txt ../../informatimago/FreeRDP/winpr/libwinpr/sysinfo/CMakeLists.txt
--- winpr/libwinpr/sysinfo/CMakeLists.txt	2019-07-24 06:11:52.554197984 +0300
+++ ../../informatimago/FreeRDP/winpr/libwinpr/sysinfo/CMakeLists.txt	2019-07-19 20:00:17.513205377 +0300
@@ -22,7 +22,7 @@
 winpr_module_add(sysinfo.c)
 
 if((NOT WIN32) AND (NOT APPLE) AND (NOT ANDROID) AND (NOT OPENBSD))
-	winpr_library_add_private(rt)
+	winpr_library_add(rt)
 endif()
 
 if(BUILD_TESTING)
diff -urN winpr/libwinpr/sysinfo/test/TestSysInfo.c ../../informatimago/FreeRDP/winpr/libwinpr/sysinfo/test/TestSysInfo.c
--- winpr/libwinpr/sysinfo/test/TestSysInfo.c	2019-07-25 20:17:16.393710513 +0300
+++ ../../informatimago/FreeRDP/winpr/libwinpr/sysinfo/test/TestSysInfo.c	2019-07-25 20:11:33.696011083 +0300
@@ -4,11 +4,9 @@
 #include <string.h> /* NOLINT */
 
 #if defined(_MSC_VER)
-#pragma warning(disable : 4996) /* deprecation */
+#	pragma warning(disable : 4996) /* deprecation */
 #endif
 
-
-
 /* Forward declare test functions. */
 int TestGetNativeSystemInfo(int, char*[]);
 int TestCPUFeatures(int, char*[]);
@@ -16,147 +14,145 @@
 int TestSystemTime(int, char*[]);
 int TestLocalTime(int, char*[]);
 
-
 #ifdef __cplusplus
-#define CM_CAST(TYPE, EXPR) static_cast<TYPE>(EXPR)
+#	define CM_CAST(TYPE, EXPR) static_cast<TYPE>(EXPR)
 #else
-#define CM_CAST(TYPE, EXPR) (TYPE)(EXPR)
+#	define CM_CAST(TYPE, EXPR) (TYPE)(EXPR)
 #endif
 
 /* Create map.  */
 
-typedef int (*MainFuncPointer)(int, char* []); /* NOLINT */
-typedef struct /* NOLINT */
+typedef int (*MainFuncPointer)(int, char*[]); /* NOLINT */
+typedef struct                                /* NOLINT */
 {
-  const char* name;
-  MainFuncPointer func;
+	const char* name;
+	MainFuncPointer func;
 } functionMapEntry;
 
 static functionMapEntry cmakeGeneratedFunctionMapEntries[] = {
-    {
-    "TestGetNativeSystemInfo",
-    TestGetNativeSystemInfo
-  },
-  {
-    "TestCPUFeatures",
-    TestCPUFeatures
-  },
-  {
-    "TestGetComputerName",
-    TestGetComputerName
-  },
-  {
-    "TestSystemTime",
-    TestSystemTime
-  },
-  {
-    "TestLocalTime",
-    TestLocalTime
-  },
+	{ "TestGetNativeSystemInfo", TestGetNativeSystemInfo },
+	{ "TestCPUFeatures", TestCPUFeatures },
+	{ "TestGetComputerName", TestGetComputerName },
+	{ "TestSystemTime", TestSystemTime },
+	{ "TestLocalTime", TestLocalTime },
 
-  { NULL, NULL } /* NOLINT */
+	{ NULL, NULL } /* NOLINT */
 };
 
-static const int NumTests = CM_CAST(int,
-  sizeof(cmakeGeneratedFunctionMapEntries) / sizeof(functionMapEntry)) - 1;
+static const int NumTests =
+    CM_CAST(int, sizeof(cmakeGeneratedFunctionMapEntries) / sizeof(functionMapEntry)) - 1;
 
 /* Allocate and create a lowercased copy of string
    (note that it has to be free'd manually) */
 static char* lowercase(const char* string)
 {
-  char *new_string, *p;
-  size_t stringSize;
+	char *new_string, *p;
+	size_t stringSize;
 
-  stringSize = CM_CAST(size_t, strlen(string) + 1);
-  new_string = CM_CAST(char*, malloc(sizeof(char) * stringSize));
+	stringSize = CM_CAST(size_t, strlen(string) + 1);
+	new_string = CM_CAST(char*, malloc(sizeof(char) * stringSize));
 
-  if (new_string == NULL) { /* NOLINT */
-    return NULL;            /* NOLINT */
-  }
-  strcpy(new_string, string);
-  for (p = new_string; *p != 0; ++p) {
-    *p = CM_CAST(char, tolower(*p));
-  }
-  return new_string;
+	if (new_string == NULL)
+	{                /* NOLINT */
+		return NULL; /* NOLINT */
+	}
+	strcpy(new_string, string);
+	for (p = new_string; *p != 0; ++p)
+	{
+		*p = CM_CAST(char, tolower(*p));
+	}
+	return new_string;
 }
 
 int main(int ac, char* av[])
 {
-  int i, testNum = 0, partial_match;
-  char *arg;
-  int testToRun = -1;
-
-  
-
-  /* If no test name was given */
-  /* process command line with user function.  */
-  if (ac < 2) {
-    /* Ask for a test.  */
-    printf("Available tests:\n");
-    for (i = 0; i < NumTests; ++i) {
-      printf("%3d. %s\n", i, cmakeGeneratedFunctionMapEntries[i].name);
-    }
-    printf("To run a test, enter the test number: ");
-    fflush(stdout);
-    if (scanf("%d", &testNum) != 1) {
-      printf("Couldn't parse that input as a number\n");
-      return -1;
-    }
-    if (testNum >= NumTests) {
-      printf("%3d is an invalid test number.\n", testNum);
-      return -1;
-    }
-    testToRun = testNum;
-    ac--;
-    av++;
-  }
-  partial_match = 0;
-  arg = NULL; /* NOLINT */
-  /* If partial match is requested.  */
-  if (testToRun == -1 && ac > 1) {
-    partial_match = (strcmp(av[1], "-R") == 0) ? 1 : 0;
-  }
-  if (partial_match != 0 && ac < 3) {
-    printf("-R needs an additional parameter.\n");
-    return -1;
-  }
-  if (testToRun == -1) {
-    arg = lowercase(av[1 + partial_match]);
-  }
-  for (i = 0; i < NumTests && testToRun == -1; ++i) {
-    char *test_name = lowercase(cmakeGeneratedFunctionMapEntries[i].name);
-    if (partial_match != 0 && strstr(test_name, arg) != NULL) { /* NOLINT */
-      testToRun = i;
-      ac -= 2;
-      av += 2;
-    } else if (partial_match == 0 && strcmp(test_name, arg) == 0) {
-      testToRun = i;
-      ac--;
-      av++;
-    }
-    free(test_name);
-  }
-  free(arg);
-  if (testToRun != -1) {
-    int result;
-
-    if (testToRun < 0 || testToRun >= NumTests) {
-      printf("testToRun was modified by TestDriver code to an invalid value: "
-             "%3d.\n",
-             testNum);
-      return -1;
-    }
-    result = (*cmakeGeneratedFunctionMapEntries[testToRun].func)(ac, av);
-
-    return result;
-  }
-
-  /* Nothing was run, display the test names.  */
-  printf("Available tests:\n");
-  for (i = 0; i < NumTests; ++i) {
-    printf("%3d. %s\n", i, cmakeGeneratedFunctionMapEntries[i].name);
-  }
-  printf("Failed: %s is an invalid test name.\n", av[1]);
+	int i, testNum = 0, partial_match;
+	char* arg;
+	int testToRun = -1;
+
+	/* If no test name was given */
+	/* process command line with user function.  */
+	if (ac < 2)
+	{
+		/* Ask for a test.  */
+		printf("Available tests:\n");
+		for (i = 0; i < NumTests; ++i)
+		{
+			printf("%3d. %s\n", i, cmakeGeneratedFunctionMapEntries[i].name);
+		}
+		printf("To run a test, enter the test number: ");
+		fflush(stdout);
+		if (scanf("%d", &testNum) != 1)
+		{
+			printf("Couldn't parse that input as a number\n");
+			return -1;
+		}
+		if (testNum >= NumTests)
+		{
+			printf("%3d is an invalid test number.\n", testNum);
+			return -1;
+		}
+		testToRun = testNum;
+		ac--;
+		av++;
+	}
+	partial_match = 0;
+	arg = NULL; /* NOLINT */
+	/* If partial match is requested.  */
+	if (testToRun == -1 && ac > 1)
+	{
+		partial_match = (strcmp(av[1], "-R") == 0) ? 1 : 0;
+	}
+	if (partial_match != 0 && ac < 3)
+	{
+		printf("-R needs an additional parameter.\n");
+		return -1;
+	}
+	if (testToRun == -1)
+	{
+		arg = lowercase(av[1 + partial_match]);
+	}
+	for (i = 0; i < NumTests && testToRun == -1; ++i)
+	{
+		char* test_name = lowercase(cmakeGeneratedFunctionMapEntries[i].name);
+		if (partial_match != 0 && strstr(test_name, arg) != NULL)
+		{ /* NOLINT */
+			testToRun = i;
+			ac -= 2;
+			av += 2;
+		}
+		else if (partial_match == 0 && strcmp(test_name, arg) == 0)
+		{
+			testToRun = i;
+			ac--;
+			av++;
+		}
+		free(test_name);
+	}
+	free(arg);
+	if (testToRun != -1)
+	{
+		int result;
+
+		if (testToRun < 0 || testToRun >= NumTests)
+		{
+			printf("testToRun was modified by TestDriver code to an invalid value: "
+			       "%3d.\n",
+			       testNum);
+			return -1;
+		}
+		result = (*cmakeGeneratedFunctionMapEntries[testToRun].func)(ac, av);
+
+		return result;
+	}
+
+	/* Nothing was run, display the test names.  */
+	printf("Available tests:\n");
+	for (i = 0; i < NumTests; ++i)
+	{
+		printf("%3d. %s\n", i, cmakeGeneratedFunctionMapEntries[i].name);
+	}
+	printf("Failed: %s is an invalid test name.\n", av[1]);
 
-  return -1;
+	return -1;
 }
diff -urN winpr/libwinpr/thread/CMakeLists.txt ../../informatimago/FreeRDP/winpr/libwinpr/thread/CMakeLists.txt
--- winpr/libwinpr/thread/CMakeLists.txt	2019-07-24 06:11:52.554197984 +0300
+++ ../../informatimago/FreeRDP/winpr/libwinpr/thread/CMakeLists.txt	2019-07-19 20:00:17.513205377 +0300
@@ -24,7 +24,7 @@
 	tls.c)
 
 if(${CMAKE_SYSTEM_NAME} MATCHES SunOS)
-	winpr_library_add_private(rt)
+	winpr_library_add(rt)
 endif()
 
 if(BUILD_TESTING)
diff -urN winpr/libwinpr/thread/test/TestThread.c ../../informatimago/FreeRDP/winpr/libwinpr/thread/test/TestThread.c
--- winpr/libwinpr/thread/test/TestThread.c	2019-07-25 20:17:16.397710533 +0300
+++ ../../informatimago/FreeRDP/winpr/libwinpr/thread/test/TestThread.c	2019-07-25 20:11:33.720011203 +0300
@@ -4,149 +4,151 @@
 #include <string.h> /* NOLINT */
 
 #if defined(_MSC_VER)
-#pragma warning(disable : 4996) /* deprecation */
+#	pragma warning(disable : 4996) /* deprecation */
 #endif
 
-
-
 /* Forward declare test functions. */
 int TestThreadCommandLineToArgv(int, char*[]);
 int TestThreadCreateProcess(int, char*[]);
 int TestThreadExitThread(int, char*[]);
 
-
 #ifdef __cplusplus
-#define CM_CAST(TYPE, EXPR) static_cast<TYPE>(EXPR)
+#	define CM_CAST(TYPE, EXPR) static_cast<TYPE>(EXPR)
 #else
-#define CM_CAST(TYPE, EXPR) (TYPE)(EXPR)
+#	define CM_CAST(TYPE, EXPR) (TYPE)(EXPR)
 #endif
 
 /* Create map.  */
 
-typedef int (*MainFuncPointer)(int, char* []); /* NOLINT */
-typedef struct /* NOLINT */
+typedef int (*MainFuncPointer)(int, char*[]); /* NOLINT */
+typedef struct                                /* NOLINT */
 {
-  const char* name;
-  MainFuncPointer func;
+	const char* name;
+	MainFuncPointer func;
 } functionMapEntry;
 
 static functionMapEntry cmakeGeneratedFunctionMapEntries[] = {
-    {
-    "TestThreadCommandLineToArgv",
-    TestThreadCommandLineToArgv
-  },
-  {
-    "TestThreadCreateProcess",
-    TestThreadCreateProcess
-  },
-  {
-    "TestThreadExitThread",
-    TestThreadExitThread
-  },
+	{ "TestThreadCommandLineToArgv", TestThreadCommandLineToArgv },
+	{ "TestThreadCreateProcess", TestThreadCreateProcess },
+	{ "TestThreadExitThread", TestThreadExitThread },
 
-  { NULL, NULL } /* NOLINT */
+	{ NULL, NULL } /* NOLINT */
 };
 
-static const int NumTests = CM_CAST(int,
-  sizeof(cmakeGeneratedFunctionMapEntries) / sizeof(functionMapEntry)) - 1;
+static const int NumTests =
+    CM_CAST(int, sizeof(cmakeGeneratedFunctionMapEntries) / sizeof(functionMapEntry)) - 1;
 
 /* Allocate and create a lowercased copy of string
    (note that it has to be free'd manually) */
 static char* lowercase(const char* string)
 {
-  char *new_string, *p;
-  size_t stringSize;
+	char *new_string, *p;
+	size_t stringSize;
 
-  stringSize = CM_CAST(size_t, strlen(string) + 1);
-  new_string = CM_CAST(char*, malloc(sizeof(char) * stringSize));
+	stringSize = CM_CAST(size_t, strlen(string) + 1);
+	new_string = CM_CAST(char*, malloc(sizeof(char) * stringSize));
 
-  if (new_string == NULL) { /* NOLINT */
-    return NULL;            /* NOLINT */
-  }
-  strcpy(new_string, string);
-  for (p = new_string; *p != 0; ++p) {
-    *p = CM_CAST(char, tolower(*p));
-  }
-  return new_string;
+	if (new_string == NULL)
+	{                /* NOLINT */
+		return NULL; /* NOLINT */
+	}
+	strcpy(new_string, string);
+	for (p = new_string; *p != 0; ++p)
+	{
+		*p = CM_CAST(char, tolower(*p));
+	}
+	return new_string;
 }
 
 int main(int ac, char* av[])
 {
-  int i, testNum = 0, partial_match;
-  char *arg;
-  int testToRun = -1;
-
-  
-
-  /* If no test name was given */
-  /* process command line with user function.  */
-  if (ac < 2) {
-    /* Ask for a test.  */
-    printf("Available tests:\n");
-    for (i = 0; i < NumTests; ++i) {
-      printf("%3d. %s\n", i, cmakeGeneratedFunctionMapEntries[i].name);
-    }
-    printf("To run a test, enter the test number: ");
-    fflush(stdout);
-    if (scanf("%d", &testNum) != 1) {
-      printf("Couldn't parse that input as a number\n");
-      return -1;
-    }
-    if (testNum >= NumTests) {
-      printf("%3d is an invalid test number.\n", testNum);
-      return -1;
-    }
-    testToRun = testNum;
-    ac--;
-    av++;
-  }
-  partial_match = 0;
-  arg = NULL; /* NOLINT */
-  /* If partial match is requested.  */
-  if (testToRun == -1 && ac > 1) {
-    partial_match = (strcmp(av[1], "-R") == 0) ? 1 : 0;
-  }
-  if (partial_match != 0 && ac < 3) {
-    printf("-R needs an additional parameter.\n");
-    return -1;
-  }
-  if (testToRun == -1) {
-    arg = lowercase(av[1 + partial_match]);
-  }
-  for (i = 0; i < NumTests && testToRun == -1; ++i) {
-    char *test_name = lowercase(cmakeGeneratedFunctionMapEntries[i].name);
-    if (partial_match != 0 && strstr(test_name, arg) != NULL) { /* NOLINT */
-      testToRun = i;
-      ac -= 2;
-      av += 2;
-    } else if (partial_match == 0 && strcmp(test_name, arg) == 0) {
-      testToRun = i;
-      ac--;
-      av++;
-    }
-    free(test_name);
-  }
-  free(arg);
-  if (testToRun != -1) {
-    int result;
-
-    if (testToRun < 0 || testToRun >= NumTests) {
-      printf("testToRun was modified by TestDriver code to an invalid value: "
-             "%3d.\n",
-             testNum);
-      return -1;
-    }
-    result = (*cmakeGeneratedFunctionMapEntries[testToRun].func)(ac, av);
-
-    return result;
-  }
-
-  /* Nothing was run, display the test names.  */
-  printf("Available tests:\n");
-  for (i = 0; i < NumTests; ++i) {
-    printf("%3d. %s\n", i, cmakeGeneratedFunctionMapEntries[i].name);
-  }
-  printf("Failed: %s is an invalid test name.\n", av[1]);
+	int i, testNum = 0, partial_match;
+	char* arg;
+	int testToRun = -1;
+
+	/* If no test name was given */
+	/* process command line with user function.  */
+	if (ac < 2)
+	{
+		/* Ask for a test.  */
+		printf("Available tests:\n");
+		for (i = 0; i < NumTests; ++i)
+		{
+			printf("%3d. %s\n", i, cmakeGeneratedFunctionMapEntries[i].name);
+		}
+		printf("To run a test, enter the test number: ");
+		fflush(stdout);
+		if (scanf("%d", &testNum) != 1)
+		{
+			printf("Couldn't parse that input as a number\n");
+			return -1;
+		}
+		if (testNum >= NumTests)
+		{
+			printf("%3d is an invalid test number.\n", testNum);
+			return -1;
+		}
+		testToRun = testNum;
+		ac--;
+		av++;
+	}
+	partial_match = 0;
+	arg = NULL; /* NOLINT */
+	/* If partial match is requested.  */
+	if (testToRun == -1 && ac > 1)
+	{
+		partial_match = (strcmp(av[1], "-R") == 0) ? 1 : 0;
+	}
+	if (partial_match != 0 && ac < 3)
+	{
+		printf("-R needs an additional parameter.\n");
+		return -1;
+	}
+	if (testToRun == -1)
+	{
+		arg = lowercase(av[1 + partial_match]);
+	}
+	for (i = 0; i < NumTests && testToRun == -1; ++i)
+	{
+		char* test_name = lowercase(cmakeGeneratedFunctionMapEntries[i].name);
+		if (partial_match != 0 && strstr(test_name, arg) != NULL)
+		{ /* NOLINT */
+			testToRun = i;
+			ac -= 2;
+			av += 2;
+		}
+		else if (partial_match == 0 && strcmp(test_name, arg) == 0)
+		{
+			testToRun = i;
+			ac--;
+			av++;
+		}
+		free(test_name);
+	}
+	free(arg);
+	if (testToRun != -1)
+	{
+		int result;
+
+		if (testToRun < 0 || testToRun >= NumTests)
+		{
+			printf("testToRun was modified by TestDriver code to an invalid value: "
+			       "%3d.\n",
+			       testNum);
+			return -1;
+		}
+		result = (*cmakeGeneratedFunctionMapEntries[testToRun].func)(ac, av);
+
+		return result;
+	}
+
+	/* Nothing was run, display the test names.  */
+	printf("Available tests:\n");
+	for (i = 0; i < NumTests; ++i)
+	{
+		printf("%3d. %s\n", i, cmakeGeneratedFunctionMapEntries[i].name);
+	}
+	printf("Failed: %s is an invalid test name.\n", av[1]);
 
-  return -1;
+	return -1;
 }
diff -urN winpr/libwinpr/thread/thread.c ../../informatimago/FreeRDP/winpr/libwinpr/thread/thread.c
--- winpr/libwinpr/thread/thread.c	2019-07-25 19:51:09.905942265 +0300
+++ ../../informatimago/FreeRDP/winpr/libwinpr/thread/thread.c	2019-07-25 20:11:33.740011302 +0300
@@ -725,7 +725,7 @@
 	 * Note: on some operating systems sched_yield is a stub returning -1.
 	 * usleep should at least trigger a context switch if any thread is waiting.
 	 */
-	if (sched_yield() != 0)
+	if (!sched_yield())
 		usleep(1);
 
 	return TRUE;
diff -urN winpr/libwinpr/utils/CMakeLists.txt ../../informatimago/FreeRDP/winpr/libwinpr/utils/CMakeLists.txt
--- winpr/libwinpr/utils/CMakeLists.txt	2019-07-24 06:11:52.558198004 +0300
+++ ../../informatimago/FreeRDP/winpr/libwinpr/utils/CMakeLists.txt	2019-07-19 20:00:34.145156321 +0300
@@ -66,7 +66,7 @@
 	)
 
 	winpr_include_directory_add(${LIBSYSTEMD_INCLUDE_DIR})
-	winpr_library_add_private(${LIBSYSTEMD_LIBRARY})
+	winpr_library_add(${LIBSYSTEMD_LIBRARY})
 endif()
 
 set(${MODULE_PREFIX}_WLOG_SRCS
@@ -130,24 +130,24 @@
 
 if(OPENSSL_FOUND)
 	winpr_include_directory_add(${OPENSSL_INCLUDE_DIR})
-	winpr_library_add_private(${OPENSSL_LIBRARIES})
+	winpr_library_add(${OPENSSL_LIBRARIES})
 endif()
 
 if(MBEDTLS_FOUND)
 	winpr_include_directory_add(${MBEDTLS_INCLUDE_DIR})
-	winpr_library_add_private(${MBEDTLS_LIBRARIES})
+	winpr_library_add(${MBEDTLS_LIBRARIES})
 endif()
 
 if(UNIX)
-	winpr_library_add_private(m)
+	winpr_library_add(m)
 endif()
 
 if((FREEBSD) AND (NOT KFREEBSD))
-	winpr_library_add_private(execinfo)
+	winpr_library_add(execinfo)
 endif()
 
 if(WIN32)
-	winpr_library_add_public(dbghelp)
+	winpr_library_add(Dbghelp)
 endif()
 
 if(BUILD_TESTING)
diff -urN winpr/libwinpr/utils/cmdline.c ../../informatimago/FreeRDP/winpr/libwinpr/utils/cmdline.c
--- winpr/libwinpr/utils/cmdline.c	2019-07-25 19:51:10.617945796 +0300
+++ ../../informatimago/FreeRDP/winpr/libwinpr/utils/cmdline.c	2019-07-25 20:11:34.448014813 +0300
@@ -21,19 +21,46 @@
 #	include "config.h"
 #endif
 
+#include <winpr/wlog.h>
 #include <winpr/crt.h>
-
 #include <winpr/cmdline.h>
 
-#include "../log.h"
-
-#define TAG WINPR_TAG("commandline")
-
 /**
  * Command-line syntax: some basic concepts:
  * https://pythonconquerstheuniverse.wordpress.com/2010/07/25/command-line-syntax-some-basic-concepts/
  */
 
+#define TAG "winpr.utils.cmdline"
+
+/*
+find_option_by_name_or_alias
+return the index of the first entry in options that has keyword as Name or Alias,  or -1 if not
+found.
+*/
+static int find_option_by_name_or_alias(COMMAND_LINE_ARGUMENT_A* options, char* keyword,
+                                        SSIZE_T keyword_length)
+{
+	size_t index;
+
+	for (index = 0; options[index].Name != NULL; index++)
+	{
+		if ((strncmp(options[index].Name, keyword, keyword_length) == 0) &&
+		    (strlen(options[index].Name) == keyword_length))
+		{
+			return index;
+		}
+
+		if ((options[index].Alias != NULL) &&
+		    (strncmp(options[index].Alias, keyword, keyword_length) == 0) &&
+		    (strlen(options[index].Alias) == keyword_length))
+		{
+			return index;
+		}
+	}
+
+	return -1;
+}
+
 /**
  * Command-Line Syntax:
  *
@@ -49,12 +76,6 @@
  *
  */
 
-static void log_error(DWORD flags, LPCSTR message, int index, LPCSTR argv)
-{
-	if ((flags & COMMAND_LINE_SILENCE_PARSER) == 0)
-		WLog_ERR(TAG, message, index, argv);
-}
-
 int CommandLineParseArgumentsA(int argc, LPSTR* argv, COMMAND_LINE_ARGUMENT_A* options, DWORD flags,
                                void* context, COMMAND_LINE_PRE_FILTER_FN_A preFilter,
                                COMMAND_LINE_POST_FILTER_FN_A postFilter)
@@ -67,7 +88,7 @@
 	const char* sigil;
 	size_t sigil_length;
 	char* keyword;
-	size_t keyword_length;
+	SSIZE_T keyword_length;
 	SSIZE_T keyword_index;
 	char* separator;
 	char* value;
@@ -90,7 +111,6 @@
 
 	for (i = 1; i < argc; i++)
 	{
-		BOOL found = FALSE;
 		BOOL escaped = TRUE;
 
 		if (preFilter)
@@ -99,8 +119,7 @@
 
 			if (count < 0)
 			{
-				log_error(flags, "Failed for index %d [%s]: PreFilter rule could not be applied", i,
-				          argv[i]);
+				WLog_ERR(TAG, "Prefilter signaled an error.");
 				status = COMMAND_LINE_ERROR;
 				return status;
 			}
@@ -145,7 +164,7 @@
 		{
 			if (notescaped)
 			{
-				log_error(flags, "Failed at index %d [%s]: Unescaped sigil", i, argv[i]);
+				WLog_DBG(TAG, "Option sigil not escaped: %s", sigil);
 				return COMMAND_LINE_ERROR;
 			}
 
@@ -155,7 +174,8 @@
 		}
 		else
 		{
-			log_error(flags, "Failed at index %d [%s]: Invalid sigil", i, argv[i]);
+			/* Note: this case seems to be handled by the caller. */
+			WLog_DBG(TAG, "Invalid option syntax: %s", sigil);
 			return COMMAND_LINE_ERROR;
 		}
 
@@ -214,29 +234,17 @@
 			if (!escaped)
 				continue;
 
-			for (j = 0; options[j].Name != NULL; j++)
-			{
-				BOOL match = FALSE;
-
-				if (strncmp(options[j].Name, keyword, keyword_length) == 0)
-				{
-					if (strlen(options[j].Name) == keyword_length)
-						match = TRUE;
-				}
+			j = find_option_by_name_or_alias(options, keyword, keyword_length);
 
-				if ((!match) && (options[j].Alias != NULL))
+			if (j < 0)
+			{
+				if ((flags & COMMAND_LINE_IGN_UNKNOWN_KEYWORD) == 0)
 				{
-					if (strncmp(options[j].Alias, keyword, keyword_length) == 0)
-					{
-						if (strlen(options[j].Alias) == keyword_length)
-							match = TRUE;
-					}
+					return COMMAND_LINE_ERROR_NO_KEYWORD;
 				}
-
-				if (!match)
-					continue;
-
-				found = match;
+			}
+			else
+			{
 				options[j].Index = i;
 
 				if ((flags & COMMAND_LINE_SEPARATOR_SPACE) && ((i + 1) < argc))
@@ -279,7 +287,7 @@
 					}
 					else if (!value_present && argument)
 					{
-						log_error(flags, "Failed at index %d [%s]: Argument required", i, argv[i]);
+						WLog_ERR(TAG, "Missing mandatory value for option: %s", argv[i + 1]);
 						return COMMAND_LINE_ERROR;
 					}
 				}
@@ -287,10 +295,7 @@
 				if (!(flags & COMMAND_LINE_SEPARATOR_SPACE))
 				{
 					if (value && (options[j].Flags & COMMAND_LINE_VALUE_FLAG))
-					{
-						log_error(flags, "Failed at index %d [%s]: Unexpected value", i, argv[i]);
 						return COMMAND_LINE_ERROR_UNEXPECTED_VALUE;
-					}
 				}
 				else
 				{
@@ -303,7 +308,6 @@
 
 				if (!value && (options[j].Flags & COMMAND_LINE_VALUE_REQUIRED))
 				{
-					log_error(flags, "Failed at index %d [%s]: Missing value", i, argv[i]);
 					status = COMMAND_LINE_ERROR_MISSING_VALUE;
 					return status;
 				}
@@ -313,10 +317,7 @@
 				if (value)
 				{
 					if (options[j].Flags & (COMMAND_LINE_VALUE_FLAG | COMMAND_LINE_VALUE_BOOL))
-					{
-						log_error(flags, "Failed at index %d [%s]: Unexpected value", i, argv[i]);
 						return COMMAND_LINE_ERROR_UNEXPECTED_VALUE;
-					}
 
 					options[j].Value = value;
 					options[j].Flags |= COMMAND_LINE_VALUE_PRESENT;
@@ -332,18 +333,14 @@
 					{
 						if (flags & COMMAND_LINE_SIGIL_ENABLE_DISABLE)
 						{
-							if (toggle == -1)
-								options[j].Value = BoolValueTrue;
-							else if (!toggle)
+							if (toggle == 0)
 								options[j].Value = BoolValueFalse;
 							else
 								options[j].Value = BoolValueTrue;
 						}
 						else
 						{
-							if (sigil[0] == '+')
-								options[j].Value = BoolValueTrue;
-							else if (sigil[0] == '-')
+							if (sigil[0] == '-')
 								options[j].Value = BoolValueFalse;
 							else
 								options[j].Value = BoolValueTrue;
@@ -359,9 +356,8 @@
 
 					if (count < 0)
 					{
-						log_error(flags,
-						          "Failed at index %d [%s]: PostFilter rule could not be applied",
-						          i, argv[i]);
+						WLog_ERR(TAG, "Postfilter signaled an error for option %s",
+						         options[j].Name);
 						status = COMMAND_LINE_ERROR;
 						return status;
 					}
@@ -376,12 +372,6 @@
 				else if (options[j].Flags & COMMAND_LINE_PRINT_BUILDCONFIG)
 					return COMMAND_LINE_STATUS_PRINT_BUILDCONFIG;
 			}
-
-			if (!found && (flags & COMMAND_LINE_IGN_UNKNOWN_KEYWORD) == 0)
-			{
-				log_error(flags, "Failed at index %d [%s]: Unexpected keyword", i, argv[i]);
-				return COMMAND_LINE_ERROR_NO_KEYWORD;
-			}
 		}
 	}
 
diff -urN winpr/libwinpr/utils/collections/BipBuffer.c ../../informatimago/FreeRDP/winpr/libwinpr/utils/collections/BipBuffer.c
--- winpr/libwinpr/utils/collections/BipBuffer.c	2019-07-25 19:51:10.629945856 +0300
+++ ../../informatimago/FreeRDP/winpr/libwinpr/utils/collections/BipBuffer.c	2019-07-25 20:11:34.460014872 +0300
@@ -21,7 +21,6 @@
 #	include "config.h"
 #endif
 
-#include <limits.h>
 #include <winpr/crt.h>
 #include <winpr/sysinfo.h>
 
@@ -221,22 +220,16 @@
 	BipBlock_Clear(bb->writeR);
 }
 
-SSIZE_T BipBuffer_Write(wBipBuffer* bb, const BYTE* data, size_t size)
+int BipBuffer_Write(wBipBuffer* bb, BYTE* data, size_t size)
 {
-	size_t status = 0;
+	int status = 0;
 	BYTE* block = NULL;
 	size_t writeSize = 0;
 	size_t blockSize = 0;
 
-	if (size == 0)
-		return 0;
-
-	if (!bb || !data)
+	if (!bb)
 		return -1;
 
-	if (size > SSIZE_MAX)
-		size = SSIZE_MAX;
-
 	block = BipBuffer_WriteReserve(bb, size);
 
 	if (!block)
@@ -253,10 +246,10 @@
 
 		CopyMemory(block, &data[status], writeSize);
 		BipBuffer_WriteCommit(bb, writeSize);
-		status += writeSize;
+		status += (int)writeSize;
 
 		if ((status == size) || (writeSize < blockSize))
-			return (SSIZE_T)status;
+			return status;
 	}
 
 	block = BipBuffer_WriteTryReserve(bb, size - status, &blockSize);
@@ -270,13 +263,13 @@
 
 		CopyMemory(block, &data[status], writeSize);
 		BipBuffer_WriteCommit(bb, writeSize);
-		status += writeSize;
+		status += (int)writeSize;
 
 		if ((status == size) || (writeSize < blockSize))
-			return (SSIZE_T)status;
+			return status;
 	}
 
-	return (SSIZE_T)status;
+	return status;
 }
 
 BYTE* BipBuffer_ReadTryReserve(wBipBuffer* bb, size_t size, size_t* reserved)
@@ -342,22 +335,16 @@
 	}
 }
 
-SSIZE_T BipBuffer_Read(wBipBuffer* bb, BYTE* data, size_t size)
+int BipBuffer_Read(wBipBuffer* bb, BYTE* data, size_t size)
 {
-	size_t status = 0;
+	int status = 0;
 	BYTE* block = NULL;
 	size_t readSize = 0;
 	size_t blockSize = 0;
 
-	if (size == 0)
-		return 0;
-
-	if (!bb || !data)
+	if (!bb)
 		return -1;
 
-	if (size > SSIZE_MAX)
-		size = SSIZE_MAX;
-
 	block = BipBuffer_ReadTryReserve(bb, 0, &blockSize);
 
 	if (block)
@@ -369,10 +356,10 @@
 
 		CopyMemory(&data[status], block, readSize);
 		BipBuffer_ReadCommit(bb, readSize);
-		status += readSize;
+		status += (int)readSize;
 
 		if ((status == size) || (readSize < blockSize))
-			return (SSIZE_T)status;
+			return status;
 	}
 
 	block = BipBuffer_ReadTryReserve(bb, 0, &blockSize);
@@ -386,13 +373,13 @@
 
 		CopyMemory(&data[status], block, readSize);
 		BipBuffer_ReadCommit(bb, readSize);
-		status += readSize;
+		status += (int)readSize;
 
 		if ((status == size) || (readSize < blockSize))
-			return (SSIZE_T)status;
+			return status;
 	}
 
-	return (SSIZE_T)status;
+	return status;
 }
 
 /**
diff -urN winpr/libwinpr/utils/collections/HashTable.c ../../informatimago/FreeRDP/winpr/libwinpr/utils/collections/HashTable.c
--- winpr/libwinpr/utils/collections/HashTable.c	2019-07-25 19:51:10.653945975 +0300
+++ ../../informatimago/FreeRDP/winpr/libwinpr/utils/collections/HashTable.c	2019-07-25 20:11:34.484014991 +0300
@@ -459,7 +459,6 @@
 
 	iKey = 0;
 	count = table->numOfElements;
-	*ppKeys = NULL;
 
 	if (count < 1)
 	{
diff -urN winpr/libwinpr/utils/collections/ObjectPool.c ../../informatimago/FreeRDP/winpr/libwinpr/utils/collections/ObjectPool.c
--- winpr/libwinpr/utils/collections/ObjectPool.c	2019-07-25 19:51:10.669946054 +0300
+++ ../../informatimago/FreeRDP/winpr/libwinpr/utils/collections/ObjectPool.c	2019-07-25 20:11:34.500015070 +0300
@@ -74,13 +74,13 @@
 
 	if ((pool->size + 1) >= pool->capacity)
 	{
-		size_t new_cap;
+		int new_cap;
 		void** new_arr;
 		new_cap = pool->capacity * 2;
 		new_arr = (void**)realloc(pool->array, sizeof(void*) * new_cap);
 
 		if (!new_arr)
-			goto out;
+			return;
 
 		pool->array = new_arr;
 		pool->capacity = new_cap;
@@ -91,8 +91,6 @@
 	if (pool->object.fnObjectUninit)
 		pool->object.fnObjectUninit(obj);
 
-out:
-
 	if (pool->synchronized)
 		LeaveCriticalSection(&pool->lock);
 }
diff -urN winpr/libwinpr/utils/debug.c ../../informatimago/FreeRDP/winpr/libwinpr/utils/debug.c
--- winpr/libwinpr/utils/debug.c	2019-07-25 19:51:10.709946252 +0300
+++ ../../informatimago/FreeRDP/winpr/libwinpr/utils/debug.c	2019-07-25 20:11:34.540015269 +0300
@@ -36,8 +36,8 @@
 
 #if defined(_WIN32) || defined(_WIN64)
 #	include <io.h>
-#	include <windows.h>
-#	include <dbghelp.h>
+#	include <Windows.h>
+#	include <Dbghelp.h>
 #	define write _write
 #endif
 
diff -urN winpr/libwinpr/utils/ini.c ../../informatimago/FreeRDP/winpr/libwinpr/utils/ini.c
--- winpr/libwinpr/utils/ini.c	2019-07-25 19:51:10.729946351 +0300
+++ ../../informatimago/FreeRDP/winpr/libwinpr/utils/ini.c	2019-07-25 20:11:34.556015348 +0300
@@ -391,10 +391,6 @@
 		else
 		{
 			separator = strchr(line, '=');
-
-			if (separator == NULL)
-				return -1;
-
 			end = separator;
 
 			while ((&end[-1] > line) && ((end[-1] == ' ') || (end[-1] == '\t')))
diff -urN winpr/libwinpr/utils/lodepng/lodepng.c ../../informatimago/FreeRDP/winpr/libwinpr/utils/lodepng/lodepng.c
--- winpr/libwinpr/utils/lodepng/lodepng.c	2019-07-25 19:51:10.869947045 +0300
+++ ../../informatimago/FreeRDP/winpr/libwinpr/utils/lodepng/lodepng.c	2019-07-25 20:11:34.696016042 +0300
@@ -123,7 +123,6 @@
 
 		if (data)
 		{
-			memset(&((char*)data)[p->allocsize], 0, newsize - p->allocsize);
 			p->allocsize = newsize;
 			p->data = (unsigned*)data;
 		}
@@ -402,10 +401,7 @@
 
 	fclose(file);
 
-	if (size < 0)
-		return 91;
-
-	if (*outsize != (size_t)size)
+	if (*outsize != size)
 		return 91;
 
 	if (!(*out) && size)
@@ -1032,9 +1028,6 @@
 {
 	unsigned treepos = 0, ct;
 
-	if (!codetree || !codetree->tree2d)
-		return 0;
-
 	for (;;)
 	{
 		if (*bp >= inbitlength)
@@ -2064,9 +2057,6 @@
 			if (!uivector_resize(&lz77_encoded, datasize))
 				ERROR_BREAK(83 /*alloc fail*/);
 
-			if (!lz77_encoded.data)
-				ERROR_BREAK(83 /* alloc fail */);
-
 			for (i = datapos; i < dataend; i++)
 				lz77_encoded.data[i] = data[i]; /*no LZ77, but still will be Huffman compressed*/
 		}
@@ -2080,12 +2070,7 @@
 		/*Count the frequencies of lit, len and dist codes*/
 		for (i = 0; i < lz77_encoded.size; i++)
 		{
-			unsigned symbol;
-
-			if (!lz77_encoded.data)
-				ERROR_BREAK(83 /* alloc fail */);
-
-			symbol = lz77_encoded.data[i];
+			unsigned symbol = lz77_encoded.data[i];
 			frequencies_ll.data[symbol]++;
 
 			if (symbol > 256)
@@ -2399,7 +2384,7 @@
 	error = hash_init(&hash, settings->windowsize);
 
 	if (error)
-		goto fail;
+		return error;
 
 	for (i = 0; i < numdeflateblocks && !error; i++)
 	{
@@ -2416,7 +2401,6 @@
 			error = deflateDynamic(out, &bp, &hash, in, start, end, settings, final);
 	}
 
-fail:
 	hash_cleanup(&hash);
 	return error;
 }
@@ -2815,15 +2799,9 @@
 {
 	/*the current bit in bitstream may be 0 or 1 for this to work*/
 	if (bit == 0)
-	{
-		size_t pos = (*bitpointer) >> 3;
-		bitstream[pos] &= (unsigned char)(~(1 << (7 - ((*bitpointer) & 0x7))));
-	}
+		bitstream[(*bitpointer) >> 3] &= (unsigned char)(~(1 << (7 - ((*bitpointer) & 0x7))));
 	else
-	{
-		size_t pos = (*bitpointer) >> 3;
-		bitstream[pos] |= (1 << (7 - ((*bitpointer) & 0x7)));
-	}
+		bitstream[(*bitpointer) >> 3] |= (1 << (7 - ((*bitpointer) & 0x7)));
 
 	(*bitpointer)++;
 }
@@ -6443,7 +6421,7 @@
 		*outsize =
 		    h + (h * ((w * bpp + 7) /
 		              8)); /*image size plus an extra byte per scanline + possible padding bits*/
-		*out = (unsigned char*)calloc(*outsize, 1);
+		*out = (unsigned char*)malloc(*outsize);
 
 		if (!(*out) && (*outsize))
 			error = 83; /*alloc fail*/
@@ -6453,7 +6431,7 @@
 			/*non multiple of 8 bits per scanline, padding bits needed per scanline*/
 			if (bpp < 8 && w * bpp != ((w * bpp + 7) / 8) * 8)
 			{
-				unsigned char* padded = (unsigned char*)calloc(h * ((w * bpp + 7) / 8), 1);
+				unsigned char* padded = (unsigned char*)malloc(h * ((w * bpp + 7) / 8));
 
 				if (!padded)
 					error = 83; /*alloc fail*/
@@ -6481,7 +6459,7 @@
 		Adam7_getpassvalues(passw, passh, filter_passstart, padded_passstart, passstart, w, h, bpp);
 		*outsize = filter_passstart[7]; /*image size plus an extra byte per scanline + possible
 		                                   padding bits*/
-		*out = (unsigned char*)calloc(*outsize, 1);
+		*out = (unsigned char*)malloc(*outsize);
 
 		if (!(*out))
 			error = 83; /*alloc fail*/
@@ -6635,7 +6613,7 @@
 	{
 		unsigned char* converted;
 		size_t size = (w * h * lodepng_get_bpp(&info.color) + 7) / 8;
-		converted = (unsigned char*)calloc(size, 1);
+		converted = (unsigned char*)malloc(size);
 
 		if (!converted && size)
 			state->error = 83; /*alloc fail*/
@@ -6861,8 +6839,8 @@
 unsigned lodepng_encode_file(const char* filename, const unsigned char* image, unsigned w,
                              unsigned h, LodePNGColorType colortype, unsigned bitdepth)
 {
-	unsigned char* buffer = NULL;
-	size_t buffersize = 0;
+	unsigned char* buffer;
+	size_t buffersize;
 	unsigned error = lodepng_encode_memory(&buffer, &buffersize, image, w, h, colortype, bitdepth);
 
 	if (!error)
diff -urN winpr/libwinpr/utils/print.c ../../informatimago/FreeRDP/winpr/libwinpr/utils/print.c
--- winpr/libwinpr/utils/print.c	2019-07-25 19:51:10.897947184 +0300
+++ ../../informatimago/FreeRDP/winpr/libwinpr/utils/print.c	2019-07-25 20:11:34.720016161 +0300
@@ -33,93 +33,44 @@
 
 #include "../log.h"
 
-void winpr_HexDump(const char* tag, UINT32 level, const BYTE* data, size_t length)
-{
-	wLog* log = WLog_Get(tag);
-	winpr_HexLogDump(log, level, data, length);
-}
-
-void winpr_HexLogDump(wLog* log, UINT32 lvl, const BYTE* data, size_t length)
+void winpr_HexDump(const char* tag, UINT32 level, const BYTE* data, int length)
 {
 	const BYTE* p = data;
-	size_t i, line, offset = 0;
-	const int maxlen = 20; /* 64bit SIZE_MAX as decimal */
-	/* String line length:
-	 * prefix          '[1234] '
-	 * hexdump         '01 02 03 04'
-	 * separator       '   '
-	 * ASIC line       'ab..cd'
-	 * zero terminator '\0'
-	 */
-	const size_t blen =
-	    ((size_t)maxlen + 3) + (WINPR_HEXDUMP_LINE_LENGTH * 3) + 3 + WINPR_HEXDUMP_LINE_LENGTH + 1;
+	int i, line, offset = 0;
+	size_t blen = 7 + WINPR_HEXDUMP_LINE_LENGTH * 5;
 	size_t pos = 0;
-	char* buffer;
-
-	if (!log || (maxlen < 0))
-		return;
-
-	buffer = malloc(blen);
+	char* buffer = malloc(blen);
 
 	if (!buffer)
 	{
-		WLog_Print(log, WLOG_ERROR, "malloc(%" PRIuz ") failed with [%" PRIuz "] %s", blen, errno,
-		           strerror(errno));
+		WLog_ERR(tag, "malloc(%" PRIuz ") failed with [%d] %s", blen, errno, strerror(errno));
 		return;
 	}
 
 	while (offset < length)
 	{
-		int rc = trio_snprintf(&buffer[pos], blen - pos, "%04" PRIuz " ", offset);
-
-		if (rc < 0)
-			goto fail;
-
-		pos += (size_t)rc;
+		pos += trio_snprintf(&buffer[pos], blen - pos, "%04x ", offset);
 		line = length - offset;
 
 		if (line > WINPR_HEXDUMP_LINE_LENGTH)
 			line = WINPR_HEXDUMP_LINE_LENGTH;
 
 		for (i = 0; i < line; i++)
-		{
-			rc = trio_snprintf(&buffer[pos], blen - pos, "%02" PRIx8 " ", p[i]);
-
-			if (rc < 0)
-				goto fail;
-
-			pos += (size_t)rc;
-		}
+			pos += trio_snprintf(&buffer[pos], blen - pos, "%02" PRIx8 " ", p[i]);
 
 		for (; i < WINPR_HEXDUMP_LINE_LENGTH; i++)
-		{
-			rc = trio_snprintf(&buffer[pos], blen - pos, "   ");
-
-			if (rc < 0)
-				goto fail;
-
-			pos += (size_t)rc;
-		}
+			pos += trio_snprintf(&buffer[pos], blen - pos, "   ");
 
 		for (i = 0; i < line; i++)
-		{
-			rc = trio_snprintf(&buffer[pos], blen - pos, "%c",
-			                   (p[i] >= 0x20 && p[i] < 0x7F) ? (char)p[i] : '.');
-
-			if (rc < 0)
-				goto fail;
-
-			pos += (size_t)rc;
-		}
+			pos += trio_snprintf(&buffer[pos], blen - pos, "%c",
+			                     (p[i] >= 0x20 && p[i] < 0x7F) ? (char)p[i] : '.');
 
-		WLog_Print(log, lvl, "%s", buffer);
+		WLog_LVL(tag, level, "%s", buffer);
 		offset += line;
 		p += line;
 		pos = 0;
 	}
 
-	WLog_Print(log, lvl, "[length=%" PRIuz "] ", length);
-fail:
 	free(buffer);
 }
 
diff -urN winpr/libwinpr/utils/ssl.c ../../informatimago/FreeRDP/winpr/libwinpr/utils/ssl.c
--- winpr/libwinpr/utils/ssl.c	2019-07-25 19:51:10.913947263 +0300
+++ ../../informatimago/FreeRDP/winpr/libwinpr/utils/ssl.c	2019-07-25 20:11:34.736016240 +0300
@@ -234,33 +234,6 @@
 
 #	endif /* OpenSSL < 1.1.0 */
 
-static BOOL winpr_enable_fips(DWORD flags)
-{
-	if (flags & WINPR_SSL_INIT_ENABLE_FIPS)
-	{
-#	if (OPENSSL_VERSION_NUMBER < 0x10001000L) || defined(LIBRESSL_VERSION_NUMBER)
-		WLog_ERR(TAG, "Openssl fips mode not available on openssl versions less than 1.0.1!");
-		return FALSE;
-#	else
-		WLog_DBG(TAG, "Ensuring openssl fips mode is ENabled");
-
-		if (FIPS_mode() != 1)
-		{
-			if (FIPS_mode_set(1))
-				WLog_INFO(TAG, "Openssl fips mode ENabled!");
-			else
-			{
-				WLog_ERR(TAG, "Openssl fips mode ENable failed!");
-				return FALSE;
-			}
-		}
-
-#	endif
-	}
-
-	return TRUE;
-}
-
 static BOOL CALLBACK _winpr_openssl_initialize(PINIT_ONCE once, PVOID param, PVOID* context)
 {
 	DWORD flags = param ? *(PDWORD)param : WINPR_SSL_INIT_DEFAULT;
@@ -298,7 +271,27 @@
 
 #	endif
 	g_winpr_openssl_initialized_by_winpr = TRUE;
-	return winpr_enable_fips(flags);
+
+	if (flags & WINPR_SSL_INIT_ENABLE_FIPS)
+	{
+#	if (OPENSSL_VERSION_NUMBER < 0x10001000L) || defined(LIBRESSL_VERSION_NUMBER)
+		WLog_ERR(TAG,
+		         "Openssl fips mode ENable not available on openssl versions less than 1.0.1!");
+#	else
+		WLog_DBG(TAG, "Ensuring openssl fips mode is ENabled");
+
+		if (FIPS_mode() != 1)
+		{
+			if (FIPS_mode_set(1))
+				WLog_INFO(TAG, "Openssl fips mode ENabled!");
+			else
+				WLog_ERR(TAG, "Openssl fips mode ENable failed!");
+		}
+
+#	endif
+	}
+
+	return TRUE;
 }
 
 /* exported functions */
@@ -306,11 +299,7 @@
 BOOL winpr_InitializeSSL(DWORD flags)
 {
 	static INIT_ONCE once = INIT_ONCE_STATIC_INIT;
-
-	if (!InitOnceExecuteOnce(&once, _winpr_openssl_initialize, &flags, NULL))
-		return FALSE;
-
-	return winpr_enable_fips(flags);
+	return InitOnceExecuteOnce(&once, _winpr_openssl_initialize, &flags, NULL);
 }
 
 BOOL winpr_CleanupSSL(DWORD flags)
diff -urN winpr/libwinpr/utils/strlst.c ../../informatimago/FreeRDP/winpr/libwinpr/utils/strlst.c
--- winpr/libwinpr/utils/strlst.c	2019-07-25 19:51:10.917947284 +0300
+++ ../../informatimago/FreeRDP/winpr/libwinpr/utils/strlst.c	2019-07-25 20:11:34.744016280 +0300
@@ -20,6 +20,7 @@
 #	include "config.h"
 #endif
 
+#include <stdarg.h>
 #include <stdio.h>
 #include <stdlib.h>
 #include <string.h>
@@ -29,54 +30,300 @@
 
 void string_list_free(char** string_list)
 {
-	int i;
-
-	for (i = 0; string_list[i]; i++)
+	if (string_list != NULL)
 	{
-		free(string_list[i]);
-	}
+		int i;
+
+		for (i = 0; string_list[i]; i++)
+		{
+			free(string_list[i]);
+		}
 
-	free(string_list);
+		free(string_list);
+	}
 }
 
-int string_list_length(const char* const* string_list)
+int string_list_length(char** string_list)
 {
 	int i;
 
+	if (string_list == NULL)
+	{
+		return 0;
+	}
+
 	for (i = 0; string_list[i]; i++)
 		;
 
 	return i;
 }
 
-char** string_list_copy(const char* const* string_list)
+char** string_list_copy(char** string_list)
 {
 	int i;
 	int length = string_list_length(string_list);
-	char** copy = calloc(length + 1, sizeof(char*));
+	char** copy = malloc((length + 1) * sizeof(char*));
 
-	if (!copy)
+	if (copy == NULL)
 	{
-		return 0;
+		return NULL;
 	}
 
 	for (i = 0; i < length; i++)
 	{
 		copy[i] = _strdup(string_list[i]);
+
+		if (copy[i] == NULL)
+		{
+			string_list_free(copy);
+			return NULL;
+		}
 	}
 
-	copy[length] = 0;
+	copy[length] = NULL;
 	return copy;
 }
 
-void string_list_print(FILE* out, const char* const* string_list)
+void string_list_print(FILE* out, char** string_list)
 {
-	int j;
-
-	for (j = 0; string_list[j]; j++)
+	if (string_list == NULL)
+	{
+		fprintf(out, "NULL\n");
+	}
+	else
 	{
-		fprintf(out, "[%2d]: %s\n", j, string_list[j]);
+		int j;
+
+		for (j = 0; string_list[j]; j++)
+		{
+			fprintf(out, "[%2d]: %s\n", j, string_list[j]);
+		}
 	}
 
 	fflush(out);
 }
+
+char* string_list_join(char** string_list, const char* separator)
+{
+	char* result;
+	char* current;
+	size_t maximum_size;
+	size_t i;
+	size_t count = string_list_length(string_list);
+	size_t separator_length = strlen(separator);
+	size_t* string_lengths = malloc(sizeof(*string_lengths) * count);
+	size_t total_length = 0;
+
+	if (string_lengths == NULL)
+	{
+		return NULL;
+	}
+
+	for (i = 0; i < count; i++)
+	{
+		string_lengths[i] = strlen(string_list[i]);
+		total_length += string_lengths[i];
+	}
+
+	maximum_size = (((count == 0) ? 0 : (count - 1) * separator_length) + total_length + 1);
+	result = malloc(maximum_size);
+
+	if (result == NULL)
+	{
+		goto done;
+	}
+
+	strcpy(result, "");
+	current = result;
+
+	for (i = 0; i < count; i++)
+	{
+		strcpy(current, string_list[i]);
+		current += string_lengths[i];
+
+		if (i < count - 1)
+		{
+			strcpy(current, separator);
+			current += separator_length;
+		}
+	}
+
+done:
+	free(string_lengths);
+	return result;
+}
+
+char* string_concatenate(const char* string, ...)
+{
+	char* result;
+	char* current;
+	/* sum the lengths of the strings */
+	const char* arg = string;
+	int total_length = 0;
+	va_list strings;
+	va_start(strings, string);
+
+	while (arg)
+	{
+		total_length += strlen(arg);
+		arg = va_arg(strings, const char*);
+	}
+
+	va_end(strings);
+	total_length += 1; /*  null byte */
+
+	if (NULL == (result = malloc(total_length)))
+	{
+		return NULL;
+	}
+
+	/* start copying */
+	current = result;
+	strcpy(current, string);
+	current += strlen(string);
+	va_start(strings, string);
+	arg = va_arg(strings, const char*);
+
+	while (arg)
+	{
+		strcpy(current, arg);
+		current += strlen(arg);
+		arg = va_arg(strings, const char*);
+	}
+
+	va_end(strings);
+	/* strcpy copied the terminating null byte */
+	return result;
+}
+
+static int extract_separated_substrings(const char* string, const char* separator,
+                                        int remove_empty_substring, char** result)
+{
+	/*
+	PRECONDITION: (string != NULL) && (strlen(string) > 0) && (separator != NULL) &&
+	(strlen(separator) > 0)
+	*/
+	size_t seplen = strlen(separator);
+	int i = 0;
+	int done = 0;
+
+	do
+	{
+		char* next = strstr(string, separator);
+		size_t sublen = 0;
+		/*
+		 * When there are no remaining separator,
+		 * we still need to add the rest of the string
+		 * so we find the end-of-string
+		 */
+		done = (next == NULL);
+
+		if (done)
+		{
+			next = strchr(string, '\0');
+		}
+
+		sublen = next - string;
+
+		if (!remove_empty_substring || (sublen > 0))
+		{
+			if (result != NULL)
+			{
+				result[i] = strndup(string, sublen);
+			}
+
+			i++;
+		}
+
+		if (!done)
+		{
+			string = next + seplen;
+		}
+	} while (!done);
+
+	return i;
+}
+
+char** string_list_split_string(const char* string, const char* separator,
+                                int remove_empty_substring)
+{
+	char** result = NULL;
+	size_t seplen = ((separator == NULL) ? 0 : strlen(separator));
+	size_t count = 0;
+
+	if (string == NULL)
+	{
+		goto empty_result;
+	}
+
+	if (seplen == 0)
+	{
+		if (remove_empty_substring && (strlen(string) == 0))
+		{
+			goto empty_result;
+		}
+
+		result = calloc(2, sizeof(*result));
+
+		if (result == NULL)
+		{
+			return NULL;
+		}
+
+		result[0] = strdup(string);
+
+		if (result[0] == NULL)
+		{
+			free(result);
+			return NULL;
+		}
+
+		return result;
+	}
+
+	count = extract_separated_substrings(string, separator, remove_empty_substring, NULL);
+	result = calloc(count + 1, sizeof(*result));
+
+	if (result == NULL)
+	{
+		return NULL;
+	}
+
+	extract_separated_substrings(string, separator, remove_empty_substring, result);
+
+	if (count != string_list_length((char**)result))
+	{
+		/* at least one of the strdup couldn't allocate */
+		string_list_free(result);
+		return NULL;
+	}
+
+	return result;
+empty_result:
+	return calloc(1, sizeof(*result));
+}
+
+int string_list_mismatch(char** a, char** b)
+{
+	int i = 0;
+
+	while (a[i] && b[i])
+	{
+		if ((a[i] != b[i]) && (strcmp(a[i], b[i]) != 0))
+		{
+			return i;
+		}
+
+		i++;
+	}
+
+	return i;
+}
+
+BOOL string_list_equal(char** a, char** b)
+{
+	int result = string_list_mismatch(a, b);
+	return a[result] == b[result];
+}
+
+/**** THE END ****/
diff -urN winpr/libwinpr/utils/test/CMakeLists.txt ../../informatimago/FreeRDP/winpr/libwinpr/utils/test/CMakeLists.txt
--- winpr/libwinpr/utils/test/CMakeLists.txt	2019-07-24 06:11:52.562198023 +0300
+++ ../../informatimago/FreeRDP/winpr/libwinpr/utils/test/CMakeLists.txt	2019-07-19 20:00:34.149156310 +0300
@@ -17,6 +17,7 @@
 	TestBitStream.c
 	TestArrayList.c
 	TestLinkedList.c
+	TestStringList.c
 	TestListDictionary.c
 	TestCmdLine.c
 	TestWLog.c
diff -urN winpr/libwinpr/utils/test/TestArrayList.c ../../informatimago/FreeRDP/winpr/libwinpr/utils/test/TestArrayList.c
--- winpr/libwinpr/utils/test/TestArrayList.c	2019-07-25 19:51:10.921947304 +0300
+++ ../../informatimago/FreeRDP/winpr/libwinpr/utils/test/TestArrayList.c	2019-07-25 20:11:34.744016280 +0300
@@ -5,12 +5,11 @@
 
 int TestArrayList(int argc, char* argv[])
 {
-	size_t index;
+	int index;
 	int count;
-	int rc;
 	size_t val;
 	wArrayList* arrayList;
-	const size_t elemsToInsert = 10;
+	const int elemsToInsert = 10;
 	arrayList = ArrayList_New(TRUE);
 
 	if (!arrayList)
@@ -18,52 +17,49 @@
 
 	for (index = 0; index < elemsToInsert; index++)
 	{
-		if (ArrayList_Add(arrayList, (void*)index) < 0)
+		if (ArrayList_Add(arrayList, (void*)(size_t)index) < 0)
 			return -1;
 	}
 
 	count = ArrayList_Count(arrayList);
 	printf("ArrayList count: %d\n", count);
 	index = ArrayList_IndexOf(arrayList, (void*)(size_t)6, -1, -1);
-	printf("ArrayList index: %" PRIdz "\n", index);
+	printf("ArrayList index: %d\n", index);
 
 	if (index != 6)
 		return -1;
 
 	ArrayList_Insert(arrayList, 5, (void*)(size_t)100);
 	index = ArrayList_IndexOf(arrayList, (void*)(size_t)6, -1, -1);
-	printf("ArrayList index: %" PRIdz "\n", index);
+	printf("ArrayList index: %d\n", index);
 
 	if (index != 7)
 		return -1;
 
 	ArrayList_Remove(arrayList, (void*)(size_t)100);
-	rc = ArrayList_IndexOf(arrayList, (void*)(size_t)6, -1, -1);
-	printf("ArrayList index: %d\n", rc);
+	index = ArrayList_IndexOf(arrayList, (void*)(size_t)6, -1, -1);
+	printf("ArrayList index: %d\n", index);
 
-	if (rc != 6)
+	if (index != 6)
 		return -1;
 
 	for (index = 0; index < elemsToInsert; index++)
 	{
 		val = (size_t)ArrayList_GetItem(arrayList, 0);
-
-		if (!ArrayList_RemoveAt(arrayList, 0))
-			return -1;
+		ArrayList_RemoveAt(arrayList, 0);
 
 		if (val != index)
 		{
-			printf("ArrayList: shifted %" PRIdz " entries, expected value %" PRIdz ", got %" PRIdz
-			       "\n",
-			       index, index, val);
+			printf("ArrayList: shifted %d entries, expected value %d, got %" PRIdz "\n", index,
+			       index, val);
 			return -1;
 		}
 	}
 
-	rc = ArrayList_IndexOf(arrayList, (void*)(size_t)elemsToInsert, -1, -1);
-	printf("ArrayList index: %d\n", rc);
+	index = ArrayList_IndexOf(arrayList, (void*)(size_t)elemsToInsert, -1, -1);
+	printf("ArrayList index: %d\n", index);
 
-	if (rc != -1)
+	if (index != -1)
 		return -1;
 
 	count = ArrayList_Count(arrayList);
diff -urN winpr/libwinpr/utils/test/TestBufferPool.c ../../informatimago/FreeRDP/winpr/libwinpr/utils/test/TestBufferPool.c
--- winpr/libwinpr/utils/test/TestBufferPool.c	2019-07-25 19:51:10.929947343 +0300
+++ ../../informatimago/FreeRDP/winpr/libwinpr/utils/test/TestBufferPool.c	2019-07-25 20:11:34.752016319 +0300
@@ -9,7 +9,7 @@
 	int BufferSize;
 	wBufferPool* pool;
 	BYTE* Buffers[10];
-	int DefaultSize = 1234;
+	DWORD DefaultSize = 1234;
 	pool = BufferPool_New(TRUE, -1, 16);
 
 	if (!pool)
diff -urN winpr/libwinpr/utils/test/TestCmdLine.c ../../informatimago/FreeRDP/winpr/libwinpr/utils/test/TestCmdLine.c
--- winpr/libwinpr/utils/test/TestCmdLine.c	2019-07-25 19:51:10.957947482 +0300
+++ ../../informatimago/FreeRDP/winpr/libwinpr/utils/test/TestCmdLine.c	2019-07-25 20:11:34.780016459 +0300
@@ -69,8 +69,8 @@
 	int testArgc;
 	char** command_line;
 	flags = COMMAND_LINE_SIGIL_SLASH | COMMAND_LINE_SEPARATOR_COLON | COMMAND_LINE_SIGIL_PLUS_MINUS;
-	testArgc = string_list_length(testArgv);
-	command_line = string_list_copy(testArgv);
+	testArgc = string_list_length((char**)testArgv);
+	command_line = string_list_copy((char**)testArgv);
 
 	if (!command_line)
 	{
diff -urN winpr/libwinpr/utils/test/TestImage.c ../../informatimago/FreeRDP/winpr/libwinpr/utils/test/TestImage.c
--- winpr/libwinpr/utils/test/TestImage.c	2019-07-25 19:51:10.965947522 +0300
+++ ../../informatimago/FreeRDP/winpr/libwinpr/utils/test/TestImage.c	2019-07-25 20:11:34.784016478 +0300
@@ -30,19 +30,13 @@
 
 	src_size = _ftelli64(fsrc);
 
-	if (src_size < 0)
-	{
-		fprintf(stderr, "Invalid file position %" PRId64 "\n", src_size);
-		goto cleanup;
-	}
-
 	if (_fseeki64(fsrc, 0, SEEK_SET))
 	{
 		fprintf(stderr, "Failed to seek to SEEK_SET\n");
 		goto cleanup;
 	}
 
-	a = malloc((size_t)src_size);
+	a = malloc(src_size);
 
 	if (!a)
 	{
@@ -50,7 +44,7 @@
 		goto cleanup;
 	}
 
-	if (fread(a, sizeof(char), (size_t)src_size, fsrc) != (size_t)src_size)
+	if (fread(a, sizeof(char), src_size, fsrc) != src_size)
 	{
 		fprintf(stderr, "Failed read %" PRId64 " bytes\n", src_size);
 		goto cleanup;
diff -urN winpr/libwinpr/utils/test/TestIni.c ../../informatimago/FreeRDP/winpr/libwinpr/utils/test/TestIni.c
--- winpr/libwinpr/utils/test/TestIni.c	2019-07-25 19:51:10.965947522 +0300
+++ ../../informatimago/FreeRDP/winpr/libwinpr/utils/test/TestIni.c	2019-07-25 20:11:34.788016499 +0300
@@ -1,5 +1,6 @@
 
 #include <winpr/crt.h>
+
 #include <winpr/ini.h>
 
 const char TEST_INI_01[] = "; This is a sample .ini config file\n"
@@ -24,18 +25,6 @@
                            "sysconfdir=\"etc\"\n"
                            "\n";
 
-const char TEST_INI_03[] = "[FreeRDS]\n"
-                           "prefix=\"/usr/local\"\n"
-                           "bindir=\"bin\"\n"
-                           "# some illegal string\n"
-                           "sbindir=\"sbin\"\n"
-                           "libdir=\"lib\"\n"
-                           "invalid key-value pair\n"
-                           "datarootdir=\"share\"\n"
-                           "localstatedir=\"var\"\n"
-                           "sysconfdir=\"etc\"\n"
-                           "\n";
-
 int TestIni(int argc, char* argv[])
 {
 	int i, j;
@@ -128,15 +117,5 @@
 
 	free(sectionNames);
 	IniFile_Free(ini);
-	/* Third sample - invalid input */
-	ini = IniFile_New();
-
-	if (IniFile_ReadBuffer(ini, TEST_INI_03) != -1)
-	{
-		IniFile_Free(ini);
-		return -1;
-	}
-
-	IniFile_Free(ini);
 	return 0;
 }
diff -urN winpr/libwinpr/utils/test/TestStringList.c ../../informatimago/FreeRDP/winpr/libwinpr/utils/test/TestStringList.c
--- winpr/libwinpr/utils/test/TestStringList.c	1970-01-01 03:00:00.000000000 +0300
+++ ../../informatimago/FreeRDP/winpr/libwinpr/utils/test/TestStringList.c	2019-07-25 20:11:34.816016638 +0300
@@ -0,0 +1,134 @@
+#include <stdio.h>
+#include <string.h>
+
+#include <winpr/strlst.h>
+
+#define printref() printf("%s:%d: in function %-40s:", __FILE__, __LINE__, __FUNCTION__)
+
+#define ERROR(format, ...)                      \
+	do                                          \
+	{                                           \
+		fprintf(stderr, format, ##__VA_ARGS__); \
+		printref();                             \
+		printf(format "\n", ##__VA_ARGS__);     \
+		fflush(stdout);                         \
+	} while (0)
+
+#define FAILURE(format, ...)                \
+	do                                      \
+	{                                       \
+		printref();                         \
+		printf(" FAILURE ");                \
+		printf(format "\n", ##__VA_ARGS__); \
+		fflush(stdout);                     \
+	} while (0)
+
+#define TEST(condition, format, ...)                                \
+	if (!(condition))                                               \
+	{                                                               \
+		FAILURE("test %s " format "\n", #condition, ##__VA_ARGS__); \
+	}
+
+static void print_test_title(int argc, char** argv)
+{
+	int i;
+	printf("Running test:");
+
+	for (i = 0; i < argc; i++)
+	{
+		printf(" %s", argv[i]);
+	}
+
+	printf("\n");
+}
+
+static char* sl0[] = { NULL };
+static char* sl1[] = { "Niflheim", NULL };
+static char* sl40[] = { "Hello", "", "World", "!", NULL };
+static char* sl40n[] = { "Hello", "World", "!", NULL };
+static char* sl44[] = { "Good", "Bye", "Cruel", "World", NULL };
+static char* sl44e[] = { "Good", "Bye", "Cruel", "World!", NULL };
+static char* separator = "<space>";
+static char* sl40string = "Hello<space><space>World<space>!";
+static char* sl44string = "Good<space>Bye<space>Cruel<space>World";
+
+#define TEST_COPY(sl, length)                                                     \
+	do                                                                            \
+	{                                                                             \
+		copy = string_list_copy(sl);                                              \
+		TEST(copy != NULL, "string_list_copy(" #sl ") returned NULL");            \
+		TEST(string_list_length(copy) == length, "got %d instead of expected %d", \
+		     string_list_length(copy), length);                                   \
+		TEST(string_list_equal(copy, sl), "copy is not equal to original!");      \
+		if (!string_list_equal(copy, sl))                                         \
+		{                                                                         \
+			printf("original = \n");                                              \
+			string_list_print(stdout, sl);                                        \
+			printf("copy = \n");                                                  \
+			string_list_print(stdout, copy);                                      \
+		}                                                                         \
+		string_list_free(copy);                                                   \
+	} while (0)
+
+int TestStringList(int argc, char* argv[])
+{
+	char* string;
+	char** copy;
+	print_test_title(argc, argv);
+	TEST(string_list_length(sl0) == 0, "got %d instead", string_list_length(sl0));
+	TEST(string_list_length(sl1) == 1, "got %d instead", string_list_length(sl1));
+	TEST(string_list_length(sl40) == 4, "got %d instead", string_list_length(sl40));
+	TEST(string_list_length(sl44) == 4, "got %d instead", string_list_length(sl44));
+	TEST(string_list_equal(sl0, sl0), "sl0 should be equal to itself!");
+	TEST(string_list_equal(sl1, sl1), "sl1 should be equal to itself!");
+	TEST(string_list_equal(sl40, sl40), "sl40 should be equal to itself!")
+	TEST(string_list_equal(sl44, sl44), "sl44 should be equal to itself!");
+	TEST(string_list_mismatch(sl0, sl0) == string_list_length(sl0),
+	     "sl0 should mismatch itself at its length,  not at %d", string_list_mismatch(sl0, sl0));
+	TEST(string_list_mismatch(sl1, sl1) == string_list_length(sl1),
+	     "sl1 should mismatch itself at its length,  not at %d", string_list_mismatch(sl1, sl1));
+	TEST(string_list_mismatch(sl40, sl40) == string_list_length(sl40),
+	     "sl40 should mismatch itself at its length,  not at %d", string_list_mismatch(sl40, sl40));
+	TEST(string_list_mismatch(sl44, sl44) == string_list_length(sl44),
+	     "sl44 should mismatch itself at its length,  not at %d", string_list_mismatch(sl44, sl44));
+	TEST(string_list_mismatch(sl0, sl1) == 0, "sl0 and sl1 should mismatch at 0!");
+	TEST(string_list_mismatch(sl1, sl1) == 1, "sl1 mismatch at 1!");
+	TEST(string_list_mismatch(sl44, sl44e) == 3, "sl44 and sl44e should mismatch at 3!");
+	TEST(string_list_equal(sl40, sl40), "sl40 should be equal to itself!");
+	TEST(string_list_equal(sl44, sl44), "sl44 should be equal to itself!");
+	TEST_COPY(sl0, 0);
+	TEST_COPY(sl1, 1);
+	TEST_COPY(sl40, 4);
+	TEST_COPY(sl44, 4);
+	{
+		string = string_list_join(sl44, separator);
+		TEST(strcmp(string, sl44string) == 0,
+		     "string_list_join of sl44 should be \"%s\",  not \"%s\".", sl44string, string);
+		{
+			copy = string_list_split_string(string, separator, 0);
+			TEST(string_list_equal(copy, sl44), "splitting \"%s\" returns a mismatch at %d", string,
+			     string_list_mismatch(copy, sl44));
+			string_list_free(copy);
+		}
+		free(string);
+	}
+	{
+		string = string_list_join(sl40, separator);
+		TEST(strcmp(string, sl40string) == 0,
+		     "string_list_join of sl40 should be \"%s\",  not \"%s\".", sl40string, string);
+		{
+			copy = string_list_split_string(string, separator, 0);
+			TEST(string_list_equal(copy, sl40), "splitting \"%s\" returns a mismatch at %d", string,
+			     string_list_mismatch(copy, sl40));
+			string_list_free(copy);
+		}
+		{
+			copy = string_list_split_string(string, separator, 1);
+			TEST(!string_list_equal(copy, sl40n), "splitting \"%s\" returns a mismatch at %d",
+			     string, string_list_mismatch(copy, sl40n));
+			string_list_free(copy);
+		}
+		free(string);
+	}
+	return 0;
+}
diff -urN winpr/libwinpr/utils/test/TestVersion.c ../../informatimago/FreeRDP/winpr/libwinpr/utils/test/TestVersion.c
--- winpr/libwinpr/utils/test/TestVersion.c	2019-07-25 19:51:10.993947660 +0300
+++ ../../informatimago/FreeRDP/winpr/libwinpr/utils/test/TestVersion.c	2019-07-25 20:11:34.820016657 +0300
@@ -10,8 +10,6 @@
 	const char* git;
 	const char* build;
 	int major = 0, minor = 0, revision = 0;
-	WINPR_UNUSED(argc);
-	WINPR_UNUSED(argv);
 	winpr_get_version(&major, &minor, &revision);
 
 	if (major != WINPR_VERSION_MAJOR)
diff -urN winpr/libwinpr/utils/test/TestWinPRUtils.c ../../informatimago/FreeRDP/winpr/libwinpr/utils/test/TestWinPRUtils.c
--- winpr/libwinpr/utils/test/TestWinPRUtils.c	2019-07-25 20:17:16.385710473 +0300
+++ ../../informatimago/FreeRDP/winpr/libwinpr/utils/test/TestWinPRUtils.c	2019-07-25 20:11:34.828016696 +0300
@@ -4,11 +4,9 @@
 #include <string.h> /* NOLINT */
 
 #if defined(_MSC_VER)
-#pragma warning(disable : 4996) /* deprecation */
+#	pragma warning(disable : 4996) /* deprecation */
 #endif
 
-
-
 /* Forward declare test functions. */
 int TestIni(int, char*[]);
 int TestVersion(int, char*[]);
@@ -22,6 +20,7 @@
 int TestBitStream(int, char*[]);
 int TestArrayList(int, char*[]);
 int TestLinkedList(int, char*[]);
+int TestStringList(int, char*[]);
 int TestListDictionary(int, char*[]);
 int TestCmdLine(int, char*[]);
 int TestWLog(int, char*[]);
@@ -32,211 +31,162 @@
 int TestMessageQueue(int, char*[]);
 int TestMessagePipe(int, char*[]);
 
-
 #ifdef __cplusplus
-#define CM_CAST(TYPE, EXPR) static_cast<TYPE>(EXPR)
+#	define CM_CAST(TYPE, EXPR) static_cast<TYPE>(EXPR)
 #else
-#define CM_CAST(TYPE, EXPR) (TYPE)(EXPR)
+#	define CM_CAST(TYPE, EXPR) (TYPE)(EXPR)
 #endif
 
 /* Create map.  */
 
-typedef int (*MainFuncPointer)(int, char* []); /* NOLINT */
-typedef struct /* NOLINT */
+typedef int (*MainFuncPointer)(int, char*[]); /* NOLINT */
+typedef struct                                /* NOLINT */
 {
-  const char* name;
-  MainFuncPointer func;
+	const char* name;
+	MainFuncPointer func;
 } functionMapEntry;
 
 static functionMapEntry cmakeGeneratedFunctionMapEntries[] = {
-    {
-    "TestIni",
-    TestIni
-  },
-  {
-    "TestVersion",
-    TestVersion
-  },
-  {
-    "TestImage",
-    TestImage
-  },
-  {
-    "TestBipBuffer",
-    TestBipBuffer
-  },
-  {
-    "TestBacktrace",
-    TestBacktrace
-  },
-  {
-    "TestQueue",
-    TestQueue
-  },
-  {
-    "TestPrint",
-    TestPrint
-  },
-  {
-    "TestPubSub",
-    TestPubSub
-  },
-  {
-    "TestStream",
-    TestStream
-  },
-  {
-    "TestBitStream",
-    TestBitStream
-  },
-  {
-    "TestArrayList",
-    TestArrayList
-  },
-  {
-    "TestLinkedList",
-    TestLinkedList
-  },
-  {
-    "TestListDictionary",
-    TestListDictionary
-  },
-  {
-    "TestCmdLine",
-    TestCmdLine
-  },
-  {
-    "TestWLog",
-    TestWLog
-  },
-  {
-    "TestWLogCallback",
-    TestWLogCallback
-  },
-  {
-    "TestHashTable",
-    TestHashTable
-  },
-  {
-    "TestBufferPool",
-    TestBufferPool
-  },
-  {
-    "TestStreamPool",
-    TestStreamPool
-  },
-  {
-    "TestMessageQueue",
-    TestMessageQueue
-  },
-  {
-    "TestMessagePipe",
-    TestMessagePipe
-  },
+	{ "TestIni", TestIni },
+	{ "TestVersion", TestVersion },
+	{ "TestImage", TestImage },
+	{ "TestBipBuffer", TestBipBuffer },
+	{ "TestBacktrace", TestBacktrace },
+	{ "TestQueue", TestQueue },
+	{ "TestPrint", TestPrint },
+	{ "TestPubSub", TestPubSub },
+	{ "TestStream", TestStream },
+	{ "TestBitStream", TestBitStream },
+	{ "TestArrayList", TestArrayList },
+	{ "TestLinkedList", TestLinkedList },
+	{ "TestStringList", TestStringList },
+	{ "TestListDictionary", TestListDictionary },
+	{ "TestCmdLine", TestCmdLine },
+	{ "TestWLog", TestWLog },
+	{ "TestWLogCallback", TestWLogCallback },
+	{ "TestHashTable", TestHashTable },
+	{ "TestBufferPool", TestBufferPool },
+	{ "TestStreamPool", TestStreamPool },
+	{ "TestMessageQueue", TestMessageQueue },
+	{ "TestMessagePipe", TestMessagePipe },
 
-  { NULL, NULL } /* NOLINT */
+	{ NULL, NULL } /* NOLINT */
 };
 
-static const int NumTests = CM_CAST(int,
-  sizeof(cmakeGeneratedFunctionMapEntries) / sizeof(functionMapEntry)) - 1;
+static const int NumTests =
+    CM_CAST(int, sizeof(cmakeGeneratedFunctionMapEntries) / sizeof(functionMapEntry)) - 1;
 
 /* Allocate and create a lowercased copy of string
    (note that it has to be free'd manually) */
 static char* lowercase(const char* string)
 {
-  char *new_string, *p;
-  size_t stringSize;
+	char *new_string, *p;
+	size_t stringSize;
 
-  stringSize = CM_CAST(size_t, strlen(string) + 1);
-  new_string = CM_CAST(char*, malloc(sizeof(char) * stringSize));
+	stringSize = CM_CAST(size_t, strlen(string) + 1);
+	new_string = CM_CAST(char*, malloc(sizeof(char) * stringSize));
 
-  if (new_string == NULL) { /* NOLINT */
-    return NULL;            /* NOLINT */
-  }
-  strcpy(new_string, string);
-  for (p = new_string; *p != 0; ++p) {
-    *p = CM_CAST(char, tolower(*p));
-  }
-  return new_string;
+	if (new_string == NULL)
+	{                /* NOLINT */
+		return NULL; /* NOLINT */
+	}
+	strcpy(new_string, string);
+	for (p = new_string; *p != 0; ++p)
+	{
+		*p = CM_CAST(char, tolower(*p));
+	}
+	return new_string;
 }
 
 int main(int ac, char* av[])
 {
-  int i, testNum = 0, partial_match;
-  char *arg;
-  int testToRun = -1;
-
-  
-
-  /* If no test name was given */
-  /* process command line with user function.  */
-  if (ac < 2) {
-    /* Ask for a test.  */
-    printf("Available tests:\n");
-    for (i = 0; i < NumTests; ++i) {
-      printf("%3d. %s\n", i, cmakeGeneratedFunctionMapEntries[i].name);
-    }
-    printf("To run a test, enter the test number: ");
-    fflush(stdout);
-    if (scanf("%d", &testNum) != 1) {
-      printf("Couldn't parse that input as a number\n");
-      return -1;
-    }
-    if (testNum >= NumTests) {
-      printf("%3d is an invalid test number.\n", testNum);
-      return -1;
-    }
-    testToRun = testNum;
-    ac--;
-    av++;
-  }
-  partial_match = 0;
-  arg = NULL; /* NOLINT */
-  /* If partial match is requested.  */
-  if (testToRun == -1 && ac > 1) {
-    partial_match = (strcmp(av[1], "-R") == 0) ? 1 : 0;
-  }
-  if (partial_match != 0 && ac < 3) {
-    printf("-R needs an additional parameter.\n");
-    return -1;
-  }
-  if (testToRun == -1) {
-    arg = lowercase(av[1 + partial_match]);
-  }
-  for (i = 0; i < NumTests && testToRun == -1; ++i) {
-    char *test_name = lowercase(cmakeGeneratedFunctionMapEntries[i].name);
-    if (partial_match != 0 && strstr(test_name, arg) != NULL) { /* NOLINT */
-      testToRun = i;
-      ac -= 2;
-      av += 2;
-    } else if (partial_match == 0 && strcmp(test_name, arg) == 0) {
-      testToRun = i;
-      ac--;
-      av++;
-    }
-    free(test_name);
-  }
-  free(arg);
-  if (testToRun != -1) {
-    int result;
-
-    if (testToRun < 0 || testToRun >= NumTests) {
-      printf("testToRun was modified by TestDriver code to an invalid value: "
-             "%3d.\n",
-             testNum);
-      return -1;
-    }
-    result = (*cmakeGeneratedFunctionMapEntries[testToRun].func)(ac, av);
-
-    return result;
-  }
-
-  /* Nothing was run, display the test names.  */
-  printf("Available tests:\n");
-  for (i = 0; i < NumTests; ++i) {
-    printf("%3d. %s\n", i, cmakeGeneratedFunctionMapEntries[i].name);
-  }
-  printf("Failed: %s is an invalid test name.\n", av[1]);
+	int i, testNum = 0, partial_match;
+	char* arg;
+	int testToRun = -1;
+
+	/* If no test name was given */
+	/* process command line with user function.  */
+	if (ac < 2)
+	{
+		/* Ask for a test.  */
+		printf("Available tests:\n");
+		for (i = 0; i < NumTests; ++i)
+		{
+			printf("%3d. %s\n", i, cmakeGeneratedFunctionMapEntries[i].name);
+		}
+		printf("To run a test, enter the test number: ");
+		fflush(stdout);
+		if (scanf("%d", &testNum) != 1)
+		{
+			printf("Couldn't parse that input as a number\n");
+			return -1;
+		}
+		if (testNum >= NumTests)
+		{
+			printf("%3d is an invalid test number.\n", testNum);
+			return -1;
+		}
+		testToRun = testNum;
+		ac--;
+		av++;
+	}
+	partial_match = 0;
+	arg = NULL; /* NOLINT */
+	/* If partial match is requested.  */
+	if (testToRun == -1 && ac > 1)
+	{
+		partial_match = (strcmp(av[1], "-R") == 0) ? 1 : 0;
+	}
+	if (partial_match != 0 && ac < 3)
+	{
+		printf("-R needs an additional parameter.\n");
+		return -1;
+	}
+	if (testToRun == -1)
+	{
+		arg = lowercase(av[1 + partial_match]);
+	}
+	for (i = 0; i < NumTests && testToRun == -1; ++i)
+	{
+		char* test_name = lowercase(cmakeGeneratedFunctionMapEntries[i].name);
+		if (partial_match != 0 && strstr(test_name, arg) != NULL)
+		{ /* NOLINT */
+			testToRun = i;
+			ac -= 2;
+			av += 2;
+		}
+		else if (partial_match == 0 && strcmp(test_name, arg) == 0)
+		{
+			testToRun = i;
+			ac--;
+			av++;
+		}
+		free(test_name);
+	}
+	free(arg);
+	if (testToRun != -1)
+	{
+		int result;
+
+		if (testToRun < 0 || testToRun >= NumTests)
+		{
+			printf("testToRun was modified by TestDriver code to an invalid value: "
+			       "%3d.\n",
+			       testNum);
+			return -1;
+		}
+		result = (*cmakeGeneratedFunctionMapEntries[testToRun].func)(ac, av);
+
+		return result;
+	}
+
+	/* Nothing was run, display the test names.  */
+	printf("Available tests:\n");
+	for (i = 0; i < NumTests; ++i)
+	{
+		printf("%3d. %s\n", i, cmakeGeneratedFunctionMapEntries[i].name);
+	}
+	printf("Failed: %s is an invalid test name.\n", av[1]);
 
-  return -1;
+	return -1;
 }
diff -urN winpr/libwinpr/utils/trio/trio.c ../../informatimago/FreeRDP/winpr/libwinpr/utils/trio/trio.c
--- winpr/libwinpr/utils/trio/trio.c	2019-07-25 19:51:11.945952381 +0300
+++ ../../informatimago/FreeRDP/winpr/libwinpr/utils/trio/trio.c	2019-07-25 20:11:35.760021318 +0300
@@ -1418,8 +1418,6 @@
 	while (TrioIsQualifier(format[offset]))
 	{
 		ch = format[offset++];
-#pragma GCC diagnostic push
-#pragma GCC diagnostic ignored "-Wimplicit-fallthrough"
 
 		switch (ch)
 		{
@@ -1699,8 +1697,6 @@
 			/* Bail out completely to make the error more obvious */
 			return TRIO_ERROR_RETURN(TRIO_EINVAL, offset);
 		}
-
-#pragma GCC diagnostic pop
 	} /* while qualifier */
 
 	parameter->endOffset = offset;
@@ -1718,8 +1714,6 @@
                                                trio_parameter_t* parameter)
 {
 	parameter->baseSpecifier = NO_BASE;
-#pragma GCC diagnostic push
-#pragma GCC diagnostic ignored "-Wimplicit-fallthrough"
 
 	switch (format[offset++])
 	{
@@ -1970,7 +1964,6 @@
 		return TRIO_ERROR_RETURN(TRIO_EINVAL, offset);
 	}
 
-#pragma GCC diagnostic pop
 	parameter->endOffset = offset;
 	return 0;
 }
@@ -4998,7 +4991,7 @@
 /*************************************************************************
  * trio_get_argument [public]
  */
-trio_pointer_t trio_get_argument TRIO_ARGS1((ref), trio_pointer_t ref)
+TRIO_CONST trio_pointer_t trio_get_argument TRIO_ARGS1((ref), trio_pointer_t ref)
 {
 #	if TRIO_FEATURE_USER_DEFINED
 	assert(((trio_reference_t*)ref)->parameter->type == FORMAT_USER_DEFINED);
@@ -6273,9 +6266,6 @@
 		{
 			infinity = ((start == 1) && (doubleString[0] == '-')) ? trio_ninf() : trio_pinf();
 
-			if (!target)
-				return FALSE;
-
 			if (flags & FLAGS_LONGDOUBLE)
 			{
 				*((trio_long_double_t*)target) = infinity;
@@ -6294,9 +6284,6 @@
 
 		if (trio_equal(doubleString, NAN_UPPER))
 		{
-			if (!target)
-				return FALSE;
-
 			/* NaN must not have a preceeding + nor - */
 			if (flags & FLAGS_LONGDOUBLE)
 			{
@@ -6404,23 +6391,14 @@
 
 	if (flags & FLAGS_LONGDOUBLE)
 	{
-		if (!target)
-			return FALSE;
-
 		*((trio_long_double_t*)target) = trio_to_long_double(doubleString, NULL);
 	}
 	else if (flags & FLAGS_LONG)
 	{
-		if (!target)
-			return FALSE;
-
 		*((double*)target) = trio_to_double(doubleString, NULL);
 	}
 	else
 	{
-		if (!target)
-			return FALSE;
-
 		*((float*)target) = trio_to_float(doubleString, NULL);
 	}
 
diff -urN winpr/libwinpr/utils/trio/triop.h ../../informatimago/FreeRDP/winpr/libwinpr/utils/trio/triop.h
--- winpr/libwinpr/utils/trio/triop.h	2019-07-25 19:51:12.217953730 +0300
+++ ../../informatimago/FreeRDP/winpr/libwinpr/utils/trio/triop.h	2019-07-25 20:11:36.032022667 +0300
@@ -428,7 +428,7 @@
 	void trio_unregister TRIO_PROTO((trio_pointer_t handle));
 
 	TRIO_CONST char* trio_get_format TRIO_PROTO((trio_pointer_t ref));
-	trio_pointer_t trio_get_argument TRIO_PROTO((trio_pointer_t ref));
+	TRIO_CONST trio_pointer_t trio_get_argument TRIO_PROTO((trio_pointer_t ref));
 
 	/* Modifiers */
 	int trio_get_width TRIO_PROTO((trio_pointer_t ref));
diff -urN winpr/libwinpr/utils/wlog/JournaldAppender.c ../../informatimago/FreeRDP/winpr/libwinpr/utils/wlog/JournaldAppender.c
--- winpr/libwinpr/utils/wlog/JournaldAppender.c	2019-07-25 19:51:12.317954226 +0300
+++ ../../informatimago/FreeRDP/winpr/libwinpr/utils/wlog/JournaldAppender.c	2019-07-25 20:11:36.136023182 +0300
@@ -188,6 +188,7 @@
 	wLogJournaldAppender* appender;
 	DWORD nSize;
 	LPCSTR name = "WLOG_JOURNALD_ID";
+	;
 	appender = (wLogJournaldAppender*)calloc(1, sizeof(wLogJournaldAppender));
 
 	if (!appender)
diff -urN winpr/libwinpr/utils/wlog/wlog.c ../../informatimago/FreeRDP/winpr/libwinpr/utils/wlog/wlog.c
--- winpr/libwinpr/utils/wlog/wlog.c	2019-07-25 19:51:12.373954503 +0300
+++ ../../informatimago/FreeRDP/winpr/libwinpr/utils/wlog/wlog.c	2019-07-25 20:11:36.188023440 +0300
@@ -45,8 +45,6 @@
 };
 typedef struct _wLogFilter wLogFilter;
 
-#define WLOG_FILTER_NOT_FILTERED -1
-#define WLOG_FILTER_NOT_INITIALIZED -2
 /**
  * References for general logging concepts:
  *
@@ -334,7 +332,7 @@
 }
 
 BOOL WLog_PrintMessageVA(wLog* log, DWORD type, DWORD level, DWORD line, const char* file,
-                         const char* function, va_list args)
+                         const char* function, const void* format, va_list args)
 {
 	BOOL status = FALSE;
 	wLogMessage message = { 0 };
@@ -346,7 +344,7 @@
 	switch (type)
 	{
 	case WLOG_MESSAGE_TEXT:
-		message.FormatString = va_arg(args, const char*);
+		message.FormatString = format;
 
 		if (!strchr(message.FormatString, '%'))
 		{
@@ -396,47 +394,29 @@
 }
 
 BOOL WLog_PrintMessage(wLog* log, DWORD type, DWORD level, DWORD line, const char* file,
-                       const char* function, ...)
+                       const char* function, const void* format, ...)
 {
 	BOOL status;
 	va_list args;
-	va_start(args, function);
-	status = WLog_PrintMessageVA(log, type, level, line, file, function, args);
+	va_start(args, format);
+	status = WLog_PrintMessageVA(log, type, level, line, file, function, format, args);
 	va_end(args);
 	return status;
 }
 
 DWORD WLog_GetLogLevel(wLog* log)
 {
-	if (!log)
-		return WLOG_OFF;
-
-	if (log->FilterLevel <= WLOG_FILTER_NOT_INITIALIZED)
+	if (log->FilterLevel < 0)
 		log->FilterLevel = WLog_GetFilterLogLevel(log);
 
-	if (log->FilterLevel > WLOG_FILTER_NOT_FILTERED)
-		return (DWORD)log->FilterLevel;
+	if ((log->FilterLevel >= 0) && (log->FilterLevel != WLOG_LEVEL_INHERIT))
+		return log->FilterLevel;
 	else if (log->Level == WLOG_LEVEL_INHERIT)
 		log->Level = WLog_GetLogLevel(log->Parent);
 
 	return log->Level;
 }
 
-BOOL WLog_IsLevelActive(wLog* _log, DWORD _log_level)
-{
-	DWORD level;
-
-	if (!_log)
-		return FALSE;
-
-	level = WLog_GetLogLevel(_log);
-
-	if (level == WLOG_OFF)
-		return FALSE;
-
-	return _log_level >= level;
-}
-
 BOOL WLog_SetStringLogLevel(wLog* log, LPCSTR level)
 {
 	int lvl;
@@ -449,27 +429,7 @@
 	if (lvl < 0)
 		return FALSE;
 
-	return WLog_SetLogLevel(log, (DWORD)lvl);
-}
-
-static BOOL WLog_reset_log_filters(wLog* log)
-{
-	DWORD x;
-
-	if (!log)
-		return FALSE;
-
-	log->FilterLevel = WLOG_FILTER_NOT_INITIALIZED;
-
-	for (x = 0; x < log->ChildrenCount; x++)
-	{
-		wLog* child = log->Children[x];
-
-		if (!WLog_reset_log_filters(child))
-			return FALSE;
-	}
-
-	return TRUE;
+	return WLog_SetLogLevel(log, lvl);
 }
 
 BOOL WLog_AddStringLogFilters(LPCSTR filter)
@@ -537,35 +497,11 @@
 
 	g_FilterCount = size;
 	free(cp);
-	return WLog_reset_log_filters(WLog_GetRoot());
-}
-
-static BOOL WLog_UpdateInheritLevel(wLog* log, DWORD logLevel)
-{
-	if (!log)
-		return FALSE;
-
-	if (log->inherit)
-	{
-		DWORD x;
-		log->Level = logLevel;
-
-		for (x = 0; x < log->ChildrenCount; x++)
-		{
-			wLog* child = log->Children[x];
-
-			if (!WLog_UpdateInheritLevel(child, logLevel))
-				return FALSE;
-		}
-	}
-
 	return TRUE;
 }
 
 BOOL WLog_SetLogLevel(wLog* log, DWORD logLevel)
 {
-	DWORD x;
-
 	if (!log)
 		return FALSE;
 
@@ -573,17 +509,7 @@
 		logLevel = WLOG_OFF;
 
 	log->Level = logLevel;
-	log->inherit = (logLevel == WLOG_LEVEL_INHERIT) ? TRUE : FALSE;
-
-	for (x = 0; x < log->ChildrenCount; x++)
-	{
-		wLog* child = log->Children[x];
-
-		if (!WLog_UpdateInheritLevel(child, logLevel))
-			return FALSE;
-	}
-
-	return WLog_reset_log_filters(log);
+	return TRUE;
 }
 
 int WLog_ParseLogLevel(LPCSTR level)
@@ -697,7 +623,6 @@
 	BOOL res = FALSE;
 	char* env;
 	DWORD nSize;
-	free(g_Filters);
 	g_Filters = NULL;
 	g_FilterCount = 0;
 	nSize = GetEnvironmentVariableA(filter, NULL, 0);
@@ -755,7 +680,7 @@
 	if (match)
 		log->FilterLevel = g_Filters[i].Level;
 	else
-		log->FilterLevel = WLOG_FILTER_NOT_FILTERED;
+		log->FilterLevel = WLOG_LEVEL_INHERIT;
 
 	return log->FilterLevel;
 }
@@ -827,7 +752,7 @@
 	log->Parent = rootLogger;
 	log->ChildrenCount = 0;
 	log->ChildrenSize = 16;
-	log->FilterLevel = WLOG_FILTER_NOT_INITIALIZED;
+	log->FilterLevel = -1;
 
 	if (!(log->Children = (wLog**)calloc(log->ChildrenSize, sizeof(wLog*))))
 		goto out_fail;
@@ -837,7 +762,6 @@
 	if (rootLogger)
 	{
 		log->Level = WLOG_LEVEL_INHERIT;
-		log->inherit = TRUE;
 	}
 	else
 	{
@@ -863,20 +787,14 @@
 			free(env);
 
 			if (iLevel >= 0)
-			{
-				if (!WLog_SetLogLevel(log, (DWORD)iLevel))
-					goto out_fail;
-			}
+				log->Level = (DWORD)iLevel;
 		}
 	}
 
 	iLevel = WLog_GetFilterLogLevel(log);
 
-	if (iLevel >= 0)
-	{
-		if (!WLog_SetLogLevel(log, (DWORD)iLevel))
-			goto out_fail;
-	}
+	if ((iLevel >= 0) && (iLevel != WLOG_LEVEL_INHERIT))
+		log->Level = (DWORD)iLevel;
 
 	return log;
 out_fail:
diff -urN winpr/libwinpr/utils/wlog/wlog.h ../../informatimago/FreeRDP/winpr/libwinpr/utils/wlog/wlog.h
--- winpr/libwinpr/utils/wlog/wlog.h	2019-07-25 19:51:12.373954503 +0300
+++ ../../informatimago/FreeRDP/winpr/libwinpr/utils/wlog/wlog.h	2019-07-25 20:11:36.188023440 +0300
@@ -69,7 +69,6 @@
 	DWORD Level;
 
 	BOOL IsRoot;
-	BOOL inherit;
 	LPSTR* Names;
 	DWORD NameCount;
 	wLogAppender* Appender;
diff -urN winpr/libwinpr/winsock/CMakeLists.txt ../../informatimago/FreeRDP/winpr/libwinpr/winsock/CMakeLists.txt
--- winpr/libwinpr/winsock/CMakeLists.txt	2019-07-24 06:11:52.566198043 +0300
+++ ../../informatimago/FreeRDP/winpr/libwinpr/winsock/CMakeLists.txt	2019-07-19 20:00:17.525205340 +0300
@@ -18,5 +18,5 @@
 winpr_module_add(winsock.c)
 
 if(WIN32)
-	winpr_library_add_public(ws2_32)
+	winpr_library_add(ws2_32)
 endif()
diff -urN winpr/libwinpr/winsock/winsock.c ../../informatimago/FreeRDP/winpr/libwinpr/winsock/winsock.c
--- winpr/libwinpr/winsock/winsock.c	2019-07-25 19:51:12.397954623 +0300
+++ ../../informatimago/FreeRDP/winpr/libwinpr/winsock/winsock.c	2019-07-25 20:11:36.212023559 +0300
@@ -926,8 +926,7 @@
 	numInterfaces = 0;
 	ifreq = ifconf.ifc_req;
 
-	while ((ifconf.ifc_len >= 0) && (offset < (size_t)ifconf.ifc_len) &&
-	       (numInterfaces < maxNumInterfaces))
+	while ((offset < ifconf.ifc_len) && (numInterfaces < maxNumInterfaces))
 	{
 		pInterface = &pInterfaces[index];
 		pAddress = (struct sockaddr_in*)&pInterface->iiAddress;
diff -urN winpr/libwinpr/wnd/test/TestWnd.c ../../informatimago/FreeRDP/winpr/libwinpr/wnd/test/TestWnd.c
--- winpr/libwinpr/wnd/test/TestWnd.c	2019-07-25 20:17:16.413710612 +0300
+++ ../../informatimago/FreeRDP/winpr/libwinpr/wnd/test/TestWnd.c	2019-07-25 20:11:36.216023579 +0300
@@ -4,144 +4,149 @@
 #include <string.h> /* NOLINT */
 
 #if defined(_MSC_VER)
-#pragma warning(disable : 4996) /* deprecation */
+#	pragma warning(disable : 4996) /* deprecation */
 #endif
 
-
-
 /* Forward declare test functions. */
 int TestWndCreateWindowEx(int, char*[]);
 int TestWndWmCopyData(int, char*[]);
 
-
 #ifdef __cplusplus
-#define CM_CAST(TYPE, EXPR) static_cast<TYPE>(EXPR)
+#	define CM_CAST(TYPE, EXPR) static_cast<TYPE>(EXPR)
 #else
-#define CM_CAST(TYPE, EXPR) (TYPE)(EXPR)
+#	define CM_CAST(TYPE, EXPR) (TYPE)(EXPR)
 #endif
 
 /* Create map.  */
 
-typedef int (*MainFuncPointer)(int, char* []); /* NOLINT */
-typedef struct /* NOLINT */
+typedef int (*MainFuncPointer)(int, char*[]); /* NOLINT */
+typedef struct                                /* NOLINT */
 {
-  const char* name;
-  MainFuncPointer func;
+	const char* name;
+	MainFuncPointer func;
 } functionMapEntry;
 
 static functionMapEntry cmakeGeneratedFunctionMapEntries[] = {
-    {
-    "TestWndCreateWindowEx",
-    TestWndCreateWindowEx
-  },
-  {
-    "TestWndWmCopyData",
-    TestWndWmCopyData
-  },
+	{ "TestWndCreateWindowEx", TestWndCreateWindowEx },
+	{ "TestWndWmCopyData", TestWndWmCopyData },
 
-  { NULL, NULL } /* NOLINT */
+	{ NULL, NULL } /* NOLINT */
 };
 
-static const int NumTests = CM_CAST(int,
-  sizeof(cmakeGeneratedFunctionMapEntries) / sizeof(functionMapEntry)) - 1;
+static const int NumTests =
+    CM_CAST(int, sizeof(cmakeGeneratedFunctionMapEntries) / sizeof(functionMapEntry)) - 1;
 
 /* Allocate and create a lowercased copy of string
    (note that it has to be free'd manually) */
 static char* lowercase(const char* string)
 {
-  char *new_string, *p;
-  size_t stringSize;
+	char *new_string, *p;
+	size_t stringSize;
 
-  stringSize = CM_CAST(size_t, strlen(string) + 1);
-  new_string = CM_CAST(char*, malloc(sizeof(char) * stringSize));
+	stringSize = CM_CAST(size_t, strlen(string) + 1);
+	new_string = CM_CAST(char*, malloc(sizeof(char) * stringSize));
 
-  if (new_string == NULL) { /* NOLINT */
-    return NULL;            /* NOLINT */
-  }
-  strcpy(new_string, string);
-  for (p = new_string; *p != 0; ++p) {
-    *p = CM_CAST(char, tolower(*p));
-  }
-  return new_string;
+	if (new_string == NULL)
+	{                /* NOLINT */
+		return NULL; /* NOLINT */
+	}
+	strcpy(new_string, string);
+	for (p = new_string; *p != 0; ++p)
+	{
+		*p = CM_CAST(char, tolower(*p));
+	}
+	return new_string;
 }
 
 int main(int ac, char* av[])
 {
-  int i, testNum = 0, partial_match;
-  char *arg;
-  int testToRun = -1;
-
-  
-
-  /* If no test name was given */
-  /* process command line with user function.  */
-  if (ac < 2) {
-    /* Ask for a test.  */
-    printf("Available tests:\n");
-    for (i = 0; i < NumTests; ++i) {
-      printf("%3d. %s\n", i, cmakeGeneratedFunctionMapEntries[i].name);
-    }
-    printf("To run a test, enter the test number: ");
-    fflush(stdout);
-    if (scanf("%d", &testNum) != 1) {
-      printf("Couldn't parse that input as a number\n");
-      return -1;
-    }
-    if (testNum >= NumTests) {
-      printf("%3d is an invalid test number.\n", testNum);
-      return -1;
-    }
-    testToRun = testNum;
-    ac--;
-    av++;
-  }
-  partial_match = 0;
-  arg = NULL; /* NOLINT */
-  /* If partial match is requested.  */
-  if (testToRun == -1 && ac > 1) {
-    partial_match = (strcmp(av[1], "-R") == 0) ? 1 : 0;
-  }
-  if (partial_match != 0 && ac < 3) {
-    printf("-R needs an additional parameter.\n");
-    return -1;
-  }
-  if (testToRun == -1) {
-    arg = lowercase(av[1 + partial_match]);
-  }
-  for (i = 0; i < NumTests && testToRun == -1; ++i) {
-    char *test_name = lowercase(cmakeGeneratedFunctionMapEntries[i].name);
-    if (partial_match != 0 && strstr(test_name, arg) != NULL) { /* NOLINT */
-      testToRun = i;
-      ac -= 2;
-      av += 2;
-    } else if (partial_match == 0 && strcmp(test_name, arg) == 0) {
-      testToRun = i;
-      ac--;
-      av++;
-    }
-    free(test_name);
-  }
-  free(arg);
-  if (testToRun != -1) {
-    int result;
-
-    if (testToRun < 0 || testToRun >= NumTests) {
-      printf("testToRun was modified by TestDriver code to an invalid value: "
-             "%3d.\n",
-             testNum);
-      return -1;
-    }
-    result = (*cmakeGeneratedFunctionMapEntries[testToRun].func)(ac, av);
-
-    return result;
-  }
-
-  /* Nothing was run, display the test names.  */
-  printf("Available tests:\n");
-  for (i = 0; i < NumTests; ++i) {
-    printf("%3d. %s\n", i, cmakeGeneratedFunctionMapEntries[i].name);
-  }
-  printf("Failed: %s is an invalid test name.\n", av[1]);
+	int i, testNum = 0, partial_match;
+	char* arg;
+	int testToRun = -1;
+
+	/* If no test name was given */
+	/* process command line with user function.  */
+	if (ac < 2)
+	{
+		/* Ask for a test.  */
+		printf("Available tests:\n");
+		for (i = 0; i < NumTests; ++i)
+		{
+			printf("%3d. %s\n", i, cmakeGeneratedFunctionMapEntries[i].name);
+		}
+		printf("To run a test, enter the test number: ");
+		fflush(stdout);
+		if (scanf("%d", &testNum) != 1)
+		{
+			printf("Couldn't parse that input as a number\n");
+			return -1;
+		}
+		if (testNum >= NumTests)
+		{
+			printf("%3d is an invalid test number.\n", testNum);
+			return -1;
+		}
+		testToRun = testNum;
+		ac--;
+		av++;
+	}
+	partial_match = 0;
+	arg = NULL; /* NOLINT */
+	/* If partial match is requested.  */
+	if (testToRun == -1 && ac > 1)
+	{
+		partial_match = (strcmp(av[1], "-R") == 0) ? 1 : 0;
+	}
+	if (partial_match != 0 && ac < 3)
+	{
+		printf("-R needs an additional parameter.\n");
+		return -1;
+	}
+	if (testToRun == -1)
+	{
+		arg = lowercase(av[1 + partial_match]);
+	}
+	for (i = 0; i < NumTests && testToRun == -1; ++i)
+	{
+		char* test_name = lowercase(cmakeGeneratedFunctionMapEntries[i].name);
+		if (partial_match != 0 && strstr(test_name, arg) != NULL)
+		{ /* NOLINT */
+			testToRun = i;
+			ac -= 2;
+			av += 2;
+		}
+		else if (partial_match == 0 && strcmp(test_name, arg) == 0)
+		{
+			testToRun = i;
+			ac--;
+			av++;
+		}
+		free(test_name);
+	}
+	free(arg);
+	if (testToRun != -1)
+	{
+		int result;
+
+		if (testToRun < 0 || testToRun >= NumTests)
+		{
+			printf("testToRun was modified by TestDriver code to an invalid value: "
+			       "%3d.\n",
+			       testNum);
+			return -1;
+		}
+		result = (*cmakeGeneratedFunctionMapEntries[testToRun].func)(ac, av);
+
+		return result;
+	}
+
+	/* Nothing was run, display the test names.  */
+	printf("Available tests:\n");
+	for (i = 0; i < NumTests; ++i)
+	{
+		printf("%3d. %s\n", i, cmakeGeneratedFunctionMapEntries[i].name);
+	}
+	printf("Failed: %s is an invalid test name.\n", av[1]);
 
-  return -1;
+	return -1;
 }
diff -urN winpr/libwinpr/wtsapi/test/TestWtsApi.c ../../informatimago/FreeRDP/winpr/libwinpr/wtsapi/test/TestWtsApi.c
--- winpr/libwinpr/wtsapi/test/TestWtsApi.c	2019-07-25 20:17:16.409710592 +0300
+++ ../../informatimago/FreeRDP/winpr/libwinpr/wtsapi/test/TestWtsApi.c	2019-07-25 20:11:36.228023638 +0300
@@ -4,11 +4,9 @@
 #include <string.h> /* NOLINT */
 
 #if defined(_MSC_VER)
-#pragma warning(disable : 4996) /* deprecation */
+#	pragma warning(disable : 4996) /* deprecation */
 #endif
 
-
-
 /* Forward declare test functions. */
 int TestWtsApiEnumerateProcesses(int, char*[]);
 int TestWtsApiEnumerateSessions(int, char*[]);
@@ -17,151 +15,146 @@
 int TestWtsApiShutdownSystem(int, char*[]);
 int TestWtsApiWaitSystemEvent(int, char*[]);
 
-
 #ifdef __cplusplus
-#define CM_CAST(TYPE, EXPR) static_cast<TYPE>(EXPR)
+#	define CM_CAST(TYPE, EXPR) static_cast<TYPE>(EXPR)
 #else
-#define CM_CAST(TYPE, EXPR) (TYPE)(EXPR)
+#	define CM_CAST(TYPE, EXPR) (TYPE)(EXPR)
 #endif
 
 /* Create map.  */
 
-typedef int (*MainFuncPointer)(int, char* []); /* NOLINT */
-typedef struct /* NOLINT */
+typedef int (*MainFuncPointer)(int, char*[]); /* NOLINT */
+typedef struct                                /* NOLINT */
 {
-  const char* name;
-  MainFuncPointer func;
+	const char* name;
+	MainFuncPointer func;
 } functionMapEntry;
 
 static functionMapEntry cmakeGeneratedFunctionMapEntries[] = {
-    {
-    "TestWtsApiEnumerateProcesses",
-    TestWtsApiEnumerateProcesses
-  },
-  {
-    "TestWtsApiEnumerateSessions",
-    TestWtsApiEnumerateSessions
-  },
-  {
-    "TestWtsApiQuerySessionInformation",
-    TestWtsApiQuerySessionInformation
-  },
-  {
-    "TestWtsApiSessionNotification",
-    TestWtsApiSessionNotification
-  },
-  {
-    "TestWtsApiShutdownSystem",
-    TestWtsApiShutdownSystem
-  },
-  {
-    "TestWtsApiWaitSystemEvent",
-    TestWtsApiWaitSystemEvent
-  },
+	{ "TestWtsApiEnumerateProcesses", TestWtsApiEnumerateProcesses },
+	{ "TestWtsApiEnumerateSessions", TestWtsApiEnumerateSessions },
+	{ "TestWtsApiQuerySessionInformation", TestWtsApiQuerySessionInformation },
+	{ "TestWtsApiSessionNotification", TestWtsApiSessionNotification },
+	{ "TestWtsApiShutdownSystem", TestWtsApiShutdownSystem },
+	{ "TestWtsApiWaitSystemEvent", TestWtsApiWaitSystemEvent },
 
-  { NULL, NULL } /* NOLINT */
+	{ NULL, NULL } /* NOLINT */
 };
 
-static const int NumTests = CM_CAST(int,
-  sizeof(cmakeGeneratedFunctionMapEntries) / sizeof(functionMapEntry)) - 1;
+static const int NumTests =
+    CM_CAST(int, sizeof(cmakeGeneratedFunctionMapEntries) / sizeof(functionMapEntry)) - 1;
 
 /* Allocate and create a lowercased copy of string
    (note that it has to be free'd manually) */
 static char* lowercase(const char* string)
 {
-  char *new_string, *p;
-  size_t stringSize;
+	char *new_string, *p;
+	size_t stringSize;
 
-  stringSize = CM_CAST(size_t, strlen(string) + 1);
-  new_string = CM_CAST(char*, malloc(sizeof(char) * stringSize));
+	stringSize = CM_CAST(size_t, strlen(string) + 1);
+	new_string = CM_CAST(char*, malloc(sizeof(char) * stringSize));
 
-  if (new_string == NULL) { /* NOLINT */
-    return NULL;            /* NOLINT */
-  }
-  strcpy(new_string, string);
-  for (p = new_string; *p != 0; ++p) {
-    *p = CM_CAST(char, tolower(*p));
-  }
-  return new_string;
+	if (new_string == NULL)
+	{                /* NOLINT */
+		return NULL; /* NOLINT */
+	}
+	strcpy(new_string, string);
+	for (p = new_string; *p != 0; ++p)
+	{
+		*p = CM_CAST(char, tolower(*p));
+	}
+	return new_string;
 }
 
 int main(int ac, char* av[])
 {
-  int i, testNum = 0, partial_match;
-  char *arg;
-  int testToRun = -1;
-
-  
-
-  /* If no test name was given */
-  /* process command line with user function.  */
-  if (ac < 2) {
-    /* Ask for a test.  */
-    printf("Available tests:\n");
-    for (i = 0; i < NumTests; ++i) {
-      printf("%3d. %s\n", i, cmakeGeneratedFunctionMapEntries[i].name);
-    }
-    printf("To run a test, enter the test number: ");
-    fflush(stdout);
-    if (scanf("%d", &testNum) != 1) {
-      printf("Couldn't parse that input as a number\n");
-      return -1;
-    }
-    if (testNum >= NumTests) {
-      printf("%3d is an invalid test number.\n", testNum);
-      return -1;
-    }
-    testToRun = testNum;
-    ac--;
-    av++;
-  }
-  partial_match = 0;
-  arg = NULL; /* NOLINT */
-  /* If partial match is requested.  */
-  if (testToRun == -1 && ac > 1) {
-    partial_match = (strcmp(av[1], "-R") == 0) ? 1 : 0;
-  }
-  if (partial_match != 0 && ac < 3) {
-    printf("-R needs an additional parameter.\n");
-    return -1;
-  }
-  if (testToRun == -1) {
-    arg = lowercase(av[1 + partial_match]);
-  }
-  for (i = 0; i < NumTests && testToRun == -1; ++i) {
-    char *test_name = lowercase(cmakeGeneratedFunctionMapEntries[i].name);
-    if (partial_match != 0 && strstr(test_name, arg) != NULL) { /* NOLINT */
-      testToRun = i;
-      ac -= 2;
-      av += 2;
-    } else if (partial_match == 0 && strcmp(test_name, arg) == 0) {
-      testToRun = i;
-      ac--;
-      av++;
-    }
-    free(test_name);
-  }
-  free(arg);
-  if (testToRun != -1) {
-    int result;
-
-    if (testToRun < 0 || testToRun >= NumTests) {
-      printf("testToRun was modified by TestDriver code to an invalid value: "
-             "%3d.\n",
-             testNum);
-      return -1;
-    }
-    result = (*cmakeGeneratedFunctionMapEntries[testToRun].func)(ac, av);
-
-    return result;
-  }
-
-  /* Nothing was run, display the test names.  */
-  printf("Available tests:\n");
-  for (i = 0; i < NumTests; ++i) {
-    printf("%3d. %s\n", i, cmakeGeneratedFunctionMapEntries[i].name);
-  }
-  printf("Failed: %s is an invalid test name.\n", av[1]);
+	int i, testNum = 0, partial_match;
+	char* arg;
+	int testToRun = -1;
+
+	/* If no test name was given */
+	/* process command line with user function.  */
+	if (ac < 2)
+	{
+		/* Ask for a test.  */
+		printf("Available tests:\n");
+		for (i = 0; i < NumTests; ++i)
+		{
+			printf("%3d. %s\n", i, cmakeGeneratedFunctionMapEntries[i].name);
+		}
+		printf("To run a test, enter the test number: ");
+		fflush(stdout);
+		if (scanf("%d", &testNum) != 1)
+		{
+			printf("Couldn't parse that input as a number\n");
+			return -1;
+		}
+		if (testNum >= NumTests)
+		{
+			printf("%3d is an invalid test number.\n", testNum);
+			return -1;
+		}
+		testToRun = testNum;
+		ac--;
+		av++;
+	}
+	partial_match = 0;
+	arg = NULL; /* NOLINT */
+	/* If partial match is requested.  */
+	if (testToRun == -1 && ac > 1)
+	{
+		partial_match = (strcmp(av[1], "-R") == 0) ? 1 : 0;
+	}
+	if (partial_match != 0 && ac < 3)
+	{
+		printf("-R needs an additional parameter.\n");
+		return -1;
+	}
+	if (testToRun == -1)
+	{
+		arg = lowercase(av[1 + partial_match]);
+	}
+	for (i = 0; i < NumTests && testToRun == -1; ++i)
+	{
+		char* test_name = lowercase(cmakeGeneratedFunctionMapEntries[i].name);
+		if (partial_match != 0 && strstr(test_name, arg) != NULL)
+		{ /* NOLINT */
+			testToRun = i;
+			ac -= 2;
+			av += 2;
+		}
+		else if (partial_match == 0 && strcmp(test_name, arg) == 0)
+		{
+			testToRun = i;
+			ac--;
+			av++;
+		}
+		free(test_name);
+	}
+	free(arg);
+	if (testToRun != -1)
+	{
+		int result;
+
+		if (testToRun < 0 || testToRun >= NumTests)
+		{
+			printf("testToRun was modified by TestDriver code to an invalid value: "
+			       "%3d.\n",
+			       testNum);
+			return -1;
+		}
+		result = (*cmakeGeneratedFunctionMapEntries[testToRun].func)(ac, av);
+
+		return result;
+	}
+
+	/* Nothing was run, display the test names.  */
+	printf("Available tests:\n");
+	for (i = 0; i < NumTests; ++i)
+	{
+		printf("%3d. %s\n", i, cmakeGeneratedFunctionMapEntries[i].name);
+	}
+	printf("Failed: %s is an invalid test name.\n", av[1]);
 
-  return -1;
+	return -1;
 }
diff -urN winpr/libwinpr/wtsapi/wtsapi_win32.c ../../informatimago/FreeRDP/winpr/libwinpr/wtsapi/wtsapi_win32.c
--- winpr/libwinpr/wtsapi/wtsapi_win32.c	2019-07-25 19:51:12.457954920 +0300
+++ ../../informatimago/FreeRDP/winpr/libwinpr/wtsapi/wtsapi_win32.c	2019-07-25 20:11:36.272023856 +0300
@@ -400,7 +400,7 @@
 
 			CopyMemory(lpBuffer, pChannel->chunk, numBytesToRead);
 			*lpNumberOfBytesTransferred += numBytesToRead;
-			lpBuffer = (BYTE*)lpBuffer + numBytesToRead;
+			((BYTE*)lpBuffer) += numBytesToRead;
 			nNumberOfBytesToRead -= numBytesToRead;
 			pChannel->readOffset += numBytesToRead;
 			pChannel->readAsync = FALSE;
@@ -503,7 +503,7 @@
 
 				CopyMemory(lpBuffer, pChannel->header, numBytesRead);
 				*lpNumberOfBytesTransferred += numBytesRead;
-				lpBuffer = (BYTE*)lpBuffer + numBytesRead;
+				((BYTE*)lpBuffer) += numBytesRead;
 				nNumberOfBytesToRead -= numBytesRead;
 			}
 
diff -urN winpr/test/TestWinPR.c ../../informatimago/FreeRDP/winpr/test/TestWinPR.c
--- winpr/test/TestWinPR.c	2019-07-25 20:17:16.425710672 +0300
+++ ../../informatimago/FreeRDP/winpr/test/TestWinPR.c	2019-07-25 20:11:36.280023897 +0300
@@ -4,144 +4,149 @@
 #include <string.h> /* NOLINT */
 
 #if defined(_MSC_VER)
-#pragma warning(disable : 4996) /* deprecation */
+#	pragma warning(disable : 4996) /* deprecation */
 #endif
 
-
-
 /* Forward declare test functions. */
 int TestIntrinsics(int, char*[]);
 int TestTypes(int, char*[]);
 
-
 #ifdef __cplusplus
-#define CM_CAST(TYPE, EXPR) static_cast<TYPE>(EXPR)
+#	define CM_CAST(TYPE, EXPR) static_cast<TYPE>(EXPR)
 #else
-#define CM_CAST(TYPE, EXPR) (TYPE)(EXPR)
+#	define CM_CAST(TYPE, EXPR) (TYPE)(EXPR)
 #endif
 
 /* Create map.  */
 
-typedef int (*MainFuncPointer)(int, char* []); /* NOLINT */
-typedef struct /* NOLINT */
+typedef int (*MainFuncPointer)(int, char*[]); /* NOLINT */
+typedef struct                                /* NOLINT */
 {
-  const char* name;
-  MainFuncPointer func;
+	const char* name;
+	MainFuncPointer func;
 } functionMapEntry;
 
 static functionMapEntry cmakeGeneratedFunctionMapEntries[] = {
-    {
-    "TestIntrinsics",
-    TestIntrinsics
-  },
-  {
-    "TestTypes",
-    TestTypes
-  },
+	{ "TestIntrinsics", TestIntrinsics },
+	{ "TestTypes", TestTypes },
 
-  { NULL, NULL } /* NOLINT */
+	{ NULL, NULL } /* NOLINT */
 };
 
-static const int NumTests = CM_CAST(int,
-  sizeof(cmakeGeneratedFunctionMapEntries) / sizeof(functionMapEntry)) - 1;
+static const int NumTests =
+    CM_CAST(int, sizeof(cmakeGeneratedFunctionMapEntries) / sizeof(functionMapEntry)) - 1;
 
 /* Allocate and create a lowercased copy of string
    (note that it has to be free'd manually) */
 static char* lowercase(const char* string)
 {
-  char *new_string, *p;
-  size_t stringSize;
+	char *new_string, *p;
+	size_t stringSize;
 
-  stringSize = CM_CAST(size_t, strlen(string) + 1);
-  new_string = CM_CAST(char*, malloc(sizeof(char) * stringSize));
+	stringSize = CM_CAST(size_t, strlen(string) + 1);
+	new_string = CM_CAST(char*, malloc(sizeof(char) * stringSize));
 
-  if (new_string == NULL) { /* NOLINT */
-    return NULL;            /* NOLINT */
-  }
-  strcpy(new_string, string);
-  for (p = new_string; *p != 0; ++p) {
-    *p = CM_CAST(char, tolower(*p));
-  }
-  return new_string;
+	if (new_string == NULL)
+	{                /* NOLINT */
+		return NULL; /* NOLINT */
+	}
+	strcpy(new_string, string);
+	for (p = new_string; *p != 0; ++p)
+	{
+		*p = CM_CAST(char, tolower(*p));
+	}
+	return new_string;
 }
 
 int main(int ac, char* av[])
 {
-  int i, testNum = 0, partial_match;
-  char *arg;
-  int testToRun = -1;
-
-  
-
-  /* If no test name was given */
-  /* process command line with user function.  */
-  if (ac < 2) {
-    /* Ask for a test.  */
-    printf("Available tests:\n");
-    for (i = 0; i < NumTests; ++i) {
-      printf("%3d. %s\n", i, cmakeGeneratedFunctionMapEntries[i].name);
-    }
-    printf("To run a test, enter the test number: ");
-    fflush(stdout);
-    if (scanf("%d", &testNum) != 1) {
-      printf("Couldn't parse that input as a number\n");
-      return -1;
-    }
-    if (testNum >= NumTests) {
-      printf("%3d is an invalid test number.\n", testNum);
-      return -1;
-    }
-    testToRun = testNum;
-    ac--;
-    av++;
-  }
-  partial_match = 0;
-  arg = NULL; /* NOLINT */
-  /* If partial match is requested.  */
-  if (testToRun == -1 && ac > 1) {
-    partial_match = (strcmp(av[1], "-R") == 0) ? 1 : 0;
-  }
-  if (partial_match != 0 && ac < 3) {
-    printf("-R needs an additional parameter.\n");
-    return -1;
-  }
-  if (testToRun == -1) {
-    arg = lowercase(av[1 + partial_match]);
-  }
-  for (i = 0; i < NumTests && testToRun == -1; ++i) {
-    char *test_name = lowercase(cmakeGeneratedFunctionMapEntries[i].name);
-    if (partial_match != 0 && strstr(test_name, arg) != NULL) { /* NOLINT */
-      testToRun = i;
-      ac -= 2;
-      av += 2;
-    } else if (partial_match == 0 && strcmp(test_name, arg) == 0) {
-      testToRun = i;
-      ac--;
-      av++;
-    }
-    free(test_name);
-  }
-  free(arg);
-  if (testToRun != -1) {
-    int result;
-
-    if (testToRun < 0 || testToRun >= NumTests) {
-      printf("testToRun was modified by TestDriver code to an invalid value: "
-             "%3d.\n",
-             testNum);
-      return -1;
-    }
-    result = (*cmakeGeneratedFunctionMapEntries[testToRun].func)(ac, av);
-
-    return result;
-  }
-
-  /* Nothing was run, display the test names.  */
-  printf("Available tests:\n");
-  for (i = 0; i < NumTests; ++i) {
-    printf("%3d. %s\n", i, cmakeGeneratedFunctionMapEntries[i].name);
-  }
-  printf("Failed: %s is an invalid test name.\n", av[1]);
+	int i, testNum = 0, partial_match;
+	char* arg;
+	int testToRun = -1;
+
+	/* If no test name was given */
+	/* process command line with user function.  */
+	if (ac < 2)
+	{
+		/* Ask for a test.  */
+		printf("Available tests:\n");
+		for (i = 0; i < NumTests; ++i)
+		{
+			printf("%3d. %s\n", i, cmakeGeneratedFunctionMapEntries[i].name);
+		}
+		printf("To run a test, enter the test number: ");
+		fflush(stdout);
+		if (scanf("%d", &testNum) != 1)
+		{
+			printf("Couldn't parse that input as a number\n");
+			return -1;
+		}
+		if (testNum >= NumTests)
+		{
+			printf("%3d is an invalid test number.\n", testNum);
+			return -1;
+		}
+		testToRun = testNum;
+		ac--;
+		av++;
+	}
+	partial_match = 0;
+	arg = NULL; /* NOLINT */
+	/* If partial match is requested.  */
+	if (testToRun == -1 && ac > 1)
+	{
+		partial_match = (strcmp(av[1], "-R") == 0) ? 1 : 0;
+	}
+	if (partial_match != 0 && ac < 3)
+	{
+		printf("-R needs an additional parameter.\n");
+		return -1;
+	}
+	if (testToRun == -1)
+	{
+		arg = lowercase(av[1 + partial_match]);
+	}
+	for (i = 0; i < NumTests && testToRun == -1; ++i)
+	{
+		char* test_name = lowercase(cmakeGeneratedFunctionMapEntries[i].name);
+		if (partial_match != 0 && strstr(test_name, arg) != NULL)
+		{ /* NOLINT */
+			testToRun = i;
+			ac -= 2;
+			av += 2;
+		}
+		else if (partial_match == 0 && strcmp(test_name, arg) == 0)
+		{
+			testToRun = i;
+			ac--;
+			av++;
+		}
+		free(test_name);
+	}
+	free(arg);
+	if (testToRun != -1)
+	{
+		int result;
+
+		if (testToRun < 0 || testToRun >= NumTests)
+		{
+			printf("testToRun was modified by TestDriver code to an invalid value: "
+			       "%3d.\n",
+			       testNum);
+			return -1;
+		}
+		result = (*cmakeGeneratedFunctionMapEntries[testToRun].func)(ac, av);
+
+		return result;
+	}
+
+	/* Nothing was run, display the test names.  */
+	printf("Available tests:\n");
+	for (i = 0; i < NumTests; ++i)
+	{
+		printf("%3d. %s\n", i, cmakeGeneratedFunctionMapEntries[i].name);
+	}
+	printf("Failed: %s is an invalid test name.\n", av[1]);
 
-  return -1;
+	return -1;
 }
diff -urN winpr/tools/hash-cli/hash.c ../../informatimago/FreeRDP/winpr/tools/hash-cli/hash.c
--- winpr/tools/hash-cli/hash.c	2019-07-25 19:51:12.469954979 +0300
+++ ../../informatimago/FreeRDP/winpr/tools/hash-cli/hash.c	2019-07-25 20:11:36.284023916 +0300
@@ -23,7 +23,6 @@
 #include <errno.h>
 
 #include <winpr/ntlm.h>
-#include <winpr/ssl.h>
 
 /**
  * Define NTOWFv1(Password, User, Domain) as
@@ -153,7 +152,6 @@
 		usage_and_exit();
 	}
 
-	winpr_InitializeSSL(WINPR_SSL_INIT_DEFAULT);
 	UserLength = strlen(User);
 	PasswordLength = strlen(Password);
 	DomainLength = (Domain) ? strlen(Domain) : 0;
@@ -166,19 +164,11 @@
 			usage_and_exit();
 		}
 
-		if (!NTOWFv2A(Password, PasswordLength, User, UserLength, Domain, DomainLength, NtHash))
-		{
-			fprintf(stderr, "Hash creation failed\n");
-			return 1;
-		}
+		NTOWFv2A(Password, PasswordLength, User, UserLength, Domain, DomainLength, NtHash);
 	}
 	else
 	{
-		if (!NTOWFv1A(Password, PasswordLength, NtHash))
-		{
-			fprintf(stderr, "Hash creation failed\n");
-			return 1;
-		}
+		NTOWFv1A(Password, PasswordLength, NtHash);
 	}
 
 	if (format == 0)
